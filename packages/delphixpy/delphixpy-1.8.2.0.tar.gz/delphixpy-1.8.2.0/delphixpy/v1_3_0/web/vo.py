#
# Copyright 2017 by Delphix
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# This class has been automatically generated from:
#     /delphix-typed-object.json
#     /delphix-timeflow-point-parameters.json
#     /delphix-timeflow-repair-parameters.json
#     /delphix-dvc-source-data-timestamp.json
#     /delphix-detach-source-parameters.json
#     /delphix-dynamic-parameter.json
#     /delphix-time-config.json
#     /delphix-support-bundle.json
#     /delphix-analytics-statistic.json
#     /delphix-host-runtime.json
#     /delphix-dvc-data-source-create-parameters.json
#     /delphix-ntp-config.json
#     /delphix-host-machine.json
#     /delphix-proxy-service.json
#     /delphix-api-error.json
#     /delphix-oracle-cluster-node-create-parameters.json
#     /delphix-interface-address.json
#     /delphix-refresh-parameters.json
#     /delphix-notification-drop.json
#     /delphix-apply-version-parameters.json
#     /delphix-network-route.json
#     /delphix-sync-parameters.json
#     /delphix-proxy-configuration.json
#     /delphix-checklist-item.json
#     /delphix-snapshotspaceparameters.json
#     /delphix-connectivity-sourceconfig.json
#     /delphix-version-info.json
#     /delphix-oracle-database-stats-section.json
#     /delphix-host-create-parameters.json
#     /delphix-attach-source-parameters.json
#     /delphix-timeflow-range-parameters.json
#     /delphix-preprovisioning-runtime.json
#     /delphix-host-os.json
#     /delphix-provision-parameters.json
#     /delphix-analytics-datapoint.json
#     /delphix-snmp-config.json
#     /delphix-filesystem-layout.json
#     /delphix-smtp-config.json
#     /delphix-sourcing-policy.json
#     /delphix-source-runtime.json
#     /delphix-database-template-config.json
#     /delphix-supportaccessstate.json
#     /delphix-compatible-repositories-parameters.json
#     /delphix-service-state.json
#     /delphix-snapshot-space-result.json
#     /delphix-oracle-active-instance.json
#     /delphix-syslog-config.json
#     /delphix-analytics-axis-constraint.json
#     /delphix-dvc-data-parent.json
#     /delphix-checklist.json
#     /delphix-network-route-lookup-parameters.json
#     /delphix-compatible-repositories-result.json
#     /delphix-file-mapping-parameters.json
#     /delphix-source-environment-create-parameters.json
#     /delphix-snapshot-runtime.json
#     /delphix-appdata-parameter.json
#     /delphix-version.json
#     /delphix-schedule.json
#     /delphix-export-parameters.json
#     /delphix-delete-parameters.json
#     /delphix-about.json
#     /delphix-global-linking-settings.json
#     /delphix-host-configuration.json
#     /delphix-certificate-fetch-parameters.json
#     /delphix-oracle-database-statistic.json
#     /delphix-credential.json
#     /delphix-connectivity-ssh.json
#     /delphix-job-event.json
#     /delphix-call-result.json
#     /delphix-fault-resolve-parameters.json
#     /delphix-domain-create-parameters.json
#     /delphix-time-range-parameters.json
#     /delphix-capacity-aggregate-data.json
#     /delphix-persistent-object.json
#     /delphix-oracle-instance.json
#     /delphix-pgsql-hba-entry.json
#     /delphix-ldap-info.json
#     /delphix-compatibility-criteria.json
#     /delphix-capacity-snapshot-data.json
#     /delphix-analytics-statistic-axis.json
#     /delphix-syslog-server.json
#     /delphix-virtual-source-operations.json
#     /delphix-oracle-log.json
#     /delphix-scrub-status.json
#     /delphix-capacity-breakdown.json
#     /delphix-traceroute-info.json
#     /delphix-source-disable-parameters.json
#     /delphix-timeflow-range.json
#     /delphix-operation.json
#     /delphix-upload-parameters.json
#     /delphix-nfs-read-write-sizes.json
#     /delphix-policy-create-and-apply-parameters.json
#     /delphix-source-start-parameters.json
#     /delphix-pgsql-ident-entry.json
#     /delphix-timeflow-bookmark-create-parameters.json
#     /delphix-loginrequest.json
#     /delphix-analytics-datapoint-set.json
#     /delphix-oracle-service.json
#     /delphix-oracle-virtual-ip.json
#     /delphix-dvc-application-create-parameters.json
#     /delphix-mssql-instance-config.json
#     /delphix-cpu-info.json
#     /delphix-phone-home-service.json
#     /delphix-file-upload-result.json
#     /delphix-capacity-base-consumer-data.json
#     /delphix-analytics-statistic-slice-event.json
#     /delphix-dvc-timeline-point-parameters.json
#     /delphix-source-connection-info.json
#     /delphix-db-container-runtime.json
#     /delphix-connectivity-jdbc.json
#     /delphix-analytics-datapoint-stream.json
#     /delphix-session.json
#     /delphix-connectivity-connector.json
#     /delphix-source-stop-parameters.json
#     /delphix-pgsql-db-config.json
#     /delphix-validate-smtp-parameters.json
#     /delphix-singleton-update.json
#     /delphix-dns-config.json
#     /delphix-link-parameters.json
#     /delphix-object-notification.json
#     /delphix-source-upgrade-parameters.json
#     /delphix-timeflow-point.json
#     /delphix-dvc-bookmark-create-parameters.json
#     /delphix-credential-update-parameters.json
#     /delphix-switch-timeflow-parameters.json
#     /delphix-dynamic-parameter-value.json
#     /delphix-policy-apply-target-parameters.json
#     /delphix-dvc-bookmark-tag.json
#     /delphix-file-mapping-result.json
#     /delphix-dvc-source-data-timestamp-parameters.json
#     /delphix-support-bundle-upload-parameters.json
#     /delphix-source-enable-parameters.json
#     /delphix-alert-action.json
#     /delphix-rollback-parameters.json
#     /delphix-oracle-rollback-parameters.json
#     /delphix-alert-action-email.json
#     /delphix-alert-action-email-list.json
#     /delphix-alert-action-email-user.json
#     /delphix-oracle-enable-parameters.json
#     /delphix-oracle-timeflow-point.json
#     /delphix-pgsql-timeflow-point.json
#     /delphix-appdata-timeflow-point.json
#     /delphix-mssql-timeflow-point.json
#     /delphix-mssql-linked-source-upgrade-parameters.json
#     /delphix-mssql-link-parameters.json
#     /delphix-appdata-link-parameters.json
#     /delphix-pgsql-link-parameters.json
#     /delphix-oracle-link-parameters.json
#     /delphix-oracle-stop-parameters.json
#     /delphix-analytics-network-interface-util-datapoint-stream.json
#     /delphix-analytics-vfs-ops-datapoint-stream.json
#     /delphix-analytics-dxfs-io-queue-ops-datapoint-stream.json
#     /delphix-analytics-iscsi-ops-datapoint-stream.json
#     /delphix-analytics-cpu-util-datapoint-stream.json
#     /delphix-analytics-disk-ops-datapoint-stream.json
#     /delphix-analytics-dxfs-ops-datapoint-stream.json
#     /delphix-analytics-nfs-ops-datapoint-stream.json
#     /delphix-pgsql-db-container-runtime.json
#     /delphix-appdata-container-runtime.json
#     /delphix-mssql-db-container-runtime.json
#     /delphix-oracle-db-container-runtime.json
#     /delphix-mssql-source-connection-info.json
#     /delphix-pgsql-source-connection-info.json
#     /delphix-oracle-source-connection-info.json
#     /delphix-appdata-source-connection-info.json
#     /delphix-oracle-si-source-connection-info.json
#     /delphix-oracle-rac-source-connection-info.json
#     /delphix-dvc-timeline-point-bookmark-input.json
#     /delphix-dvc-timeline-point-time-parameters.json
#     /delphix-dvc-timeline-point-latest-time-input.json
#     /delphix-dvc-timeline-point-time-input.json
#     /delphix-capacity-current-consumer-data.json
#     /delphix-capacity-historical-consumer-data.json
#     /delphix-dvc-application-template-create-parameters.json
#     /delphix-dvc-application-container-create-parameters.json
#     /delphix-oracle-start-parameters.json
#     /delphix-run-command-operation.json
#     /delphix-run-expect-operation.json
#     /delphix-oracle-disable-parameters.json
#     /delphix-analytics-statistic-enum-axis.json
#     /delphix-pgsql-compatibility-criteria.json
#     /delphix-mssql-compatibility-criteria.json
#     /delphix-oracle-compatibility-criteria.json
#     /delphix-oracle-rac-instance.json
#     /delphix-alert.json
#     /delphix-user-object.json
#     /delphix-dvc-user-preferences.json
#     /delphix-fault.json
#     /delphix-audit-event.json
#     /delphix-snmp-manager.json
#     /delphix-alert-profile.json
#     /delphix-fault-effect.json
#     /delphix-network-interface.json
#     /delphix-policy.json
#     /delphix-x509certificate.json
#     /delphix-replicationspec.json
#     /delphix-role.json
#     /delphix-named-user-object.json
#     /delphix-source.json
#     /delphix-readonly-named-user-object.json
#     /delphix-locale-settings.json
#     /delphix-source-environment.json
#     /delphix-host-environment.json
#     /delphix-oracle-cluster.json
#     /delphix-windows-host-environment.json
#     /delphix-unix-host-environment.json
#     /delphix-permission.json
#     /delphix-source-config.json
#     /delphix-ldap-server.json
#     /delphix-host.json
#     /delphix-authorization.json
#     /delphix-source-repository.json
#     /delphix-pgsql-install.json
#     /delphix-mssql-instance.json
#     /delphix-appdata-source-repository.json
#     /delphix-oracle-install.json
#     /delphix-unix-host.json
#     /delphix-windows-host.json
#     /delphix-pgsql-db-cluster-config.json
#     /delphix-oracle-db-config.json
#     /delphix-appdata-source-config.json
#     /delphix-mssql-db-config.json
#     /delphix-mssql-si-config.json
#     /delphix-oracle-si-config.json
#     /delphix-oracle-rac-config.json
#     /delphix-pgsql-source.json
#     /delphix-oracle-source.json
#     /delphix-mssql-source.json
#     /delphix-appdata-source.json
#     /delphix-appdata-virtual-source.json
#     /delphix-appdata-linked-source.json
#     /delphix-mssql-virtual-source.json
#     /delphix-mssql-linked-source.json
#     /delphix-mssql-staging-source.json
#     /delphix-oracle-virtual-source.json
#     /delphix-oracle-linked-source.json
#     /delphix-pgsql-staging-source.json
#     /delphix-pgsql-virtual-source.json
#     /delphix-pgsql-linked-source.json
#     /delphix-group.json
#     /delphix-domain.json
#     /delphix-dvc-branch.json
#     /delphix-user.json
#     /delphix-namespace.json
#     /delphix-source-environment-user.json
#     /delphix-job.json
#     /delphix-upgrade-version.json
#     /delphix-dvc-bookmark.json
#     /delphix-appdata-toolkit.json
#     /delphix-container.json
#     /delphix-orphan-filesystem.json
#     /delphix-orphan-snapshot.json
#     /delphix-database-template.json
#     /delphix-analytics-statistic-slice.json
#     /delphix-storage-device.json
#     /delphix-dvc-application.json
#     /delphix-timeflow-snapshot.json
#     /delphix-dvc-operation.json
#     /delphix-timeflow.json
#     /delphix-timeflow-bookmark.json
#     /delphix-oracle-listener.json
#     /delphix-dvc-data-source.json
#     /delphix-oracle-cluster-node.json
#     /delphix-oracle-scan-listener.json
#     /delphix-oracle-node-listener.json
#     /delphix-appdata-timeflow.json
#     /delphix-pgsql-timeflow.json
#     /delphix-oracle-timeflow.json
#     /delphix-mssql-timeflow.json
#     /delphix-pgsql-snapshot.json
#     /delphix-appdata-snapshot.json
#     /delphix-mssql-snapshot.json
#     /delphix-oracle-snapshot.json
#     /delphix-dvc-application-template.json
#     /delphix-dvc-application-container.json
#     /delphix-configured-storage-device.json
#     /delphix-db-container.json
#     /delphix-appdata-container.json
#     /delphix-mssql-db-container.json
#     /delphix-pgsql-db-container.json
#     /delphix-oracle-db-container.json
#     /delphix-schedule-policy.json
#     /delphix-reservation-policy.json
#     /delphix-quota-policy.json
#     /delphix-retention-policy.json
#     /delphix-refresh-policy.json
#     /delphix-sync-policy.json
#     /delphix-snapshot-policy.json
#     /delphix-capacity-base-system-data.json
#     /delphix-capacity-base-group-data.json
#     /delphix-capacity-current-group-data.json
#     /delphix-capacity-historical-group-data.json
#     /delphix-capacity-historical-system-data.json
#     /delphix-capacity-current-system-data.json
#     /delphix-error-result.json
#     /delphix-ok-result.json
#     /delphix-data-result.json
#     /delphix-list-result.json
#     /delphix-publickey-credential.json
#     /delphix-password-credential.json
#     /delphix-systemkey-credential.json
#     /delphix-keypair-credential.json
#     /delphix-system.json
#     /delphix-oracle-delete-parameters.json
#     /delphix-appdata-export-parameters.json
#     /delphix-db-export-parameters.json
#     /delphix-mssql-export-parameters.json
#     /delphix-oracle-export-parameters.json
#     /delphix-pgsql-export-parameters.json
#     /delphix-mssql-snapshot-runtime.json
#     /delphix-oracle-snapshot-runtime.json
#     /delphix-appdata-snapshot-runtime.json
#     /delphix-oracle-cluster-create-parameters.json
#     /delphix-host-environment-create-parameters.json
#     /delphix-xpp-status.json
#     /delphix-dvc-timestamp-data-parent.json
#     /delphix-dvc-bookmark-data-parent.json
#     /delphix-analytics-integer-constraint.json
#     /delphix-analytics-boolean-constraint.json
#     /delphix-analytics-path-constraint.json
#     /delphix-analytics-enum-constraint.json
#     /delphix-analytics-string-constraint.json
#     /delphix-analytics-null-constraint.json
#     /delphix-analytics-string-equal-constraint.json
#     /delphix-analytics-enum-equal-constraint.json
#     /delphix-analytics-path-descendant-constraint.json
#     /delphix-analytics-boolean-equal-constraint.json
#     /delphix-analytics-integer-less-than-constraint.json
#     /delphix-analytics-integer-greater-than-constraint.json
#     /delphix-analytics-integer-equal-constraint.json
#     /delphix-xpp-compatibility-parameters.json
#     /delphix-migrate-compatibility-parameters.json
#     /delphix-staging-compatibility-parameters.json
#     /delphix-provision-compatibility-parameters.json
#     /delphix-upgrade-compatibility-parameters.json
#     /delphix-oracle-source-runtime.json
#     /delphix-mssql-source-runtime.json
#     /delphix-appdata-source-runtime.json
#     /delphix-pgsql-source-runtime.json
#     /delphix-oracle-sourcing-policy.json
#     /delphix-appdata-filesystem-layout.json
#     /delphix-timeflow-filesystem-layout.json
#     /delphix-analytics-io-ops-datapoint.json
#     /delphix-analytics-cpu-util-datapoint.json
#     /delphix-analytics-network-interface-util-datapoint.json
#     /delphix-appdata-provision-parameters.json
#     /delphix-oracle-provision-parameters.json
#     /delphix-mssql-provision-parameters.json
#     /delphix-pgsql-provision-parameters.json
#     /delphix-oracle-attach-source-parameters.json
#     /delphix-pgsql-attach-source-parameters.json
#     /delphix-mssql-attach-source-parameters.json
#     /delphix-windows-host-create-parameters.json
#     /delphix-unix-host-create-parameters.json
#     /delphix-connectivity-pgsql-db-cluster-config.json
#     /delphix-checklist-item-detail.json
#     /delphix-xpp-last-run-status.json
#     /delphix-xpp-validate-status.json
#     /delphix-xpp-staging-status.json
#     /delphix-xpp-target-status.json
#     /delphix-pgsql-sync-parameters.json
#     /delphix-mssql-sync-parameters.json
#     /delphix-oracle-refresh-parameters.json
#     /delphix-dynamic-enum-parameter.json
#     /delphix-dynamic-string-parameter.json
#     /delphix-dynamic-boolean-parameter.json
#     /delphix-dynamic-integer-parameter.json
#     /delphix-dynamic-password-parameter.json
#     /delphix-timeflow-repair-ssh.json
#     /delphix-timeflow-point-bookmark-tag.json
#     /delphix-timeflow-point-timestamp.json
#     /delphix-timeflow-point-location.json
#     /delphix-timeflow-point-bookmark.json
#     /delphix-timeflow-point-semantic.json
#
# Do not edit this file manually!
#
from delphixpy.v1_3_0 import factory
from delphixpy.v1_3_0 import common

class __Undef(object):
    def __repr__(self):
        return "undef"

_UNDEFINED = __Undef()

class TypedObject(object):
    """
    Super schema for all other schemas
    """
    def __init__(self, undef_enabled=True):
        self.__undef__ = _UNDEFINED if undef_enabled else None
        self._type = ("TypedObject", True)
        self._type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = cls()
        obj.__undef__ = _UNDEFINED if undef_enabled else None
        if "type" not in data:
            raise ValueError("Missing required property \"type\".")
        obj._type = (data.get("type", obj.__undef__), dirty)
        if obj._type[0] is not None and obj._type[0] is not obj.__undef__:
            assert isinstance(obj._type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._type[0]))
            common.validate_format(obj._type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = {}

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "type" == "type" or (self.type is not self.__undef__ and not (dirty and not self._type[1])):
            dct["type"] = dictify(self.type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._type = (self._type[0], True)

    def is_dirty(self):
        return any([self._type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TypedObject):
            return False
        return self.type == other.type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def type(self):
        """
        Object type

        :rtype: ``basestring``
        """
        return self._type[0]

    @type.setter
    def type(self, value):
        self._type = (value, True)

class TimeflowPointParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters indicating
    a timeflow point to use as input to database operations.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointParameters, self).__init__()
        self._type = ("TimeflowPointParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointParameters):
            return False
        return super(TimeflowPointParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class TimeflowRepairParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters to repair
    log files within a timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRepairParameters, self).__init__()
        self._type = ("TimeflowRepairParameters", True)
        self._end_location = (self.__undef__, True)
        self._start_location = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRepairParameters, cls).from_dict(data, dirty, undef_enabled)
        if "endLocation" not in data:
            raise ValueError("Missing required property \"endLocation\".")
        obj._end_location = (data.get("endLocation", obj.__undef__), dirty)
        if obj._end_location[0] is not None and obj._end_location[0] is not obj.__undef__:
            assert isinstance(obj._end_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_location[0]))
            common.validate_format(obj._end_location[0], "None", None, None)
        if "startLocation" not in data:
            raise ValueError("Missing required property \"startLocation\".")
        obj._start_location = (data.get("startLocation", obj.__undef__), dirty)
        if obj._start_location[0] is not None and obj._start_location[0] is not obj.__undef__:
            assert isinstance(obj._start_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_location[0]))
            common.validate_format(obj._start_location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRepairParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_location" == "type" or (self.end_location is not self.__undef__ and not (dirty and not self._end_location[1])):
            dct["endLocation"] = dictify(self.end_location)
        if "start_location" == "type" or (self.start_location is not self.__undef__ and not (dirty and not self._start_location[1])):
            dct["startLocation"] = dictify(self.start_location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_location = (self._end_location[0], True)
        self._start_location = (self._start_location[0], True)

    def is_dirty(self):
        return any([self._end_location[1], self._start_location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRepairParameters):
            return False
        return super(TimeflowRepairParameters, self).__eq__(other) and \
               self.end_location == other.end_location and \
               self.start_location == other.start_location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_location(self):
        """
        The ending point of the range of logfiles to fetch.

        :rtype: ``basestring``
        """
        return self._end_location[0]

    @end_location.setter
    def end_location(self, value):
        self._end_location = (value, True)

    @property
    def start_location(self):
        """
        The starting point of the range of logfiles to fetch.

        :rtype: ``basestring``
        """
        return self._start_location[0]

    @start_location.setter
    def start_location(self, value):
        self._start_location = (value, True)

class DVCSourceDataTimestamp(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The association
    between a DVC data source and a point in time that's provisionable.
    """
    def __init__(self, undef_enabled=True):
        super(DVCSourceDataTimestamp, self).__init__()
        self._type = ("DVCSourceDataTimestamp", True)
        self._source = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCSourceDataTimestamp, cls).from_dict(data, dirty, undef_enabled)
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "objectReference", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCSourceDataTimestamp, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._source[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCSourceDataTimestamp):
            return False
        return super(DVCSourceDataTimestamp, self).__eq__(other) and \
               self.source == other.source and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        A reference to the DVC data source.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def timestamp(self):
        """
        The point in time which is provisionable on the source.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class DetachSourceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters passed
    in for a database detach source operation.
    """
    def __init__(self, undef_enabled=True):
        super(DetachSourceParameters, self).__init__()
        self._type = ("DetachSourceParameters", True)
        self._source = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DetachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DetachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)

    def is_dirty(self):
        return any([self._source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DetachSourceParameters):
            return False
        return super(DetachSourceParameters, self).__eq__(other) and \
               self.source == other.source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Reference to the source to be removed. This must be a linked source
        attached to the target database.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

class DynamicParameter(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The description of how
    a dynamic parameter is presented to clients and what validation clients can
    do on user input for the parameter.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicParameter, self).__init__()
        self._type = ("DynamicParameter", True)
        self._pretty_name = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicParameter, cls).from_dict(data, dirty, undef_enabled)
        if "prettyName" not in data:
            raise ValueError("Missing required property \"prettyName\".")
        obj._pretty_name = (data.get("prettyName", obj.__undef__), dirty)
        if obj._pretty_name[0] is not None and obj._pretty_name[0] is not obj.__undef__:
            assert isinstance(obj._pretty_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pretty_name[0]))
            common.validate_format(obj._pretty_name[0], "None", 1, None)
        if "description" not in data:
            raise ValueError("Missing required property \"description\".")
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", 1, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "pretty_name" == "type" or (self.pretty_name is not self.__undef__ and not (dirty and not self._pretty_name[1])):
            dct["prettyName"] = dictify(self.pretty_name)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._pretty_name = (self._pretty_name[0], True)
        self._description = (self._description[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._pretty_name[1], self._description[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicParameter):
            return False
        return super(DynamicParameter, self).__eq__(other) and \
               self.pretty_name == other.pretty_name and \
               self.description == other.description and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def pretty_name(self):
        """
        A short, human-readable name for clients to use instead of 'name' when
        requesting user input. For example, while 'name' might be 'portNumber',
        'prettyName' could be 'Port Number'.

        :rtype: ``basestring``
        """
        return self._pretty_name[0]

    @pretty_name.setter
    def pretty_name(self, value):
        self._pretty_name = (value, True)

    @property
    def description(self):
        """
        The description of what this property means and how it is used.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def name(self):
        """
        The name clients should use when setting the parameter's value.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class TimeConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Get and set the
    current time configuration.
    """
    def __init__(self, undef_enabled=True):
        super(TimeConfig, self).__init__()
        self._type = ("TimeConfig", True)
        self._ntp_config = (self.__undef__, True)
        self._system_time_zone = (self.__undef__, True)
        self._current_time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeConfig, cls).from_dict(data, dirty, undef_enabled)
        if "ntpConfig" in data and data["ntpConfig"] is not None:
            obj._ntp_config = (factory.create_object(data["ntpConfig"], "NTPConfig"), dirty)
            factory.validate_type(obj._ntp_config[0], "NTPConfig")
        else:
            obj._ntp_config = (obj.__undef__, dirty)
        obj._system_time_zone = (data.get("systemTimeZone", obj.__undef__), dirty)
        if obj._system_time_zone[0] is not None and obj._system_time_zone[0] is not obj.__undef__:
            assert isinstance(obj._system_time_zone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._system_time_zone[0]))
            common.validate_format(obj._system_time_zone[0], "None", None, None)
        obj._current_time = (data.get("currentTime", obj.__undef__), dirty)
        if obj._current_time[0] is not None and obj._current_time[0] is not obj.__undef__:
            assert isinstance(obj._current_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_time[0]))
            common.validate_format(obj._current_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ntp_config" == "type" or (self.ntp_config is not self.__undef__ and not (dirty and not self._ntp_config[1])):
            dct["ntpConfig"] = dictify(self.ntp_config)
        if "system_time_zone" == "type" or (self.system_time_zone is not self.__undef__ and not (dirty and not self._system_time_zone[1])):
            dct["systemTimeZone"] = dictify(self.system_time_zone)
        if "current_time" == "type" or (self.current_time is not self.__undef__ and not (dirty and not self._current_time[1])):
            dct["currentTime"] = dictify(self.current_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ntp_config = (self._ntp_config[0], True)
        self._system_time_zone = (self._system_time_zone[0], True)
        self._current_time = (self._current_time[0], True)

    def is_dirty(self):
        return any([self._ntp_config[1], self._system_time_zone[1], self._current_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeConfig):
            return False
        return super(TimeConfig, self).__eq__(other) and \
               self.ntp_config == other.ntp_config and \
               self.system_time_zone == other.system_time_zone and \
               self.current_time == other.current_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ntp_config(self):
        """
        NTP configuration

        :rtype: :py:class:`v1_3_0.web.vo.NTPConfig`
        """
        return self._ntp_config[0]

    @ntp_config.setter
    def ntp_config(self, value):
        self._ntp_config = (value, True)

    @property
    def system_time_zone(self):
        """
        *(default value: Etc/UTC)* Default time zone for system wide policies
        and schedules. The management service is automatically restarted if the
        timezone is changed.

        :rtype: ``basestring``
        """
        return self._system_time_zone[0]

    @system_time_zone.setter
    def system_time_zone(self, value):
        self._system_time_zone = (value, True)

    @property
    def current_time(self):
        """
        Current system time. This value can only be set if NTP is disabled. The
        management service is automatically restarted if the time is changed.

        :rtype: ``basestring``
        """
        return self._current_time[0]

    @current_time.setter
    def current_time(self, value):
        self._current_time = (value, True)

class SupportBundle(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Generates a "support
    bundle" that contains logs, metadata, and other supporting data used by the
    Delphix support.
    """
    def __init__(self, undef_enabled=True):
        super(SupportBundle, self).__init__()
        self._type = ("SupportBundle", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SupportBundle, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SupportBundle, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SupportBundle):
            return False
        return super(SupportBundle, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class Statistic(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Multidimensional
    analytics statistics which can be queried for data.
    """
    def __init__(self, undef_enabled=True):
        super(Statistic, self).__init__()
        self._type = ("Statistic", True)
        self._explanation = (self.__undef__, True)
        self._statistic_type = (self.__undef__, True)
        self._axes = (self.__undef__, True)
        self._min_collection_interval = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Statistic, cls).from_dict(data, dirty, undef_enabled)
        obj._explanation = (data.get("explanation", obj.__undef__), dirty)
        if obj._explanation[0] is not None and obj._explanation[0] is not obj.__undef__:
            assert isinstance(obj._explanation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._explanation[0]))
            common.validate_format(obj._explanation[0], "None", None, None)
        obj._statistic_type = (data.get("statisticType", obj.__undef__), dirty)
        if obj._statistic_type[0] is not None and obj._statistic_type[0] is not obj.__undef__:
            assert isinstance(obj._statistic_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._statistic_type[0]))
            common.validate_format(obj._statistic_type[0], "None", None, None)
        obj._axes = []
        for item in data.get("axes") or []:
            obj._axes.append(factory.create_object(item))
            factory.validate_type(obj._axes[-1], "StatisticAxis")
        obj._axes = (obj._axes, dirty)
        obj._min_collection_interval = (data.get("minCollectionInterval", obj.__undef__), dirty)
        if obj._min_collection_interval[0] is not None and obj._min_collection_interval[0] is not obj.__undef__:
            assert isinstance(obj._min_collection_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._min_collection_interval[0]))
            common.validate_format(obj._min_collection_interval[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Statistic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "explanation" == "type" or (self.explanation is not self.__undef__ and not (dirty and not self._explanation[1])):
            dct["explanation"] = dictify(self.explanation)
        if "statistic_type" == "type" or (self.statistic_type is not self.__undef__ and not (dirty and not self._statistic_type[1])):
            dct["statisticType"] = dictify(self.statistic_type)
        if "axes" == "type" or (self.axes is not self.__undef__ and not (dirty and not self._axes[1])):
            dct["axes"] = dictify(self.axes)
        if "min_collection_interval" == "type" or (self.min_collection_interval is not self.__undef__ and not (dirty and not self._min_collection_interval[1])):
            dct["minCollectionInterval"] = dictify(self.min_collection_interval)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._explanation = (self._explanation[0], True)
        self._statistic_type = (self._statistic_type[0], True)
        self._axes = (self._axes[0], True)
        self._min_collection_interval = (self._min_collection_interval[0], True)

    def is_dirty(self):
        return any([self._explanation[1], self._statistic_type[1], self._axes[1], self._min_collection_interval[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Statistic):
            return False
        return super(Statistic, self).__eq__(other) and \
               self.explanation == other.explanation and \
               self.statistic_type == other.statistic_type and \
               self.axes == other.axes and \
               self.min_collection_interval == other.min_collection_interval

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def explanation(self):
        """
        A deeper explanation of the data this can collect.

        :rtype: ``basestring``
        """
        return self._explanation[0]

    @explanation.setter
    def explanation(self, value):
        self._explanation = (value, True)

    @property
    def statistic_type(self):
        """
        The type name for the data this can collect.

        :rtype: ``basestring``
        """
        return self._statistic_type[0]

    @statistic_type.setter
    def statistic_type(self, value):
        self._statistic_type = (value, True)

    @property
    def axes(self):
        """
        The set of axes this statistic has.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.StatisticAxis`
        """
        return self._axes[0]

    @axes.setter
    def axes(self, value):
        self._axes = (value, True)

    @property
    def min_collection_interval(self):
        """
        The smallest unit of time this statistic can measure on.

        :rtype: ``int``
        """
        return self._min_collection_interval[0]

    @min_collection_interval.setter
    def min_collection_interval(self, value):
        self._min_collection_interval = (value, True)

class HostRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Runtime, non-
    persistent properties for a host machine.
    """
    def __init__(self, undef_enabled=True):
        super(HostRuntime, self).__init__()
        self._type = ("HostRuntime", True)
        self._available = (self.__undef__, True)
        self._trace_route_info = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._available = (data.get("available", obj.__undef__), dirty)
        if obj._available[0] is not None and obj._available[0] is not obj.__undef__:
            assert isinstance(obj._available[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._available[0]))
            common.validate_format(obj._available[0], "None", None, None)
        if "traceRouteInfo" in data and data["traceRouteInfo"] is not None:
            obj._trace_route_info = (factory.create_object(data["traceRouteInfo"], "TracerouteInfo"), dirty)
            factory.validate_type(obj._trace_route_info[0], "TracerouteInfo")
        else:
            obj._trace_route_info = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "available" == "type" or (self.available is not self.__undef__ and not (dirty and not self._available[1])):
            dct["available"] = dictify(self.available)
        if "trace_route_info" == "type" or (self.trace_route_info is not self.__undef__ and not (dirty and not self._trace_route_info[1])):
            dct["traceRouteInfo"] = dictify(self.trace_route_info)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._available = (self._available[0], True)
        self._trace_route_info = (self._trace_route_info[0], True)

    def is_dirty(self):
        return any([self._available[1], self._trace_route_info[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostRuntime):
            return False
        return super(HostRuntime, self).__eq__(other) and \
               self.available == other.available and \
               self.trace_route_info == other.trace_route_info

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def available(self):
        """
        True if the host is up and a connection can be established.

        :rtype: ``bool``
        """
        return self._available[0]

    @available.setter
    def available(self, value):
        self._available = (value, True)

    @property
    def trace_route_info(self):
        """
        Traceroute network hops from host to Delphix Engine.

        :rtype: :py:class:`v1_3_0.web.vo.TracerouteInfo`
        """
        return self._trace_route_info[0]

    @trace_route_info.setter
    def trace_route_info(self, value):
        self._trace_route_info = (value, True)

class DVCDataSourceCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used to
    create the DVC data sources.
    """
    def __init__(self, undef_enabled=True):
        super(DVCDataSourceCreateParameters, self).__init__()
        self._type = ("DVCDataSourceCreateParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCDataSourceCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "DVCDataSource"), dirty)
            factory.validate_type(obj._source[0], "DVCDataSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCDataSourceCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCDataSourceCreateParameters):
            return False
        return super(DVCDataSourceCreateParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The DVC data source object.

        :rtype: :py:class:`v1_3_0.web.vo.DVCDataSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        A reference to the underlying container object.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class NTPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* NTP (network time
    protocol) configuration
    """
    def __init__(self, undef_enabled=True):
        super(NTPConfig, self).__init__()
        self._type = ("NTPConfig", True)
        self._multicast_address = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._use_multicast = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NTPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._multicast_address = (data.get("multicastAddress", obj.__undef__), dirty)
        if obj._multicast_address[0] is not None and obj._multicast_address[0] is not obj.__undef__:
            assert isinstance(obj._multicast_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._multicast_address[0]))
            common.validate_format(obj._multicast_address[0], "ipv4Address", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._use_multicast = (data.get("useMulticast", obj.__undef__), dirty)
        if obj._use_multicast[0] is not None and obj._use_multicast[0] is not obj.__undef__:
            assert isinstance(obj._use_multicast[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_multicast[0]))
            common.validate_format(obj._use_multicast[0], "None", None, None)
        obj._servers = []
        for item in data.get("servers") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "host", None, None)
            obj._servers.append(item)
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NTPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "multicast_address" == "type" or (self.multicast_address is not self.__undef__ and not (dirty and not self._multicast_address[1])):
            dct["multicastAddress"] = dictify(self.multicast_address)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "use_multicast" == "type" or (self.use_multicast is not self.__undef__ and not (dirty and not self._use_multicast[1])):
            dct["useMulticast"] = dictify(self.use_multicast)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._multicast_address = (self._multicast_address[0], True)
        self._enabled = (self._enabled[0], True)
        self._use_multicast = (self._use_multicast[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._multicast_address[1], self._enabled[1], self._use_multicast[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NTPConfig):
            return False
        return super(NTPConfig, self).__eq__(other) and \
               self.multicast_address == other.multicast_address and \
               self.enabled == other.enabled and \
               self.use_multicast == other.use_multicast and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def multicast_address(self):
        """
        *(default value: 224.0.1.1)* Address to use for multicast NTP
        discovery. This is only valid when 'useMulticast' is set.

        :rtype: ``basestring``
        """
        return self._multicast_address[0]

    @multicast_address.setter
    def multicast_address(self, value):
        self._multicast_address = (value, True)

    @property
    def enabled(self):
        """
        If true, then time is synchronized with the configured NTP servers. The
        management service is automatically restarted if this value is changed.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def use_multicast(self):
        """
        If true, discover NTP servers using multicast.

        :rtype: ``bool``
        """
        return self._use_multicast[0]

    @use_multicast.setter
    def use_multicast(self, value):
        self._use_multicast = (value, True)

    @property
    def servers(self):
        """
        A list of NTP servers to use for synchronization. At least one server
        must be specified if multicast is not being used

        :rtype: ``list`` of ``basestring``
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class HostMachine(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The representation of
    the host machine.
    """
    def __init__(self, undef_enabled=True):
        super(HostMachine, self).__init__()
        self._type = ("HostMachine", True)
        self._platform = (self.__undef__, True)
        self._memory_size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostMachine, cls).from_dict(data, dirty, undef_enabled)
        obj._platform = (data.get("platform", obj.__undef__), dirty)
        if obj._platform[0] is not None and obj._platform[0] is not obj.__undef__:
            assert isinstance(obj._platform[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._platform[0]))
            common.validate_format(obj._platform[0], "None", None, None)
        obj._memory_size = (data.get("memorySize", obj.__undef__), dirty)
        if obj._memory_size[0] is not None and obj._memory_size[0] is not obj.__undef__:
            assert isinstance(obj._memory_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._memory_size[0]))
            common.validate_format(obj._memory_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostMachine, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "platform" == "type" or (self.platform is not self.__undef__ and not (dirty and not self._platform[1])):
            dct["platform"] = dictify(self.platform)
        if "memory_size" == "type" or (self.memory_size is not self.__undef__ and not (dirty and not self._memory_size[1])):
            dct["memorySize"] = dictify(self.memory_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._platform = (self._platform[0], True)
        self._memory_size = (self._memory_size[0], True)

    def is_dirty(self):
        return any([self._platform[1], self._memory_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostMachine):
            return False
        return super(HostMachine, self).__eq__(other) and \
               self.platform == other.platform and \
               self.memory_size == other.memory_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def platform(self):
        """
        The platform for the host machine.

        :rtype: ``basestring``
        """
        return self._platform[0]

    @platform.setter
    def platform(self, value):
        self._platform = (value, True)

    @property
    def memory_size(self):
        """
        The amount of RAM on the host machine.

        :rtype: ``float``
        """
        return self._memory_size[0]

    @memory_size.setter
    def memory_size(self, value):
        self._memory_size = (value, True)

class ProxyService(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Proxy service
    configuration
    """
    def __init__(self, undef_enabled=True):
        super(ProxyService, self).__init__()
        self._type = ("ProxyService", True)
        self._https = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProxyService, cls).from_dict(data, dirty, undef_enabled)
        if "https" not in data:
            raise ValueError("Missing required property \"https\".")
        if "https" in data and data["https"] is not None:
            obj._https = (factory.create_object(data["https"], "ProxyConfiguration"), dirty)
            factory.validate_type(obj._https[0], "ProxyConfiguration")
        else:
            obj._https = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProxyService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "https" == "type" or (self.https is not self.__undef__ and not (dirty and not self._https[1])):
            dct["https"] = dictify(self.https)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._https = (self._https[0], True)

    def is_dirty(self):
        return any([self._https[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProxyService):
            return False
        return super(ProxyService, self).__eq__(other) and \
               self.https == other.https

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def https(self):
        """
        HTTPS proxy configuration

        :rtype: :py:class:`v1_3_0.web.vo.ProxyConfiguration`
        """
        return self._https[0]

    @https.setter
    def https(self, value):
        self._https = (value, True)

class APIError(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Description of an
    error encountered during an API call.
    """
    def __init__(self, undef_enabled=True):
        super(APIError, self).__init__()
        self._type = ("APIError", True)
        self._action = (self.__undef__, True)
        self._details = (self.__undef__, True)
        self._id = (self.__undef__, True)
        self._command_output = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APIError, cls).from_dict(data, dirty, undef_enabled)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._details = (data.get("details", obj.__undef__), dirty)
        if obj._details[0] is not None and obj._details[0] is not obj.__undef__:
            assert isinstance(obj._details[0], dict) or isinstance(obj._details[0], basestring), ("Expected one of [u'object', u'string'], but got %s" % type(obj._details[0]))
            common.validate_format(obj._details[0], "None", None, None)
        obj._id = (data.get("id", obj.__undef__), dirty)
        if obj._id[0] is not None and obj._id[0] is not obj.__undef__:
            assert isinstance(obj._id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._id[0]))
            common.validate_format(obj._id[0], "None", None, None)
        obj._command_output = (data.get("commandOutput", obj.__undef__), dirty)
        if obj._command_output[0] is not None and obj._command_output[0] is not obj.__undef__:
            assert isinstance(obj._command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command_output[0]))
            common.validate_format(obj._command_output[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APIError, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "details" == "type" or (self.details is not self.__undef__ and not (dirty and not self._details[1])):
            dct["details"] = dictify(self.details)
        if "id" == "type" or (self.id is not self.__undef__ and not (dirty and not self._id[1])):
            dct["id"] = dictify(self.id)
        if "command_output" == "type" or (self.command_output is not self.__undef__ and not (dirty and not self._command_output[1])):
            dct["commandOutput"] = dictify(self.command_output)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action = (self._action[0], True)
        self._details = (self._details[0], True)
        self._id = (self._id[0], True)
        self._command_output = (self._command_output[0], True)

    def is_dirty(self):
        return any([self._action[1], self._details[1], self._id[1], self._command_output[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APIError):
            return False
        return super(APIError, self).__eq__(other) and \
               self.action == other.action and \
               self.details == other.details and \
               self.id == other.id and \
               self.command_output == other.command_output

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action(self):
        """
        Action to be taken by the user, if any, to fix the underlying problem.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def details(self):
        """
        For validation errors, a map of fields to APIError objects. For all
        other errors, a string with further details of the error.

        :rtype: ``dict`` *or* ``basestring``
        """
        return self._details[0]

    @details.setter
    def details(self, value):
        self._details = (value, True)

    @property
    def id(self):
        """
        A stable identifier for the class of error encountered.

        :rtype: ``basestring``
        """
        return self._id[0]

    @id.setter
    def id(self, value):
        self._id = (value, True)

    @property
    def command_output(self):
        """
        Extra output, often from a script or other external process, that may
        give more insight into the cause of this error.

        :rtype: ``basestring``
        """
        return self._command_output[0]

    @command_output.setter
    def command_output(self, value):
        self._command_output = (value, True)

class OracleClusterNodeCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used
    for oracle cluster node operations.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterNodeCreateParameters, self).__init__()
        self._type = ("OracleClusterNodeCreateParameters", True)
        self._host_parameters = (self.__undef__, True)
        self._cluster = (self.__undef__, True)
        self._virtual_i_ps = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterNodeCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "hostParameters" in data and data["hostParameters"] is not None:
            obj._host_parameters = (factory.create_object(data["hostParameters"], "HostCreateParameters"), dirty)
            factory.validate_type(obj._host_parameters[0], "HostCreateParameters")
        else:
            obj._host_parameters = (obj.__undef__, dirty)
        obj._cluster = (data.get("cluster", obj.__undef__), dirty)
        if obj._cluster[0] is not None and obj._cluster[0] is not obj.__undef__:
            assert isinstance(obj._cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster[0]))
            common.validate_format(obj._cluster[0], "objectReference", None, None)
        obj._virtual_i_ps = []
        for item in data.get("virtualIPs") or []:
            obj._virtual_i_ps.append(factory.create_object(item))
            factory.validate_type(obj._virtual_i_ps[-1], "OracleVirtualIP")
        obj._virtual_i_ps = (obj._virtual_i_ps, dirty)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterNodeCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_parameters" == "type" or (self.host_parameters is not self.__undef__ and not (dirty and not self._host_parameters[1])):
            dct["hostParameters"] = dictify(self.host_parameters)
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "virtual_i_ps" == "type" or (self.virtual_i_ps is not self.__undef__ and not (dirty and not self._virtual_i_ps[1])):
            dct["virtualIPs"] = dictify(self.virtual_i_ps)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_parameters = (self._host_parameters[0], True)
        self._cluster = (self._cluster[0], True)
        self._virtual_i_ps = (self._virtual_i_ps[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._host_parameters[1], self._cluster[1], self._virtual_i_ps[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterNodeCreateParameters):
            return False
        return super(OracleClusterNodeCreateParameters, self).__eq__(other) and \
               self.host_parameters == other.host_parameters and \
               self.cluster == other.cluster and \
               self.virtual_i_ps == other.virtual_i_ps and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_parameters(self):
        """
        The host object associated with the cluster node.

        :rtype: :py:class:`v1_3_0.web.vo.HostCreateParameters`
        """
        return self._host_parameters[0]

    @host_parameters.setter
    def host_parameters(self, value):
        self._host_parameters = (value, True)

    @property
    def cluster(self):
        """
        The cluster to which the node belongs.

        :rtype: ``basestring``
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def virtual_i_ps(self):
        """
        The list of virtual IPs belonging to this node.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleVirtualIP`
        """
        return self._virtual_i_ps[0]

    @virtual_i_ps.setter
    def virtual_i_ps(self, value):
        self._virtual_i_ps = (value, True)

    @property
    def name(self):
        """
        The name of the cluster node.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class InterfaceAddress(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* IP address assigned to
    a network interface.
    """
    def __init__(self, undef_enabled=True):
        super(InterfaceAddress, self).__init__()
        self._type = ("InterfaceAddress", True)
        self._state = (self.__undef__, True)
        self._address_type = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(InterfaceAddress, cls).from_dict(data, dirty, undef_enabled)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'OK', u'TENTATIVE', u'DUPLICATE'], "Expected enum [u'OK', u'TENTATIVE', u'DUPLICATE'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._address_type = (data.get("addressType", obj.__undef__), dirty)
        if obj._address_type[0] is not None and obj._address_type[0] is not obj.__undef__:
            assert isinstance(obj._address_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address_type[0]))
            assert obj._address_type[0] in [u'STATIC', u'DHCP'], "Expected enum [u'STATIC', u'DHCP'] but got %s" % obj._address_type[0]
            common.validate_format(obj._address_type[0], "None", None, None)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "cidrAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(InterfaceAddress, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "address_type" == "type" or (self.address_type is not self.__undef__ and not (dirty and not self._address_type[1])):
            dct["addressType"] = dictify(self.address_type)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._state = (self._state[0], True)
        self._address_type = (self._address_type[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._state[1], self._address_type[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, InterfaceAddress):
            return False
        return super(InterfaceAddress, self).__eq__(other) and \
               self.state == other.state and \
               self.address_type == other.address_type and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def state(self):
        """
        The state of the address. *(permitted values: OK, TENTATIVE,
        DUPLICATE)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def address_type(self):
        """
        *(default value: STATIC)* The type of address (STATIC or DHCP).
        *(permitted values: STATIC, DHCP)*

        :rtype: ``basestring``
        """
        return self._address_type[0]

    @address_type.setter
    def address_type(self, value):
        self._address_type = (value, True)

    @property
    def address(self):
        """
        The address in Classless Inter-Domain Routing (CIDR) notation.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class RefreshParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to refresh MSSQL databases or AppData vFiles.
    """
    def __init__(self, undef_enabled=True):
        super(RefreshParameters, self).__init__()
        self._type = ("RefreshParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RefreshParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RefreshParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RefreshParameters):
            return False
        return super(RefreshParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point, bookmark or semantic location to refresh the
        database to.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class NotificationDrop(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An object to track
    dropped notifications.
    """
    def __init__(self, undef_enabled=True):
        super(NotificationDrop, self).__init__()
        self._type = ("NotificationDrop", True)
        self._drop_count = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NotificationDrop, cls).from_dict(data, dirty, undef_enabled)
        obj._drop_count = (data.get("dropCount", obj.__undef__), dirty)
        if obj._drop_count[0] is not None and obj._drop_count[0] is not obj.__undef__:
            assert isinstance(obj._drop_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._drop_count[0]))
            common.validate_format(obj._drop_count[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NotificationDrop, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "drop_count" == "type" or (self.drop_count is not self.__undef__ and not (dirty and not self._drop_count[1])):
            dct["dropCount"] = dictify(self.drop_count)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._drop_count = (self._drop_count[0], True)

    def is_dirty(self):
        return any([self._drop_count[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NotificationDrop):
            return False
        return super(NotificationDrop, self).__eq__(other) and \
               self.drop_count == other.drop_count

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def drop_count(self):
        """
        The number of notifications which were dropped since the last
        notifications were pulled. If this is greater than zero, you may want
        to refresh your view of the data to ensure everything is up to date.

        :rtype: ``int``
        """
        return self._drop_count[0]

    @drop_count.setter
    def drop_count(self, value):
        self._drop_count = (value, True)

class ApplyVersionParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to upgrade.
    """
    def __init__(self, undef_enabled=True):
        super(ApplyVersionParameters, self).__init__()
        self._type = ("ApplyVersionParameters", True)
        self._reboot = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ApplyVersionParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._reboot = (data.get("reboot", obj.__undef__), dirty)
        if obj._reboot[0] is not None and obj._reboot[0] is not obj.__undef__:
            assert isinstance(obj._reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._reboot[0]))
            common.validate_format(obj._reboot[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ApplyVersionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "reboot" == "type" or (self.reboot is not self.__undef__ and not (dirty and not self._reboot[1])):
            dct["reboot"] = dictify(self.reboot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._reboot = (self._reboot[0], True)

    def is_dirty(self):
        return any([self._reboot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ApplyVersionParameters):
            return False
        return super(ApplyVersionParameters, self).__eq__(other) and \
               self.reboot == other.reboot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def reboot(self):
        """
        *(default value: True)* If true, the system reboots immediately after
        upgrade.  If false, the system is shutdown.

        :rtype: ``bool``
        """
        return self._reboot[0]

    @reboot.setter
    def reboot(self, value):
        self._reboot = (value, True)

class NetworkRoute(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* IP routing table.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkRoute, self).__init__()
        self._type = ("NetworkRoute", True)
        self._out_interface = (self.__undef__, True)
        self._destination = (self.__undef__, True)
        self._gateway = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkRoute, cls).from_dict(data, dirty, undef_enabled)
        obj._out_interface = (data.get("outInterface", obj.__undef__), dirty)
        if obj._out_interface[0] is not None and obj._out_interface[0] is not obj.__undef__:
            assert isinstance(obj._out_interface[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._out_interface[0]))
            common.validate_format(obj._out_interface[0], "objectReference", None, None)
        obj._destination = (data.get("destination", obj.__undef__), dirty)
        if obj._destination[0] is not None and obj._destination[0] is not obj.__undef__:
            assert isinstance(obj._destination[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination[0]))
            common.validate_format(obj._destination[0], "routeDestination", None, None)
        obj._gateway = (data.get("gateway", obj.__undef__), dirty)
        if obj._gateway[0] is not None and obj._gateway[0] is not obj.__undef__:
            assert isinstance(obj._gateway[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._gateway[0]))
            common.validate_format(obj._gateway[0], "ipAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkRoute, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "out_interface" == "type" or (self.out_interface is not self.__undef__ and not (dirty and not self._out_interface[1])):
            dct["outInterface"] = dictify(self.out_interface)
        if "destination" == "type" or (self.destination is not self.__undef__ and not (dirty and not self._destination[1])):
            dct["destination"] = dictify(self.destination)
        if "gateway" == "type" or (self.gateway is not self.__undef__ and not (dirty and not self._gateway[1])):
            dct["gateway"] = dictify(self.gateway)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._out_interface = (self._out_interface[0], True)
        self._destination = (self._destination[0], True)
        self._gateway = (self._gateway[0], True)

    def is_dirty(self):
        return any([self._out_interface[1], self._destination[1], self._gateway[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkRoute):
            return False
        return super(NetworkRoute, self).__eq__(other) and \
               self.out_interface == other.out_interface and \
               self.destination == other.destination and \
               self.gateway == other.gateway

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def out_interface(self):
        """
        Output interface to use for the route.

        :rtype: ``basestring``
        """
        return self._out_interface[0]

    @out_interface.setter
    def out_interface(self, value):
        self._out_interface = (value, True)

    @property
    def destination(self):
        """
        Destination for the route in Classless Inter-Domain Routing (CIDR)
        notation or the keyword 'default'.

        :rtype: ``basestring``
        """
        return self._destination[0]

    @destination.setter
    def destination(self, value):
        self._destination = (value, True)

    @property
    def gateway(self):
        """
        Next hop for the route.

        :rtype: ``basestring``
        """
        return self._gateway[0]

    @gateway.setter
    def gateway(self, value):
        self._gateway = (value, True)

class SyncParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to sync requests.
    """
    def __init__(self, undef_enabled=True):
        super(SyncParameters, self).__init__()
        self._type = ("SyncParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyncParameters):
            return False
        return super(SyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ProxyConfiguration(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Proxy configuration
    for a specific protocol.
    """
    def __init__(self, undef_enabled=True):
        super(ProxyConfiguration, self).__init__()
        self._type = ("ProxyConfiguration", True)
        self._username = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProxyConfiguration, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProxyConfiguration, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._host = (self._host[0], True)
        self._password = (self._password[0], True)
        self._enabled = (self._enabled[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._host[1], self._password[1], self._enabled[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProxyConfiguration):
            return False
        return super(ProxyConfiguration, self).__eq__(other) and \
               self.username == other.username and \
               self.host == other.host and \
               self.password == other.password and \
               self.enabled == other.enabled and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        If authentication is required, the username to use when connecting to
        the proxy.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def host(self):
        """
        Host or IP address to use as proxy.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def password(self):
        """
        If authentication is required, the password to use when connecting to
        the proxy.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def enabled(self):
        """
        True if the proxy is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def port(self):
        """
        Port to use when connecting to the proxy host.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class ChecklistItem(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Generic checklist
    item.
    """
    def __init__(self, undef_enabled=True):
        super(ChecklistItem, self).__init__()
        self._type = ("ChecklistItem", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ChecklistItem, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ChecklistItem, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ChecklistItem):
            return False
        return super(ChecklistItem, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SnapshotSpaceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Input to the operation
    to determine how much space is used by a set of snapshots.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotSpaceParameters, self).__init__()
        self._type = ("SnapshotSpaceParameters", True)
        self._object_references = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotSpaceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "objectReferences" not in data:
            raise ValueError("Missing required property \"objectReferences\".")
        obj._object_references = []
        for item in data.get("objectReferences") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._object_references.append(item)
        obj._object_references = (obj._object_references, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotSpaceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_references" == "type" or (self.object_references is not self.__undef__ and not (dirty and not self._object_references[1])):
            dct["objectReferences"] = dictify(self.object_references)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_references = (self._object_references[0], True)

    def is_dirty(self):
        return any([self._object_references[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotSpaceParameters):
            return False
        return super(SnapshotSpaceParameters, self).__eq__(other) and \
               self.object_references == other.object_references

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_references(self):
        """
        FilesystemObjects to query, in canonical object reference form.

        :rtype: ``list`` of ``basestring``
        """
        return self._object_references[0]

    @object_references.setter
    def object_references(self, value):
        self._object_references = (value, True)

class SourceConfigConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Mechanism to test JDBC
    connectivity to source configs.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConfigConnectivity, self).__init__()
        self._type = ("SourceConfigConnectivity", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConfigConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConfigConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConfigConnectivity):
            return False
        return super(SourceConfigConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        Database username.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        Database password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

class VersionInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Representation of a
    Delphix software revision.
    """
    def __init__(self, undef_enabled=True):
        super(VersionInfo, self).__init__()
        self._type = ("VersionInfo", True)
        self._micro = (self.__undef__, True)
        self._major = (self.__undef__, True)
        self._minor = (self.__undef__, True)
        self._patch = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VersionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._micro = (data.get("micro", obj.__undef__), dirty)
        if obj._micro[0] is not None and obj._micro[0] is not obj.__undef__:
            assert isinstance(obj._micro[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._micro[0]))
            common.validate_format(obj._micro[0], "None", None, None)
        obj._major = (data.get("major", obj.__undef__), dirty)
        if obj._major[0] is not None and obj._major[0] is not obj.__undef__:
            assert isinstance(obj._major[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._major[0]))
            common.validate_format(obj._major[0], "None", None, None)
        obj._minor = (data.get("minor", obj.__undef__), dirty)
        if obj._minor[0] is not None and obj._minor[0] is not obj.__undef__:
            assert isinstance(obj._minor[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._minor[0]))
            common.validate_format(obj._minor[0], "None", None, None)
        obj._patch = (data.get("patch", obj.__undef__), dirty)
        if obj._patch[0] is not None and obj._patch[0] is not obj.__undef__:
            assert isinstance(obj._patch[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._patch[0]))
            common.validate_format(obj._patch[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VersionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "micro" == "type" or (self.micro is not self.__undef__ and not (dirty and not self._micro[1])):
            dct["micro"] = dictify(self.micro)
        if "major" == "type" or (self.major is not self.__undef__ and not (dirty and not self._major[1])):
            dct["major"] = dictify(self.major)
        if "minor" == "type" or (self.minor is not self.__undef__ and not (dirty and not self._minor[1])):
            dct["minor"] = dictify(self.minor)
        if "patch" == "type" or (self.patch is not self.__undef__ and not (dirty and not self._patch[1])):
            dct["patch"] = dictify(self.patch)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._micro = (self._micro[0], True)
        self._major = (self._major[0], True)
        self._minor = (self._minor[0], True)
        self._patch = (self._patch[0], True)

    def is_dirty(self):
        return any([self._micro[1], self._major[1], self._minor[1], self._patch[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VersionInfo):
            return False
        return super(VersionInfo, self).__eq__(other) and \
               self.micro == other.micro and \
               self.major == other.major and \
               self.minor == other.minor and \
               self.patch == other.patch

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def micro(self):
        """
        Micro version number.

        :rtype: ``int``
        """
        return self._micro[0]

    @micro.setter
    def micro(self, value):
        self._micro = (value, True)

    @property
    def major(self):
        """
        Major version number.

        :rtype: ``int``
        """
        return self._major[0]

    @major.setter
    def major(self, value):
        self._major = (value, True)

    @property
    def minor(self):
        """
        Minor version number.

        :rtype: ``int``
        """
        return self._minor[0]

    @minor.setter
    def minor(self, value):
        self._minor = (value, True)

    @property
    def patch(self):
        """
        Patch version number.

        :rtype: ``int``
        """
        return self._patch[0]

    @patch.setter
    def patch(self, value):
        self._patch = (value, True)

class OracleDatabaseStatsSection(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Oracle database
    performance statistics for a specific section.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseStatsSection, self).__init__()
        self._type = ("OracleDatabaseStatsSection", True)
        self._row_values = (self.__undef__, True)
        self._column_headers = (self.__undef__, True)
        self._section_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseStatsSection, cls).from_dict(data, dirty, undef_enabled)
        obj._row_values = []
        for item in data.get("rowValues") or []:
            obj._row_values.append(factory.create_object(item))
            factory.validate_type(obj._row_values[-1], "OracleDatabaseStatistic")
        obj._row_values = (obj._row_values, dirty)
        obj._column_headers = []
        for item in data.get("columnHeaders") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._column_headers.append(item)
        obj._column_headers = (obj._column_headers, dirty)
        obj._section_name = (data.get("sectionName", obj.__undef__), dirty)
        if obj._section_name[0] is not None and obj._section_name[0] is not obj.__undef__:
            assert isinstance(obj._section_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._section_name[0]))
            common.validate_format(obj._section_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseStatsSection, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "row_values" == "type" or (self.row_values is not self.__undef__ and not (dirty and not self._row_values[1])):
            dct["rowValues"] = dictify(self.row_values)
        if "column_headers" == "type" or (self.column_headers is not self.__undef__ and not (dirty and not self._column_headers[1])):
            dct["columnHeaders"] = dictify(self.column_headers)
        if "section_name" == "type" or (self.section_name is not self.__undef__ and not (dirty and not self._section_name[1])):
            dct["sectionName"] = dictify(self.section_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._row_values = (self._row_values[0], True)
        self._column_headers = (self._column_headers[0], True)
        self._section_name = (self._section_name[0], True)

    def is_dirty(self):
        return any([self._row_values[1], self._column_headers[1], self._section_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseStatsSection):
            return False
        return super(OracleDatabaseStatsSection, self).__eq__(other) and \
               self.row_values == other.row_values and \
               self.column_headers == other.column_headers and \
               self.section_name == other.section_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def row_values(self):
        """
        List of statistic rows corresponding to column headers.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleDatabaseStatistic`
        """
        return self._row_values[0]

    @row_values.setter
    def row_values(self, value):
        self._row_values = (value, True)

    @property
    def column_headers(self):
        """
        List of statistic column headers.

        :rtype: ``list`` of ``basestring``
        """
        return self._column_headers[0]

    @column_headers.setter
    def column_headers(self, value):
        self._column_headers = (value, True)

    @property
    def section_name(self):
        """
        Database statistic section name.

        :rtype: ``basestring``
        """
        return self._section_name[0]

    @section_name.setter
    def section_name(self, value):
        self._section_name = (value, True)

class HostCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used
    for the add host operation.
    """
    def __init__(self, undef_enabled=True):
        super(HostCreateParameters, self).__init__()
        self._type = ("HostCreateParameters", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "host" in data and data["host"] is not None:
            obj._host = (factory.create_object(data["host"], "Host"), dirty)
            factory.validate_type(obj._host[0], "Host")
        else:
            obj._host = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostCreateParameters):
            return False
        return super(HostCreateParameters, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The host object.

        :rtype: :py:class:`v1_3_0.web.vo.Host`
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class AttachSourceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Represents the
    parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(AttachSourceParameters, self).__init__()
        self._type = ("AttachSourceParameters", True)
        self._source = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AttachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "Source"), dirty)
            factory.validate_type(obj._source[0], "Source")
        else:
            obj._source = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AttachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)

    def is_dirty(self):
        return any([self._source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AttachSourceParameters):
            return False
        return super(AttachSourceParameters, self).__eq__(other) and \
               self.source == other.source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing source
        config.

        :rtype: :py:class:`v1_3_0.web.vo.Source`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

class TimeflowRangeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to fetch timeflow ranges.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRangeParameters, self).__init__()
        self._type = ("TimeflowRangeParameters", True)
        self._end_point = (self.__undef__, True)
        self._start_point = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRangeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "endPoint" in data and data["endPoint"] is not None:
            obj._end_point = (factory.create_object(data["endPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._end_point[0], "TimeflowPoint")
        else:
            obj._end_point = (obj.__undef__, dirty)
        if "startPoint" in data and data["startPoint"] is not None:
            obj._start_point = (factory.create_object(data["startPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._start_point[0], "TimeflowPoint")
        else:
            obj._start_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRangeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_point" == "type" or (self.end_point is not self.__undef__ and not (dirty and not self._end_point[1])):
            dct["endPoint"] = dictify(self.end_point)
        if "start_point" == "type" or (self.start_point is not self.__undef__ and not (dirty and not self._start_point[1])):
            dct["startPoint"] = dictify(self.start_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_point = (self._end_point[0], True)
        self._start_point = (self._start_point[0], True)

    def is_dirty(self):
        return any([self._end_point[1], self._start_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRangeParameters):
            return False
        return super(TimeflowRangeParameters, self).__eq__(other) and \
               self.end_point == other.end_point and \
               self.start_point == other.start_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_point(self):
        """
        The ending timeflow point of the time period to search for timeflow
        ranges.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._end_point[0]

    @end_point.setter
    def end_point(self, value):
        self._end_point = (value, True)

    @property
    def start_point(self):
        """
        The starting timeflow point of the time period to search for timeflow
        ranges.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._start_point[0]

    @start_point.setter
    def start_point(self, value):
        self._start_point = (value, True)

class PreProvisioningRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Runtime properties for
    pre-provisioning of a MSSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(PreProvisioningRuntime, self).__init__()
        self._type = ("PreProvisioningRuntime", True)
        self._status = (self.__undef__, True)
        self._last_update_timestamp = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._pending_action = (self.__undef__, True)
        self._pre_provisioning_state = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PreProvisioningRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._last_update_timestamp = (data.get("lastUpdateTimestamp", obj.__undef__), dirty)
        if obj._last_update_timestamp[0] is not None and obj._last_update_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._last_update_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_update_timestamp[0]))
            common.validate_format(obj._last_update_timestamp[0], "None", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._pending_action = (data.get("pendingAction", obj.__undef__), dirty)
        if obj._pending_action[0] is not None and obj._pending_action[0] is not obj.__undef__:
            assert isinstance(obj._pending_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pending_action[0]))
            common.validate_format(obj._pending_action[0], "None", None, None)
        obj._pre_provisioning_state = (data.get("preProvisioningState", obj.__undef__), dirty)
        if obj._pre_provisioning_state[0] is not None and obj._pre_provisioning_state[0] is not obj.__undef__:
            assert isinstance(obj._pre_provisioning_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_provisioning_state[0]))
            assert obj._pre_provisioning_state[0] in [u'ACTIVE', u'INACTIVE', u'FAULTED', u'UNKNOWN'], "Expected enum [u'ACTIVE', u'INACTIVE', u'FAULTED', u'UNKNOWN'] but got %s" % obj._pre_provisioning_state[0]
            common.validate_format(obj._pre_provisioning_state[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PreProvisioningRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "last_update_timestamp" == "type" or (self.last_update_timestamp is not self.__undef__ and not (dirty and not self._last_update_timestamp[1])):
            dct["lastUpdateTimestamp"] = dictify(self.last_update_timestamp)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "pending_action" == "type" or (self.pending_action is not self.__undef__ and not (dirty and not self._pending_action[1])):
            dct["pendingAction"] = dictify(self.pending_action)
        if "pre_provisioning_state" == "type" or (self.pre_provisioning_state is not self.__undef__ and not (dirty and not self._pre_provisioning_state[1])):
            dct["preProvisioningState"] = dictify(self.pre_provisioning_state)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._last_update_timestamp = (self._last_update_timestamp[0], True)
        self._response = (self._response[0], True)
        self._pending_action = (self._pending_action[0], True)
        self._pre_provisioning_state = (self._pre_provisioning_state[0], True)

    def is_dirty(self):
        return any([self._status[1], self._last_update_timestamp[1], self._response[1], self._pending_action[1], self._pre_provisioning_state[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PreProvisioningRuntime):
            return False
        return super(PreProvisioningRuntime, self).__eq__(other) and \
               self.status == other.status and \
               self.last_update_timestamp == other.last_update_timestamp and \
               self.response == other.response and \
               self.pending_action == other.pending_action and \
               self.pre_provisioning_state == other.pre_provisioning_state

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the pre-provisioning run.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def last_update_timestamp(self):
        """
        Timestamp of the last update to the status.

        :rtype: ``basestring``
        """
        return self._last_update_timestamp[0]

    @last_update_timestamp.setter
    def last_update_timestamp(self, value):
        self._last_update_timestamp = (value, True)

    @property
    def response(self):
        """
        Response taken based on the status of the pre-provisioning run.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def pending_action(self):
        """
        User action required to resolve any error that the pre-provisioning run
        encountered.

        :rtype: ``basestring``
        """
        return self._pending_action[0]

    @pending_action.setter
    def pending_action(self, value):
        self._pending_action = (value, True)

    @property
    def pre_provisioning_state(self):
        """
        Indicates the current state of pre-provisioning for the database.
        *(permitted values: ACTIVE, INACTIVE, FAULTED, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._pre_provisioning_state[0]

    @pre_provisioning_state.setter
    def pre_provisioning_state(self, value):
        self._pre_provisioning_state = (value, True)

class HostOS(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The operating system
    information for the host.
    """
    def __init__(self, undef_enabled=True):
        super(HostOS, self).__init__()
        self._type = ("HostOS", True)
        self._kernel = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._release = (self.__undef__, True)
        self._timezone = (self.__undef__, True)
        self._distribution = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostOS, cls).from_dict(data, dirty, undef_enabled)
        obj._kernel = (data.get("kernel", obj.__undef__), dirty)
        if obj._kernel[0] is not None and obj._kernel[0] is not obj.__undef__:
            assert isinstance(obj._kernel[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._kernel[0]))
            common.validate_format(obj._kernel[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._release = (data.get("release", obj.__undef__), dirty)
        if obj._release[0] is not None and obj._release[0] is not obj.__undef__:
            assert isinstance(obj._release[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._release[0]))
            common.validate_format(obj._release[0], "None", None, None)
        obj._timezone = (data.get("timezone", obj.__undef__), dirty)
        if obj._timezone[0] is not None and obj._timezone[0] is not obj.__undef__:
            assert isinstance(obj._timezone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timezone[0]))
            common.validate_format(obj._timezone[0], "None", None, None)
        obj._distribution = (data.get("distribution", obj.__undef__), dirty)
        if obj._distribution[0] is not None and obj._distribution[0] is not obj.__undef__:
            assert isinstance(obj._distribution[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._distribution[0]))
            common.validate_format(obj._distribution[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostOS, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "kernel" == "type" or (self.kernel is not self.__undef__ and not (dirty and not self._kernel[1])):
            dct["kernel"] = dictify(self.kernel)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "release" == "type" or (self.release is not self.__undef__ and not (dirty and not self._release[1])):
            dct["release"] = dictify(self.release)
        if "timezone" == "type" or (self.timezone is not self.__undef__ and not (dirty and not self._timezone[1])):
            dct["timezone"] = dictify(self.timezone)
        if "distribution" == "type" or (self.distribution is not self.__undef__ and not (dirty and not self._distribution[1])):
            dct["distribution"] = dictify(self.distribution)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._kernel = (self._kernel[0], True)
        self._name = (self._name[0], True)
        self._version = (self._version[0], True)
        self._release = (self._release[0], True)
        self._timezone = (self._timezone[0], True)
        self._distribution = (self._distribution[0], True)

    def is_dirty(self):
        return any([self._kernel[1], self._name[1], self._version[1], self._release[1], self._timezone[1], self._distribution[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostOS):
            return False
        return super(HostOS, self).__eq__(other) and \
               self.kernel == other.kernel and \
               self.name == other.name and \
               self.version == other.version and \
               self.release == other.release and \
               self.timezone == other.timezone and \
               self.distribution == other.distribution

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def kernel(self):
        """
        The OS kernel.

        :rtype: ``basestring``
        """
        return self._kernel[0]

    @kernel.setter
    def kernel(self, value):
        self._kernel = (value, True)

    @property
    def name(self):
        """
        The OS name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def version(self):
        """
        The OS version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def release(self):
        """
        The OS release.

        :rtype: ``basestring``
        """
        return self._release[0]

    @release.setter
    def release(self, value):
        self._release = (value, True)

    @property
    def timezone(self):
        """
        The OS timezone.

        :rtype: ``basestring``
        """
        return self._timezone[0]

    @timezone.setter
    def timezone(self, value):
        self._timezone = (value, True)

    @property
    def distribution(self):
        """
        The OS distribution.

        :rtype: ``basestring``
        """
        return self._distribution[0]

    @distribution.setter
    def distribution(self, value):
        self._distribution = (value, True)

class ProvisionParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to provision requests.
    """
    def __init__(self, undef_enabled=True):
        super(ProvisionParameters, self).__init__()
        self._type = ("ProvisionParameters", True)
        self._source_config = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "Source"), dirty)
            factory.validate_type(obj._source[0], "Source")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "Container"), dirty)
            factory.validate_type(obj._container[0], "Container")
        else:
            obj._container = (obj.__undef__, dirty)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._source[1], self._container[1], self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProvisionParameters):
            return False
        return super(ProvisionParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.source == other.source and \
               self.container == other.container and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_3_0.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_3_0.web.vo.Source`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_3_0.web.vo.Container`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point, bookmark or semantic location to base provisioning
        on.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class Datapoint(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A datapoint recorded
    by the analytics system.
    """
    def __init__(self, undef_enabled=True):
        super(Datapoint, self).__init__()
        self._type = ("Datapoint", True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Datapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Datapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Datapoint):
            return False
        return super(Datapoint, self).__eq__(other) and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The time this datapoint was collected.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class SNMPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* SNMP configuration
    """
    def __init__(self, undef_enabled=True):
        super(SNMPConfig, self).__init__()
        self._type = ("SNMPConfig", True)
        self._enabled = (self.__undef__, True)
        self._severity = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SNMPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING', u'INFORMATIONAL'], "Expected enum [u'CRITICAL', u'WARNING', u'INFORMATIONAL'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SNMPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)
        self._severity = (self._severity[0], True)

    def is_dirty(self):
        return any([self._enabled[1], self._severity[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SNMPConfig):
            return False
        return super(SNMPConfig, self).__eq__(other) and \
               self.enabled == other.enabled and \
               self.severity == other.severity

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the SNMP service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def severity(self):
        """
        *(default value: WARNING)* SNMP trap severity. SNMP managers are only
        notified of events at or above this level. *(permitted values:
        CRITICAL, WARNING, INFORMATIONAL)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

class FilesystemLayout(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The filesystem
    configuration of a database.
    """
    def __init__(self, undef_enabled=True):
        super(FilesystemLayout, self).__init__()
        self._type = ("FilesystemLayout", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FilesystemLayout):
            return False
        return super(FilesystemLayout, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SMTPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* SMTP configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SMTPConfig, self).__init__()
        self._type = ("SMTPConfig", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._send_timeout = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._tls_enabled = (self.__undef__, True)
        self._server = (self.__undef__, True)
        self._authentication_enabled = (self.__undef__, True)
        self._from_address = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SMTPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        obj._send_timeout = (data.get("sendTimeout", obj.__undef__), dirty)
        if obj._send_timeout[0] is not None and obj._send_timeout[0] is not obj.__undef__:
            assert isinstance(obj._send_timeout[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._send_timeout[0]))
            common.validate_format(obj._send_timeout[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._tls_enabled = (data.get("tlsEnabled", obj.__undef__), dirty)
        if obj._tls_enabled[0] is not None and obj._tls_enabled[0] is not obj.__undef__:
            assert isinstance(obj._tls_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._tls_enabled[0]))
            common.validate_format(obj._tls_enabled[0], "None", None, None)
        obj._server = (data.get("server", obj.__undef__), dirty)
        if obj._server[0] is not None and obj._server[0] is not obj.__undef__:
            assert isinstance(obj._server[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server[0]))
            common.validate_format(obj._server[0], "host", None, None)
        obj._authentication_enabled = (data.get("authenticationEnabled", obj.__undef__), dirty)
        if obj._authentication_enabled[0] is not None and obj._authentication_enabled[0] is not obj.__undef__:
            assert isinstance(obj._authentication_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._authentication_enabled[0]))
            common.validate_format(obj._authentication_enabled[0], "None", None, None)
        obj._from_address = (data.get("fromAddress", obj.__undef__), dirty)
        if obj._from_address[0] is not None and obj._from_address[0] is not obj.__undef__:
            assert isinstance(obj._from_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._from_address[0]))
            common.validate_format(obj._from_address[0], "email", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SMTPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "send_timeout" == "type" or (self.send_timeout is not self.__undef__ and not (dirty and not self._send_timeout[1])):
            dct["sendTimeout"] = dictify(self.send_timeout)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "tls_enabled" == "type" or (self.tls_enabled is not self.__undef__ and not (dirty and not self._tls_enabled[1])):
            dct["tlsEnabled"] = dictify(self.tls_enabled)
        if "server" == "type" or (self.server is not self.__undef__ and not (dirty and not self._server[1])):
            dct["server"] = dictify(self.server)
        if "authentication_enabled" == "type" or (self.authentication_enabled is not self.__undef__ and not (dirty and not self._authentication_enabled[1])):
            dct["authenticationEnabled"] = dictify(self.authentication_enabled)
        if "from_address" == "type" or (self.from_address is not self.__undef__ and not (dirty and not self._from_address[1])):
            dct["fromAddress"] = dictify(self.from_address)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)
        self._send_timeout = (self._send_timeout[0], True)
        self._enabled = (self._enabled[0], True)
        self._tls_enabled = (self._tls_enabled[0], True)
        self._server = (self._server[0], True)
        self._authentication_enabled = (self._authentication_enabled[0], True)
        self._from_address = (self._from_address[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1], self._send_timeout[1], self._enabled[1], self._tls_enabled[1], self._server[1], self._authentication_enabled[1], self._from_address[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SMTPConfig):
            return False
        return super(SMTPConfig, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password and \
               self.send_timeout == other.send_timeout and \
               self.enabled == other.enabled and \
               self.tls_enabled == other.tls_enabled and \
               self.server == other.server and \
               self.authentication_enabled == other.authentication_enabled and \
               self.from_address == other.from_address and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        If authentication is enabled, username to use when authenticating to
        the server.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        If authentication is enabled, password to use when authenticating to
        the server.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def send_timeout(self):
        """
        Maximum timeout to wait, in seconds, when sending mail.

        :rtype: ``int``
        """
        return self._send_timeout[0]

    @send_timeout.setter
    def send_timeout(self, value):
        self._send_timeout = (value, True)

    @property
    def enabled(self):
        """
        True if outbound email is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def tls_enabled(self):
        """
        True if TLS (transport layer security) should be used.

        :rtype: ``bool``
        """
        return self._tls_enabled[0]

    @tls_enabled.setter
    def tls_enabled(self, value):
        self._tls_enabled = (value, True)

    @property
    def server(self):
        """
        IP address or hostname of SMTP relay server.

        :rtype: ``basestring``
        """
        return self._server[0]

    @server.setter
    def server(self, value):
        self._server = (value, True)

    @property
    def authentication_enabled(self):
        """
        True if username/password authentication should be used.

        :rtype: ``bool``
        """
        return self._authentication_enabled[0]

    @authentication_enabled.setter
    def authentication_enabled(self, value):
        self._authentication_enabled = (value, True)

    @property
    def from_address(self):
        """
        From address to use when sending mail. If unspecified,
        'noreply@delphix.com' is used.

        :rtype: ``basestring``
        """
        return self._from_address[0]

    @from_address.setter
    def from_address(self, value):
        self._from_address = (value, True)

    @property
    def port(self):
        """
        *(default value: -1)* Port number to use. A value of -1 indicates the
        default (25 or 587 for TLS).

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class SourcingPolicy(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Database policies for
    managing snapsync and logsync across sources for a MSSQL container.
    """
    def __init__(self, undef_enabled=True):
        super(SourcingPolicy, self).__init__()
        self._type = ("SourcingPolicy", True)
        self._load_from_backup = (self.__undef__, True)
        self._logsync_enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourcingPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._load_from_backup = (data.get("loadFromBackup", obj.__undef__), dirty)
        if obj._load_from_backup[0] is not None and obj._load_from_backup[0] is not obj.__undef__:
            assert isinstance(obj._load_from_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._load_from_backup[0]))
            common.validate_format(obj._load_from_backup[0], "None", None, None)
        obj._logsync_enabled = (data.get("logsyncEnabled", obj.__undef__), dirty)
        if obj._logsync_enabled[0] is not None and obj._logsync_enabled[0] is not obj.__undef__:
            assert isinstance(obj._logsync_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._logsync_enabled[0]))
            common.validate_format(obj._logsync_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourcingPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "load_from_backup" == "type" or (self.load_from_backup is not self.__undef__ and not (dirty and not self._load_from_backup[1])):
            dct["loadFromBackup"] = dictify(self.load_from_backup)
        if "logsync_enabled" == "type" or (self.logsync_enabled is not self.__undef__ and not (dirty and not self._logsync_enabled[1])):
            dct["logsyncEnabled"] = dictify(self.logsync_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._load_from_backup = (self._load_from_backup[0], True)
        self._logsync_enabled = (self._logsync_enabled[0], True)

    def is_dirty(self):
        return any([self._load_from_backup[1], self._logsync_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourcingPolicy):
            return False
        return super(SourcingPolicy, self).__eq__(other) and \
               self.load_from_backup == other.load_from_backup and \
               self.logsync_enabled == other.logsync_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def load_from_backup(self):
        """
        True if the initial load and subsequent syncs for this container
        restore from already                             existing database
        backups. In such cases Delphix does not take any full database backups
        of the source database. When false, Delphix will take a full backup of
        the source.

        :rtype: ``bool``
        """
        return self._load_from_backup[0]

    @load_from_backup.setter
    def load_from_backup(self, value):
        self._load_from_backup = (value, True)

    @property
    def logsync_enabled(self):
        """
        True if logsync should run for this database.

        :rtype: ``bool``
        """
        return self._logsync_enabled[0]

    @logsync_enabled.setter
    def logsync_enabled(self, value):
        self._logsync_enabled = (value, True)

class SourceRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Runtime properties of
    a linked or virtual source database.
    """
    def __init__(self, undef_enabled=True):
        super(SourceRuntime, self).__init__()
        self._type = ("SourceRuntime", True)
        self._accessible = (self.__undef__, True)
        self._database_size = (self.__undef__, True)
        self._status = (self.__undef__, True)
        self._not_accessible_reason = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._accessible = (data.get("accessible", obj.__undef__), dirty)
        if obj._accessible[0] is not None and obj._accessible[0] is not obj.__undef__:
            assert isinstance(obj._accessible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._accessible[0]))
            common.validate_format(obj._accessible[0], "None", None, None)
        obj._database_size = (data.get("databaseSize", obj.__undef__), dirty)
        if obj._database_size[0] is not None and obj._database_size[0] is not obj.__undef__:
            assert isinstance(obj._database_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._database_size[0]))
            common.validate_format(obj._database_size[0], "None", None, None)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'RUNNING', u'INACTIVE', u'PENDING', u'CANCELED', u'FAILED', u'CHECKING', u'UNKNOWN'], "Expected enum [u'RUNNING', u'INACTIVE', u'PENDING', u'CANCELED', u'FAILED', u'CHECKING', u'UNKNOWN'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._not_accessible_reason = (data.get("notAccessibleReason", obj.__undef__), dirty)
        if obj._not_accessible_reason[0] is not None and obj._not_accessible_reason[0] is not obj.__undef__:
            assert isinstance(obj._not_accessible_reason[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._not_accessible_reason[0]))
            common.validate_format(obj._not_accessible_reason[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "accessible" == "type" or (self.accessible is not self.__undef__ and not (dirty and not self._accessible[1])):
            dct["accessible"] = dictify(self.accessible)
        if "database_size" == "type" or (self.database_size is not self.__undef__ and not (dirty and not self._database_size[1])):
            dct["databaseSize"] = dictify(self.database_size)
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "not_accessible_reason" == "type" or (self.not_accessible_reason is not self.__undef__ and not (dirty and not self._not_accessible_reason[1])):
            dct["notAccessibleReason"] = dictify(self.not_accessible_reason)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._accessible = (self._accessible[0], True)
        self._database_size = (self._database_size[0], True)
        self._status = (self._status[0], True)
        self._not_accessible_reason = (self._not_accessible_reason[0], True)

    def is_dirty(self):
        return any([self._accessible[1], self._database_size[1], self._status[1], self._not_accessible_reason[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceRuntime):
            return False
        return super(SourceRuntime, self).__eq__(other) and \
               self.accessible == other.accessible and \
               self.database_size == other.database_size and \
               self.status == other.status and \
               self.not_accessible_reason == other.not_accessible_reason

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def accessible(self):
        """
        True if the source is jdbc accessible. If false then no properties can
        be retrieved.

        :rtype: ``bool``
        """
        return self._accessible[0]

    @accessible.setter
    def accessible(self, value):
        self._accessible = (value, True)

    @property
    def database_size(self):
        """
        Size of the database in bytes.

        :rtype: ``float``
        """
        return self._database_size[0]

    @database_size.setter
    def database_size(self, value):
        self._database_size = (value, True)

    @property
    def status(self):
        """
        Status of the source. 'Unknown' if all attempts to connect to the
        source failed. *(permitted values: RUNNING, INACTIVE, PENDING,
        CANCELED, FAILED, CHECKING, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def not_accessible_reason(self):
        """
        The reason why the source is not jdbc accessible.

        :rtype: ``basestring``
        """
        return self._not_accessible_reason[0]

    @not_accessible_reason.setter
    def not_accessible_reason(self, value):
        self._not_accessible_reason = (value, True)

class DatabaseTemplateConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Static template
    configuration information for a given source type.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseTemplateConfig, self).__init__()
        self._type = ("DatabaseTemplateConfig", True)
        self._reserved = (self.__undef__, True)
        self._source_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseTemplateConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._reserved = []
        for item in data.get("reserved") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._reserved.append(item)
        obj._reserved = (obj._reserved, dirty)
        obj._source_type = (data.get("sourceType", obj.__undef__), dirty)
        if obj._source_type[0] is not None and obj._source_type[0] is not obj.__undef__:
            assert isinstance(obj._source_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_type[0]))
            common.validate_format(obj._source_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseTemplateConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "reserved" == "type" or (self.reserved is not self.__undef__ and not (dirty and not self._reserved[1])):
            dct["reserved"] = dictify(self.reserved)
        if "source_type" == "type" or (self.source_type is not self.__undef__ and not (dirty and not self._source_type[1])):
            dct["sourceType"] = dictify(self.source_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._reserved = (self._reserved[0], True)
        self._source_type = (self._source_type[0], True)

    def is_dirty(self):
        return any([self._reserved[1], self._source_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseTemplateConfig):
            return False
        return super(DatabaseTemplateConfig, self).__eq__(other) and \
               self.reserved == other.reserved and \
               self.source_type == other.source_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def reserved(self):
        """
        A list of reserved parameters names that cannot be used in the
        template.

        :rtype: ``list`` of ``basestring``
        """
        return self._reserved[0]

    @reserved.setter
    def reserved(self, value):
        self._reserved = (value, True)

    @property
    def source_type(self):
        """
        The object type for sources to which this template is applicable.

        :rtype: ``basestring``
        """
        return self._source_type[0]

    @source_type.setter
    def source_type(self, value):
        self._source_type = (value, True)

class SupportAccessState(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The state of the
    access to the support shell.
    """
    def __init__(self, undef_enabled=True):
        super(SupportAccessState, self).__init__()
        self._type = ("SupportAccessState", True)
        self._token = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._access_type = (self.__undef__, True)
        self._start_time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SupportAccessState, cls).from_dict(data, dirty, undef_enabled)
        obj._token = (data.get("token", obj.__undef__), dirty)
        if obj._token[0] is not None and obj._token[0] is not obj.__undef__:
            assert isinstance(obj._token[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._token[0]))
            common.validate_format(obj._token[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._access_type = (data.get("accessType", obj.__undef__), dirty)
        if obj._access_type[0] is not None and obj._access_type[0] is not obj.__undef__:
            assert isinstance(obj._access_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._access_type[0]))
            assert obj._access_type[0] in [u'DISABLED', u'ENABLED_NO_TOKEN', u'ENABLED_WITH_TOKEN'], "Expected enum [u'DISABLED', u'ENABLED_NO_TOKEN', u'ENABLED_WITH_TOKEN'] but got %s" % obj._access_type[0]
            common.validate_format(obj._access_type[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SupportAccessState, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "token" == "type" or (self.token is not self.__undef__ and not (dirty and not self._token[1])):
            dct["token"] = dictify(self.token)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "access_type" == "type" or (self.access_type is not self.__undef__ and not (dirty and not self._access_type[1])):
            dct["accessType"] = dictify(self.access_type)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._token = (self._token[0], True)
        self._end_time = (self._end_time[0], True)
        self._access_type = (self._access_type[0], True)
        self._start_time = (self._start_time[0], True)

    def is_dirty(self):
        return any([self._token[1], self._end_time[1], self._access_type[1], self._start_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SupportAccessState):
            return False
        return super(SupportAccessState, self).__eq__(other) and \
               self.token == other.token and \
               self.end_time == other.end_time and \
               self.access_type == other.access_type and \
               self.start_time == other.start_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def token(self):
        """
        If ENABLED_WITH_TOKEN, the token that must be supplied to login.

        :rtype: ``basestring``
        """
        return self._token[0]

    @token.setter
    def token(self, value):
        self._token = (value, True)

    @property
    def end_time(self):
        """
        If ENABLED_WITH_TOKEN, time that the token will no longer be valid.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def access_type(self):
        """
        How the support shell can be accessed. *(permitted values: DISABLED,
        ENABLED_NO_TOKEN, ENABLED_WITH_TOKEN)*

        :rtype: ``basestring``
        """
        return self._access_type[0]

    @access_type.setter
    def access_type(self, value):
        self._access_type = (value, True)

    @property
    def start_time(self):
        """
        If ENABLED_WITH_TOKEN, the time that the token will be valid.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

class CompatibleRepositoriesParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The compatibility
    parameters to use for filtering the list of available repositories.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibleRepositoriesParameters, self).__init__()
        self._type = ("CompatibleRepositoriesParameters", True)
        self._environment = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibleRepositoriesParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibleRepositoriesParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)

    def is_dirty(self):
        return any([self._environment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibleRepositoriesParameters):
            return False
        return super(CompatibleRepositoriesParameters, self).__eq__(other) and \
               self.environment == other.environment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Restrict returned repositories to this environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

class ServiceState(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The runtime state of a
    Delphix service.
    """
    def __init__(self, undef_enabled=True):
        super(ServiceState, self).__init__()
        self._type = ("ServiceState", True)
        self._state = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ServiceState, cls).from_dict(data, dirty, undef_enabled)
        if "state" not in data:
            raise ValueError("Missing required property \"state\".")
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            common.validate_format(obj._state[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ServiceState, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._state = (self._state[0], True)

    def is_dirty(self):
        return any([self._state[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ServiceState):
            return False
        return super(ServiceState, self).__eq__(other) and \
               self.state == other.state

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def state(self):
        """
        A string representation of the service state.

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

class SnapshotSpaceResult(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Result of the
    operation to determine how much space is used by a set of snapshots.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotSpaceResult, self).__init__()
        self._type = ("SnapshotSpaceResult", True)
        self._total_size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotSpaceResult, cls).from_dict(data, dirty, undef_enabled)
        obj._total_size = (data.get("totalSize", obj.__undef__), dirty)
        if obj._total_size[0] is not None and obj._total_size[0] is not obj.__undef__:
            assert isinstance(obj._total_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total_size[0]))
            common.validate_format(obj._total_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotSpaceResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "total_size" == "type" or (self.total_size is not self.__undef__ and not (dirty and not self._total_size[1])):
            dct["totalSize"] = dictify(self.total_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._total_size = (self._total_size[0], True)

    def is_dirty(self):
        return any([self._total_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotSpaceResult):
            return False
        return super(SnapshotSpaceResult, self).__eq__(other) and \
               self.total_size == other.total_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def total_size(self):
        """
        Total amount of space, in bytes, that would be freed by deleting the
        input snapshots.

        :rtype: ``float``
        """
        return self._total_size[0]

    @total_size.setter
    def total_size(self, value):
        self._total_size = (value, True)

class OracleActiveInstance(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Active instance
    information for an Oracle database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleActiveInstance, self).__init__()
        self._type = ("OracleActiveInstance", True)
        self._instance_number = (self.__undef__, True)
        self._host_name = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleActiveInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_number = (data.get("instanceNumber", obj.__undef__), dirty)
        if obj._instance_number[0] is not None and obj._instance_number[0] is not obj.__undef__:
            assert isinstance(obj._instance_number[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._instance_number[0]))
            common.validate_format(obj._instance_number[0], "None", None, None)
        obj._host_name = (data.get("hostName", obj.__undef__), dirty)
        if obj._host_name[0] is not None and obj._host_name[0] is not obj.__undef__:
            assert isinstance(obj._host_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host_name[0]))
            common.validate_format(obj._host_name[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleActiveInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_number" == "type" or (self.instance_number is not self.__undef__ and not (dirty and not self._instance_number[1])):
            dct["instanceNumber"] = dictify(self.instance_number)
        if "host_name" == "type" or (self.host_name is not self.__undef__ and not (dirty and not self._host_name[1])):
            dct["hostName"] = dictify(self.host_name)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_number = (self._instance_number[0], True)
        self._host_name = (self._host_name[0], True)
        self._instance_name = (self._instance_name[0], True)

    def is_dirty(self):
        return any([self._instance_number[1], self._host_name[1], self._instance_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleActiveInstance):
            return False
        return super(OracleActiveInstance, self).__eq__(other) and \
               self.instance_number == other.instance_number and \
               self.host_name == other.host_name and \
               self.instance_name == other.instance_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_number(self):
        """
        The number of the Oracle instance.

        :rtype: ``int``
        """
        return self._instance_number[0]

    @instance_number.setter
    def instance_number(self, value):
        self._instance_number = (value, True)

    @property
    def host_name(self):
        """
        The name of the host the instance runs on.

        :rtype: ``basestring``
        """
        return self._host_name[0]

    @host_name.setter
    def host_name(self, value):
        self._host_name = (value, True)

    @property
    def instance_name(self):
        """
        The name of the Oracle instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

class SyslogConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Syslog configuration
    """
    def __init__(self, undef_enabled=True):
        super(SyslogConfig, self).__init__()
        self._type = ("SyslogConfig", True)
        self._pattern = (self.__undef__, True)
        self._format = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._severity = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyslogConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._pattern = (data.get("pattern", obj.__undef__), dirty)
        if obj._pattern[0] is not None and obj._pattern[0] is not obj.__undef__:
            assert isinstance(obj._pattern[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pattern[0]))
            common.validate_format(obj._pattern[0], "None", None, None)
        obj._format = (data.get("format", obj.__undef__), dirty)
        if obj._format[0] is not None and obj._format[0] is not obj.__undef__:
            assert isinstance(obj._format[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._format[0]))
            assert obj._format[0] in [u'TEXT', u'JSON'], "Expected enum [u'TEXT', u'JSON'] but got %s" % obj._format[0]
            common.validate_format(obj._format[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'EMERGENCY', u'ALERT', u'CRITICAL', u'ERROR', u'WARNING', u'NOTICE', u'INFORMATIONAL', u'DEBUG'], "Expected enum [u'EMERGENCY', u'ALERT', u'CRITICAL', u'ERROR', u'WARNING', u'NOTICE', u'INFORMATIONAL', u'DEBUG'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        obj._servers = []
        for item in data.get("servers") or []:
            obj._servers.append(factory.create_object(item))
            factory.validate_type(obj._servers[-1], "SyslogServer")
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyslogConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "pattern" == "type" or (self.pattern is not self.__undef__ and not (dirty and not self._pattern[1])):
            dct["pattern"] = dictify(self.pattern)
        if "format" == "type" or (self.format is not self.__undef__ and not (dirty and not self._format[1])):
            dct["format"] = dictify(self.format)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._pattern = (self._pattern[0], True)
        self._format = (self._format[0], True)
        self._enabled = (self._enabled[0], True)
        self._severity = (self._severity[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._pattern[1], self._format[1], self._enabled[1], self._severity[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyslogConfig):
            return False
        return super(SyslogConfig, self).__eq__(other) and \
               self.pattern == other.pattern and \
               self.format == other.format and \
               self.enabled == other.enabled and \
               self.severity == other.severity and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def pattern(self):
        """
        *(default value: %-5p delphix : %m%n)* Syslog logging pattern. Events
        will be logged in the pattern as specified.

        :rtype: ``basestring``
        """
        return self._pattern[0]

    @pattern.setter
    def pattern(self, value):
        self._pattern = (value, True)

    @property
    def format(self):
        """
        *(default value: TEXT)* Syslog message format. *(permitted values:
        TEXT, JSON)*

        :rtype: ``basestring``
        """
        return self._format[0]

    @format.setter
    def format(self, value):
        self._format = (value, True)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the syslog service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def severity(self):
        """
        *(default value: WARNING)* Syslog logging severity. Only events at or
        above this severity will be logged. *(permitted values: EMERGENCY,
        ALERT, CRITICAL, ERROR, WARNING, NOTICE, INFORMATIONAL, DEBUG)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

    @property
    def servers(self):
        """
        List of syslog servers. At least one syslog server must be specified.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.SyslogServer`
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class AxisConstraint(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Constraints placed on
    the axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(AxisConstraint, self).__init__()
        self._type = ("AxisConstraint", True)
        self._axis_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AxisConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._axis_name = (data.get("axisName", obj.__undef__), dirty)
        if obj._axis_name[0] is not None and obj._axis_name[0] is not obj.__undef__:
            assert isinstance(obj._axis_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._axis_name[0]))
            common.validate_format(obj._axis_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AxisConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "axis_name" == "type" or (self.axis_name is not self.__undef__ and not (dirty and not self._axis_name[1])):
            dct["axisName"] = dictify(self.axis_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._axis_name = (self._axis_name[0], True)

    def is_dirty(self):
        return any([self._axis_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AxisConstraint):
            return False
        return super(AxisConstraint, self).__eq__(other) and \
               self.axis_name == other.axis_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def axis_name(self):
        """
        The name of the axis being constrained.

        :rtype: ``basestring``
        """
        return self._axis_name[0]

    @axis_name.setter
    def axis_name(self, value):
        self._axis_name = (value, True)

class DVCDataParent(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The data parent of a
    REFRESH or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(DVCDataParent, self).__init__()
        self._type = ("DVCDataParent", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCDataParent, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCDataParent):
            return False
        return super(DVCDataParent, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class Checklist(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Generic checklist
    object.
    """
    def __init__(self, undef_enabled=True):
        super(Checklist, self).__init__()
        self._type = ("Checklist", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Checklist, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Checklist, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Checklist):
            return False
        return super(Checklist, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NetworkRouteLookupParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters used for a
    routing table lookup.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkRouteLookupParameters, self).__init__()
        self._type = ("NetworkRouteLookupParameters", True)
        self._destination = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkRouteLookupParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._destination = (data.get("destination", obj.__undef__), dirty)
        if obj._destination[0] is not None and obj._destination[0] is not obj.__undef__:
            assert isinstance(obj._destination[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination[0]))
            common.validate_format(obj._destination[0], "host", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkRouteLookupParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "destination" == "type" or (self.destination is not self.__undef__ and not (dirty and not self._destination[1])):
            dct["destination"] = dictify(self.destination)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._destination = (self._destination[0], True)

    def is_dirty(self):
        return any([self._destination[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkRouteLookupParameters):
            return False
        return super(NetworkRouteLookupParameters, self).__eq__(other) and \
               self.destination == other.destination

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def destination(self):
        """
        Destination address or hostname.

        :rtype: ``basestring``
        """
        return self._destination[0]

    @destination.setter
    def destination(self, value):
        self._destination = (value, True)

class CompatibleRepositoriesResult(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Result of a compatible
    repositories request.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibleRepositoriesResult, self).__init__()
        self._type = ("CompatibleRepositoriesResult", True)
        self._repositories = (self.__undef__, True)
        self._criteria = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibleRepositoriesResult, cls).from_dict(data, dirty, undef_enabled)
        if "repositories" not in data:
            raise ValueError("Missing required property \"repositories\".")
        obj._repositories = []
        for item in data.get("repositories") or []:
            obj._repositories.append(factory.create_object(item))
            factory.validate_type(obj._repositories[-1], "SourceRepository")
        obj._repositories = (obj._repositories, dirty)
        if "criteria" not in data:
            raise ValueError("Missing required property \"criteria\".")
        if "criteria" in data and data["criteria"] is not None:
            obj._criteria = (factory.create_object(data["criteria"], "CompatibilityCriteria"), dirty)
            factory.validate_type(obj._criteria[0], "CompatibilityCriteria")
        else:
            obj._criteria = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibleRepositoriesResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "repositories" == "type" or (self.repositories is not self.__undef__ and not (dirty and not self._repositories[1])):
            dct["repositories"] = dictify(self.repositories)
        if "criteria" == "type" or (self.criteria is not self.__undef__ and not (dirty and not self._criteria[1])):
            dct["criteria"] = dictify(self.criteria)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._repositories = (self._repositories[0], True)
        self._criteria = (self._criteria[0], True)

    def is_dirty(self):
        return any([self._repositories[1], self._criteria[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibleRepositoriesResult):
            return False
        return super(CompatibleRepositoriesResult, self).__eq__(other) and \
               self.repositories == other.repositories and \
               self.criteria == other.criteria

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def repositories(self):
        """
        The list of compatible repositories.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.SourceRepository`
        """
        return self._repositories[0]

    @repositories.setter
    def repositories(self, value):
        self._repositories = (value, True)

    @property
    def criteria(self):
        """
        The criteria matched to select compatible repositories.

        :rtype: :py:class:`v1_3_0.web.vo.CompatibilityCriteria`
        """
        return self._criteria[0]

    @criteria.setter
    def criteria(self, value):
        self._criteria = (value, True)

class FileMappingParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Input parameters to
    test file mapping rules.
    """
    def __init__(self, undef_enabled=True):
        super(FileMappingParameters, self).__init__()
        self._type = ("FileMappingParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)
        self._mapping_rules = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileMappingParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        if "mappingRules" not in data:
            raise ValueError("Missing required property \"mappingRules\".")
        obj._mapping_rules = (data.get("mappingRules", obj.__undef__), dirty)
        if obj._mapping_rules[0] is not None and obj._mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mapping_rules[0]))
            common.validate_format(obj._mapping_rules[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileMappingParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        if "mapping_rules" == "type" or (self.mapping_rules is not self.__undef__ and not (dirty and not self._mapping_rules[1])):
            dct["mappingRules"] = dictify(self.mapping_rules)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)
        self._mapping_rules = (self._mapping_rules[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1], self._mapping_rules[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileMappingParameters):
            return False
        return super(FileMappingParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters and \
               self.mapping_rules == other.mapping_rules

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point, bookmark or semantic location to use for list of
        files.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

    @property
    def mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._mapping_rules[0]

    @mapping_rules.setter
    def mapping_rules(self, value):
        self._mapping_rules = (value, True)

class SourceEnvironmentCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used
    for source environment create parameters.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnvironmentCreateParameters, self).__init__()
        self._type = ("SourceEnvironmentCreateParameters", True)
        self._primary_user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnvironmentCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "primaryUser" in data and data["primaryUser"] is not None:
            obj._primary_user = (factory.create_object(data["primaryUser"], "EnvironmentUser"), dirty)
            factory.validate_type(obj._primary_user[0], "EnvironmentUser")
        else:
            obj._primary_user = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnvironmentCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "primary_user" == "type" or (self.primary_user is not self.__undef__ and not (dirty and not self._primary_user[1])):
            dct["primaryUser"] = dictify(self.primary_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._primary_user = (self._primary_user[0], True)

    def is_dirty(self):
        return any([self._primary_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnvironmentCreateParameters):
            return False
        return super(SourceEnvironmentCreateParameters, self).__eq__(other) and \
               self.primary_user == other.primary_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def primary_user(self):
        """
        The primary user associated with the environment.

        :rtype: :py:class:`v1_3_0.web.vo.EnvironmentUser`
        """
        return self._primary_user[0]

    @primary_user.setter
    def primary_user(self, value):
        self._primary_user = (value, True)

class SnapshotRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Runtime properties of
    a timeflow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotRuntime, self).__init__()
        self._type = ("SnapshotRuntime", True)
        self._provisionable = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._provisionable = (data.get("provisionable", obj.__undef__), dirty)
        if obj._provisionable[0] is not None and obj._provisionable[0] is not obj.__undef__:
            assert isinstance(obj._provisionable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisionable[0]))
            common.validate_format(obj._provisionable[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provisionable" == "type" or (self.provisionable is not self.__undef__ and not (dirty and not self._provisionable[1])):
            dct["provisionable"] = dictify(self.provisionable)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provisionable = (self._provisionable[0], True)

    def is_dirty(self):
        return any([self._provisionable[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotRuntime):
            return False
        return super(SnapshotRuntime, self).__eq__(other) and \
               self.provisionable == other.provisionable

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provisionable(self):
        """
        True if this snapshot can be used as the basis for provisioning a new
        timeflow.

        :rtype: ``bool``
        """
        return self._provisionable[0]

    @provisionable.setter
    def provisionable(self, value):
        self._provisionable = (value, True)

class AppDataParameter(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Specifies input
    parameters to operations on AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataParameter, self).__init__()
        self._type = ("AppDataParameter", True)
        self._default = (self.__undef__, True)
        self._environment_variable = (self.__undef__, True)
        self._parameter = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataParameter, cls).from_dict(data, dirty, undef_enabled)
        if "default" not in data:
            raise ValueError("Missing required property \"default\".")
        obj._default = (data.get("default", obj.__undef__), dirty)
        if obj._default[0] is not None and obj._default[0] is not obj.__undef__:
            assert isinstance(obj._default[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default[0]))
            common.validate_format(obj._default[0], "None", None, None)
        if "environmentVariable" not in data:
            raise ValueError("Missing required property \"environmentVariable\".")
        obj._environment_variable = (data.get("environmentVariable", obj.__undef__), dirty)
        if obj._environment_variable[0] is not None and obj._environment_variable[0] is not obj.__undef__:
            assert isinstance(obj._environment_variable[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_variable[0]))
            common.validate_format(obj._environment_variable[0], "None", None, None)
        if "parameter" not in data:
            raise ValueError("Missing required property \"parameter\".")
        if "parameter" in data and data["parameter"] is not None:
            obj._parameter = (factory.create_object(data["parameter"], "DynamicParameter"), dirty)
            factory.validate_type(obj._parameter[0], "DynamicParameter")
        else:
            obj._parameter = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "default" == "type" or (self.default is not self.__undef__ and not (dirty and not self._default[1])):
            dct["default"] = dictify(self.default)
        if "environment_variable" == "type" or (self.environment_variable is not self.__undef__ and not (dirty and not self._environment_variable[1])):
            dct["environmentVariable"] = dictify(self.environment_variable)
        if "parameter" == "type" or (self.parameter is not self.__undef__ and not (dirty and not self._parameter[1])):
            dct["parameter"] = dictify(self.parameter)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._default = (self._default[0], True)
        self._environment_variable = (self._environment_variable[0], True)
        self._parameter = (self._parameter[0], True)

    def is_dirty(self):
        return any([self._default[1], self._environment_variable[1], self._parameter[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataParameter):
            return False
        return super(AppDataParameter, self).__eq__(other) and \
               self.default == other.default and \
               self.environment_variable == other.environment_variable and \
               self.parameter == other.parameter

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def default(self):
        """
        The default value for this input. This value must pass validation as
        the dynamic parameter type given for this parameter.

        :rtype: ``basestring``
        """
        return self._default[0]

    @default.setter
    def default(self, value):
        self._default = (value, True)

    @property
    def environment_variable(self):
        """
        The name of the environment variable that will be used to pass this
        input to scripts on the target host. This name must contain only upper-
        case letters, numbers, and underscores and begin with a letter. Names
        should be prefixed with a unique name to avoid collisions with existing
        environment variables, for example use 'DLPX_WEBSERVER_PORT' instead of
        'PORT'.

        :rtype: ``basestring``
        """
        return self._environment_variable[0]

    @environment_variable.setter
    def environment_variable(self, value):
        self._environment_variable = (value, True)

    @property
    def parameter(self):
        """
        The dynamic parameter to give to clients when requesting input.

        :rtype: :py:class:`v1_3_0.web.vo.DynamicParameter`
        """
        return self._parameter[0]

    @parameter.setter
    def parameter(self, value):
        self._parameter = (value, True)

class APIVersion(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Describes an API
    version.
    """
    def __init__(self, undef_enabled=True):
        super(APIVersion, self).__init__()
        self._type = ("APIVersion", True)
        self._micro = (self.__undef__, True)
        self._major = (self.__undef__, True)
        self._minor = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APIVersion, cls).from_dict(data, dirty, undef_enabled)
        obj._micro = (data.get("micro", obj.__undef__), dirty)
        if obj._micro[0] is not None and obj._micro[0] is not obj.__undef__:
            assert isinstance(obj._micro[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._micro[0]))
            common.validate_format(obj._micro[0], "None", None, None)
        if "major" not in data:
            raise ValueError("Missing required property \"major\".")
        obj._major = (data.get("major", obj.__undef__), dirty)
        if obj._major[0] is not None and obj._major[0] is not obj.__undef__:
            assert isinstance(obj._major[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._major[0]))
            common.validate_format(obj._major[0], "None", None, None)
        if "minor" not in data:
            raise ValueError("Missing required property \"minor\".")
        obj._minor = (data.get("minor", obj.__undef__), dirty)
        if obj._minor[0] is not None and obj._minor[0] is not obj.__undef__:
            assert isinstance(obj._minor[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._minor[0]))
            common.validate_format(obj._minor[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APIVersion, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "micro" == "type" or (self.micro is not self.__undef__ and not (dirty and not self._micro[1])):
            dct["micro"] = dictify(self.micro)
        if "major" == "type" or (self.major is not self.__undef__ and not (dirty and not self._major[1])):
            dct["major"] = dictify(self.major)
        if "minor" == "type" or (self.minor is not self.__undef__ and not (dirty and not self._minor[1])):
            dct["minor"] = dictify(self.minor)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._micro = (self._micro[0], True)
        self._major = (self._major[0], True)
        self._minor = (self._minor[0], True)

    def is_dirty(self):
        return any([self._micro[1], self._major[1], self._minor[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APIVersion):
            return False
        return super(APIVersion, self).__eq__(other) and \
               self.micro == other.micro and \
               self.major == other.major and \
               self.minor == other.minor

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def micro(self):
        """
        Micro API version number

        :rtype: ``int``
        """
        return self._micro[0]

    @micro.setter
    def micro(self, value):
        self._micro = (value, True)

    @property
    def major(self):
        """
        Major API version number

        :rtype: ``int``
        """
        return self._major[0]

    @major.setter
    def major(self, value):
        self._major = (value, True)

    @property
    def minor(self):
        """
        Minor API version number

        :rtype: ``int``
        """
        return self._minor[0]

    @minor.setter
    def minor(self, value):
        self._minor = (value, True)

class Schedule(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Represent a schedule
    in the Delphix system.
    """
    def __init__(self, undef_enabled=True):
        super(Schedule, self).__init__()
        self._type = ("Schedule", True)
        self._cron_string = (self.__undef__, True)
        self._cutoff_time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Schedule, cls).from_dict(data, dirty, undef_enabled)
        obj._cron_string = (data.get("cronString", obj.__undef__), dirty)
        if obj._cron_string[0] is not None and obj._cron_string[0] is not obj.__undef__:
            assert isinstance(obj._cron_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cron_string[0]))
            common.validate_format(obj._cron_string[0], "None", None, 120)
        obj._cutoff_time = (data.get("cutoffTime", obj.__undef__), dirty)
        if obj._cutoff_time[0] is not None and obj._cutoff_time[0] is not obj.__undef__:
            assert isinstance(obj._cutoff_time[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cutoff_time[0]))
            common.validate_format(obj._cutoff_time[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Schedule, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cron_string" == "type" or (self.cron_string is not self.__undef__ and not (dirty and not self._cron_string[1])):
            dct["cronString"] = dictify(self.cron_string)
        if "cutoff_time" == "type" or (self.cutoff_time is not self.__undef__ and not (dirty and not self._cutoff_time[1])):
            dct["cutoffTime"] = dictify(self.cutoff_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cron_string = (self._cron_string[0], True)
        self._cutoff_time = (self._cutoff_time[0], True)

    def is_dirty(self):
        return any([self._cron_string[1], self._cutoff_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Schedule):
            return False
        return super(Schedule, self).__eq__(other) and \
               self.cron_string == other.cron_string and \
               self.cutoff_time == other.cutoff_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cron_string(self):
        """
        Schedule cron string. See CronTrigger documentation at http://quartz-
        scheduler.org/ for details.

        :rtype: ``basestring``
        """
        return self._cron_string[0]

    @cron_string.setter
    def cron_string(self, value):
        self._cron_string = (value, True)

    @property
    def cutoff_time(self):
        """
        Cutoff time in seconds. The policy job will suspend if not completed
        within the given time limit.

        :rtype: ``int``
        """
        return self._cutoff_time[0]

    @cutoff_time.setter
    def cutoff_time(self, value):
        self._cutoff_time = (value, True)

class ExportParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to export requests.
    """
    def __init__(self, undef_enabled=True):
        super(ExportParameters, self).__init__()
        self._type = ("ExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._timeflow_point_parameters = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "FilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "FilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._timeflow_point_parameters[1], self._file_mapping_rules[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ExportParameters):
            return False
        return super(ExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.timeflow_point_parameters == other.timeflow_point_parameters and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_3_0.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point, bookmark or semantic location to base export on.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_3_0.web.vo.FilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class DeleteParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters passed
    in for a MSSQL database or AppData delete operation.
    """
    def __init__(self, undef_enabled=True):
        super(DeleteParameters, self).__init__()
        self._type = ("DeleteParameters", True)
        self._force = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DeleteParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._force = (data.get("force", obj.__undef__), dirty)
        if obj._force[0] is not None and obj._force[0] is not obj.__undef__:
            assert isinstance(obj._force[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._force[0]))
            common.validate_format(obj._force[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DeleteParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "force" == "type" or (self.force is not self.__undef__ and not (dirty and not self._force[1])):
            dct["force"] = dictify(self.force)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._force = (self._force[0], True)

    def is_dirty(self):
        return any([self._force[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DeleteParameters):
            return False
        return super(DeleteParameters, self).__eq__(other) and \
               self.force == other.force

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def force(self):
        """
        Flag indicating whether to continue the operation upon failures.

        :rtype: ``bool``
        """
        return self._force[0]

    @force.setter
    def force(self, value):
        self._force = (value, True)

class PublicSystemInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Retrieve static
    system-wide properties.
    """
    def __init__(self, undef_enabled=True):
        super(PublicSystemInfo, self).__init__()
        self._type = ("PublicSystemInfo", True)
        self._enabled_features = (self.__undef__, True)
        self._build_version = (self.__undef__, True)
        self._configured = (self.__undef__, True)
        self._api_version = (self.__undef__, True)
        self._product_name = (self.__undef__, True)
        self._product_type = (self.__undef__, True)
        self._build_title = (self.__undef__, True)
        self._build_timestamp = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PublicSystemInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._enabled_features = []
        for item in data.get("enabledFeatures") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            assert item in [u'DVC', u'XPP'], "Expected enum [u'DVC', u'XPP'] but got %s" % item
            common.validate_format(item, "None", None, None)
            obj._enabled_features.append(item)
        obj._enabled_features = (obj._enabled_features, dirty)
        if "buildVersion" in data and data["buildVersion"] is not None:
            obj._build_version = (factory.create_object(data["buildVersion"], "VersionInfo"), dirty)
            factory.validate_type(obj._build_version[0], "VersionInfo")
        else:
            obj._build_version = (obj.__undef__, dirty)
        obj._configured = (data.get("configured", obj.__undef__), dirty)
        if obj._configured[0] is not None and obj._configured[0] is not obj.__undef__:
            assert isinstance(obj._configured[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._configured[0]))
            common.validate_format(obj._configured[0], "None", None, None)
        if "apiVersion" in data and data["apiVersion"] is not None:
            obj._api_version = (factory.create_object(data["apiVersion"], "APIVersion"), dirty)
            factory.validate_type(obj._api_version[0], "APIVersion")
        else:
            obj._api_version = (obj.__undef__, dirty)
        obj._product_name = (data.get("productName", obj.__undef__), dirty)
        if obj._product_name[0] is not None and obj._product_name[0] is not obj.__undef__:
            assert isinstance(obj._product_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._product_name[0]))
            common.validate_format(obj._product_name[0], "None", None, None)
        obj._product_type = (data.get("productType", obj.__undef__), dirty)
        if obj._product_type[0] is not None and obj._product_type[0] is not obj.__undef__:
            assert isinstance(obj._product_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._product_type[0]))
            common.validate_format(obj._product_type[0], "None", None, None)
        obj._build_title = (data.get("buildTitle", obj.__undef__), dirty)
        if obj._build_title[0] is not None and obj._build_title[0] is not obj.__undef__:
            assert isinstance(obj._build_title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_title[0]))
            common.validate_format(obj._build_title[0], "None", None, None)
        obj._build_timestamp = (data.get("buildTimestamp", obj.__undef__), dirty)
        if obj._build_timestamp[0] is not None and obj._build_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._build_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_timestamp[0]))
            common.validate_format(obj._build_timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PublicSystemInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled_features" == "type" or (self.enabled_features is not self.__undef__ and not (dirty and not self._enabled_features[1])):
            dct["enabledFeatures"] = dictify(self.enabled_features)
        if "build_version" == "type" or (self.build_version is not self.__undef__ and not (dirty and not self._build_version[1])):
            dct["buildVersion"] = dictify(self.build_version)
        if "configured" == "type" or (self.configured is not self.__undef__ and not (dirty and not self._configured[1])):
            dct["configured"] = dictify(self.configured)
        if "api_version" == "type" or (self.api_version is not self.__undef__ and not (dirty and not self._api_version[1])):
            dct["apiVersion"] = dictify(self.api_version)
        if "product_name" == "type" or (self.product_name is not self.__undef__ and not (dirty and not self._product_name[1])):
            dct["productName"] = dictify(self.product_name)
        if "product_type" == "type" or (self.product_type is not self.__undef__ and not (dirty and not self._product_type[1])):
            dct["productType"] = dictify(self.product_type)
        if "build_title" == "type" or (self.build_title is not self.__undef__ and not (dirty and not self._build_title[1])):
            dct["buildTitle"] = dictify(self.build_title)
        if "build_timestamp" == "type" or (self.build_timestamp is not self.__undef__ and not (dirty and not self._build_timestamp[1])):
            dct["buildTimestamp"] = dictify(self.build_timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled_features = (self._enabled_features[0], True)
        self._build_version = (self._build_version[0], True)
        self._configured = (self._configured[0], True)
        self._api_version = (self._api_version[0], True)
        self._product_name = (self._product_name[0], True)
        self._product_type = (self._product_type[0], True)
        self._build_title = (self._build_title[0], True)
        self._build_timestamp = (self._build_timestamp[0], True)

    def is_dirty(self):
        return any([self._enabled_features[1], self._build_version[1], self._configured[1], self._api_version[1], self._product_name[1], self._product_type[1], self._build_title[1], self._build_timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PublicSystemInfo):
            return False
        return super(PublicSystemInfo, self).__eq__(other) and \
               self.enabled_features == other.enabled_features and \
               self.build_version == other.build_version and \
               self.configured == other.configured and \
               self.api_version == other.api_version and \
               self.product_name == other.product_name and \
               self.product_type == other.product_type and \
               self.build_title == other.build_title and \
               self.build_timestamp == other.build_timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled_features(self):
        """
        The list of enabled features on this Delphix Engine.

        :rtype: ``list`` of ``basestring``
        """
        return self._enabled_features[0]

    @enabled_features.setter
    def enabled_features(self, value):
        self._enabled_features = (value, True)

    @property
    def build_version(self):
        """
        Delphix version of the current system software.

        :rtype: :py:class:`v1_3_0.web.vo.VersionInfo`
        """
        return self._build_version[0]

    @build_version.setter
    def build_version(self, value):
        self._build_version = (value, True)

    @property
    def configured(self):
        """
        Indicates whether the server has gone through initial setup or not.

        :rtype: ``bool``
        """
        return self._configured[0]

    @configured.setter
    def configured(self, value):
        self._configured = (value, True)

    @property
    def api_version(self):
        """
        Maximum supported API version of the current system software.

        :rtype: :py:class:`v1_3_0.web.vo.APIVersion`
        """
        return self._api_version[0]

    @api_version.setter
    def api_version(self, value):
        self._api_version = (value, True)

    @property
    def product_name(self):
        """
        Name of the product that the system is running.

        :rtype: ``basestring``
        """
        return self._product_name[0]

    @product_name.setter
    def product_name(self, value):
        self._product_name = (value, True)

    @property
    def product_type(self):
        """
        Product type.

        :rtype: ``basestring``
        """
        return self._product_type[0]

    @product_type.setter
    def product_type(self, value):
        self._product_type = (value, True)

    @property
    def build_title(self):
        """
        Description of the current system software.

        :rtype: ``basestring``
        """
        return self._build_title[0]

    @build_title.setter
    def build_title(self, value):
        self._build_title = (value, True)

    @property
    def build_timestamp(self):
        """
        Time at which the current system software was built.

        :rtype: ``basestring``
        """
        return self._build_timestamp[0]

    @build_timestamp.setter
    def build_timestamp(self, value):
        self._build_timestamp = (value, True)

class GlobalLinkingSettings(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* System-wide linking
    settings
    """
    def __init__(self, undef_enabled=True):
        super(GlobalLinkingSettings, self).__init__()
        self._type = ("GlobalLinkingSettings", True)
        self._encrypted_linking_enabled_by_default = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(GlobalLinkingSettings, cls).from_dict(data, dirty, undef_enabled)
        obj._encrypted_linking_enabled_by_default = (data.get("encryptedLinkingEnabledByDefault", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled_by_default[0] is not None and obj._encrypted_linking_enabled_by_default[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled_by_default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled_by_default[0]))
            common.validate_format(obj._encrypted_linking_enabled_by_default[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(GlobalLinkingSettings, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "encrypted_linking_enabled_by_default" == "type" or (self.encrypted_linking_enabled_by_default is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled_by_default[1])):
            dct["encryptedLinkingEnabledByDefault"] = dictify(self.encrypted_linking_enabled_by_default)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._encrypted_linking_enabled_by_default = (self._encrypted_linking_enabled_by_default[0], True)

    def is_dirty(self):
        return any([self._encrypted_linking_enabled_by_default[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, GlobalLinkingSettings):
            return False
        return super(GlobalLinkingSettings, self).__eq__(other) and \
               self.encrypted_linking_enabled_by_default == other.encrypted_linking_enabled_by_default

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def encrypted_linking_enabled_by_default(self):
        """
        True if encrypted linking should be enabled by default on new dSources.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled_by_default[0]

    @encrypted_linking_enabled_by_default.setter
    def encrypted_linking_enabled_by_default(self, value):
        self._encrypted_linking_enabled_by_default = (value, True)

class HostConfiguration(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The representation of
    the host configuration properties.
    """
    def __init__(self, undef_enabled=True):
        super(HostConfiguration, self).__init__()
        self._type = ("HostConfiguration", True)
        self._discovered = (self.__undef__, True)
        self._machine = (self.__undef__, True)
        self._last_refreshed = (self.__undef__, True)
        self._operating_system = (self.__undef__, True)
        self._last_updated = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostConfiguration, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        if "machine" in data and data["machine"] is not None:
            obj._machine = (factory.create_object(data["machine"], "HostMachine"), dirty)
            factory.validate_type(obj._machine[0], "HostMachine")
        else:
            obj._machine = (obj.__undef__, dirty)
        obj._last_refreshed = (data.get("lastRefreshed", obj.__undef__), dirty)
        if obj._last_refreshed[0] is not None and obj._last_refreshed[0] is not obj.__undef__:
            assert isinstance(obj._last_refreshed[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_refreshed[0]))
            common.validate_format(obj._last_refreshed[0], "None", None, None)
        if "operatingSystem" in data and data["operatingSystem"] is not None:
            obj._operating_system = (factory.create_object(data["operatingSystem"], "HostOS"), dirty)
            factory.validate_type(obj._operating_system[0], "HostOS")
        else:
            obj._operating_system = (obj.__undef__, dirty)
        obj._last_updated = (data.get("lastUpdated", obj.__undef__), dirty)
        if obj._last_updated[0] is not None and obj._last_updated[0] is not obj.__undef__:
            assert isinstance(obj._last_updated[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_updated[0]))
            common.validate_format(obj._last_updated[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostConfiguration, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "machine" == "type" or (self.machine is not self.__undef__ and not (dirty and not self._machine[1])):
            dct["machine"] = dictify(self.machine)
        if "last_refreshed" == "type" or (self.last_refreshed is not self.__undef__ and not (dirty and not self._last_refreshed[1])):
            dct["lastRefreshed"] = dictify(self.last_refreshed)
        if "operating_system" == "type" or (self.operating_system is not self.__undef__ and not (dirty and not self._operating_system[1])):
            dct["operatingSystem"] = dictify(self.operating_system)
        if "last_updated" == "type" or (self.last_updated is not self.__undef__ and not (dirty and not self._last_updated[1])):
            dct["lastUpdated"] = dictify(self.last_updated)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._machine = (self._machine[0], True)
        self._last_refreshed = (self._last_refreshed[0], True)
        self._operating_system = (self._operating_system[0], True)
        self._last_updated = (self._last_updated[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._machine[1], self._last_refreshed[1], self._operating_system[1], self._last_updated[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostConfiguration):
            return False
        return super(HostConfiguration, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.machine == other.machine and \
               self.last_refreshed == other.last_refreshed and \
               self.operating_system == other.operating_system and \
               self.last_updated == other.last_updated

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Indicates whether the host configuration properties were discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def machine(self):
        """
        The host machine information.

        :rtype: :py:class:`v1_3_0.web.vo.HostMachine`
        """
        return self._machine[0]

    @machine.setter
    def machine(self, value):
        self._machine = (value, True)

    @property
    def last_refreshed(self):
        """
        The timestamp when the host was last refreshed.

        :rtype: ``basestring``
        """
        return self._last_refreshed[0]

    @last_refreshed.setter
    def last_refreshed(self, value):
        self._last_refreshed = (value, True)

    @property
    def operating_system(self):
        """
        The host operating system information.

        :rtype: :py:class:`v1_3_0.web.vo.HostOS`
        """
        return self._operating_system[0]

    @operating_system.setter
    def operating_system(self, value):
        self._operating_system = (value, True)

    @property
    def last_updated(self):
        """
        The timestamp when the host was last updated.

        :rtype: ``basestring``
        """
        return self._last_updated[0]

    @last_updated.setter
    def last_updated(self, value):
        self._last_updated = (value, True)

class CertificateFetchParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters for
    fetching a certficate.
    """
    def __init__(self, undef_enabled=True):
        super(CertificateFetchParameters, self).__init__()
        self._type = ("CertificateFetchParameters", True)
        self._host = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CertificateFetchParameters, cls).from_dict(data, dirty, undef_enabled)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CertificateFetchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._host[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CertificateFetchParameters):
            return False
        return super(CertificateFetchParameters, self).__eq__(other) and \
               self.host == other.host and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        Hostname or IP address.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def port(self):
        """
        Port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class OracleDatabaseStatistic(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A row in the database
    performance statistic table.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseStatistic, self).__init__()
        self._type = ("OracleDatabaseStatistic", True)
        self._statistic_values = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseStatistic, cls).from_dict(data, dirty, undef_enabled)
        obj._statistic_values = []
        for item in data.get("statisticValues") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._statistic_values.append(item)
        obj._statistic_values = (obj._statistic_values, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseStatistic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "statistic_values" == "type" or (self.statistic_values is not self.__undef__ and not (dirty and not self._statistic_values[1])):
            dct["statisticValues"] = dictify(self.statistic_values)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._statistic_values = (self._statistic_values[0], True)

    def is_dirty(self):
        return any([self._statistic_values[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseStatistic):
            return False
        return super(OracleDatabaseStatistic, self).__eq__(other) and \
               self.statistic_values == other.statistic_values

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def statistic_values(self):
        """
        A single performance statistic row.

        :rtype: ``list`` of ``basestring``
        """
        return self._statistic_values[0]

    @statistic_values.setter
    def statistic_values(self, value):
        self._statistic_values = (value, True)

class Credential(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The security
    credential.
    """
    def __init__(self, undef_enabled=True):
        super(Credential, self).__init__()
        self._type = ("Credential", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Credential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Credential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Credential):
            return False
        return super(Credential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SSHConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Mechanism to test SSH
    connectivity of arbitrary hosts.
    """
    def __init__(self, undef_enabled=True):
        super(SSHConnectivity, self).__init__()
        self._type = ("SSHConnectivity", True)
        self._username = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SSHConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credentials" not in data:
            raise ValueError("Missing required property \"credentials\".")
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SSHConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credentials = (self._credentials[0], True)
        self._port = (self._port[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credentials[1], self._port[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SSHConnectivity):
            return False
        return super(SSHConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.credentials == other.credentials and \
               self.port == other.port and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        User name.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credentials(self):
        """
        User credentials.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def port(self):
        """
        *(default value: 22)* SSH port on remote server.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def address(self):
        """
        Target host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class JobEvent(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Represents a job event
    object. This can either be a state change or a progress update.
    """
    def __init__(self, undef_enabled=True):
        super(JobEvent, self).__init__()
        self._type = ("JobEvent", True)
        self._message_action = (self.__undef__, True)
        self._message_command_output = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._message_details = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._percent_complete = (self.__undef__, True)
        self._message_code = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JobEvent, cls).from_dict(data, dirty, undef_enabled)
        obj._message_action = (data.get("messageAction", obj.__undef__), dirty)
        if obj._message_action[0] is not None and obj._message_action[0] is not obj.__undef__:
            assert isinstance(obj._message_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_action[0]))
            common.validate_format(obj._message_action[0], "None", None, None)
        obj._message_command_output = (data.get("messageCommandOutput", obj.__undef__), dirty)
        if obj._message_command_output[0] is not None and obj._message_command_output[0] is not obj.__undef__:
            assert isinstance(obj._message_command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_command_output[0]))
            common.validate_format(obj._message_command_output[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._message_details = (data.get("messageDetails", obj.__undef__), dirty)
        if obj._message_details[0] is not None and obj._message_details[0] is not obj.__undef__:
            assert isinstance(obj._message_details[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_details[0]))
            common.validate_format(obj._message_details[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED', u'RETRYABLE'], "Expected enum [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED', u'RETRYABLE'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._percent_complete = (data.get("percentComplete", obj.__undef__), dirty)
        if obj._percent_complete[0] is not None and obj._percent_complete[0] is not obj.__undef__:
            assert isinstance(obj._percent_complete[0], float), ("Expected one of [u'number'], but got %s" % type(obj._percent_complete[0]))
            common.validate_format(obj._percent_complete[0], "None", None, None)
        obj._message_code = (data.get("messageCode", obj.__undef__), dirty)
        if obj._message_code[0] is not None and obj._message_code[0] is not obj.__undef__:
            assert isinstance(obj._message_code[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_code[0]))
            common.validate_format(obj._message_code[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JobEvent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "message_action" == "type" or (self.message_action is not self.__undef__ and not (dirty and not self._message_action[1])):
            dct["messageAction"] = dictify(self.message_action)
        if "message_command_output" == "type" or (self.message_command_output is not self.__undef__ and not (dirty and not self._message_command_output[1])):
            dct["messageCommandOutput"] = dictify(self.message_command_output)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "message_details" == "type" or (self.message_details is not self.__undef__ and not (dirty and not self._message_details[1])):
            dct["messageDetails"] = dictify(self.message_details)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "percent_complete" == "type" or (self.percent_complete is not self.__undef__ and not (dirty and not self._percent_complete[1])):
            dct["percentComplete"] = dictify(self.percent_complete)
        if "message_code" == "type" or (self.message_code is not self.__undef__ and not (dirty and not self._message_code[1])):
            dct["messageCode"] = dictify(self.message_code)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._message_action = (self._message_action[0], True)
        self._message_command_output = (self._message_command_output[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._message_details = (self._message_details[0], True)
        self._state = (self._state[0], True)
        self._percent_complete = (self._percent_complete[0], True)
        self._message_code = (self._message_code[0], True)

    def is_dirty(self):
        return any([self._message_action[1], self._message_command_output[1], self._timestamp[1], self._message_details[1], self._state[1], self._percent_complete[1], self._message_code[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JobEvent):
            return False
        return super(JobEvent, self).__eq__(other) and \
               self.message_action == other.message_action and \
               self.message_command_output == other.message_command_output and \
               self.timestamp == other.timestamp and \
               self.message_details == other.message_details and \
               self.state == other.state and \
               self.percent_complete == other.percent_complete and \
               self.message_code == other.message_code

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def message_action(self):
        """
        Localized message action.

        :rtype: ``basestring``
        """
        return self._message_action[0]

    @message_action.setter
    def message_action(self, value):
        self._message_action = (value, True)

    @property
    def message_command_output(self):
        """
        Command output associated with the event, if applicable.

        :rtype: ``basestring``
        """
        return self._message_command_output[0]

    @message_command_output.setter
    def message_command_output(self, value):
        self._message_command_output = (value, True)

    @property
    def timestamp(self):
        """
        Time the event occurred.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def message_details(self):
        """
        Localized message details.

        :rtype: ``basestring``
        """
        return self._message_details[0]

    @message_details.setter
    def message_details(self, value):
        self._message_details = (value, True)

    @property
    def state(self):
        """
        New state of the job. *(permitted values: INITIAL, RUNNING, SUSPENDED,
        CANCELED, COMPLETED, FAILED, RETRYABLE)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def percent_complete(self):
        """
        Completion percentage.

        :rtype: ``float``
        """
        return self._percent_complete[0]

    @percent_complete.setter
    def percent_complete(self, value):
        self._percent_complete = (value, True)

    @property
    def message_code(self):
        """
        Message ID associated with the event.

        :rtype: ``basestring``
        """
        return self._message_code[0]

    @message_code.setter
    def message_code(self, value):
        self._message_code = (value, True)

class CallResult(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Result of an API call.
    """
    def __init__(self, undef_enabled=True):
        super(CallResult, self).__init__()
        self._type = ("CallResult", True)
        self._status = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CallResult, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'OK', u'ERROR'], "Expected enum [u'OK', u'ERROR'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CallResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)

    def is_dirty(self):
        return any([self._status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CallResult):
            return False
        return super(CallResult, self).__eq__(other) and \
               self.status == other.status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Indicates whether an error occurred during the call. *(permitted
        values: OK, ERROR)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

class FaultResolveParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input when marking a fault as resolved.
    """
    def __init__(self, undef_enabled=True):
        super(FaultResolveParameters, self).__init__()
        self._type = ("FaultResolveParameters", True)
        self._comments = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FaultResolveParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._comments = (data.get("comments", obj.__undef__), dirty)
        if obj._comments[0] is not None and obj._comments[0] is not obj.__undef__:
            assert isinstance(obj._comments[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._comments[0]))
            common.validate_format(obj._comments[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FaultResolveParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "comments" == "type" or (self.comments is not self.__undef__ and not (dirty and not self._comments[1])):
            dct["comments"] = dictify(self.comments)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._comments = (self._comments[0], True)

    def is_dirty(self):
        return any([self._comments[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FaultResolveParameters):
            return False
        return super(FaultResolveParameters, self).__eq__(other) and \
               self.comments == other.comments

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def comments(self):
        """
        The comments describing the steps taken to resolve a fault.

        :rtype: ``basestring``
        """
        return self._comments[0]

    @comments.setter
    def comments(self, value):
        self._comments = (value, True)

class DomainCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters used for
    creating a domain.
    """
    def __init__(self, undef_enabled=True):
        super(DomainCreateParameters, self).__init__()
        self._type = ("DomainCreateParameters", True)
        self._default_user = (self.__undef__, True)
        self._devices = (self.__undef__, True)
        self._default_password = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DomainCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._default_user = (data.get("defaultUser", obj.__undef__), dirty)
        if obj._default_user[0] is not None and obj._default_user[0] is not obj.__undef__:
            assert isinstance(obj._default_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_user[0]))
            common.validate_format(obj._default_user[0], "None", 1, 256)
        obj._devices = []
        for item in data.get("devices") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._devices.append(item)
        obj._devices = (obj._devices, dirty)
        obj._default_password = (data.get("defaultPassword", obj.__undef__), dirty)
        if obj._default_password[0] is not None and obj._default_password[0] is not obj.__undef__:
            assert isinstance(obj._default_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_password[0]))
            common.validate_format(obj._default_password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DomainCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "default_user" == "type" or (self.default_user is not self.__undef__ and not (dirty and not self._default_user[1])):
            dct["defaultUser"] = dictify(self.default_user)
        if "devices" == "type" or (self.devices is not self.__undef__ and not (dirty and not self._devices[1])):
            dct["devices"] = dictify(self.devices)
        if "default_password" == "type" or (self.default_password is not self.__undef__ and not (dirty and not self._default_password[1])):
            dct["defaultPassword"] = dictify(self.default_password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._default_user = (self._default_user[0], True)
        self._devices = (self._devices[0], True)
        self._default_password = (self._default_password[0], True)

    def is_dirty(self):
        return any([self._default_user[1], self._devices[1], self._default_password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DomainCreateParameters):
            return False
        return super(DomainCreateParameters, self).__eq__(other) and \
               self.default_user == other.default_user and \
               self.devices == other.devices and \
               self.default_password == other.default_password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def default_user(self):
        """
        *(default value: delphix_admin)* Name of the default domain
        administrator to create.

        :rtype: ``basestring``
        """
        return self._default_user[0]

    @default_user.setter
    def default_user(self, value):
        self._default_user = (value, True)

    @property
    def devices(self):
        """
        List of storage devices to use for the domain.

        :rtype: ``list`` of ``basestring``
        """
        return self._devices[0]

    @devices.setter
    def devices(self, value):
        self._devices = (value, True)

    @property
    def default_password(self):
        """
        *(default value: delphix)* Password to use for the default domain
        administrator.

        :rtype: ``basestring``
        """
        return self._default_password[0]

    @default_password.setter
    def default_password(self, value):
        self._default_password = (value, True)

class TimeRangeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input for methods requiring a time range.
    """
    def __init__(self, undef_enabled=True):
        super(TimeRangeParameters, self).__init__()
        self._type = ("TimeRangeParameters", True)
        self._end_time = (self.__undef__, True)
        self._start_time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeRangeParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeRangeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_time = (self._end_time[0], True)
        self._start_time = (self._start_time[0], True)

    def is_dirty(self):
        return any([self._end_time[1], self._start_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeRangeParameters):
            return False
        return super(TimeRangeParameters, self).__eq__(other) and \
               self.end_time == other.end_time and \
               self.start_time == other.start_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_time(self):
        """
        The date at the end of the period.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def start_time(self):
        """
        The date at the beginning of the period.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

class AggregateCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Capacity data for an
    aggregation of containers.
    """
    def __init__(self, undef_enabled=True):
        super(AggregateCapacityData, self).__init__()
        self._type = ("AggregateCapacityData", True)
        self._source = (self.__undef__, True)
        self._virtual = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AggregateCapacityData, cls).from_dict(data, dirty, undef_enabled)
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._source[0], "CapacityBreakdown")
        else:
            obj._source = (obj.__undef__, dirty)
        if "virtual" in data and data["virtual"] is not None:
            obj._virtual = (factory.create_object(data["virtual"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._virtual[0], "CapacityBreakdown")
        else:
            obj._virtual = (obj.__undef__, dirty)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AggregateCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "virtual" == "type" or (self.virtual is not self.__undef__ and not (dirty and not self._virtual[1])):
            dct["virtual"] = dictify(self.virtual)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._virtual = (self._virtual[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._source[1], self._virtual[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AggregateCapacityData):
            return False
        return super(AggregateCapacityData, self).__eq__(other) and \
               self.source == other.source and \
               self.virtual == other.virtual and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Statistics for dSources in this aggregation.

        :rtype: :py:class:`v1_3_0.web.vo.CapacityBreakdown`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def virtual(self):
        """
        Statistics for VDBs in this aggregation.

        :rtype: :py:class:`v1_3_0.web.vo.CapacityBreakdown`
        """
        return self._virtual[0]

    @virtual.setter
    def virtual(self, value):
        self._virtual = (value, True)

    @property
    def timestamp(self):
        """
        Time at which this information was sampled.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class PersistentObject(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Super schema for all
    typed schemas with a reference property
    """
    def __init__(self, undef_enabled=True):
        super(PersistentObject, self).__init__()
        self._type = ("PersistentObject", True)
        self._namespace = (self.__undef__, True)
        self._reference = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PersistentObject, cls).from_dict(data, dirty, undef_enabled)
        obj._namespace = (data.get("namespace", obj.__undef__), dirty)
        if obj._namespace[0] is not None and obj._namespace[0] is not obj.__undef__:
            assert isinstance(obj._namespace[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._namespace[0]))
            common.validate_format(obj._namespace[0], "objectReference", None, None)
        obj._reference = (data.get("reference", obj.__undef__), dirty)
        if obj._reference[0] is not None and obj._reference[0] is not obj.__undef__:
            assert isinstance(obj._reference[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._reference[0]))
            common.validate_format(obj._reference[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PersistentObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "namespace" == "type" or (self.namespace is not self.__undef__ and not (dirty and not self._namespace[1])):
            dct["namespace"] = dictify(self.namespace)
        if "reference" == "type" or (self.reference is not self.__undef__ and not (dirty and not self._reference[1])):
            dct["reference"] = dictify(self.reference)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._namespace = (self._namespace[0], True)
        self._reference = (self._reference[0], True)

    def is_dirty(self):
        return any([self._namespace[1], self._reference[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PersistentObject):
            return False
        return super(PersistentObject, self).__eq__(other) and \
               self.namespace == other.namespace and \
               self.reference == other.reference

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def namespace(self):
        """
        Alternate namespace for this object, for replicated and restored
        objects

        :rtype: ``basestring``
        """
        return self._namespace[0]

    @namespace.setter
    def namespace(self, value):
        self._namespace = (value, True)

    @property
    def reference(self):
        """
        Object reference

        :rtype: ``basestring``
        """
        return self._reference[0]

    @reference.setter
    def reference(self, value):
        self._reference = (value, True)

class OracleInstance(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Representation of an
    Oracle instance configuration
    """
    def __init__(self, undef_enabled=True):
        super(OracleInstance, self).__init__()
        self._type = ("OracleInstance", True)
        self._instance_number = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_number = (data.get("instanceNumber", obj.__undef__), dirty)
        if obj._instance_number[0] is not None and obj._instance_number[0] is not obj.__undef__:
            assert isinstance(obj._instance_number[0], float), ("Expected one of [u'number'], but got %s" % type(obj._instance_number[0]))
            common.validate_format(obj._instance_number[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, 15)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_number" == "type" or (self.instance_number is not self.__undef__ and not (dirty and not self._instance_number[1])):
            dct["instanceNumber"] = dictify(self.instance_number)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_number = (self._instance_number[0], True)
        self._instance_name = (self._instance_name[0], True)

    def is_dirty(self):
        return any([self._instance_number[1], self._instance_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleInstance):
            return False
        return super(OracleInstance, self).__eq__(other) and \
               self.instance_number == other.instance_number and \
               self.instance_name == other.instance_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_number(self):
        """
        The number of the instance.

        :rtype: ``float``
        """
        return self._instance_number[0]

    @instance_number.setter
    def instance_number(self, value):
        self._instance_number = (value, True)

    @property
    def instance_name(self):
        """
        The name of the instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

class PgSQLHBAEntry(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An entry in the
    PostgreSQL host-based authentication file (pg_hba.conf).
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLHBAEntry, self).__init__()
        self._type = ("PgSQLHBAEntry", True)
        self._auth_method = (self.__undef__, True)
        self._database = (self.__undef__, True)
        self._auth_options = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._entry_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLHBAEntry, cls).from_dict(data, dirty, undef_enabled)
        obj._auth_method = (data.get("authMethod", obj.__undef__), dirty)
        if obj._auth_method[0] is not None and obj._auth_method[0] is not obj.__undef__:
            assert isinstance(obj._auth_method[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_method[0]))
            assert obj._auth_method[0] in [u'trust', u'reject', u'md5', u'password', u'gss', u'sspi', u'krb5', u'ident', u'peer', u'ldap', u'radius', u'cert', u'pam'], "Expected enum [u'trust', u'reject', u'md5', u'password', u'gss', u'sspi', u'krb5', u'ident', u'peer', u'ldap', u'radius', u'cert', u'pam'] but got %s" % obj._auth_method[0]
            common.validate_format(obj._auth_method[0], "None", None, None)
        obj._database = (data.get("database", obj.__undef__), dirty)
        if obj._database[0] is not None and obj._database[0] is not obj.__undef__:
            assert isinstance(obj._database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database[0]))
            common.validate_format(obj._database[0], "None", None, 63)
        obj._auth_options = (data.get("authOptions", obj.__undef__), dirty)
        if obj._auth_options[0] is not None and obj._auth_options[0] is not obj.__undef__:
            assert isinstance(obj._auth_options[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_options[0]))
            common.validate_format(obj._auth_options[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 63)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        obj._entry_type = (data.get("entryType", obj.__undef__), dirty)
        if obj._entry_type[0] is not None and obj._entry_type[0] is not obj.__undef__:
            assert isinstance(obj._entry_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._entry_type[0]))
            assert obj._entry_type[0] in [u'local', u'host', u'hostssl', u'hostnossl'], "Expected enum [u'local', u'host', u'hostssl', u'hostnossl'] but got %s" % obj._entry_type[0]
            common.validate_format(obj._entry_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLHBAEntry, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "auth_method" == "type" or (self.auth_method is not self.__undef__ and not (dirty and not self._auth_method[1])):
            dct["authMethod"] = dictify(self.auth_method)
        if "database" == "type" or (self.database is not self.__undef__ and not (dirty and not self._database[1])):
            dct["database"] = dictify(self.database)
        if "auth_options" == "type" or (self.auth_options is not self.__undef__ and not (dirty and not self._auth_options[1])):
            dct["authOptions"] = dictify(self.auth_options)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "entry_type" == "type" or (self.entry_type is not self.__undef__ and not (dirty and not self._entry_type[1])):
            dct["entryType"] = dictify(self.entry_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._auth_method = (self._auth_method[0], True)
        self._database = (self._database[0], True)
        self._auth_options = (self._auth_options[0], True)
        self._user = (self._user[0], True)
        self._address = (self._address[0], True)
        self._entry_type = (self._entry_type[0], True)

    def is_dirty(self):
        return any([self._auth_method[1], self._database[1], self._auth_options[1], self._user[1], self._address[1], self._entry_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLHBAEntry):
            return False
        return super(PgSQLHBAEntry, self).__eq__(other) and \
               self.auth_method == other.auth_method and \
               self.database == other.database and \
               self.auth_options == other.auth_options and \
               self.user == other.user and \
               self.address == other.address and \
               self.entry_type == other.entry_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def auth_method(self):
        """
        The authentication method to use when connecting via this entry.
        *(permitted values: trust, reject, md5, password, gss, sspi, krb5,
        ident, peer, ldap, radius, cert, pam)*

        :rtype: ``basestring``
        """
        return self._auth_method[0]

    @auth_method.setter
    def auth_method(self, value):
        self._auth_method = (value, True)

    @property
    def database(self):
        """
        *(default value: all)* The database name this entry matches.

        :rtype: ``basestring``
        """
        return self._database[0]

    @database.setter
    def database(self, value):
        self._database = (value, True)

    @property
    def auth_options(self):
        """
        Options for the authentication method.

        :rtype: ``basestring``
        """
        return self._auth_options[0]

    @auth_options.setter
    def auth_options(self, value):
        self._auth_options = (value, True)

    @property
    def user(self):
        """
        *(default value: all)* The database username this entry matches.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def address(self):
        """
        The client machine address that this entry matches.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def entry_type(self):
        """
        The connection type of this entry. *(permitted values: local, host,
        hostssl, hostnossl)*

        :rtype: ``basestring``
        """
        return self._entry_type[0]

    @entry_type.setter
    def entry_type(self, value):
        self._entry_type = (value, True)

class LdapInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Global LDAP
    information.
    """
    def __init__(self, undef_enabled=True):
        super(LdapInfo, self).__init__()
        self._type = ("LdapInfo", True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LdapInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LdapInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LdapInfo):
            return False
        return super(LdapInfo, self).__eq__(other) and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        Whether LDAP authentication is configured and enabled or not for this
        Delphix Engine.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class CompatibilityCriteria(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The compatibility
    criteria to use for selecting compatible repositories. Parameters with a
    value of null are not considered when selecting compatible repositories.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibilityCriteria, self).__init__()
        self._type = ("CompatibilityCriteria", True)
        self._staging_enabled = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._architecture = (self.__undef__, True)
        self._os = (self.__undef__, True)
        self._processor = (self.__undef__, True)
        self._provisioning_enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._staging_enabled = (data.get("stagingEnabled", obj.__undef__), dirty)
        if obj._staging_enabled[0] is not None and obj._staging_enabled[0] is not obj.__undef__:
            assert isinstance(obj._staging_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging_enabled[0]))
            common.validate_format(obj._staging_enabled[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._architecture = (data.get("architecture", obj.__undef__), dirty)
        if obj._architecture[0] is not None and obj._architecture[0] is not obj.__undef__:
            assert isinstance(obj._architecture[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._architecture[0]))
            common.validate_format(obj._architecture[0], "None", None, None)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            assert obj._os[0] in [u'Linux', u'AIX', u'HPUX', u'SunOS', u'Windows', u'Other'], "Expected enum [u'Linux', u'AIX', u'HPUX', u'SunOS', u'Windows', u'Other'] but got %s" % obj._os[0]
            common.validate_format(obj._os[0], "None", None, None)
        obj._processor = (data.get("processor", obj.__undef__), dirty)
        if obj._processor[0] is not None and obj._processor[0] is not obj.__undef__:
            assert isinstance(obj._processor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._processor[0]))
            common.validate_format(obj._processor[0], "None", None, None)
        obj._provisioning_enabled = (data.get("provisioningEnabled", obj.__undef__), dirty)
        if obj._provisioning_enabled[0] is not None and obj._provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisioning_enabled[0]))
            common.validate_format(obj._provisioning_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "staging_enabled" == "type" or (self.staging_enabled is not self.__undef__ and not (dirty and not self._staging_enabled[1])):
            dct["stagingEnabled"] = dictify(self.staging_enabled)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "architecture" == "type" or (self.architecture is not self.__undef__ and not (dirty and not self._architecture[1])):
            dct["architecture"] = dictify(self.architecture)
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        if "processor" == "type" or (self.processor is not self.__undef__ and not (dirty and not self._processor[1])):
            dct["processor"] = dictify(self.processor)
        if "provisioning_enabled" == "type" or (self.provisioning_enabled is not self.__undef__ and not (dirty and not self._provisioning_enabled[1])):
            dct["provisioningEnabled"] = dictify(self.provisioning_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._staging_enabled = (self._staging_enabled[0], True)
        self._environment = (self._environment[0], True)
        self._architecture = (self._architecture[0], True)
        self._os = (self._os[0], True)
        self._processor = (self._processor[0], True)
        self._provisioning_enabled = (self._provisioning_enabled[0], True)

    def is_dirty(self):
        return any([self._staging_enabled[1], self._environment[1], self._architecture[1], self._os[1], self._processor[1], self._provisioning_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibilityCriteria):
            return False
        return super(CompatibilityCriteria, self).__eq__(other) and \
               self.staging_enabled == other.staging_enabled and \
               self.environment == other.environment and \
               self.architecture == other.architecture and \
               self.os == other.os and \
               self.processor == other.processor and \
               self.provisioning_enabled == other.provisioning_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def staging_enabled(self):
        """
        If true, selected repositories have staging enabled.

        :rtype: ``bool``
        """
        return self._staging_enabled[0]

    @staging_enabled.setter
    def staging_enabled(self, value):
        self._staging_enabled = (value, True)

    @property
    def environment(self):
        """
        Selected repositories are installed on this environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def architecture(self):
        """
        Selected repositories are installed on a host with this architecture
        (32-bit or 64-bit).

        :rtype: ``int``
        """
        return self._architecture[0]

    @architecture.setter
    def architecture(self, value):
        self._architecture = (value, True)

    @property
    def os(self):
        """
        Selected repositories are installed on a host with this OS. *(permitted
        values: Linux, AIX, HPUX, SunOS, Windows, Other)*

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

    @property
    def processor(self):
        """
        Selected repositories are installed on a host with this type of
        processor.

        :rtype: ``basestring``
        """
        return self._processor[0]

    @processor.setter
    def processor(self, value):
        self._processor = (value, True)

    @property
    def provisioning_enabled(self):
        """
        If true, selected repositories have provisioning enabled.

        :rtype: ``bool``
        """
        return self._provisioning_enabled[0]

    @provisioning_enabled.setter
    def provisioning_enabled(self, value):
        self._provisioning_enabled = (value, True)

class SnapshotCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Capacity metrics for a
    single snapshot
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotCapacityData, self).__init__()
        self._type = ("SnapshotCapacityData", True)
        self._descendant_vd_bs = (self.__undef__, True)
        self._manual_retention = (self.__undef__, True)
        self._snapshot = (self.__undef__, True)
        self._policy_retention = (self.__undef__, True)
        self._snapshot_timestamp = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._descendant_vd_bs = []
        for item in data.get("descendantVDBs") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._descendant_vd_bs.append(item)
        obj._descendant_vd_bs = (obj._descendant_vd_bs, dirty)
        obj._manual_retention = (data.get("manualRetention", obj.__undef__), dirty)
        if obj._manual_retention[0] is not None and obj._manual_retention[0] is not obj.__undef__:
            assert isinstance(obj._manual_retention[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._manual_retention[0]))
            common.validate_format(obj._manual_retention[0], "None", None, None)
        obj._snapshot = (data.get("snapshot", obj.__undef__), dirty)
        if obj._snapshot[0] is not None and obj._snapshot[0] is not obj.__undef__:
            assert isinstance(obj._snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot[0]))
            common.validate_format(obj._snapshot[0], "objectReference", None, None)
        obj._policy_retention = (data.get("policyRetention", obj.__undef__), dirty)
        if obj._policy_retention[0] is not None and obj._policy_retention[0] is not obj.__undef__:
            assert isinstance(obj._policy_retention[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._policy_retention[0]))
            common.validate_format(obj._policy_retention[0], "None", None, None)
        obj._snapshot_timestamp = (data.get("snapshotTimestamp", obj.__undef__), dirty)
        if obj._snapshot_timestamp[0] is not None and obj._snapshot_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._snapshot_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot_timestamp[0]))
            common.validate_format(obj._snapshot_timestamp[0], "date", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "descendant_vd_bs" == "type" or (self.descendant_vd_bs is not self.__undef__ and not (dirty and not self._descendant_vd_bs[1])):
            dct["descendantVDBs"] = dictify(self.descendant_vd_bs)
        if "manual_retention" == "type" or (self.manual_retention is not self.__undef__ and not (dirty and not self._manual_retention[1])):
            dct["manualRetention"] = dictify(self.manual_retention)
        if "snapshot" == "type" or (self.snapshot is not self.__undef__ and not (dirty and not self._snapshot[1])):
            dct["snapshot"] = dictify(self.snapshot)
        if "policy_retention" == "type" or (self.policy_retention is not self.__undef__ and not (dirty and not self._policy_retention[1])):
            dct["policyRetention"] = dictify(self.policy_retention)
        if "snapshot_timestamp" == "type" or (self.snapshot_timestamp is not self.__undef__ and not (dirty and not self._snapshot_timestamp[1])):
            dct["snapshotTimestamp"] = dictify(self.snapshot_timestamp)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._descendant_vd_bs = (self._descendant_vd_bs[0], True)
        self._manual_retention = (self._manual_retention[0], True)
        self._snapshot = (self._snapshot[0], True)
        self._policy_retention = (self._policy_retention[0], True)
        self._snapshot_timestamp = (self._snapshot_timestamp[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._descendant_vd_bs[1], self._manual_retention[1], self._snapshot[1], self._policy_retention[1], self._snapshot_timestamp[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotCapacityData):
            return False
        return super(SnapshotCapacityData, self).__eq__(other) and \
               self.descendant_vd_bs == other.descendant_vd_bs and \
               self.manual_retention == other.manual_retention and \
               self.snapshot == other.snapshot and \
               self.policy_retention == other.policy_retention and \
               self.snapshot_timestamp == other.snapshot_timestamp and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def descendant_vd_bs(self):
        """
        List of VDBs that have been provisioned from this snapshot.

        :rtype: ``list`` of ``basestring``
        """
        return self._descendant_vd_bs[0]

    @descendant_vd_bs.setter
    def descendant_vd_bs(self, value):
        self._descendant_vd_bs = (value, True)

    @property
    def manual_retention(self):
        """
        The manual retention setting on this snapshot, in days.

        :rtype: ``int``
        """
        return self._manual_retention[0]

    @manual_retention.setter
    def manual_retention(self, value):
        self._manual_retention = (value, True)

    @property
    def snapshot(self):
        """
        Reference to the snapshot.

        :rtype: ``basestring``
        """
        return self._snapshot[0]

    @snapshot.setter
    def snapshot(self, value):
        self._snapshot = (value, True)

    @property
    def policy_retention(self):
        """
        Whether this snapshot is currently being retained due to policy
        settings.

        :rtype: ``bool``
        """
        return self._policy_retention[0]

    @policy_retention.setter
    def policy_retention(self, value):
        self._policy_retention = (value, True)

    @property
    def snapshot_timestamp(self):
        """
        Time at which this snapshot was taken.

        :rtype: ``basestring``
        """
        return self._snapshot_timestamp[0]

    @snapshot_timestamp.setter
    def snapshot_timestamp(self, value):
        self._snapshot_timestamp = (value, True)

    @property
    def size(self):
        """
        Amount of space allocated exclusively to this snapshot.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class StatisticAxis(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The attributes of a
    statistic axis.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticAxis, self).__init__()
        self._type = ("StatisticAxis", True)
        self._explanation = (self.__undef__, True)
        self._constraint_type = (self.__undef__, True)
        self._value_type = (self.__undef__, True)
        self._axis_name = (self.__undef__, True)
        self._stream_attribute = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticAxis, cls).from_dict(data, dirty, undef_enabled)
        obj._explanation = (data.get("explanation", obj.__undef__), dirty)
        if obj._explanation[0] is not None and obj._explanation[0] is not obj.__undef__:
            assert isinstance(obj._explanation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._explanation[0]))
            common.validate_format(obj._explanation[0], "None", None, None)
        obj._constraint_type = (data.get("constraintType", obj.__undef__), dirty)
        if obj._constraint_type[0] is not None and obj._constraint_type[0] is not obj.__undef__:
            assert isinstance(obj._constraint_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._constraint_type[0]))
            common.validate_format(obj._constraint_type[0], "None", None, None)
        obj._value_type = (data.get("valueType", obj.__undef__), dirty)
        if obj._value_type[0] is not None and obj._value_type[0] is not obj.__undef__:
            assert isinstance(obj._value_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._value_type[0]))
            assert obj._value_type[0] in [u'INTEGER', u'BOOLEAN', u'STRING', u'HISTOGRAM'], "Expected enum [u'INTEGER', u'BOOLEAN', u'STRING', u'HISTOGRAM'] but got %s" % obj._value_type[0]
            common.validate_format(obj._value_type[0], "None", None, None)
        obj._axis_name = (data.get("axisName", obj.__undef__), dirty)
        if obj._axis_name[0] is not None and obj._axis_name[0] is not obj.__undef__:
            assert isinstance(obj._axis_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._axis_name[0]))
            common.validate_format(obj._axis_name[0], "None", None, None)
        obj._stream_attribute = (data.get("streamAttribute", obj.__undef__), dirty)
        if obj._stream_attribute[0] is not None and obj._stream_attribute[0] is not obj.__undef__:
            assert isinstance(obj._stream_attribute[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._stream_attribute[0]))
            common.validate_format(obj._stream_attribute[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticAxis, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "explanation" == "type" or (self.explanation is not self.__undef__ and not (dirty and not self._explanation[1])):
            dct["explanation"] = dictify(self.explanation)
        if "constraint_type" == "type" or (self.constraint_type is not self.__undef__ and not (dirty and not self._constraint_type[1])):
            dct["constraintType"] = dictify(self.constraint_type)
        if "value_type" == "type" or (self.value_type is not self.__undef__ and not (dirty and not self._value_type[1])):
            dct["valueType"] = dictify(self.value_type)
        if "axis_name" == "type" or (self.axis_name is not self.__undef__ and not (dirty and not self._axis_name[1])):
            dct["axisName"] = dictify(self.axis_name)
        if "stream_attribute" == "type" or (self.stream_attribute is not self.__undef__ and not (dirty and not self._stream_attribute[1])):
            dct["streamAttribute"] = dictify(self.stream_attribute)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._explanation = (self._explanation[0], True)
        self._constraint_type = (self._constraint_type[0], True)
        self._value_type = (self._value_type[0], True)
        self._axis_name = (self._axis_name[0], True)
        self._stream_attribute = (self._stream_attribute[0], True)

    def is_dirty(self):
        return any([self._explanation[1], self._constraint_type[1], self._value_type[1], self._axis_name[1], self._stream_attribute[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticAxis):
            return False
        return super(StatisticAxis, self).__eq__(other) and \
               self.explanation == other.explanation and \
               self.constraint_type == other.constraint_type and \
               self.value_type == other.value_type and \
               self.axis_name == other.axis_name and \
               self.stream_attribute == other.stream_attribute

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def explanation(self):
        """
        A deeper explanation of the data this corresponds to.

        :rtype: ``basestring``
        """
        return self._explanation[0]

    @explanation.setter
    def explanation(self, value):
        self._explanation = (value, True)

    @property
    def constraint_type(self):
        """
        The type of constraint that can be applied to this axis.

        :rtype: ``basestring``
        """
        return self._constraint_type[0]

    @constraint_type.setter
    def constraint_type(self, value):
        self._constraint_type = (value, True)

    @property
    def value_type(self):
        """
        The type of value this axis will have for collected data. *(permitted
        values: INTEGER, BOOLEAN, STRING, HISTOGRAM)*

        :rtype: ``basestring``
        """
        return self._value_type[0]

    @value_type.setter
    def value_type(self, value):
        self._value_type = (value, True)

    @property
    def axis_name(self):
        """
        The name for this axis.

        :rtype: ``basestring``
        """
        return self._axis_name[0]

    @axis_name.setter
    def axis_name(self, value):
        self._axis_name = (value, True)

    @property
    def stream_attribute(self):
        """
        Whether this axis appears as an attribute of a datapoint stream or of
        datapoints themselves.

        :rtype: ``bool``
        """
        return self._stream_attribute[0]

    @stream_attribute.setter
    def stream_attribute(self, value):
        self._stream_attribute = (value, True)

class SyslogServer(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Syslog server
    configuration
    """
    def __init__(self, undef_enabled=True):
        super(SyslogServer, self).__init__()
        self._type = ("SyslogServer", True)
        self._protocol = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyslogServer, cls).from_dict(data, dirty, undef_enabled)
        if "protocol" not in data:
            raise ValueError("Missing required property \"protocol\".")
        obj._protocol = (data.get("protocol", obj.__undef__), dirty)
        if obj._protocol[0] is not None and obj._protocol[0] is not obj.__undef__:
            assert isinstance(obj._protocol[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._protocol[0]))
            assert obj._protocol[0] in [u'udp', u'tcp'], "Expected enum [u'udp', u'tcp'] but got %s" % obj._protocol[0]
            common.validate_format(obj._protocol[0], "None", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyslogServer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "protocol" == "type" or (self.protocol is not self.__undef__ and not (dirty and not self._protocol[1])):
            dct["protocol"] = dictify(self.protocol)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._protocol = (self._protocol[0], True)
        self._port = (self._port[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._protocol[1], self._port[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyslogServer):
            return False
        return super(SyslogServer, self).__eq__(other) and \
               self.protocol == other.protocol and \
               self.port == other.port and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def protocol(self):
        """
        *(default value: udp)* Syslog transport protocol. *(permitted values:
        udp, tcp)*

        :rtype: ``basestring``
        """
        return self._protocol[0]

    @protocol.setter
    def protocol(self, value):
        self._protocol = (value, True)

    @property
    def port(self):
        """
        *(default value: 514)* Syslog port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def address(self):
        """
        Syslog host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class VirtualSourceOperations(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Describes operations
    which are performed on virtual sources at various times.
    """
    def __init__(self, undef_enabled=True):
        super(VirtualSourceOperations, self).__init__()
        self._type = ("VirtualSourceOperations", True)
        self._post_refresh = (self.__undef__, True)
        self._pre_refresh = (self.__undef__, True)
        self._configure_clone = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VirtualSourceOperations, cls).from_dict(data, dirty, undef_enabled)
        obj._post_refresh = []
        for item in data.get("postRefresh") or []:
            obj._post_refresh.append(factory.create_object(item))
            factory.validate_type(obj._post_refresh[-1], "Operation")
        obj._post_refresh = (obj._post_refresh, dirty)
        obj._pre_refresh = []
        for item in data.get("preRefresh") or []:
            obj._pre_refresh.append(factory.create_object(item))
            factory.validate_type(obj._pre_refresh[-1], "Operation")
        obj._pre_refresh = (obj._pre_refresh, dirty)
        obj._configure_clone = []
        for item in data.get("configureClone") or []:
            obj._configure_clone.append(factory.create_object(item))
            factory.validate_type(obj._configure_clone[-1], "Operation")
        obj._configure_clone = (obj._configure_clone, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VirtualSourceOperations, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "post_refresh" == "type" or (self.post_refresh is not self.__undef__ and not (dirty and not self._post_refresh[1])):
            dct["postRefresh"] = dictify(self.post_refresh)
        if "pre_refresh" == "type" or (self.pre_refresh is not self.__undef__ and not (dirty and not self._pre_refresh[1])):
            dct["preRefresh"] = dictify(self.pre_refresh)
        if "configure_clone" == "type" or (self.configure_clone is not self.__undef__ and not (dirty and not self._configure_clone[1])):
            dct["configureClone"] = dictify(self.configure_clone)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._post_refresh = (self._post_refresh[0], True)
        self._pre_refresh = (self._pre_refresh[0], True)
        self._configure_clone = (self._configure_clone[0], True)

    def is_dirty(self):
        return any([self._post_refresh[1], self._pre_refresh[1], self._configure_clone[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VirtualSourceOperations):
            return False
        return super(VirtualSourceOperations, self).__eq__(other) and \
               self.post_refresh == other.post_refresh and \
               self.pre_refresh == other.pre_refresh and \
               self.configure_clone == other.configure_clone

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def post_refresh(self):
        """
        Operations to perform after refreshing a virtual source. These
        operations can be used to restore any data or configuration backed up
        in the preRefresh operations.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._post_refresh[0]

    @post_refresh.setter
    def post_refresh(self, value):
        self._post_refresh = (value, True)

    @property
    def pre_refresh(self):
        """
        Operations to perform before refreshing a virtual source. These
        operations can backup any data or configuration from the running source
        before doing the refresh.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._pre_refresh[0]

    @pre_refresh.setter
    def pre_refresh(self, value):
        self._pre_refresh = (value, True)

    @property
    def configure_clone(self):
        """
        Operations to perform when initially creating the virtual source and
        every time it is refreshed.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._configure_clone[0]

    @configure_clone.setter
    def configure_clone(self, value):
        self._configure_clone = (value, True)

class OracleLog(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Oracle log file.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLog, self).__init__()
        self._type = ("OracleLog", True)
        self._instance_num = (self.__undef__, True)
        self._sequence = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLog, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_num = (data.get("instanceNum", obj.__undef__), dirty)
        if obj._instance_num[0] is not None and obj._instance_num[0] is not obj.__undef__:
            assert isinstance(obj._instance_num[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._instance_num[0]))
            common.validate_format(obj._instance_num[0], "None", None, None)
        obj._sequence = (data.get("sequence", obj.__undef__), dirty)
        if obj._sequence[0] is not None and obj._sequence[0] is not obj.__undef__:
            assert isinstance(obj._sequence[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._sequence[0]))
            common.validate_format(obj._sequence[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLog, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_num" == "type" or (self.instance_num is not self.__undef__ and not (dirty and not self._instance_num[1])):
            dct["instanceNum"] = dictify(self.instance_num)
        if "sequence" == "type" or (self.sequence is not self.__undef__ and not (dirty and not self._sequence[1])):
            dct["sequence"] = dictify(self.sequence)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_num = (self._instance_num[0], True)
        self._sequence = (self._sequence[0], True)

    def is_dirty(self):
        return any([self._instance_num[1], self._sequence[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLog):
            return False
        return super(OracleLog, self).__eq__(other) and \
               self.instance_num == other.instance_num and \
               self.sequence == other.sequence

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_num(self):
        """
        Instance number associated with the log file.

        :rtype: ``int``
        """
        return self._instance_num[0]

    @instance_num.setter
    def instance_num(self, value):
        self._instance_num = (value, True)

    @property
    def sequence(self):
        """
        Sequence number for the log file.

        :rtype: ``int``
        """
        return self._sequence[0]

    @sequence.setter
    def sequence(self, value):
        self._sequence = (value, True)

class ScrubStatus(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The status of a scrub
    of the storage in the system.
    """
    def __init__(self, undef_enabled=True):
        super(ScrubStatus, self).__init__()
        self._type = ("ScrubStatus", True)
        self._errors = (self.__undef__, True)
        self._completed = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._total = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ScrubStatus, cls).from_dict(data, dirty, undef_enabled)
        obj._errors = (data.get("errors", obj.__undef__), dirty)
        if obj._errors[0] is not None and obj._errors[0] is not obj.__undef__:
            assert isinstance(obj._errors[0], float), ("Expected one of [u'number'], but got %s" % type(obj._errors[0]))
            common.validate_format(obj._errors[0], "None", None, None)
        obj._completed = (data.get("completed", obj.__undef__), dirty)
        if obj._completed[0] is not None and obj._completed[0] is not obj.__undef__:
            assert isinstance(obj._completed[0], float), ("Expected one of [u'number'], but got %s" % type(obj._completed[0]))
            common.validate_format(obj._completed[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'], "Expected enum [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ScrubStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "errors" == "type" or (self.errors is not self.__undef__ and not (dirty and not self._errors[1])):
            dct["errors"] = dictify(self.errors)
        if "completed" == "type" or (self.completed is not self.__undef__ and not (dirty and not self._completed[1])):
            dct["completed"] = dictify(self.completed)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._errors = (self._errors[0], True)
        self._completed = (self._completed[0], True)
        self._state = (self._state[0], True)
        self._end_time = (self._end_time[0], True)
        self._start_time = (self._start_time[0], True)
        self._total = (self._total[0], True)

    def is_dirty(self):
        return any([self._errors[1], self._completed[1], self._state[1], self._end_time[1], self._start_time[1], self._total[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ScrubStatus):
            return False
        return super(ScrubStatus, self).__eq__(other) and \
               self.errors == other.errors and \
               self.completed == other.completed and \
               self.state == other.state and \
               self.end_time == other.end_time and \
               self.start_time == other.start_time and \
               self.total == other.total

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def errors(self):
        """
        Number of errors encountered during scrub.

        :rtype: ``float``
        """
        return self._errors[0]

    @errors.setter
    def errors(self, value):
        self._errors = (value, True)

    @property
    def completed(self):
        """
        Amount of data scrubbed, in bytes.

        :rtype: ``float``
        """
        return self._completed[0]

    @completed.setter
    def completed(self, value):
        self._completed = (value, True)

    @property
    def state(self):
        """
        Scrub state. *(permitted values: NONE, ACTIVE, COMPLETED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def end_time(self):
        """
        Time scrub ended.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def start_time(self):
        """
        Time scrub was started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def total(self):
        """
        Total amount of data to scrub (including completed), in bytes.

        :rtype: ``float``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

class CapacityBreakdown(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Storage stats
    breakdown.
    """
    def __init__(self, undef_enabled=True):
        super(CapacityBreakdown, self).__init__()
        self._type = ("CapacityBreakdown", True)
        self._manual_space = (self.__undef__, True)
        self._unvirtualized_space = (self.__undef__, True)
        self._active_space = (self.__undef__, True)
        self._policy_space = (self.__undef__, True)
        self._log_space = (self.__undef__, True)
        self._timeflow_unvirtualized_space = (self.__undef__, True)
        self._sync_space = (self.__undef__, True)
        self._descendant_space = (self.__undef__, True)
        self._actual_space = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CapacityBreakdown, cls).from_dict(data, dirty, undef_enabled)
        obj._manual_space = (data.get("manualSpace", obj.__undef__), dirty)
        if obj._manual_space[0] is not None and obj._manual_space[0] is not obj.__undef__:
            assert isinstance(obj._manual_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._manual_space[0]))
            common.validate_format(obj._manual_space[0], "None", None, None)
        obj._unvirtualized_space = (data.get("unvirtualizedSpace", obj.__undef__), dirty)
        if obj._unvirtualized_space[0] is not None and obj._unvirtualized_space[0] is not obj.__undef__:
            assert isinstance(obj._unvirtualized_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unvirtualized_space[0]))
            common.validate_format(obj._unvirtualized_space[0], "None", None, None)
        obj._active_space = (data.get("activeSpace", obj.__undef__), dirty)
        if obj._active_space[0] is not None and obj._active_space[0] is not obj.__undef__:
            assert isinstance(obj._active_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._active_space[0]))
            common.validate_format(obj._active_space[0], "None", None, None)
        obj._policy_space = (data.get("policySpace", obj.__undef__), dirty)
        if obj._policy_space[0] is not None and obj._policy_space[0] is not obj.__undef__:
            assert isinstance(obj._policy_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._policy_space[0]))
            common.validate_format(obj._policy_space[0], "None", None, None)
        obj._log_space = (data.get("logSpace", obj.__undef__), dirty)
        if obj._log_space[0] is not None and obj._log_space[0] is not obj.__undef__:
            assert isinstance(obj._log_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._log_space[0]))
            common.validate_format(obj._log_space[0], "None", None, None)
        obj._timeflow_unvirtualized_space = (data.get("timeflowUnvirtualizedSpace", obj.__undef__), dirty)
        if obj._timeflow_unvirtualized_space[0] is not None and obj._timeflow_unvirtualized_space[0] is not obj.__undef__:
            assert isinstance(obj._timeflow_unvirtualized_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._timeflow_unvirtualized_space[0]))
            common.validate_format(obj._timeflow_unvirtualized_space[0], "None", None, None)
        obj._sync_space = (data.get("syncSpace", obj.__undef__), dirty)
        if obj._sync_space[0] is not None and obj._sync_space[0] is not obj.__undef__:
            assert isinstance(obj._sync_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._sync_space[0]))
            common.validate_format(obj._sync_space[0], "None", None, None)
        obj._descendant_space = (data.get("descendantSpace", obj.__undef__), dirty)
        if obj._descendant_space[0] is not None and obj._descendant_space[0] is not obj.__undef__:
            assert isinstance(obj._descendant_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._descendant_space[0]))
            common.validate_format(obj._descendant_space[0], "None", None, None)
        obj._actual_space = (data.get("actualSpace", obj.__undef__), dirty)
        if obj._actual_space[0] is not None and obj._actual_space[0] is not obj.__undef__:
            assert isinstance(obj._actual_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._actual_space[0]))
            common.validate_format(obj._actual_space[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CapacityBreakdown, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "manual_space" == "type" or (self.manual_space is not self.__undef__ and not (dirty and not self._manual_space[1])):
            dct["manualSpace"] = dictify(self.manual_space)
        if "unvirtualized_space" == "type" or (self.unvirtualized_space is not self.__undef__ and not (dirty and not self._unvirtualized_space[1])):
            dct["unvirtualizedSpace"] = dictify(self.unvirtualized_space)
        if "active_space" == "type" or (self.active_space is not self.__undef__ and not (dirty and not self._active_space[1])):
            dct["activeSpace"] = dictify(self.active_space)
        if "policy_space" == "type" or (self.policy_space is not self.__undef__ and not (dirty and not self._policy_space[1])):
            dct["policySpace"] = dictify(self.policy_space)
        if "log_space" == "type" or (self.log_space is not self.__undef__ and not (dirty and not self._log_space[1])):
            dct["logSpace"] = dictify(self.log_space)
        if "timeflow_unvirtualized_space" == "type" or (self.timeflow_unvirtualized_space is not self.__undef__ and not (dirty and not self._timeflow_unvirtualized_space[1])):
            dct["timeflowUnvirtualizedSpace"] = dictify(self.timeflow_unvirtualized_space)
        if "sync_space" == "type" or (self.sync_space is not self.__undef__ and not (dirty and not self._sync_space[1])):
            dct["syncSpace"] = dictify(self.sync_space)
        if "descendant_space" == "type" or (self.descendant_space is not self.__undef__ and not (dirty and not self._descendant_space[1])):
            dct["descendantSpace"] = dictify(self.descendant_space)
        if "actual_space" == "type" or (self.actual_space is not self.__undef__ and not (dirty and not self._actual_space[1])):
            dct["actualSpace"] = dictify(self.actual_space)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._manual_space = (self._manual_space[0], True)
        self._unvirtualized_space = (self._unvirtualized_space[0], True)
        self._active_space = (self._active_space[0], True)
        self._policy_space = (self._policy_space[0], True)
        self._log_space = (self._log_space[0], True)
        self._timeflow_unvirtualized_space = (self._timeflow_unvirtualized_space[0], True)
        self._sync_space = (self._sync_space[0], True)
        self._descendant_space = (self._descendant_space[0], True)
        self._actual_space = (self._actual_space[0], True)

    def is_dirty(self):
        return any([self._manual_space[1], self._unvirtualized_space[1], self._active_space[1], self._policy_space[1], self._log_space[1], self._timeflow_unvirtualized_space[1], self._sync_space[1], self._descendant_space[1], self._actual_space[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CapacityBreakdown):
            return False
        return super(CapacityBreakdown, self).__eq__(other) and \
               self.manual_space == other.manual_space and \
               self.unvirtualized_space == other.unvirtualized_space and \
               self.active_space == other.active_space and \
               self.policy_space == other.policy_space and \
               self.log_space == other.log_space and \
               self.timeflow_unvirtualized_space == other.timeflow_unvirtualized_space and \
               self.sync_space == other.sync_space and \
               self.descendant_space == other.descendant_space and \
               self.actual_space == other.actual_space

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def manual_space(self):
        """
        Amount of space used for snapshots held by manual retention settings.

        :rtype: ``float``
        """
        return self._manual_space[0]

    @manual_space.setter
    def manual_space(self, value):
        self._manual_space = (value, True)

    @property
    def unvirtualized_space(self):
        """
        Unvirtualized space used by the container.

        :rtype: ``float``
        """
        return self._unvirtualized_space[0]

    @unvirtualized_space.setter
    def unvirtualized_space(self, value):
        self._unvirtualized_space = (value, True)

    @property
    def active_space(self):
        """
        Amount of space used for the active copy of the container.

        :rtype: ``float``
        """
        return self._active_space[0]

    @active_space.setter
    def active_space(self, value):
        self._active_space = (value, True)

    @property
    def policy_space(self):
        """
        Amount of space used for snapshots held by policy settings.

        :rtype: ``float``
        """
        return self._policy_space[0]

    @policy_space.setter
    def policy_space(self, value):
        self._policy_space = (value, True)

    @property
    def log_space(self):
        """
        Amount of space used by logs.

        :rtype: ``float``
        """
        return self._log_space[0]

    @log_space.setter
    def log_space(self, value):
        self._log_space = (value, True)

    @property
    def timeflow_unvirtualized_space(self):
        """
        Unvirtualized space used by the TimeFlow.

        :rtype: ``float``
        """
        return self._timeflow_unvirtualized_space[0]

    @timeflow_unvirtualized_space.setter
    def timeflow_unvirtualized_space(self, value):
        self._timeflow_unvirtualized_space = (value, True)

    @property
    def sync_space(self):
        """
        Amount of space used by snapshots.

        :rtype: ``float``
        """
        return self._sync_space[0]

    @sync_space.setter
    def sync_space(self, value):
        self._sync_space = (value, True)

    @property
    def descendant_space(self):
        """
        Amount of space used for snapshots from which VDBs have been
        provisioned.

        :rtype: ``float``
        """
        return self._descendant_space[0]

    @descendant_space.setter
    def descendant_space(self, value):
        self._descendant_space = (value, True)

    @property
    def actual_space(self):
        """
        Actual space used by the container.

        :rtype: ``float``
        """
        return self._actual_space[0]

    @actual_space.setter
    def actual_space(self, value):
        self._actual_space = (value, True)

class TracerouteInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Trace route info from
    target host to Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(TracerouteInfo, self).__init__()
        self._type = ("TracerouteInfo", True)
        self._network_hops = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TracerouteInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._network_hops = (data.get("networkHops", obj.__undef__), dirty)
        if obj._network_hops[0] is not None and obj._network_hops[0] is not obj.__undef__:
            assert isinstance(obj._network_hops[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._network_hops[0]))
            common.validate_format(obj._network_hops[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TracerouteInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "network_hops" == "type" or (self.network_hops is not self.__undef__ and not (dirty and not self._network_hops[1])):
            dct["networkHops"] = dictify(self.network_hops)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._network_hops = (self._network_hops[0], True)

    def is_dirty(self):
        return any([self._network_hops[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TracerouteInfo):
            return False
        return super(TracerouteInfo, self).__eq__(other) and \
               self.network_hops == other.network_hops

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def network_hops(self):
        """
        Latency of network hops from host to Delphix Engine.

        :rtype: ``basestring``
        """
        return self._network_hops[0]

    @network_hops.setter
    def network_hops(self, value):
        self._network_hops = (value, True)

class SourceDisableParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to disable MSSQL or AppData sources.
    """
    def __init__(self, undef_enabled=True):
        super(SourceDisableParameters, self).__init__()
        self._type = ("SourceDisableParameters", True)
        self._attempt_cleanup = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceDisableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._attempt_cleanup = (data.get("attemptCleanup", obj.__undef__), dirty)
        if obj._attempt_cleanup[0] is not None and obj._attempt_cleanup[0] is not obj.__undef__:
            assert isinstance(obj._attempt_cleanup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._attempt_cleanup[0]))
            common.validate_format(obj._attempt_cleanup[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceDisableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "attempt_cleanup" == "type" or (self.attempt_cleanup is not self.__undef__ and not (dirty and not self._attempt_cleanup[1])):
            dct["attemptCleanup"] = dictify(self.attempt_cleanup)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._attempt_cleanup = (self._attempt_cleanup[0], True)

    def is_dirty(self):
        return any([self._attempt_cleanup[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceDisableParameters):
            return False
        return super(SourceDisableParameters, self).__eq__(other) and \
               self.attempt_cleanup == other.attempt_cleanup

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def attempt_cleanup(self):
        """
        *(default value: True)* Whether to attempt a cleanup of the database
        from the environment before the disable.

        :rtype: ``bool``
        """
        return self._attempt_cleanup[0]

    @attempt_cleanup.setter
    def attempt_cleanup(self, value):
        self._attempt_cleanup = (value, True)

class TimeflowRange(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Time range within a
    timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRange, self).__init__()
        self._type = ("TimeflowRange", True)
        self._provisionable = (self.__undef__, True)
        self._end_point = (self.__undef__, True)
        self._start_point = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRange, cls).from_dict(data, dirty, undef_enabled)
        obj._provisionable = (data.get("provisionable", obj.__undef__), dirty)
        if obj._provisionable[0] is not None and obj._provisionable[0] is not obj.__undef__:
            assert isinstance(obj._provisionable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisionable[0]))
            common.validate_format(obj._provisionable[0], "None", None, None)
        if "endPoint" in data and data["endPoint"] is not None:
            obj._end_point = (factory.create_object(data["endPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._end_point[0], "TimeflowPoint")
        else:
            obj._end_point = (obj.__undef__, dirty)
        if "startPoint" in data and data["startPoint"] is not None:
            obj._start_point = (factory.create_object(data["startPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._start_point[0], "TimeflowPoint")
        else:
            obj._start_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRange, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provisionable" == "type" or (self.provisionable is not self.__undef__ and not (dirty and not self._provisionable[1])):
            dct["provisionable"] = dictify(self.provisionable)
        if "end_point" == "type" or (self.end_point is not self.__undef__ and not (dirty and not self._end_point[1])):
            dct["endPoint"] = dictify(self.end_point)
        if "start_point" == "type" or (self.start_point is not self.__undef__ and not (dirty and not self._start_point[1])):
            dct["startPoint"] = dictify(self.start_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provisionable = (self._provisionable[0], True)
        self._end_point = (self._end_point[0], True)
        self._start_point = (self._start_point[0], True)

    def is_dirty(self):
        return any([self._provisionable[1], self._end_point[1], self._start_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRange):
            return False
        return super(TimeflowRange, self).__eq__(other) and \
               self.provisionable == other.provisionable and \
               self.end_point == other.end_point and \
               self.start_point == other.start_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provisionable(self):
        """
        Whether or not this timeflow range is provisionable.

        :rtype: ``bool``
        """
        return self._provisionable[0]

    @provisionable.setter
    def provisionable(self, value):
        self._provisionable = (value, True)

    @property
    def end_point(self):
        """
        The ending timeflow point of this range.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._end_point[0]

    @end_point.setter
    def end_point(self, value):
        self._end_point = (value, True)

    @property
    def start_point(self):
        """
        The starting timeflow point of this range.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._start_point[0]

    @start_point.setter
    def start_point(self, value):
        self._start_point = (value, True)

class Operation(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A user-specifiable
    operation that can be performed on virtual sources.
    """
    def __init__(self, undef_enabled=True):
        super(Operation, self).__init__()
        self._type = ("Operation", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Operation, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Operation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Operation):
            return False
        return super(Operation, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class UploadParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to request an upload.
    """
    def __init__(self, undef_enabled=True):
        super(UploadParameters, self).__init__()
        self._type = ("UploadParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UploadParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UploadParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UploadParameters):
            return False
        return super(UploadParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NfsReadWriteSizes(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* NFS read/write sizes
    from target host to Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(NfsReadWriteSizes, self).__init__()
        self._type = ("NfsReadWriteSizes", True)
        self._current_read_size = (self.__undef__, True)
        self._max_write_size = (self.__undef__, True)
        self._max_read_size = (self.__undef__, True)
        self._current_write_size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NfsReadWriteSizes, cls).from_dict(data, dirty, undef_enabled)
        obj._current_read_size = (data.get("currentReadSize", obj.__undef__), dirty)
        if obj._current_read_size[0] is not None and obj._current_read_size[0] is not obj.__undef__:
            assert isinstance(obj._current_read_size[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_read_size[0]))
            common.validate_format(obj._current_read_size[0], "None", None, None)
        obj._max_write_size = (data.get("maxWriteSize", obj.__undef__), dirty)
        if obj._max_write_size[0] is not None and obj._max_write_size[0] is not obj.__undef__:
            assert isinstance(obj._max_write_size[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._max_write_size[0]))
            common.validate_format(obj._max_write_size[0], "None", None, None)
        obj._max_read_size = (data.get("maxReadSize", obj.__undef__), dirty)
        if obj._max_read_size[0] is not None and obj._max_read_size[0] is not obj.__undef__:
            assert isinstance(obj._max_read_size[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._max_read_size[0]))
            common.validate_format(obj._max_read_size[0], "None", None, None)
        obj._current_write_size = (data.get("currentWriteSize", obj.__undef__), dirty)
        if obj._current_write_size[0] is not None and obj._current_write_size[0] is not obj.__undef__:
            assert isinstance(obj._current_write_size[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_write_size[0]))
            common.validate_format(obj._current_write_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NfsReadWriteSizes, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "current_read_size" == "type" or (self.current_read_size is not self.__undef__ and not (dirty and not self._current_read_size[1])):
            dct["currentReadSize"] = dictify(self.current_read_size)
        if "max_write_size" == "type" or (self.max_write_size is not self.__undef__ and not (dirty and not self._max_write_size[1])):
            dct["maxWriteSize"] = dictify(self.max_write_size)
        if "max_read_size" == "type" or (self.max_read_size is not self.__undef__ and not (dirty and not self._max_read_size[1])):
            dct["maxReadSize"] = dictify(self.max_read_size)
        if "current_write_size" == "type" or (self.current_write_size is not self.__undef__ and not (dirty and not self._current_write_size[1])):
            dct["currentWriteSize"] = dictify(self.current_write_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._current_read_size = (self._current_read_size[0], True)
        self._max_write_size = (self._max_write_size[0], True)
        self._max_read_size = (self._max_read_size[0], True)
        self._current_write_size = (self._current_write_size[0], True)

    def is_dirty(self):
        return any([self._current_read_size[1], self._max_write_size[1], self._max_read_size[1], self._current_write_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NfsReadWriteSizes):
            return False
        return super(NfsReadWriteSizes, self).__eq__(other) and \
               self.current_read_size == other.current_read_size and \
               self.max_write_size == other.max_write_size and \
               self.max_read_size == other.max_read_size and \
               self.current_write_size == other.current_write_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def current_read_size(self):
        """
        NFS current read size.

        :rtype: ``basestring``
        """
        return self._current_read_size[0]

    @current_read_size.setter
    def current_read_size(self, value):
        self._current_read_size = (value, True)

    @property
    def max_write_size(self):
        """
        Maximum NFS write size.

        :rtype: ``basestring``
        """
        return self._max_write_size[0]

    @max_write_size.setter
    def max_write_size(self, value):
        self._max_write_size = (value, True)

    @property
    def max_read_size(self):
        """
        Maximum NFS read size.

        :rtype: ``basestring``
        """
        return self._max_read_size[0]

    @max_read_size.setter
    def max_read_size(self, value):
        self._max_read_size = (value, True)

    @property
    def current_write_size(self):
        """
        NFS current write size.

        :rtype: ``basestring``
        """
        return self._current_write_size[0]

    @current_write_size.setter
    def current_write_size(self, value):
        self._current_write_size = (value, True)

class PolicyCreateAndApplyParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used
    for creating and applying policies.
    """
    def __init__(self, undef_enabled=True):
        super(PolicyCreateAndApplyParameters, self).__init__()
        self._type = ("PolicyCreateAndApplyParameters", True)
        self._policy = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PolicyCreateAndApplyParameters, cls).from_dict(data, dirty, undef_enabled)
        if "policy" not in data:
            raise ValueError("Missing required property \"policy\".")
        if "policy" in data and data["policy"] is not None:
            obj._policy = (factory.create_object(data["policy"], "Policy"), dirty)
            factory.validate_type(obj._policy[0], "Policy")
        else:
            obj._policy = (obj.__undef__, dirty)
        if "target" not in data:
            raise ValueError("Missing required property \"target\".")
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PolicyCreateAndApplyParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "policy" == "type" or (self.policy is not self.__undef__ and not (dirty and not self._policy[1])):
            dct["policy"] = dictify(self.policy)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._policy = (self._policy[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._policy[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PolicyCreateAndApplyParameters):
            return False
        return super(PolicyCreateAndApplyParameters, self).__eq__(other) and \
               self.policy == other.policy and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def policy(self):
        """
        Policy to create

        :rtype: :py:class:`v1_3_0.web.vo.Policy`
        """
        return self._policy[0]

    @policy.setter
    def policy(self, value):
        self._policy = (value, True)

    @property
    def target(self):
        """
        Object reference of the target

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class SourceStartParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to start MSSQL sources.
    """
    def __init__(self, undef_enabled=True):
        super(SourceStartParameters, self).__init__()
        self._type = ("SourceStartParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceStartParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceStartParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceStartParameters):
            return False
        return super(SourceStartParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLIdentEntry(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An entry in the
    PostgreSQL username map file (pg_ident.conf).
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLIdentEntry, self).__init__()
        self._type = ("PgSQLIdentEntry", True)
        self._map_name = (self.__undef__, True)
        self._system_username = (self.__undef__, True)
        self._database_username = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLIdentEntry, cls).from_dict(data, dirty, undef_enabled)
        obj._map_name = (data.get("mapName", obj.__undef__), dirty)
        if obj._map_name[0] is not None and obj._map_name[0] is not obj.__undef__:
            assert isinstance(obj._map_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._map_name[0]))
            common.validate_format(obj._map_name[0], "None", None, None)
        obj._system_username = (data.get("systemUsername", obj.__undef__), dirty)
        if obj._system_username[0] is not None and obj._system_username[0] is not obj.__undef__:
            assert isinstance(obj._system_username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._system_username[0]))
            common.validate_format(obj._system_username[0], "None", None, None)
        obj._database_username = (data.get("databaseUsername", obj.__undef__), dirty)
        if obj._database_username[0] is not None and obj._database_username[0] is not obj.__undef__:
            assert isinstance(obj._database_username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_username[0]))
            common.validate_format(obj._database_username[0], "None", None, 63)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLIdentEntry, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "map_name" == "type" or (self.map_name is not self.__undef__ and not (dirty and not self._map_name[1])):
            dct["mapName"] = dictify(self.map_name)
        if "system_username" == "type" or (self.system_username is not self.__undef__ and not (dirty and not self._system_username[1])):
            dct["systemUsername"] = dictify(self.system_username)
        if "database_username" == "type" or (self.database_username is not self.__undef__ and not (dirty and not self._database_username[1])):
            dct["databaseUsername"] = dictify(self.database_username)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._map_name = (self._map_name[0], True)
        self._system_username = (self._system_username[0], True)
        self._database_username = (self._database_username[0], True)

    def is_dirty(self):
        return any([self._map_name[1], self._system_username[1], self._database_username[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLIdentEntry):
            return False
        return super(PgSQLIdentEntry, self).__eq__(other) and \
               self.map_name == other.map_name and \
               self.system_username == other.system_username and \
               self.database_username == other.database_username

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def map_name(self):
        """
        The name of the map to which this entry belongs (used to refer to the
        map in pg_hba.conf).

        :rtype: ``basestring``
        """
        return self._map_name[0]

    @map_name.setter
    def map_name(self, value):
        self._map_name = (value, True)

    @property
    def system_username(self):
        """
        The operating system username this entry matches.

        :rtype: ``basestring``
        """
        return self._system_username[0]

    @system_username.setter
    def system_username(self, value):
        self._system_username = (value, True)

    @property
    def database_username(self):
        """
        The database username this entry matches.

        :rtype: ``basestring``
        """
        return self._database_username[0]

    @database_username.setter
    def database_username(self, value):
        self._database_username = (value, True)

class TimeflowBookmarkCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to create timeflow bookmarks.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowBookmarkCreateParameters, self).__init__()
        self._type = ("TimeflowBookmarkCreateParameters", True)
        self._retention_proof = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._timeflow_point = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowBookmarkCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._retention_proof = (data.get("retentionProof", obj.__undef__), dirty)
        if obj._retention_proof[0] is not None and obj._retention_proof[0] is not obj.__undef__:
            assert isinstance(obj._retention_proof[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._retention_proof[0]))
            common.validate_format(obj._retention_proof[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, 64)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        if "timeflowPoint" not in data:
            raise ValueError("Missing required property \"timeflowPoint\".")
        if "timeflowPoint" in data and data["timeflowPoint"] is not None:
            obj._timeflow_point = (factory.create_object(data["timeflowPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._timeflow_point[0], "TimeflowPoint")
        else:
            obj._timeflow_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowBookmarkCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "retention_proof" == "type" or (self.retention_proof is not self.__undef__ and not (dirty and not self._retention_proof[1])):
            dct["retentionProof"] = dictify(self.retention_proof)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "timeflow_point" == "type" or (self.timeflow_point is not self.__undef__ and not (dirty and not self._timeflow_point[1])):
            dct["timeflowPoint"] = dictify(self.timeflow_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._retention_proof = (self._retention_proof[0], True)
        self._tag = (self._tag[0], True)
        self._name = (self._name[0], True)
        self._timeflow_point = (self._timeflow_point[0], True)

    def is_dirty(self):
        return any([self._retention_proof[1], self._tag[1], self._name[1], self._timeflow_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowBookmarkCreateParameters):
            return False
        return super(TimeflowBookmarkCreateParameters, self).__eq__(other) and \
               self.retention_proof == other.retention_proof and \
               self.tag == other.tag and \
               self.name == other.name and \
               self.timeflow_point == other.timeflow_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def retention_proof(self):
        """
        Indicates whether retention should be allowed to clean up the timeflow
        bookmark and associated data.

        :rtype: ``bool``
        """
        return self._retention_proof[0]

    @retention_proof.setter
    def retention_proof(self, value):
        self._retention_proof = (value, True)

    @property
    def tag(self):
        """
        A tag for the bookmark that can be used to group bookmarks together or
        qualify the type of the bookmark.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def name(self):
        """
        The bookmark name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def timeflow_point(self):
        """
        The timeflow point which is referenced by this bookmark.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._timeflow_point[0]

    @timeflow_point.setter
    def timeflow_point(self, value):
        self._timeflow_point = (value, True)

class LoginRequest(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Represents a Delphix
    user authentication request.
    """
    def __init__(self, undef_enabled=True):
        super(LoginRequest, self).__init__()
        self._type = ("LoginRequest", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LoginRequest, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            assert obj._target[0] in [u'DOMAIN', u'SYSTEM'], "Expected enum [u'DOMAIN', u'SYSTEM'] but got %s" % obj._target[0]
            common.validate_format(obj._target[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LoginRequest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LoginRequest):
            return False
        return super(LoginRequest, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        User name of user to authenticate

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        Password of user to authenticate

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def target(self):
        """
        Authentication domain *(permitted values: DOMAIN, SYSTEM)*

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class DatapointSet(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A set of datapoints
    from a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DatapointSet, self).__init__()
        self._type = ("DatapointSet", True)
        self._resolution = (self.__undef__, True)
        self._datapoint_streams = (self.__undef__, True)
        self._collection_events = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatapointSet, cls).from_dict(data, dirty, undef_enabled)
        obj._resolution = (data.get("resolution", obj.__undef__), dirty)
        if obj._resolution[0] is not None and obj._resolution[0] is not obj.__undef__:
            assert isinstance(obj._resolution[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._resolution[0]))
            common.validate_format(obj._resolution[0], "None", None, None)
        obj._datapoint_streams = []
        for item in data.get("datapointStreams") or []:
            obj._datapoint_streams.append(factory.create_object(item))
            factory.validate_type(obj._datapoint_streams[-1], "DatapointStream")
        obj._datapoint_streams = (obj._datapoint_streams, dirty)
        obj._collection_events = []
        for item in data.get("collectionEvents") or []:
            obj._collection_events.append(factory.create_object(item))
            factory.validate_type(obj._collection_events[-1], "StatisticSliceEvent")
        obj._collection_events = (obj._collection_events, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatapointSet, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "resolution" == "type" or (self.resolution is not self.__undef__ and not (dirty and not self._resolution[1])):
            dct["resolution"] = dictify(self.resolution)
        if "datapoint_streams" == "type" or (self.datapoint_streams is not self.__undef__ and not (dirty and not self._datapoint_streams[1])):
            dct["datapointStreams"] = dictify(self.datapoint_streams)
        if "collection_events" == "type" or (self.collection_events is not self.__undef__ and not (dirty and not self._collection_events[1])):
            dct["collectionEvents"] = dictify(self.collection_events)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._resolution = (self._resolution[0], True)
        self._datapoint_streams = (self._datapoint_streams[0], True)
        self._collection_events = (self._collection_events[0], True)

    def is_dirty(self):
        return any([self._resolution[1], self._datapoint_streams[1], self._collection_events[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatapointSet):
            return False
        return super(DatapointSet, self).__eq__(other) and \
               self.resolution == other.resolution and \
               self.datapoint_streams == other.datapoint_streams and \
               self.collection_events == other.collection_events

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def resolution(self):
        """
        The amount of time each datapoint spans.

        :rtype: ``int``
        """
        return self._resolution[0]

    @resolution.setter
    def resolution(self, value):
        self._resolution = (value, True)

    @property
    def datapoint_streams(self):
        """
        The set of datapoint streams in the result.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.DatapointStream`
        """
        return self._datapoint_streams[0]

    @datapoint_streams.setter
    def datapoint_streams(self, value):
        self._datapoint_streams = (value, True)

    @property
    def collection_events(self):
        """
        Events encountered during the requested time window related to this
        slice's status.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.StatisticSliceEvent`
        """
        return self._collection_events[0]

    @collection_events.setter
    def collection_events(self, value):
        self._collection_events = (value, True)

class OracleService(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The representation of
    an oracle service object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleService, self).__init__()
        self._type = ("OracleService", True)
        self._discovered = (self.__undef__, True)
        self._jdbc_connection_string = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleService, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._jdbc_connection_string = (data.get("jdbcConnectionString", obj.__undef__), dirty)
        if obj._jdbc_connection_string[0] is not None and obj._jdbc_connection_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_connection_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_connection_string[0]))
            common.validate_format(obj._jdbc_connection_string[0], "oracleJDBCConnectionString", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "jdbc_connection_string" == "type" or (self.jdbc_connection_string is not self.__undef__ and not (dirty and not self._jdbc_connection_string[1])):
            dct["jdbcConnectionString"] = dictify(self.jdbc_connection_string)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._jdbc_connection_string = (self._jdbc_connection_string[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._jdbc_connection_string[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleService):
            return False
        return super(OracleService, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.jdbc_connection_string == other.jdbc_connection_string

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this service was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def jdbc_connection_string(self):
        """
        The connection string used to connect to JDBC.

        :rtype: ``basestring``
        """
        return self._jdbc_connection_string[0]

    @jdbc_connection_string.setter
    def jdbc_connection_string(self, value):
        self._jdbc_connection_string = (value, True)

class OracleVirtualIP(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used
    for virtual IP operations.
    """
    def __init__(self, undef_enabled=True):
        super(OracleVirtualIP, self).__init__()
        self._type = ("OracleVirtualIP", True)
        self._discovered = (self.__undef__, True)
        self._ip = (self.__undef__, True)
        self._domain_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleVirtualIP, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        if "ip" not in data:
            raise ValueError("Missing required property \"ip\".")
        obj._ip = (data.get("ip", obj.__undef__), dirty)
        if obj._ip[0] is not None and obj._ip[0] is not obj.__undef__:
            assert isinstance(obj._ip[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ip[0]))
            common.validate_format(obj._ip[0], "ipv4Address", None, None)
        if "domainName" not in data:
            raise ValueError("Missing required property \"domainName\".")
        obj._domain_name = (data.get("domainName", obj.__undef__), dirty)
        if obj._domain_name[0] is not None and obj._domain_name[0] is not obj.__undef__:
            assert isinstance(obj._domain_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._domain_name[0]))
            common.validate_format(obj._domain_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleVirtualIP, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "ip" == "type" or (self.ip is not self.__undef__ and not (dirty and not self._ip[1])):
            dct["ip"] = dictify(self.ip)
        if "domain_name" == "type" or (self.domain_name is not self.__undef__ and not (dirty and not self._domain_name[1])):
            dct["domainName"] = dictify(self.domain_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._ip = (self._ip[0], True)
        self._domain_name = (self._domain_name[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._ip[1], self._domain_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleVirtualIP):
            return False
        return super(OracleVirtualIP, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.ip == other.ip and \
               self.domain_name == other.domain_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        A boolean indicating whether this VIP was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def ip(self):
        """
        The virtual IP address.

        :rtype: ``basestring``
        """
        return self._ip[0]

    @ip.setter
    def ip(self, value):
        self._ip = (value, True)

    @property
    def domain_name(self):
        """
        The name of the domain where the cluster is residing.

        :rtype: ``basestring``
        """
        return self._domain_name[0]

    @domain_name.setter
    def domain_name(self, value):
        self._domain_name = (value, True)

class DVCApplicationCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used to
    create an application.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplicationCreateParameters, self).__init__()
        self._type = ("DVCApplicationCreateParameters", True)
        self._notes = (self.__undef__, True)
        self._properties = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._data_sources = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplicationCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._notes = (data.get("notes", obj.__undef__), dirty)
        if obj._notes[0] is not None and obj._notes[0] is not obj.__undef__:
            assert isinstance(obj._notes[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._notes[0]))
            common.validate_format(obj._notes[0], "None", None, 4096)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        obj._data_sources = []
        for item in data.get("dataSources") or []:
            obj._data_sources.append(factory.create_object(item))
            factory.validate_type(obj._data_sources[-1], "DVCDataSourceCreateParameters")
        obj._data_sources = (obj._data_sources, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplicationCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "notes" == "type" or (self.notes is not self.__undef__ and not (dirty and not self._notes[1])):
            dct["notes"] = dictify(self.notes)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "data_sources" == "type" or (self.data_sources is not self.__undef__ and not (dirty and not self._data_sources[1])):
            dct["dataSources"] = dictify(self.data_sources)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._notes = (self._notes[0], True)
        self._properties = (self._properties[0], True)
        self._name = (self._name[0], True)
        self._data_sources = (self._data_sources[0], True)

    def is_dirty(self):
        return any([self._notes[1], self._properties[1], self._name[1], self._data_sources[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplicationCreateParameters):
            return False
        return super(DVCApplicationCreateParameters, self).__eq__(other) and \
               self.notes == other.notes and \
               self.properties == other.properties and \
               self.name == other.name and \
               self.data_sources == other.data_sources

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def notes(self):
        """
        A description of this application to define what it is used for.

        :rtype: ``basestring``
        """
        return self._notes[0]

    @notes.setter
    def notes(self, value):
        self._notes = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this application.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

    @property
    def name(self):
        """
        The name of the application.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def data_sources(self):
        """
        The set of data sources that belong to this application.

        :rtype: ``list`` of
            :py:class:`v1_3_0.web.vo.DVCDataSourceCreateParameters`
        """
        return self._data_sources[0]

    @data_sources.setter
    def data_sources(self, value):
        self._data_sources = (value, True)

class MSSqlInstanceConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* MSSQL instance
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlInstanceConfig, self).__init__()
        self._type = ("MSSqlInstanceConfig", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlInstanceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlInstanceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlInstanceConfig):
            return False
        return super(MSSqlInstanceConfig, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The reference to the associated host.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class CPUInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Describes a processor
    available to the system.
    """
    def __init__(self, undef_enabled=True):
        super(CPUInfo, self).__init__()
        self._type = ("CPUInfo", True)
        self._cores = (self.__undef__, True)
        self._speed = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CPUInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._cores = (data.get("cores", obj.__undef__), dirty)
        if obj._cores[0] is not None and obj._cores[0] is not obj.__undef__:
            assert isinstance(obj._cores[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cores[0]))
            common.validate_format(obj._cores[0], "None", None, None)
        obj._speed = (data.get("speed", obj.__undef__), dirty)
        if obj._speed[0] is not None and obj._speed[0] is not obj.__undef__:
            assert isinstance(obj._speed[0], float), ("Expected one of [u'number'], but got %s" % type(obj._speed[0]))
            common.validate_format(obj._speed[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CPUInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cores" == "type" or (self.cores is not self.__undef__ and not (dirty and not self._cores[1])):
            dct["cores"] = dictify(self.cores)
        if "speed" == "type" or (self.speed is not self.__undef__ and not (dirty and not self._speed[1])):
            dct["speed"] = dictify(self.speed)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cores = (self._cores[0], True)
        self._speed = (self._speed[0], True)

    def is_dirty(self):
        return any([self._cores[1], self._speed[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CPUInfo):
            return False
        return super(CPUInfo, self).__eq__(other) and \
               self.cores == other.cores and \
               self.speed == other.speed

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cores(self):
        """
        Number of cores in the processor.

        :rtype: ``int``
        """
        return self._cores[0]

    @cores.setter
    def cores(self, value):
        self._cores = (value, True)

    @property
    def speed(self):
        """
        Speed of the processor, in hertz.

        :rtype: ``float``
        """
        return self._speed[0]

    @speed.setter
    def speed(self, value):
        self._speed = (value, True)

class PhoneHomeService(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Phone home service
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(PhoneHomeService, self).__init__()
        self._type = ("PhoneHomeService", True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PhoneHomeService, cls).from_dict(data, dirty, undef_enabled)
        if "enabled" not in data:
            raise ValueError("Missing required property \"enabled\".")
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PhoneHomeService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PhoneHomeService):
            return False
        return super(PhoneHomeService, self).__eq__(other) and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        True if the phone home service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class FileUploadResult(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Result of a file
    upload request.
    """
    def __init__(self, undef_enabled=True):
        super(FileUploadResult, self).__init__()
        self._type = ("FileUploadResult", True)
        self._token = (self.__undef__, True)
        self._post_url = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileUploadResult, cls).from_dict(data, dirty, undef_enabled)
        obj._token = (data.get("token", obj.__undef__), dirty)
        if obj._token[0] is not None and obj._token[0] is not obj.__undef__:
            assert isinstance(obj._token[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._token[0]))
            common.validate_format(obj._token[0], "None", None, None)
        obj._post_url = (data.get("postUrl", obj.__undef__), dirty)
        if obj._post_url[0] is not None and obj._post_url[0] is not obj.__undef__:
            assert isinstance(obj._post_url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_url[0]))
            common.validate_format(obj._post_url[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileUploadResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "token" == "type" or (self.token is not self.__undef__ and not (dirty and not self._token[1])):
            dct["token"] = dictify(self.token)
        if "post_url" == "type" or (self.post_url is not self.__undef__ and not (dirty and not self._post_url[1])):
            dct["postUrl"] = dictify(self.post_url)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._token = (self._token[0], True)
        self._post_url = (self._post_url[0], True)

    def is_dirty(self):
        return any([self._token[1], self._post_url[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileUploadResult):
            return False
        return super(FileUploadResult, self).__eq__(other) and \
               self.token == other.token and \
               self.post_url == other.post_url

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def token(self):
        """
        Token to pass with upload to identify the upload.

        :rtype: ``basestring``
        """
        return self._token[0]

    @token.setter
    def token(self, value):
        self._token = (value, True)

    @property
    def post_url(self):
        """
        URL to upload to.

        :rtype: ``basestring``
        """
        return self._post_url[0]

    @post_url.setter
    def post_url(self, value):
        self._post_url = (value, True)

class BaseConsumerCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Data about a
    particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(BaseConsumerCapacityData, self).__init__()
        self._type = ("BaseConsumerCapacityData", True)
        self._breakdown = (self.__undef__, True)
        self._group = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._parent = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._group_name = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        if "breakdown" in data and data["breakdown"] is not None:
            obj._breakdown = (factory.create_object(data["breakdown"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._breakdown[0], "CapacityBreakdown")
        else:
            obj._breakdown = (obj.__undef__, dirty)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._parent = (data.get("parent", obj.__undef__), dirty)
        if obj._parent[0] is not None and obj._parent[0] is not obj.__undef__:
            assert isinstance(obj._parent[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent[0]))
            common.validate_format(obj._parent[0], "objectReference", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._group_name = (data.get("groupName", obj.__undef__), dirty)
        if obj._group_name[0] is not None and obj._group_name[0] is not obj.__undef__:
            assert isinstance(obj._group_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group_name[0]))
            common.validate_format(obj._group_name[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "breakdown" == "type" or (self.breakdown is not self.__undef__ and not (dirty and not self._breakdown[1])):
            dct["breakdown"] = dictify(self.breakdown)
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "parent" == "type" or (self.parent is not self.__undef__ and not (dirty and not self._parent[1])):
            dct["parent"] = dictify(self.parent)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "group_name" == "type" or (self.group_name is not self.__undef__ and not (dirty and not self._group_name[1])):
            dct["groupName"] = dictify(self.group_name)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._breakdown = (self._breakdown[0], True)
        self._group = (self._group[0], True)
        self._name = (self._name[0], True)
        self._parent = (self._parent[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._group_name = (self._group_name[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._breakdown[1], self._group[1], self._name[1], self._parent[1], self._timestamp[1], self._group_name[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseConsumerCapacityData):
            return False
        return super(BaseConsumerCapacityData, self).__eq__(other) and \
               self.breakdown == other.breakdown and \
               self.group == other.group and \
               self.name == other.name and \
               self.parent == other.parent and \
               self.timestamp == other.timestamp and \
               self.group_name == other.group_name and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def breakdown(self):
        """
        Statistics for this consumer.

        :rtype: :py:class:`v1_3_0.web.vo.CapacityBreakdown`
        """
        return self._breakdown[0]

    @breakdown.setter
    def breakdown(self, value):
        self._breakdown = (value, True)

    @property
    def group(self):
        """
        Reference to this container's group.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

    @property
    def name(self):
        """
        Name of the container.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def parent(self):
        """
        Container from which this timeflow was provisioned.

        :rtype: ``basestring``
        """
        return self._parent[0]

    @parent.setter
    def parent(self, value):
        self._parent = (value, True)

    @property
    def timestamp(self):
        """
        Time at which this information was sampled.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def group_name(self):
        """
        Name of this container's group.

        :rtype: ``basestring``
        """
        return self._group_name[0]

    @group_name.setter
    def group_name(self, value):
        self._group_name = (value, True)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class StatisticSliceEvent(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A set of events
    affecting a particular analytics slice's collection.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticSliceEvent, self).__init__()
        self._type = ("StatisticSliceEvent", True)
        self._event_type = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticSliceEvent, cls).from_dict(data, dirty, undef_enabled)
        obj._event_type = (data.get("eventType", obj.__undef__), dirty)
        if obj._event_type[0] is not None and obj._event_type[0] is not obj.__undef__:
            assert isinstance(obj._event_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_type[0]))
            assert obj._event_type[0] in [u'RUNNING', u'PAUSED'], "Expected enum [u'RUNNING', u'PAUSED'] but got %s" % obj._event_type[0]
            common.validate_format(obj._event_type[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticSliceEvent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_type" == "type" or (self.event_type is not self.__undef__ and not (dirty and not self._event_type[1])):
            dct["eventType"] = dictify(self.event_type)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_type = (self._event_type[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._event_type[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticSliceEvent):
            return False
        return super(StatisticSliceEvent, self).__eq__(other) and \
               self.event_type == other.event_type and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_type(self):
        """
        The type of event that occurred. Reflects the state of the slice after
        the event. *(permitted values: RUNNING, PAUSED)*

        :rtype: ``basestring``
        """
        return self._event_type[0]

    @event_type.setter
    def event_type(self, value):
        self._event_type = (value, True)

    @property
    def timestamp(self):
        """
        The time the event occurred.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class DVCTimelinePointParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Specifies the DVC
    timeline point to use for DVC timeline operations such as refresh and
    create bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimelinePointParameters, self).__init__()
        self._type = ("DVCTimelinePointParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimelinePointParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimelinePointParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimelinePointParameters):
            return False
        return super(DVCTimelinePointParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SourceConnectionInfo(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Contains information
    that can be used to connect to the source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConnectionInfo, self).__init__()
        self._type = ("SourceConnectionInfo", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConnectionInfo):
            return False
        return super(SourceConnectionInfo, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DBContainerRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Runtime properties of
    a database container.
    """
    def __init__(self, undef_enabled=True):
        super(DBContainerRuntime, self).__init__()
        self._type = ("DBContainerRuntime", True)
        self._log_sync_active = (self.__undef__, True)
        self._pre_provisioning_status = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._log_sync_active = (data.get("logSyncActive", obj.__undef__), dirty)
        if obj._log_sync_active[0] is not None and obj._log_sync_active[0] is not obj.__undef__:
            assert isinstance(obj._log_sync_active[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._log_sync_active[0]))
            common.validate_format(obj._log_sync_active[0], "None", None, None)
        if "preProvisioningStatus" in data and data["preProvisioningStatus"] is not None:
            obj._pre_provisioning_status = (factory.create_object(data["preProvisioningStatus"], "PreProvisioningRuntime"), dirty)
            factory.validate_type(obj._pre_provisioning_status[0], "PreProvisioningRuntime")
        else:
            obj._pre_provisioning_status = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "log_sync_active" == "type" or (self.log_sync_active is not self.__undef__ and not (dirty and not self._log_sync_active[1])):
            dct["logSyncActive"] = dictify(self.log_sync_active)
        if "pre_provisioning_status" == "type" or (self.pre_provisioning_status is not self.__undef__ and not (dirty and not self._pre_provisioning_status[1])):
            dct["preProvisioningStatus"] = dictify(self.pre_provisioning_status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._log_sync_active = (self._log_sync_active[0], True)
        self._pre_provisioning_status = (self._pre_provisioning_status[0], True)

    def is_dirty(self):
        return any([self._log_sync_active[1], self._pre_provisioning_status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DBContainerRuntime):
            return False
        return super(DBContainerRuntime, self).__eq__(other) and \
               self.log_sync_active == other.log_sync_active and \
               self.pre_provisioning_status == other.pre_provisioning_status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def log_sync_active(self):
        """
        True if the LogSync is enabled and running for this container.

        :rtype: ``bool``
        """
        return self._log_sync_active[0]

    @log_sync_active.setter
    def log_sync_active(self, value):
        self._log_sync_active = (value, True)

    @property
    def pre_provisioning_status(self):
        """
        The pre-provisioning runtime for the container.

        :rtype: :py:class:`v1_3_0.web.vo.PreProvisioningRuntime`
        """
        return self._pre_provisioning_status[0]

    @pre_provisioning_status.setter
    def pre_provisioning_status(self, value):
        self._pre_provisioning_status = (value, True)

class JDBCConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Mechanism to test JDBC
    connectivity of arbitrary databases.
    """
    def __init__(self, undef_enabled=True):
        super(JDBCConnectivity, self).__init__()
        self._type = ("JDBCConnectivity", True)
        self._url = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JDBCConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "url" not in data:
            raise ValueError("Missing required property \"url\".")
        obj._url = (data.get("url", obj.__undef__), dirty)
        if obj._url[0] is not None and obj._url[0] is not obj.__undef__:
            assert isinstance(obj._url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._url[0]))
            common.validate_format(obj._url[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "None", None, None)
        if "user" not in data:
            raise ValueError("Missing required property \"user\".")
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JDBCConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "url" == "type" or (self.url is not self.__undef__ and not (dirty and not self._url[1])):
            dct["url"] = dictify(self.url)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._url = (self._url[0], True)
        self._password = (self._password[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._url[1], self._password[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JDBCConnectivity):
            return False
        return super(JDBCConnectivity, self).__eq__(other) and \
               self.url == other.url and \
               self.password == other.password and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def url(self):
        """
        JDBC connection URL.

        :rtype: ``basestring``
        """
        return self._url[0]

    @url.setter
    def url(self, value):
        self._url = (value, True)

    @property
    def password(self):
        """
        Database password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def user(self):
        """
        Database username.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class DatapointStream(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A stream of datapoints
    from a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DatapointStream, self).__init__()
        self._type = ("DatapointStream", True)
        self._datapoints = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._datapoints = []
        for item in data.get("datapoints") or []:
            obj._datapoints.append(factory.create_object(item))
            factory.validate_type(obj._datapoints[-1], "Datapoint")
        obj._datapoints = (obj._datapoints, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "datapoints" == "type" or (self.datapoints is not self.__undef__ and not (dirty and not self._datapoints[1])):
            dct["datapoints"] = dictify(self.datapoints)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._datapoints = (self._datapoints[0], True)

    def is_dirty(self):
        return any([self._datapoints[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatapointStream):
            return False
        return super(DatapointStream, self).__eq__(other) and \
               self.datapoints == other.datapoints

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def datapoints(self):
        """
        The set of datapoints in the stream.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Datapoint`
        """
        return self._datapoints[0]

    @datapoints.setter
    def datapoints(self, value):
        self._datapoints = (value, True)

class APISession(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Describes a delphix
    web service session and is the result of an initial handshake.
    """
    def __init__(self, undef_enabled=True):
        super(APISession, self).__init__()
        self._type = ("APISession", True)
        self._locale = (self.__undef__, True)
        self._client = (self.__undef__, True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APISession, cls).from_dict(data, dirty, undef_enabled)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            common.validate_format(obj._locale[0], "None", None, None)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "None", None, 64)
        if "version" not in data:
            raise ValueError("Missing required property \"version\".")
        if "version" in data and data["version"] is not None:
            obj._version = (factory.create_object(data["version"], "APIVersion"), dirty)
            factory.validate_type(obj._version[0], "APIVersion")
        else:
            obj._version = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APISession, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._locale = (self._locale[0], True)
        self._client = (self._client[0], True)
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._locale[1], self._client[1], self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APISession):
            return False
        return super(APISession, self).__eq__(other) and \
               self.locale == other.locale and \
               self.client == other.client and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def locale(self):
        """
        Locale in the format of an ISO639 language code followed by an ISO3166
        country code, for example 'en_US'. Defaults to 'en_US'.

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

    @property
    def client(self):
        """
        Client software identification token.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def version(self):
        """
        Version of the API to use.

        :rtype: :py:class:`v1_3_0.web.vo.APIVersion`
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class ConnectorConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Mechanism to test
    Connector connectivity of arbitrary hosts.
    """
    def __init__(self, undef_enabled=True):
        super(ConnectorConnectivity, self).__init__()
        self._type = ("ConnectorConnectivity", True)
        self._username = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._proxy = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ConnectorConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credentials" not in data:
            raise ValueError("Missing required property \"credentials\".")
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._proxy = (data.get("proxy", obj.__undef__), dirty)
        if obj._proxy[0] is not None and obj._proxy[0] is not obj.__undef__:
            assert isinstance(obj._proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._proxy[0]))
            common.validate_format(obj._proxy[0], "objectReference", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ConnectorConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "proxy" == "type" or (self.proxy is not self.__undef__ and not (dirty and not self._proxy[1])):
            dct["proxy"] = dictify(self.proxy)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credentials = (self._credentials[0], True)
        self._address = (self._address[0], True)
        self._proxy = (self._proxy[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credentials[1], self._address[1], self._proxy[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ConnectorConnectivity):
            return False
        return super(ConnectorConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.credentials == other.credentials and \
               self.address == other.address and \
               self.proxy == other.proxy and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        User name.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credentials(self):
        """
        User credentials.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def address(self):
        """
        Target host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def proxy(self):
        """
        Host to use as a proxy for credential validation.

        :rtype: ``basestring``
        """
        return self._proxy[0]

    @proxy.setter
    def proxy(self, value):
        self._proxy = (value, True)

    @property
    def port(self):
        """
        *(default value: 9100)* Connector port on remote server.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class SourceStopParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to stop MSSQL sources.
    """
    def __init__(self, undef_enabled=True):
        super(SourceStopParameters, self).__init__()
        self._type = ("SourceStopParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceStopParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceStopParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceStopParameters):
            return False
        return super(SourceStopParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLDBConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Configuration
    information for a PostgreSQL database in a cluster.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBConfig, self).__init__()
        self._type = ("PgSQLDBConfig", True)
        self._database_cluster = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._database_cluster = (data.get("databaseCluster", obj.__undef__), dirty)
        if obj._database_cluster[0] is not None and obj._database_cluster[0] is not obj.__undef__:
            assert isinstance(obj._database_cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_cluster[0]))
            common.validate_format(obj._database_cluster[0], "objectReference", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 63)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_cluster" == "type" or (self.database_cluster is not self.__undef__ and not (dirty and not self._database_cluster[1])):
            dct["databaseCluster"] = dictify(self.database_cluster)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_cluster = (self._database_cluster[0], True)
        self._credentials = (self._credentials[0], True)
        self._user = (self._user[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._database_cluster[1], self._credentials[1], self._user[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBConfig):
            return False
        return super(PgSQLDBConfig, self).__eq__(other) and \
               self.database_cluster == other.database_cluster and \
               self.credentials == other.credentials and \
               self.user == other.user and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_cluster(self):
        """
        The PostgreSQL cluster this database is part of.

        :rtype: ``basestring``
        """
        return self._database_cluster[0]

    @database_cluster.setter
    def database_cluster(self, value):
        self._database_cluster = (value, True)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class ValidateSMTPParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Validate SMTP
    configuration without committing it by sending mail to the specified
    address(es).
    """
    def __init__(self, undef_enabled=True):
        super(ValidateSMTPParameters, self).__init__()
        self._type = ("ValidateSMTPParameters", True)
        self._config = (self.__undef__, True)
        self._addresses = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ValidateSMTPParameters, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        if "config" in data and data["config"] is not None:
            obj._config = (factory.create_object(data["config"], "SMTPConfig"), dirty)
            factory.validate_type(obj._config[0], "SMTPConfig")
        else:
            obj._config = (obj.__undef__, dirty)
        if "addresses" not in data:
            raise ValueError("Missing required property \"addresses\".")
        obj._addresses = []
        for item in data.get("addresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._addresses.append(item)
        obj._addresses = (obj._addresses, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ValidateSMTPParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)
        self._addresses = (self._addresses[0], True)

    def is_dirty(self):
        return any([self._config[1], self._addresses[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ValidateSMTPParameters):
            return False
        return super(ValidateSMTPParameters, self).__eq__(other) and \
               self.config == other.config and \
               self.addresses == other.addresses

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        SMTP configuration to use for validation.

        :rtype: :py:class:`v1_3_0.web.vo.SMTPConfig`
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def addresses(self):
        """
        List of email addresses to send test email to.

        :rtype: ``list`` of ``basestring``
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

class SingletonUpdate(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An event indicating an
    update to a singleton object on the system.
    """
    def __init__(self, undef_enabled=True):
        super(SingletonUpdate, self).__init__()
        self._type = ("SingletonUpdate", True)
        self._object_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SingletonUpdate, cls).from_dict(data, dirty, undef_enabled)
        obj._object_type = (data.get("objectType", obj.__undef__), dirty)
        if obj._object_type[0] is not None and obj._object_type[0] is not obj.__undef__:
            assert isinstance(obj._object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object_type[0]))
            common.validate_format(obj._object_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SingletonUpdate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_type" == "type" or (self.object_type is not self.__undef__ and not (dirty and not self._object_type[1])):
            dct["objectType"] = dictify(self.object_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_type = (self._object_type[0], True)

    def is_dirty(self):
        return any([self._object_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SingletonUpdate):
            return False
        return super(SingletonUpdate, self).__eq__(other) and \
               self.object_type == other.object_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_type(self):
        """
        Type of target object.

        :rtype: ``basestring``
        """
        return self._object_type[0]

    @object_type.setter
    def object_type(self, value):
        self._object_type = (value, True)

class DNSConfig(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* DNS Client
    Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(DNSConfig, self).__init__()
        self._type = ("DNSConfig", True)
        self._domain = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DNSConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._domain = (data.get("domain", obj.__undef__), dirty)
        if obj._domain[0] is not None and obj._domain[0] is not obj.__undef__:
            assert isinstance(obj._domain[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._domain[0]))
            common.validate_format(obj._domain[0], "None", None, None)
        obj._servers = []
        for item in data.get("servers") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "ipAddress", None, None)
            obj._servers.append(item)
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DNSConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "domain" == "type" or (self.domain is not self.__undef__ and not (dirty and not self._domain[1])):
            dct["domain"] = dictify(self.domain)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._domain = (self._domain[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._domain[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DNSConfig):
            return False
        return super(DNSConfig, self).__eq__(other) and \
               self.domain == other.domain and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def domain(self):
        """
        DNS domain name.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._domain[0]

    @domain.setter
    def domain(self, value):
        self._domain = (value, True)

    @property
    def servers(self):
        """
        List of DNS servers.

        :rtype: ``list`` of ``basestring``
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class LinkParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Represents the
    parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(LinkParameters, self).__init__()
        self._type = ("LinkParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LinkParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "Source"), dirty)
            factory.validate_type(obj._source[0], "Source")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "Container"), dirty)
            factory.validate_type(obj._container[0], "Container")
        else:
            obj._container = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LinkParameters):
            return False
        return super(LinkParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.Source`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        Container to create as part of the linking process.

        :rtype: :py:class:`v1_3_0.web.vo.Container`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class ObjectNotification(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An event indicating a
    change to an object on the system.
    """
    def __init__(self, undef_enabled=True):
        super(ObjectNotification, self).__init__()
        self._type = ("ObjectNotification", True)
        self._event_type = (self.__undef__, True)
        self._object = (self.__undef__, True)
        self._object_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ObjectNotification, cls).from_dict(data, dirty, undef_enabled)
        obj._event_type = (data.get("eventType", obj.__undef__), dirty)
        if obj._event_type[0] is not None and obj._event_type[0] is not obj.__undef__:
            assert isinstance(obj._event_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_type[0]))
            assert obj._event_type[0] in [u'CREATE', u'UPDATE', u'DELETE'], "Expected enum [u'CREATE', u'UPDATE', u'DELETE'] but got %s" % obj._event_type[0]
            common.validate_format(obj._event_type[0], "None", None, None)
        obj._object = (data.get("object", obj.__undef__), dirty)
        if obj._object[0] is not None and obj._object[0] is not obj.__undef__:
            assert isinstance(obj._object[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object[0]))
            common.validate_format(obj._object[0], "objectReference", None, None)
        obj._object_type = (data.get("objectType", obj.__undef__), dirty)
        if obj._object_type[0] is not None and obj._object_type[0] is not obj.__undef__:
            assert isinstance(obj._object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object_type[0]))
            common.validate_format(obj._object_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ObjectNotification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_type" == "type" or (self.event_type is not self.__undef__ and not (dirty and not self._event_type[1])):
            dct["eventType"] = dictify(self.event_type)
        if "object" == "type" or (self.object is not self.__undef__ and not (dirty and not self._object[1])):
            dct["object"] = dictify(self.object)
        if "object_type" == "type" or (self.object_type is not self.__undef__ and not (dirty and not self._object_type[1])):
            dct["objectType"] = dictify(self.object_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_type = (self._event_type[0], True)
        self._object = (self._object[0], True)
        self._object_type = (self._object_type[0], True)

    def is_dirty(self):
        return any([self._event_type[1], self._object[1], self._object_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ObjectNotification):
            return False
        return super(ObjectNotification, self).__eq__(other) and \
               self.event_type == other.event_type and \
               self.object == other.object and \
               self.object_type == other.object_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_type(self):
        """
        Type of operation on the object. *(permitted values: CREATE, UPDATE,
        DELETE)*

        :rtype: ``basestring``
        """
        return self._event_type[0]

    @event_type.setter
    def event_type(self, value):
        self._event_type = (value, True)

    @property
    def object(self):
        """
        Target object reference.

        :rtype: ``basestring``
        """
        return self._object[0]

    @object.setter
    def object(self, value):
        self._object = (value, True)

    @property
    def object_type(self):
        """
        Type of target object.

        :rtype: ``basestring``
        """
        return self._object_type[0]

    @object_type.setter
    def object_type(self, value):
        self._object_type = (value, True)

class SourceUpgradeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to upgrade a source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceUpgradeParameters, self).__init__()
        self._type = ("SourceUpgradeParameters", True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceUpgradeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceUpgradeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceUpgradeParameters):
            return False
        return super(SourceUpgradeParameters, self).__eq__(other) and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config that the source database upgrades to.

        :rtype: :py:class:`v1_3_0.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class TimeflowPoint(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Timeflow points
    represent a unique point within a timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPoint, self).__init__()
        self._type = ("TimeflowPoint", True)
        self._timestamp = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._timeflow[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPoint):
            return False
        return super(TimeflowPoint, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.timeflow == other.timeflow and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the timeflow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def timeflow(self):
        """
        Reference to timeflow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def location(self):
        """
        The timeflow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

class DVCBookmarkCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters used to
    create a DVC bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(DVCBookmarkCreateParameters, self).__init__()
        self._type = ("DVCBookmarkCreateParameters", True)
        self._bookmark = (self.__undef__, True)
        self._timeline_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCBookmarkCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" in data and data["bookmark"] is not None:
            obj._bookmark = (factory.create_object(data["bookmark"], "DVCBookmark"), dirty)
            factory.validate_type(obj._bookmark[0], "DVCBookmark")
        else:
            obj._bookmark = (obj.__undef__, dirty)
        if "timelinePointParameters" not in data:
            raise ValueError("Missing required property \"timelinePointParameters\".")
        if "timelinePointParameters" in data and data["timelinePointParameters"] is not None:
            obj._timeline_point_parameters = (factory.create_object(data["timelinePointParameters"], "DVCTimelinePointTimeParameters"), dirty)
            factory.validate_type(obj._timeline_point_parameters[0], "DVCTimelinePointTimeParameters")
        else:
            obj._timeline_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCBookmarkCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "timeline_point_parameters" == "type" or (self.timeline_point_parameters is not self.__undef__ and not (dirty and not self._timeline_point_parameters[1])):
            dct["timelinePointParameters"] = dictify(self.timeline_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._timeline_point_parameters = (self._timeline_point_parameters[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._timeline_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCBookmarkCreateParameters):
            return False
        return super(DVCBookmarkCreateParameters, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.timeline_point_parameters == other.timeline_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The DVC bookmark object.

        :rtype: :py:class:`v1_3_0.web.vo.DVCBookmark`
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def timeline_point_parameters(self):
        """
        The DVC data timeline point at which the bookmark will be created.

        :rtype: :py:class:`v1_3_0.web.vo.DVCTimelinePointTimeParameters`
        """
        return self._timeline_point_parameters[0]

    @timeline_point_parameters.setter
    def timeline_point_parameters(self, value):
        self._timeline_point_parameters = (value, True)

class CredentialUpdateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters to update a
    Delphix user's password
    """
    def __init__(self, undef_enabled=True):
        super(CredentialUpdateParameters, self).__init__()
        self._type = ("CredentialUpdateParameters", True)
        self._new_credential = (self.__undef__, True)
        self._old_credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CredentialUpdateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "newCredential" in data and data["newCredential"] is not None:
            obj._new_credential = (factory.create_object(data["newCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._new_credential[0], "PasswordCredential")
        else:
            obj._new_credential = (obj.__undef__, dirty)
        if "oldCredential" in data and data["oldCredential"] is not None:
            obj._old_credential = (factory.create_object(data["oldCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._old_credential[0], "PasswordCredential")
        else:
            obj._old_credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CredentialUpdateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "new_credential" == "type" or (self.new_credential is not self.__undef__ and not (dirty and not self._new_credential[1])):
            dct["newCredential"] = dictify(self.new_credential)
        if "old_credential" == "type" or (self.old_credential is not self.__undef__ and not (dirty and not self._old_credential[1])):
            dct["oldCredential"] = dictify(self.old_credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._new_credential = (self._new_credential[0], True)
        self._old_credential = (self._old_credential[0], True)

    def is_dirty(self):
        return any([self._new_credential[1], self._old_credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CredentialUpdateParameters):
            return False
        return super(CredentialUpdateParameters, self).__eq__(other) and \
               self.new_credential == other.new_credential and \
               self.old_credential == other.old_credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def new_credential(self):
        """
        New credentials

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._new_credential[0]

    @new_credential.setter
    def new_credential(self, value):
        self._new_credential = (value, True)

    @property
    def old_credential(self):
        """
        Old credentials

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._old_credential[0]

    @old_credential.setter
    def old_credential(self, value):
        self._old_credential = (value, True)

class SwitchTimeflowParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The input parameters
    used for the TimeFlow switch operation.
    """
    def __init__(self, undef_enabled=True):
        super(SwitchTimeflowParameters, self).__init__()
        self._type = ("SwitchTimeflowParameters", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SwitchTimeflowParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SwitchTimeflowParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SwitchTimeflowParameters):
            return False
        return super(SwitchTimeflowParameters, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        The reference to the target TimeFlow that should be made the current
        TimeFlow.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class DynamicParameterValue(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A settable value for a
    dynamic parameter. Each value object has an associated DynamicParameter
    definition that defines acceptable inputs.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicParameterValue, self).__init__()
        self._type = ("DynamicParameterValue", True)
        self._definition = (self.__undef__, True)
        self._value = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicParameterValue, cls).from_dict(data, dirty, undef_enabled)
        if "definition" not in data:
            raise ValueError("Missing required property \"definition\".")
        if "definition" in data and data["definition"] is not None:
            obj._definition = (factory.create_object(data["definition"], "DynamicParameter"), dirty)
            factory.validate_type(obj._definition[0], "DynamicParameter")
        else:
            obj._definition = (obj.__undef__, dirty)
        if "value" not in data:
            raise ValueError("Missing required property \"value\".")
        obj._value = (data.get("value", obj.__undef__), dirty)
        if obj._value[0] is not None and obj._value[0] is not obj.__undef__:
            assert isinstance(obj._value[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._value[0]))
            common.validate_format(obj._value[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicParameterValue, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "definition" == "type" or (self.definition is not self.__undef__ and not (dirty and not self._definition[1])):
            dct["definition"] = dictify(self.definition)
        if "value" == "type" or (self.value is not self.__undef__ and not (dirty and not self._value[1])):
            dct["value"] = dictify(self.value)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._definition = (self._definition[0], True)
        self._value = (self._value[0], True)

    def is_dirty(self):
        return any([self._definition[1], self._value[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicParameterValue):
            return False
        return super(DynamicParameterValue, self).__eq__(other) and \
               self.definition == other.definition and \
               self.value == other.value

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def definition(self):
        """
        The contraints this value will be validated against.

        :rtype: :py:class:`v1_3_0.web.vo.DynamicParameter`
        """
        return self._definition[0]

    @definition.setter
    def definition(self, value):
        self._definition = (value, True)

    @property
    def value(self):
        """
        The value. This must be valid according to the associated definition.

        :rtype: ``basestring``
        """
        return self._value[0]

    @value.setter
    def value(self, value):
        self._value = (value, True)

class PolicyApplyTargetParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Specifices the target
    to which a policy is applied.
    """
    def __init__(self, undef_enabled=True):
        super(PolicyApplyTargetParameters, self).__init__()
        self._type = ("PolicyApplyTargetParameters", True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PolicyApplyTargetParameters, cls).from_dict(data, dirty, undef_enabled)
        if "target" not in data:
            raise ValueError("Missing required property \"target\".")
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PolicyApplyTargetParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PolicyApplyTargetParameters):
            return False
        return super(PolicyApplyTargetParameters, self).__eq__(other) and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target(self):
        """
        Object reference of the target

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class DVCBookmarkTag(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* A user-defined label
    for a DVC bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(DVCBookmarkTag, self).__init__()
        self._type = ("DVCBookmarkTag", True)
        self._tag = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCBookmarkTag, cls).from_dict(data, dirty, undef_enabled)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCBookmarkTag, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._tag = (self._tag[0], True)

    def is_dirty(self):
        return any([self._tag[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCBookmarkTag):
            return False
        return super(DVCBookmarkTag, self).__eq__(other) and \
               self.tag == other.tag

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def tag(self):
        """
        The user-defined label.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

class FileMappingResult(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Result of a file
    mapping request.
    """
    def __init__(self, undef_enabled=True):
        super(FileMappingResult, self).__init__()
        self._type = ("FileMappingResult", True)
        self._mapped_files = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileMappingResult, cls).from_dict(data, dirty, undef_enabled)
        obj._mapped_files = (data.get("mappedFiles", obj.__undef__), dirty)
        if obj._mapped_files[0] is not None and obj._mapped_files[0] is not obj.__undef__:
            assert isinstance(obj._mapped_files[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._mapped_files[0]))
            common.validate_format(obj._mapped_files[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileMappingResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mapped_files" == "type" or (self.mapped_files is not self.__undef__ and not (dirty and not self._mapped_files[1])):
            dct["mappedFiles"] = dictify(self.mapped_files)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mapped_files = (self._mapped_files[0], True)

    def is_dirty(self):
        return any([self._mapped_files[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileMappingResult):
            return False
        return super(FileMappingResult, self).__eq__(other) and \
               self.mapped_files == other.mapped_files

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mapped_files(self):
        """
        Mapped files.

        :rtype: ``dict``
        """
        return self._mapped_files[0]

    @mapped_files.setter
    def mapped_files(self, value):
        self._mapped_files = (value, True)

class DVCSourceDataTimestampParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Input parameters for
    the API that given a point in time, returns the timestamps of the latest
    provisionable points, before the specified time, for each data source in
    the given application.
    """
    def __init__(self, undef_enabled=True):
        super(DVCSourceDataTimestampParameters, self).__init__()
        self._type = ("DVCSourceDataTimestampParameters", True)
        self._application = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCSourceDataTimestampParameters, cls).from_dict(data, dirty, undef_enabled)
        if "application" not in data:
            raise ValueError("Missing required property \"application\".")
        obj._application = (data.get("application", obj.__undef__), dirty)
        if obj._application[0] is not None and obj._application[0] is not obj.__undef__:
            assert isinstance(obj._application[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application[0]))
            common.validate_format(obj._application[0], "objectReference", None, None)
        if "time" not in data:
            raise ValueError("Missing required property \"time\".")
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCSourceDataTimestampParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "application" == "type" or (self.application is not self.__undef__ and not (dirty and not self._application[1])):
            dct["application"] = dictify(self.application)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._application = (self._application[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._application[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCSourceDataTimestampParameters):
            return False
        return super(DVCSourceDataTimestampParameters, self).__eq__(other) and \
               self.application == other.application and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def application(self):
        """
        A reference to the DVC application.

        :rtype: ``basestring``
        """
        return self._application[0]

    @application.setter
    def application(self, value):
        self._application = (value, True)

    @property
    def time(self):
        """
        The time that will be used to find provisionable timestamps for the
        sources in the application.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class SupportBundleUploadParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* Parameters to be used
    when uploading a support bundle.
    """
    def __init__(self, undef_enabled=True):
        super(SupportBundleUploadParameters, self).__init__()
        self._type = ("SupportBundleUploadParameters", True)
        self._case_number = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SupportBundleUploadParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._case_number = (data.get("caseNumber", obj.__undef__), dirty)
        if obj._case_number[0] is not None and obj._case_number[0] is not obj.__undef__:
            assert isinstance(obj._case_number[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._case_number[0]))
            common.validate_format(obj._case_number[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SupportBundleUploadParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "case_number" == "type" or (self.case_number is not self.__undef__ and not (dirty and not self._case_number[1])):
            dct["caseNumber"] = dictify(self.case_number)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._case_number = (self._case_number[0], True)

    def is_dirty(self):
        return any([self._case_number[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SupportBundleUploadParameters):
            return False
        return super(SupportBundleUploadParameters, self).__eq__(other) and \
               self.case_number == other.case_number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def case_number(self):
        """
        The Delphix support case number.

        :rtype: ``int``
        """
        return self._case_number[0]

    @case_number.setter
    def case_number(self, value):
        self._case_number = (value, True)

class SourceEnableParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as input to enable MSSQL or AppData sources.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnableParameters, self).__init__()
        self._type = ("SourceEnableParameters", True)
        self._attempt_start = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._attempt_start = (data.get("attemptStart", obj.__undef__), dirty)
        if obj._attempt_start[0] is not None and obj._attempt_start[0] is not obj.__undef__:
            assert isinstance(obj._attempt_start[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._attempt_start[0]))
            common.validate_format(obj._attempt_start[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "attempt_start" == "type" or (self.attempt_start is not self.__undef__ and not (dirty and not self._attempt_start[1])):
            dct["attemptStart"] = dictify(self.attempt_start)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._attempt_start = (self._attempt_start[0], True)

    def is_dirty(self):
        return any([self._attempt_start[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnableParameters):
            return False
        return super(SourceEnableParameters, self).__eq__(other) and \
               self.attempt_start == other.attempt_start

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def attempt_start(self):
        """
        *(default value: True)* Whether to attempt a startup of the source
        after the enable.

        :rtype: ``bool``
        """
        return self._attempt_start[0]

    @attempt_start.setter
    def attempt_start(self, value):
        self._attempt_start = (value, True)

class AlertAction(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* An action taken in
    response to an alert being generated.  These are aggregated into
    $AlertProfile objects that filter and direct alerts for each user.  This is
    an abstract object type and cannot be directly instantiated.
    """
    def __init__(self, undef_enabled=True):
        super(AlertAction, self).__init__()
        self._type = ("AlertAction", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertAction, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertAction, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertAction):
            return False
        return super(AlertAction, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class RollbackParameters(TypedObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TypedObject` *)* The parameters to use
    as inputs for rollback requests.
    """
    def __init__(self, undef_enabled=True):
        super(RollbackParameters, self).__init__()
        self._type = ("RollbackParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RollbackParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RollbackParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RollbackParameters):
            return False
        return super(RollbackParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark or semantic location to roll the database
        back to.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class OracleRollbackParameters(RollbackParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.RollbackParameters` *)* The parameters
    to use as input to roll back Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRollbackParameters, self).__init__()
        self._type = ("OracleRollbackParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRollbackParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRollbackParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRollbackParameters):
            return False
        return super(OracleRollbackParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the user who has the required privileges to perform the
        rollback operation.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the user who has the required privileges to
        run the rollback operation.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class AlertActionEmail(AlertAction):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AlertAction` *)* An alert action that
    generates email in some form.  This is an abstract type and cannot be
    instantiated directly.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmail, self).__init__()
        self._type = ("AlertActionEmail", True)
        self._format = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmail, cls).from_dict(data, dirty, undef_enabled)
        obj._format = (data.get("format", obj.__undef__), dirty)
        if obj._format[0] is not None and obj._format[0] is not obj.__undef__:
            assert isinstance(obj._format[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._format[0]))
            assert obj._format[0] in [u'HTML', u'TEXT', u'JSON'], "Expected enum [u'HTML', u'TEXT', u'JSON'] but got %s" % obj._format[0]
            common.validate_format(obj._format[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmail, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "format" == "type" or (self.format is not self.__undef__ and not (dirty and not self._format[1])):
            dct["format"] = dictify(self.format)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._format = (self._format[0], True)

    def is_dirty(self):
        return any([self._format[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmail):
            return False
        return super(AlertActionEmail, self).__eq__(other) and \
               self.format == other.format

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def format(self):
        """
        *(default value: HTML)* Email format to use.  The HTML format will
        generate a multipart message containing both HTML and plain text.  The
        TEXT format will explicitly generate text-only mail.  The JSON format
        will generate a JSON object identical to the $Alert format returned
        through the web services API. *(permitted values: HTML, TEXT, JSON)*

        :rtype: ``basestring``
        """
        return self._format[0]

    @format.setter
    def format(self, value):
        self._format = (value, True)

class AlertActionEmailList(AlertActionEmail):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AlertActionEmail` *)* Alert action to
    email a list of users in response to an alert.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmailList, self).__init__()
        self._type = ("AlertActionEmailList", True)
        self._addresses = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmailList, cls).from_dict(data, dirty, undef_enabled)
        if "addresses" not in data:
            raise ValueError("Missing required property \"addresses\".")
        obj._addresses = []
        for item in data.get("addresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._addresses.append(item)
        obj._addresses = (obj._addresses, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmailList, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._addresses = (self._addresses[0], True)

    def is_dirty(self):
        return any([self._addresses[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmailList):
            return False
        return super(AlertActionEmailList, self).__eq__(other) and \
               self.addresses == other.addresses

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def addresses(self):
        """
        List of email addresses to send mail to.

        :rtype: ``list`` of ``basestring``
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

class AlertActionEmailUser(AlertActionEmail):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AlertActionEmail` *)* Alert action that
    sends email to the email address associated with the user.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmailUser, self).__init__()
        self._type = ("AlertActionEmailUser", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmailUser, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmailUser, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmailUser):
            return False
        return super(AlertActionEmailUser, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleEnableParameters(SourceEnableParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceEnableParameters` *)* The
    parameters to use as input to enable Oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleEnableParameters, self).__init__()
        self._type = ("OracleEnableParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleEnableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleEnableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleEnableParameters):
            return False
        return super(OracleEnableParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class OracleTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPoint` *)* A unique point
    within an Oracle database timeflow
    """
    def __init__(self, undef_enabled=True):
        super(OracleTimeflowPoint, self).__init__()
        self._type = ("OracleTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTimeflowPoint):
            return False
        return super(OracleTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to timeflow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class PgSQLTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPoint` *)* A unique point
    within a PostgreSQL database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLTimeflowPoint, self).__init__()
        self._type = ("PgSQLTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLTimeflowPoint):
            return False
        return super(PgSQLTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class AppDataTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPoint` *)* A unique point
    within an AppData TimeFlow
    """
    def __init__(self, undef_enabled=True):
        super(AppDataTimeflowPoint, self).__init__()
        self._type = ("AppDataTimeflowPoint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataTimeflowPoint):
            return False
        return super(AppDataTimeflowPoint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPoint` *)* A unique point
    within an MSSql database timeflow
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlTimeflowPoint, self).__init__()
        self._type = ("MSSqlTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlTimeflowPoint):
            return False
        return super(MSSqlTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to timeflow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class MSSqlLinkedSourceUpgradeParameters(SourceUpgradeParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceUpgradeParameters` *)* The
    parameters to use as input to upgrade an MSSQL linked source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkedSourceUpgradeParameters, self).__init__()
        self._type = ("MSSqlLinkedSourceUpgradeParameters", True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkedSourceUpgradeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkedSourceUpgradeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkedSourceUpgradeParameters):
            return False
        return super(MSSqlLinkedSourceUpgradeParameters, self).__eq__(other) and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ppt_repository(self):
        """
        The SQL instance on the PPT environment that we want to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class MSSqlLinkParameters(LinkParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.LinkParameters` *)* MSSQL specific
    parameters for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkParameters, self).__init__()
        self._type = ("MSSqlLinkParameters", True)
        self._ppt_host_user = (self.__undef__, True)
        self._backup_uuid = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        obj._backup_uuid = (data.get("backupUUID", obj.__undef__), dirty)
        if obj._backup_uuid[0] is not None and obj._backup_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_uuid[0]))
            common.validate_format(obj._backup_uuid[0], "None", None, None)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MSSqlDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MSSqlDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "MSSqlLinkedSource"), dirty)
            factory.validate_type(obj._source[0], "MSSqlLinkedSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "backup_uuid" == "type" or (self.backup_uuid is not self.__undef__ and not (dirty and not self._backup_uuid[1])):
            dct["backupUUID"] = dictify(self.backup_uuid)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._backup_uuid = (self._backup_uuid[0], True)
        self._container = (self._container[0], True)
        self._source = (self._source[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._ppt_host_user[1], self._backup_uuid[1], self._container[1], self._source[1], self._staging_post_script[1], self._db_user[1], self._db_credentials[1], self._source_host_user[1], self._staging_pre_script[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkParameters):
            return False
        return super(MSSqlLinkParameters, self).__eq__(other) and \
               self.ppt_host_user == other.ppt_host_user and \
               self.backup_uuid == other.backup_uuid and \
               self.container == other.container and \
               self.source == other.source and \
               self.staging_post_script == other.staging_post_script and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials and \
               self.source_host_user == other.source_host_user and \
               self.staging_pre_script == other.staging_pre_script and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ppt_host_user(self):
        """
        Information about the host OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def backup_uuid(self):
        """
        The UUID of the full or differential backup of the source database to
        restore from for the first dSource snapshot. The backup should be
        present in the shared backup location for the source database. This
        property is relevant only when loading from an existing backup.

        :rtype: ``basestring``
        """
        return self._backup_uuid[0]

    @backup_uuid.setter
    def backup_uuid(self, value):
        self._backup_uuid = (value, True)

    @property
    def container(self):
        """
        Container to create as part of the linking process.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlLinkedSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def staging_post_script(self):
        """
        A user-provided powershell script or executable to run after restoring
        from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def db_user(self):
        """
        The user name for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def source_host_user(self):
        """
        Information about the host OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def staging_pre_script(self):
        """
        A user-provided powershell script or executable to run prior to
        restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def ppt_repository(self):
        """
        The SQL instance on the PPT environment that we want to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class AppDataLinkParameters(LinkParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.LinkParameters` *)* Represents the
    AppData specific parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkParameters, self).__init__()
        self._type = ("AppDataLinkParameters", True)
        self._source = (self.__undef__, True)
        self._follow_symlinks = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._excludes = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "AppDataSource"), dirty)
            factory.validate_type(obj._source[0], "AppDataSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._follow_symlinks = []
        for item in data.get("followSymlinks") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._follow_symlinks.append(item)
        obj._follow_symlinks = (obj._follow_symlinks, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._excludes = []
        for item in data.get("excludes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._excludes.append(item)
        obj._excludes = (obj._excludes, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "follow_symlinks" == "type" or (self.follow_symlinks is not self.__undef__ and not (dirty and not self._follow_symlinks[1])):
            dct["followSymlinks"] = dictify(self.follow_symlinks)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "excludes" == "type" or (self.excludes is not self.__undef__ and not (dirty and not self._excludes[1])):
            dct["excludes"] = dictify(self.excludes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._follow_symlinks = (self._follow_symlinks[0], True)
        self._container = (self._container[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._excludes = (self._excludes[0], True)

    def is_dirty(self):
        return any([self._source[1], self._follow_symlinks[1], self._container[1], self._environment_user[1], self._excludes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkParameters):
            return False
        return super(AppDataLinkParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.follow_symlinks == other.follow_symlinks and \
               self.container == other.container and \
               self.environment_user == other.environment_user and \
               self.excludes == other.excludes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def follow_symlinks(self):
        """
        List of symlinks in the source to follow when running rsync. These
        paths are relative to the root of the source directory. All other
        symlinks are preserved.

        :rtype: ``list`` of ``basestring``
        """
        return self._follow_symlinks[0]

    @follow_symlinks.setter
    def follow_symlinks(self, value):
        self._follow_symlinks = (value, True)

    @property
    def container(self):
        """
        Container to create as part of the linking process.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def environment_user(self):
        """
        The OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def excludes(self):
        """
        List of subdirectories in the source to exclude when running rsync.
        These paths are relative to the root of the source directory.

        :rtype: ``list`` of ``basestring``
        """
        return self._excludes[0]

    @excludes.setter
    def excludes(self, value):
        self._excludes = (value, True)

class PgSQLLinkParameters(LinkParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.LinkParameters` *)* PostgreSQL specific
    parameters for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLLinkParameters, self).__init__()
        self._type = ("PgSQLLinkParameters", True)
        self._ppt_host_user = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLLinkParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "PgSQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "PgSQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "PgSQLLinkedSource"), dirty)
            factory.validate_type(obj._source[0], "PgSQLLinkedSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLLinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._container = (self._container[0], True)
        self._source = (self._source[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._ppt_host_user[1], self._container[1], self._source[1], self._connection_database[1], self._db_user[1], self._db_credentials[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLLinkParameters):
            return False
        return super(PgSQLLinkParameters, self).__eq__(other) and \
               self.ppt_host_user == other.ppt_host_user and \
               self.container == other.container and \
               self.source == other.source and \
               self.connection_database == other.connection_database and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ppt_host_user(self):
        """
        Information about the host OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def container(self):
        """
        Container to create as part of the linking process.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLLinkedSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def connection_database(self):
        """
        *(default value: postgres)* The database that must be used to run SQL
        queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def db_user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credential of the database cluster user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def ppt_repository(self):
        """
        The Postgres installation on the PPT environment that will be used for
        pre-provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class OracleLinkParameters(LinkParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.LinkParameters` *)* Represents the
    Oracle specific parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLinkParameters, self).__init__()
        self._type = ("OracleLinkParameters", True)
        self._container = (self.__undef__, True)
        self._non_sys_credentials = (self.__undef__, True)
        self._link_now = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._non_sys_user = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLinkParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "OracleDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "OracleDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "nonSysCredentials" in data and data["nonSysCredentials"] is not None:
            obj._non_sys_credentials = (factory.create_object(data["nonSysCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._non_sys_credentials[0], "PasswordCredential")
        else:
            obj._non_sys_credentials = (obj.__undef__, dirty)
        obj._link_now = (data.get("linkNow", obj.__undef__), dirty)
        if obj._link_now[0] is not None and obj._link_now[0] is not obj.__undef__:
            assert isinstance(obj._link_now[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._link_now[0]))
            common.validate_format(obj._link_now[0], "None", None, None)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleLinkedSource"), dirty)
            factory.validate_type(obj._source[0], "OracleLinkedSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._non_sys_user = (data.get("nonSysUser", obj.__undef__), dirty)
        if obj._non_sys_user[0] is not None and obj._non_sys_user[0] is not obj.__undef__:
            assert isinstance(obj._non_sys_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._non_sys_user[0]))
            common.validate_format(obj._non_sys_user[0], "None", None, 30)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "non_sys_credentials" == "type" or (self.non_sys_credentials is not self.__undef__ and not (dirty and not self._non_sys_credentials[1])):
            dct["nonSysCredentials"] = dictify(self.non_sys_credentials)
        if "link_now" == "type" or (self.link_now is not self.__undef__ and not (dirty and not self._link_now[1])):
            dct["linkNow"] = dictify(self.link_now)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "non_sys_user" == "type" or (self.non_sys_user is not self.__undef__ and not (dirty and not self._non_sys_user[1])):
            dct["nonSysUser"] = dictify(self.non_sys_user)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._non_sys_credentials = (self._non_sys_credentials[0], True)
        self._link_now = (self._link_now[0], True)
        self._source = (self._source[0], True)
        self._non_sys_user = (self._non_sys_user[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._db_user = (self._db_user[0], True)

    def is_dirty(self):
        return any([self._container[1], self._non_sys_credentials[1], self._link_now[1], self._source[1], self._non_sys_user[1], self._environment_user[1], self._db_credentials[1], self._db_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLinkParameters):
            return False
        return super(OracleLinkParameters, self).__eq__(other) and \
               self.container == other.container and \
               self.non_sys_credentials == other.non_sys_credentials and \
               self.link_now == other.link_now and \
               self.source == other.source and \
               self.non_sys_user == other.non_sys_user and \
               self.environment_user == other.environment_user and \
               self.db_credentials == other.db_credentials and \
               self.db_user == other.db_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        Container to create as part of the linking process.

        :rtype: :py:class:`v1_3_0.web.vo.OracleDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def non_sys_credentials(self):
        """
        Non-SYS database credentials to access this database.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._non_sys_credentials[0]

    @non_sys_credentials.setter
    def non_sys_credentials(self, value):
        self._non_sys_credentials = (value, True)

    @property
    def link_now(self):
        """
        True if initial load should be done immediately.

        :rtype: ``bool``
        """
        return self._link_now[0]

    @link_now.setter
    def link_now(self, value):
        self._link_now = (value, True)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.OracleLinkedSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def non_sys_user(self):
        """
        Non-SYS database user to access this database.

        :rtype: ``basestring``
        """
        return self._non_sys_user[0]

    @non_sys_user.setter
    def non_sys_user(self, value):
        self._non_sys_user = (value, True)

    @property
    def environment_user(self):
        """
        Information about the os user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def db_credentials(self):
        """
        The password for the DB user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def db_user(self):
        """
        The name of the DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

class OracleStopParameters(SourceStopParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceStopParameters` *)* The
    parameters to use as input to stop oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleStopParameters, self).__init__()
        self._type = ("OracleStopParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._abort = (self.__undef__, True)
        self._instances = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleStopParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._abort = (data.get("abort", obj.__undef__), dirty)
        if obj._abort[0] is not None and obj._abort[0] is not obj.__undef__:
            assert isinstance(obj._abort[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._abort[0]))
            common.validate_format(obj._abort[0], "None", None, None)
        obj._instances = []
        for item in data.get("instances") or []:
            assert isinstance(item, float), ("Expected one of [u'number'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._instances.append(item)
        obj._instances = (obj._instances, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleStopParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "abort" == "type" or (self.abort is not self.__undef__ and not (dirty and not self._abort[1])):
            dct["abort"] = dictify(self.abort)
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)
        self._abort = (self._abort[0], True)
        self._instances = (self._instances[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1], self._abort[1], self._instances[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleStopParameters):
            return False
        return super(OracleStopParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential and \
               self.abort == other.abort and \
               self.instances == other.instances

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def abort(self):
        """
        Whether to issue 'shutdown abort' to shutdown Oracle instances.

        :rtype: ``bool``
        """
        return self._abort[0]

    @abort.setter
    def abort(self, value):
        self._abort = (value, True)

    @property
    def instances(self):
        """
        List of specific Oracle instances to stop.

        :rtype: ``list`` of ``float``
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

class NetworkInterfaceUtilDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a NETWORK_INTERFACE_UTIL analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterfaceUtilDatapointStream, self).__init__()
        self._type = ("NetworkInterfaceUtilDatapointStream", True)
        self._network_interface = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterfaceUtilDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._network_interface = (data.get("networkInterface", obj.__undef__), dirty)
        if obj._network_interface[0] is not None and obj._network_interface[0] is not obj.__undef__:
            assert isinstance(obj._network_interface[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._network_interface[0]))
            common.validate_format(obj._network_interface[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterfaceUtilDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "network_interface" == "type" or (self.network_interface is not self.__undef__ and not (dirty and not self._network_interface[1])):
            dct["networkInterface"] = dictify(self.network_interface)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._network_interface = (self._network_interface[0], True)

    def is_dirty(self):
        return any([self._network_interface[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterfaceUtilDatapointStream):
            return False
        return super(NetworkInterfaceUtilDatapointStream, self).__eq__(other) and \
               self.network_interface == other.network_interface

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def network_interface(self):
        """
        Which network interface was utilized.

        :rtype: ``basestring``
        """
        return self._network_interface[0]

    @network_interface.setter
    def network_interface(self, value):
        self._network_interface = (value, True)

class VfsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a VFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(VfsOpsDatapointStream, self).__init__()
        self._type = ("VfsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VfsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VfsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VfsOpsDatapointStream):
            return False
        return super(VfsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class DxFsIoQueueOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a DxFS_IO_QUEUE_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DxFsIoQueueOpsDatapointStream, self).__init__()
        self._type = ("DxFsIoQueueOpsDatapointStream", True)
        self._priority = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DxFsIoQueueOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._priority = (data.get("priority", obj.__undef__), dirty)
        if obj._priority[0] is not None and obj._priority[0] is not obj.__undef__:
            assert isinstance(obj._priority[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._priority[0]))
            assert obj._priority[0] in [u'sync', u'cache/agg', u'asyncw', u'asyncr', u'resilver', u'scrub', u'ddt_prefetch'], "Expected enum [u'sync', u'cache/agg', u'asyncw', u'asyncr', u'resilver', u'scrub', u'ddt_prefetch'] but got %s" % obj._priority[0]
            common.validate_format(obj._priority[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write', u'claim', u'free', u'ioctl', u'null'], "Expected enum [u'read', u'write', u'claim', u'free', u'ioctl', u'null'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DxFsIoQueueOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "priority" == "type" or (self.priority is not self.__undef__ and not (dirty and not self._priority[1])):
            dct["priority"] = dictify(self.priority)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._priority = (self._priority[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._priority[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DxFsIoQueueOpsDatapointStream):
            return False
        return super(DxFsIoQueueOpsDatapointStream, self).__eq__(other) and \
               self.priority == other.priority and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def priority(self):
        """
        Priority of the I/O. *(permitted values: sync, cache/agg, asyncw,
        asyncr, resilver, scrub, ddt_prefetch)*

        :rtype: ``basestring``
        """
        return self._priority[0]

    @priority.setter
    def priority(self, value):
        self._priority = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write, claim, free,
        ioctl, null)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class IScsiOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a iSCSI_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IScsiOpsDatapointStream, self).__init__()
        self._type = ("IScsiOpsDatapointStream", True)
        self._client = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IScsiOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "host", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IScsiOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._client = (self._client[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._client[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IScsiOpsDatapointStream):
            return False
        return super(IScsiOpsDatapointStream, self).__eq__(other) and \
               self.client == other.client and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def client(self):
        """
        Address of the client.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class CpuUtilDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a CPU_UTIL analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(CpuUtilDatapointStream, self).__init__()
        self._type = ("CpuUtilDatapointStream", True)
        self._cpu = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CpuUtilDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cpu = (data.get("cpu", obj.__undef__), dirty)
        if obj._cpu[0] is not None and obj._cpu[0] is not obj.__undef__:
            assert isinstance(obj._cpu[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cpu[0]))
            common.validate_format(obj._cpu[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CpuUtilDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cpu" == "type" or (self.cpu is not self.__undef__ and not (dirty and not self._cpu[1])):
            dct["cpu"] = dictify(self.cpu)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cpu = (self._cpu[0], True)

    def is_dirty(self):
        return any([self._cpu[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CpuUtilDatapointStream):
            return False
        return super(CpuUtilDatapointStream, self).__eq__(other) and \
               self.cpu == other.cpu

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cpu(self):
        """
        Which CPU was utilized.

        :rtype: ``int``
        """
        return self._cpu[0]

    @cpu.setter
    def cpu(self, value):
        self._cpu = (value, True)

class DiskOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a DISK_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DiskOpsDatapointStream, self).__init__()
        self._type = ("DiskOpsDatapointStream", True)
        self._device = (self.__undef__, True)
        self._error = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DiskOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._device = (data.get("device", obj.__undef__), dirty)
        if obj._device[0] is not None and obj._device[0] is not obj.__undef__:
            assert isinstance(obj._device[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._device[0]))
            common.validate_format(obj._device[0], "None", None, None)
        obj._error = (data.get("error", obj.__undef__), dirty)
        if obj._error[0] is not None and obj._error[0] is not obj.__undef__:
            assert isinstance(obj._error[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._error[0]))
            common.validate_format(obj._error[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DiskOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "device" == "type" or (self.device is not self.__undef__ and not (dirty and not self._device[1])):
            dct["device"] = dictify(self.device)
        if "error" == "type" or (self.error is not self.__undef__ and not (dirty and not self._error[1])):
            dct["error"] = dictify(self.error)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._device = (self._device[0], True)
        self._error = (self._error[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._device[1], self._error[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DiskOpsDatapointStream):
            return False
        return super(DiskOpsDatapointStream, self).__eq__(other) and \
               self.device == other.device and \
               self.error == other.error and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def device(self):
        """
        Device the I/Os were issued to.

        :rtype: ``basestring``
        """
        return self._device[0]

    @device.setter
    def device(self, value):
        self._device = (value, True)

    @property
    def error(self):
        """
        Whether the I/Os resulted in errors.

        :rtype: ``bool``
        """
        return self._error[0]

    @error.setter
    def error(self, value):
        self._error = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class DxFsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from a DxFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DxFsOpsDatapointStream, self).__init__()
        self._type = ("DxFsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DxFsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DxFsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DxFsOpsDatapointStream):
            return False
        return super(DxFsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class NfsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatapointStream` *)* A stream of
    datapoints from an NFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(NfsOpsDatapointStream, self).__init__()
        self._type = ("NfsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._client = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NfsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "host", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NfsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._client = (self._client[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._client[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NfsOpsDatapointStream):
            return False
        return super(NfsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.client == other.client and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def client(self):
        """
        Address of the client.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class PgSQLDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DBContainerRuntime` *)* Runtime
    properties of a PostgreSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBContainerRuntime, self).__init__()
        self._type = ("PgSQLDBContainerRuntime", True)
        self._last_restored_wal_segment = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._last_restored_wal_segment = (data.get("lastRestoredWALSegment", obj.__undef__), dirty)
        if obj._last_restored_wal_segment[0] is not None and obj._last_restored_wal_segment[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_wal_segment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_wal_segment[0]))
            common.validate_format(obj._last_restored_wal_segment[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_restored_wal_segment" == "type" or (self.last_restored_wal_segment is not self.__undef__ and not (dirty and not self._last_restored_wal_segment[1])):
            dct["lastRestoredWALSegment"] = dictify(self.last_restored_wal_segment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_restored_wal_segment = (self._last_restored_wal_segment[0], True)

    def is_dirty(self):
        return any([self._last_restored_wal_segment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBContainerRuntime):
            return False
        return super(PgSQLDBContainerRuntime, self).__eq__(other) and \
               self.last_restored_wal_segment == other.last_restored_wal_segment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_restored_wal_segment(self):
        """
        The ID of the WAL segment that was last restored in this container (if
        applicable).

        :rtype: ``basestring``
        """
        return self._last_restored_wal_segment[0]

    @last_restored_wal_segment.setter
    def last_restored_wal_segment(self, value):
        self._last_restored_wal_segment = (value, True)

class AppDataContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DBContainerRuntime` *)* Runtime
    properties of an AppData container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataContainerRuntime, self).__init__()
        self._type = ("AppDataContainerRuntime", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataContainerRuntime):
            return False
        return super(AppDataContainerRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DBContainerRuntime` *)* Runtime
    properties of a MSSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDBContainerRuntime, self).__init__()
        self._type = ("MSSqlDBContainerRuntime", True)
        self._last_restored_backup_set_uuid = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._last_restored_backup_set_uuid = (data.get("lastRestoredBackupSetUUID", obj.__undef__), dirty)
        if obj._last_restored_backup_set_uuid[0] is not None and obj._last_restored_backup_set_uuid[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_backup_set_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_backup_set_uuid[0]))
            common.validate_format(obj._last_restored_backup_set_uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_restored_backup_set_uuid" == "type" or (self.last_restored_backup_set_uuid is not self.__undef__ and not (dirty and not self._last_restored_backup_set_uuid[1])):
            dct["lastRestoredBackupSetUUID"] = dictify(self.last_restored_backup_set_uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_restored_backup_set_uuid = (self._last_restored_backup_set_uuid[0], True)

    def is_dirty(self):
        return any([self._last_restored_backup_set_uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDBContainerRuntime):
            return False
        return super(MSSqlDBContainerRuntime, self).__eq__(other) and \
               self.last_restored_backup_set_uuid == other.last_restored_backup_set_uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_restored_backup_set_uuid(self):
        """
        The UUID of the source database backupset that was last restored in
        this container.

        :rtype: ``basestring``
        """
        return self._last_restored_backup_set_uuid[0]

    @last_restored_backup_set_uuid.setter
    def last_restored_backup_set_uuid(self, value):
        self._last_restored_backup_set_uuid = (value, True)

class OracleDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DBContainerRuntime` *)* Runtime
    properties of an Oracle database container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDBContainerRuntime, self).__init__()
        self._type = ("OracleDBContainerRuntime", True)
        self._cross_platform_eligible = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._cross_platform_eligible = (data.get("crossPlatformEligible", obj.__undef__), dirty)
        if obj._cross_platform_eligible[0] is not None and obj._cross_platform_eligible[0] is not obj.__undef__:
            assert isinstance(obj._cross_platform_eligible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cross_platform_eligible[0]))
            common.validate_format(obj._cross_platform_eligible[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cross_platform_eligible" == "type" or (self.cross_platform_eligible is not self.__undef__ and not (dirty and not self._cross_platform_eligible[1])):
            dct["crossPlatformEligible"] = dictify(self.cross_platform_eligible)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cross_platform_eligible = (self._cross_platform_eligible[0], True)

    def is_dirty(self):
        return any([self._cross_platform_eligible[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDBContainerRuntime):
            return False
        return super(OracleDBContainerRuntime, self).__eq__(other) and \
               self.cross_platform_eligible == other.cross_platform_eligible

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cross_platform_eligible(self):
        """
        Indicates whether or not the given container is cross-platform eligible
        or not.

        :rtype: ``bool``
        """
        return self._cross_platform_eligible[0]

    @cross_platform_eligible.setter
    def cross_platform_eligible(self, value):
        self._cross_platform_eligible = (value, True)

class MSSqlSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a SQL server source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSourceConnectionInfo, self).__init__()
        self._type = ("MSSqlSourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._instance_jdbc_string = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._instance_jdbc_string = (data.get("instanceJDBCString", obj.__undef__), dirty)
        if obj._instance_jdbc_string[0] is not None and obj._instance_jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._instance_jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_jdbc_string[0]))
            common.validate_format(obj._instance_jdbc_string[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "instance_jdbc_string" == "type" or (self.instance_jdbc_string is not self.__undef__ and not (dirty and not self._instance_jdbc_string[1])):
            dct["instanceJDBCString"] = dictify(self.instance_jdbc_string)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._instance_jdbc_string = (self._instance_jdbc_string[0], True)
        self._instance_name = (self._instance_name[0], True)
        self._port = (self._port[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._host[1], self._instance_jdbc_string[1], self._instance_name[1], self._port[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSourceConnectionInfo):
            return False
        return super(MSSqlSourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.instance_jdbc_string == other.instance_jdbc_string and \
               self.instance_name == other.instance_name and \
               self.port == other.port and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def instance_jdbc_string(self):
        """
        The JDBC string used to connect to the SQL server instance.

        :rtype: ``basestring``
        """
        return self._instance_jdbc_string[0]

    @instance_jdbc_string.setter
    def instance_jdbc_string(self, value):
        self._instance_jdbc_string = (value, True)

    @property
    def instance_name(self):
        """
        The name of the instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

    @property
    def port(self):
        """
        The port number used to connect to the source.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class PgSQLSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSourceConnectionInfo, self).__init__()
        self._type = ("PgSQLSourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._jdbc_string = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._pg_data_directory = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._jdbc_string = (data.get("jdbcString", obj.__undef__), dirty)
        if obj._jdbc_string[0] is not None and obj._jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_string[0]))
            common.validate_format(obj._jdbc_string[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._pg_data_directory = (data.get("pgDataDirectory", obj.__undef__), dirty)
        if obj._pg_data_directory[0] is not None and obj._pg_data_directory[0] is not obj.__undef__:
            assert isinstance(obj._pg_data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pg_data_directory[0]))
            common.validate_format(obj._pg_data_directory[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "jdbc_string" == "type" or (self.jdbc_string is not self.__undef__ and not (dirty and not self._jdbc_string[1])):
            dct["jdbcString"] = dictify(self.jdbc_string)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "pg_data_directory" == "type" or (self.pg_data_directory is not self.__undef__ and not (dirty and not self._pg_data_directory[1])):
            dct["pgDataDirectory"] = dictify(self.pg_data_directory)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._jdbc_string = (self._jdbc_string[0], True)
        self._port = (self._port[0], True)
        self._pg_data_directory = (self._pg_data_directory[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._host[1], self._jdbc_string[1], self._port[1], self._pg_data_directory[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSourceConnectionInfo):
            return False
        return super(PgSQLSourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.jdbc_string == other.jdbc_string and \
               self.port == other.port and \
               self.pg_data_directory == other.pg_data_directory and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def jdbc_string(self):
        """
        The JDBC string used to connect to the PostgreSQL server instance.

        :rtype: ``basestring``
        """
        return self._jdbc_string[0]

    @jdbc_string.setter
    def jdbc_string(self, value):
        self._jdbc_string = (value, True)

    @property
    def port(self):
        """
        The port on which the PostgresSQL server for the cluster is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def pg_data_directory(self):
        """
        The data directory for the PostgreSQL cluster.

        :rtype: ``basestring``
        """
        return self._pg_data_directory[0]

    @pg_data_directory.setter
    def pg_data_directory(self, value):
        self._pg_data_directory = (value, True)

    @property
    def user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a single instance Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourceConnectionInfo, self).__init__()
        self._type = ("OracleSourceConnectionInfo", True)
        self._jdbc_strings = (self.__undef__, True)
        self._oracle_home = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._jdbc_strings = []
        for item in data.get("jdbcStrings") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._jdbc_strings.append(item)
        obj._jdbc_strings = (obj._jdbc_strings, dirty)
        obj._oracle_home = (data.get("oracleHome", obj.__undef__), dirty)
        if obj._oracle_home[0] is not None and obj._oracle_home[0] is not obj.__undef__:
            assert isinstance(obj._oracle_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._oracle_home[0]))
            common.validate_format(obj._oracle_home[0], "None", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "jdbc_strings" == "type" or (self.jdbc_strings is not self.__undef__ and not (dirty and not self._jdbc_strings[1])):
            dct["jdbcStrings"] = dictify(self.jdbc_strings)
        if "oracle_home" == "type" or (self.oracle_home is not self.__undef__ and not (dirty and not self._oracle_home[1])):
            dct["oracleHome"] = dictify(self.oracle_home)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._jdbc_strings = (self._jdbc_strings[0], True)
        self._oracle_home = (self._oracle_home[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._jdbc_strings[1], self._oracle_home[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourceConnectionInfo):
            return False
        return super(OracleSourceConnectionInfo, self).__eq__(other) and \
               self.jdbc_strings == other.jdbc_strings and \
               self.oracle_home == other.oracle_home and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def jdbc_strings(self):
        """
        The JDBC strings used to connect to the source.

        :rtype: ``list`` of ``basestring``
        """
        return self._jdbc_strings[0]

    @jdbc_strings.setter
    def jdbc_strings(self, value):
        self._jdbc_strings = (value, True)

    @property
    def oracle_home(self):
        """
        The Oracle installation home.

        :rtype: ``basestring``
        """
        return self._oracle_home[0]

    @oracle_home.setter
    def oracle_home(self, value):
        self._oracle_home = (value, True)

    @property
    def database_name(self):
        """
        The database name.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class AppDataSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to the application source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceConnectionInfo, self).__init__()
        self._type = ("AppDataSourceConnectionInfo", True)
        self._path = (self.__undef__, True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "None", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._path = (self._path[0], True)
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._path[1], self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceConnectionInfo):
            return False
        return super(AppDataSourceConnectionInfo, self).__eq__(other) and \
               self.path == other.path and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def path(self):
        """
        The path where the application data is located on the host.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class OracleSISourceConnectionInfo(OracleSourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleSourceConnectionInfo` *)*
    Contains information that can be used to connect to a single instance
    Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSISourceConnectionInfo, self).__init__()
        self._type = ("OracleSISourceConnectionInfo", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSISourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSISourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSISourceConnectionInfo):
            return False
        return super(OracleSISourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class OracleRACSourceConnectionInfo(OracleSourceConnectionInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleSourceConnectionInfo` *)*
    Contains information that can be used to connect to a single instance
    Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACSourceConnectionInfo, self).__init__()
        self._type = ("OracleRACSourceConnectionInfo", True)
        self._remote_listener = (self.__undef__, True)
        self._nodes = (self.__undef__, True)
        self._crs_cluster_home = (self.__undef__, True)
        self._scan = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_listener = (data.get("remoteListener", obj.__undef__), dirty)
        if obj._remote_listener[0] is not None and obj._remote_listener[0] is not obj.__undef__:
            assert isinstance(obj._remote_listener[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_listener[0]))
            common.validate_format(obj._remote_listener[0], "None", None, None)
        obj._nodes = []
        for item in data.get("nodes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._nodes.append(item)
        obj._nodes = (obj._nodes, dirty)
        obj._crs_cluster_home = (data.get("crsClusterHome", obj.__undef__), dirty)
        if obj._crs_cluster_home[0] is not None and obj._crs_cluster_home[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_home[0]))
            common.validate_format(obj._crs_cluster_home[0], "None", None, None)
        obj._scan = (data.get("scan", obj.__undef__), dirty)
        if obj._scan[0] is not None and obj._scan[0] is not obj.__undef__:
            assert isinstance(obj._scan[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._scan[0]))
            common.validate_format(obj._scan[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_listener" == "type" or (self.remote_listener is not self.__undef__ and not (dirty and not self._remote_listener[1])):
            dct["remoteListener"] = dictify(self.remote_listener)
        if "nodes" == "type" or (self.nodes is not self.__undef__ and not (dirty and not self._nodes[1])):
            dct["nodes"] = dictify(self.nodes)
        if "crs_cluster_home" == "type" or (self.crs_cluster_home is not self.__undef__ and not (dirty and not self._crs_cluster_home[1])):
            dct["crsClusterHome"] = dictify(self.crs_cluster_home)
        if "scan" == "type" or (self.scan is not self.__undef__ and not (dirty and not self._scan[1])):
            dct["scan"] = dictify(self.scan)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_listener = (self._remote_listener[0], True)
        self._nodes = (self._nodes[0], True)
        self._crs_cluster_home = (self._crs_cluster_home[0], True)
        self._scan = (self._scan[0], True)

    def is_dirty(self):
        return any([self._remote_listener[1], self._nodes[1], self._crs_cluster_home[1], self._scan[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACSourceConnectionInfo):
            return False
        return super(OracleRACSourceConnectionInfo, self).__eq__(other) and \
               self.remote_listener == other.remote_listener and \
               self.nodes == other.nodes and \
               self.crs_cluster_home == other.crs_cluster_home and \
               self.scan == other.scan

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_listener(self):
        """
        The default remote_listener parameter to be used for databases on the
        cluster.

        :rtype: ``basestring``
        """
        return self._remote_listener[0]

    @remote_listener.setter
    def remote_listener(self, value):
        self._remote_listener = (value, True)

    @property
    def nodes(self):
        """
        The addresses for the nodes on which the source resides.

        :rtype: ``list`` of ``basestring``
        """
        return self._nodes[0]

    @nodes.setter
    def nodes(self, value):
        self._nodes = (value, True)

    @property
    def crs_cluster_home(self):
        """
        The location of the cluster installation.

        :rtype: ``basestring``
        """
        return self._crs_cluster_home[0]

    @crs_cluster_home.setter
    def crs_cluster_home(self, value):
        self._crs_cluster_home = (value, True)

    @property
    def scan(self):
        """
        The Single Client Access Name of the cluster (11.2 and greater clusters
        only).

        :rtype: ``basestring``
        """
        return self._scan[0]

    @scan.setter
    def scan(self, value):
        self._scan = (value, True)

class DVCTimelinePointBookmarkInput(DVCTimelinePointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCTimelinePointParameters` *)*
    Specifies the DVC timeline point using a reference to the DVC bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimelinePointBookmarkInput, self).__init__()
        self._type = ("DVCTimelinePointBookmarkInput", True)
        self._bookmark = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimelinePointBookmarkInput, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" not in data:
            raise ValueError("Missing required property \"bookmark\".")
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimelinePointBookmarkInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)

    def is_dirty(self):
        return any([self._bookmark[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimelinePointBookmarkInput):
            return False
        return super(DVCTimelinePointBookmarkInput, self).__eq__(other) and \
               self.bookmark == other.bookmark

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The DVC bookmark.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

class DVCTimelinePointTimeParameters(DVCTimelinePointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCTimelinePointParameters` *)*
    Specifies time related timeline parameters such as time input and latest
    time input.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimelinePointTimeParameters, self).__init__()
        self._type = ("DVCTimelinePointTimeParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimelinePointTimeParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimelinePointTimeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimelinePointTimeParameters):
            return False
        return super(DVCTimelinePointTimeParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCTimelinePointLatestTimeInput(DVCTimelinePointTimeParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCTimelinePointTimeParameters` *)*
    Specifies the use of the latest available data from the parent DVC
    application template.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimelinePointLatestTimeInput, self).__init__()
        self._type = ("DVCTimelinePointLatestTimeInput", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimelinePointLatestTimeInput, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimelinePointLatestTimeInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimelinePointLatestTimeInput):
            return False
        return super(DVCTimelinePointLatestTimeInput, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCTimelinePointTimeInput(DVCTimelinePointTimeParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCTimelinePointTimeParameters` *)*
    Specifies a point in time on the DVC timeline for a specific application.
    Latest provisionable points before the specified time will be used.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimelinePointTimeInput, self).__init__()
        self._type = ("DVCTimelinePointTimeInput", True)
        self._source_application = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimelinePointTimeInput, cls).from_dict(data, dirty, undef_enabled)
        if "sourceApplication" not in data:
            raise ValueError("Missing required property \"sourceApplication\".")
        obj._source_application = (data.get("sourceApplication", obj.__undef__), dirty)
        if obj._source_application[0] is not None and obj._source_application[0] is not obj.__undef__:
            assert isinstance(obj._source_application[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_application[0]))
            common.validate_format(obj._source_application[0], "objectReference", None, None)
        if "time" not in data:
            raise ValueError("Missing required property \"time\".")
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimelinePointTimeInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_application" == "type" or (self.source_application is not self.__undef__ and not (dirty and not self._source_application[1])):
            dct["sourceApplication"] = dictify(self.source_application)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_application = (self._source_application[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._source_application[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimelinePointTimeInput):
            return False
        return super(DVCTimelinePointTimeInput, self).__eq__(other) and \
               self.source_application == other.source_application and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_application(self):
        """
        The reference to the application used for this operation.

        :rtype: ``basestring``
        """
        return self._source_application[0]

    @source_application.setter
    def source_application(self, value):
        self._source_application = (value, True)

    @property
    def time(self):
        """
        A point in time on the application's timeline.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class CurrentConsumerCapacityData(BaseConsumerCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseConsumerCapacityData` *)* Current
    data about a particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentConsumerCapacityData, self).__init__()
        self._type = ("CurrentConsumerCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentConsumerCapacityData):
            return False
        return super(CurrentConsumerCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class HistoricalConsumerCapacityData(BaseConsumerCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseConsumerCapacityData` *)*
    Historical data about a particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalConsumerCapacityData, self).__init__()
        self._type = ("HistoricalConsumerCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalConsumerCapacityData):
            return False
        return super(HistoricalConsumerCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCApplicationTemplateCreateParameters(DVCApplicationCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCApplicationCreateParameters` *)* The
    parameters used to create an application template.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplicationTemplateCreateParameters, self).__init__()
        self._type = ("DVCApplicationTemplateCreateParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplicationTemplateCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplicationTemplateCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplicationTemplateCreateParameters):
            return False
        return super(DVCApplicationTemplateCreateParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCApplicationContainerCreateParameters(DVCApplicationCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCApplicationCreateParameters` *)* The
    parameters used to create an application container.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplicationContainerCreateParameters, self).__init__()
        self._type = ("DVCApplicationContainerCreateParameters", True)
        self._bookmark = (self.__undef__, True)
        self._owner = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplicationContainerCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._owner = (data.get("owner", obj.__undef__), dirty)
        if obj._owner[0] is not None and obj._owner[0] is not obj.__undef__:
            assert isinstance(obj._owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._owner[0]))
            common.validate_format(obj._owner[0], "objectReference", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplicationContainerCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "owner" == "type" or (self.owner is not self.__undef__ and not (dirty and not self._owner[1])):
            dct["owner"] = dictify(self.owner)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._owner = (self._owner[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._owner[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplicationContainerCreateParameters):
            return False
        return super(DVCApplicationContainerCreateParameters, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.owner == other.owner and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        A reference to the bookmark that represents the inital state of the new
        application container. If no bookmark is specified then one is created
        at now on the template.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def owner(self):
        """
        A reference to the user that owns this application container.

        :rtype: ``basestring``
        """
        return self._owner[0]

    @owner.setter
    def owner(self, value):
        self._owner = (value, True)

    @property
    def template(self):
        """
        A reference to the template that this application container is
        provisioned from.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class OracleStartParameters(SourceStartParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceStartParameters` *)* The
    parameters to use as input to start oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleStartParameters, self).__init__()
        self._type = ("OracleStartParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._instances = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleStartParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._instances = []
        for item in data.get("instances") or []:
            assert isinstance(item, float), ("Expected one of [u'number'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._instances.append(item)
        obj._instances = (obj._instances, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleStartParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)
        self._instances = (self._instances[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1], self._instances[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleStartParameters):
            return False
        return super(OracleStartParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential and \
               self.instances == other.instances

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def instances(self):
        """
        List of specific Oracle instances to start.

        :rtype: ``list`` of ``float``
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

class RunCommandOperation(Operation):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Operation` *)* A user-specifiable
    operation that runs a command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunCommandOperation, self).__init__()
        self._type = ("RunCommandOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunCommandOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunCommandOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunCommandOperation):
            return False
        return super(RunCommandOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class RunExpectOperation(Operation):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Operation` *)* A user-specifiable
    operation that runs an expect script on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunExpectOperation, self).__init__()
        self._type = ("RunExpectOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunExpectOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunExpectOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunExpectOperation):
            return False
        return super(RunExpectOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The expect command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class OracleDisableParameters(SourceDisableParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceDisableParameters` *)* The
    parameters to use as input to disable oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDisableParameters, self).__init__()
        self._type = ("OracleDisableParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDisableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDisableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDisableParameters):
            return False
        return super(OracleDisableParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class StatisticEnumAxis(StatisticAxis):
    """
    *(extends* :py:class:`v1_3_0.web.vo.StatisticAxis` *)* The attributes of a
    statistic axis which is an enum type.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticEnumAxis, self).__init__()
        self._type = ("StatisticEnumAxis", True)
        self._enum_values = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticEnumAxis, cls).from_dict(data, dirty, undef_enabled)
        obj._enum_values = []
        for item in data.get("enumValues") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._enum_values.append(item)
        obj._enum_values = (obj._enum_values, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticEnumAxis, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enum_values" == "type" or (self.enum_values is not self.__undef__ and not (dirty and not self._enum_values[1])):
            dct["enumValues"] = dictify(self.enum_values)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enum_values = (self._enum_values[0], True)

    def is_dirty(self):
        return any([self._enum_values[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticEnumAxis):
            return False
        return super(StatisticEnumAxis, self).__eq__(other) and \
               self.enum_values == other.enum_values

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enum_values(self):
        """
        The set of values that are allowed for this axis.

        :rtype: ``list`` of ``basestring``
        """
        return self._enum_values[0]

    @enum_values.setter
    def enum_values(self, value):
        self._enum_values = (value, True)

class PgSQLCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible PgSQL repositories.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLCompatibilityCriteria, self).__init__()
        self._type = ("PgSQLCompatibilityCriteria", True)
        self._segment_size = (self.__undef__, True)
        self._variant = (self.__undef__, True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._segment_size = (data.get("segmentSize", obj.__undef__), dirty)
        if obj._segment_size[0] is not None and obj._segment_size[0] is not obj.__undef__:
            assert isinstance(obj._segment_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._segment_size[0]))
            common.validate_format(obj._segment_size[0], "None", None, None)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'PostgreSQL', u'EnterpriseDB'], "Expected enum [u'PostgreSQL', u'EnterpriseDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "pgsqlVersion", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "segment_size" == "type" or (self.segment_size is not self.__undef__ and not (dirty and not self._segment_size[1])):
            dct["segmentSize"] = dictify(self.segment_size)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._segment_size = (self._segment_size[0], True)
        self._variant = (self._variant[0], True)
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._segment_size[1], self._variant[1], self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLCompatibilityCriteria):
            return False
        return super(PgSQLCompatibilityCriteria, self).__eq__(other) and \
               self.segment_size == other.segment_size and \
               self.variant == other.variant and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def segment_size(self):
        """
        Selected repositories have this size WAL segments.

        :rtype: ``int``
        """
        return self._segment_size[0]

    @segment_size.setter
    def segment_size(self, value):
        self._segment_size = (value, True)

    @property
    def variant(self):
        """
        Selected repositories will match this variant of the PostgreSQL
        distribution. *(permitted values: PostgreSQL, EnterpriseDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class MSSqlCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible MSSql repositories.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlCompatibilityCriteria, self).__init__()
        self._type = ("MSSqlCompatibilityCriteria", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlCompatibilityCriteria):
            return False
        return super(MSSqlCompatibilityCriteria, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class OracleCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible Oracle repositories.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCompatibilityCriteria, self).__init__()
        self._type = ("OracleCompatibilityCriteria", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCompatibilityCriteria):
            return False
        return super(OracleCompatibilityCriteria, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class OracleRACInstance(OracleInstance):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleInstance` *)* The representation
    of an Oracle Database RAC Instance Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACInstance, self).__init__()
        self._type = ("OracleRACInstance", True)
        self._node = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._node = (data.get("node", obj.__undef__), dirty)
        if obj._node[0] is not None and obj._node[0] is not obj.__undef__:
            assert isinstance(obj._node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._node[0]))
            common.validate_format(obj._node[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "node" == "type" or (self.node is not self.__undef__ and not (dirty and not self._node[1])):
            dct["node"] = dictify(self.node)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._node = (self._node[0], True)

    def is_dirty(self):
        return any([self._node[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACInstance):
            return False
        return super(OracleRACInstance, self).__eq__(other) and \
               self.node == other.node

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def node(self):
        """
        Reference to the Oracle cluster node that the RAC instance is running
        on.

        :rtype: ``basestring``
        """
        return self._node[0]

    @node.setter
    def node(self, value):
        self._node = (value, True)

class Alert(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* An alert
    describing an event for a given object.
    """
    def __init__(self, undef_enabled=True):
        super(Alert, self).__init__()
        self._type = ("Alert", True)
        self._event_response = (self.__undef__, True)
        self._event_title = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._event_description = (self.__undef__, True)
        self._event_severity = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._event_command_output = (self.__undef__, True)
        self._event_action = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._event = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Alert, cls).from_dict(data, dirty, undef_enabled)
        obj._event_response = (data.get("eventResponse", obj.__undef__), dirty)
        if obj._event_response[0] is not None and obj._event_response[0] is not obj.__undef__:
            assert isinstance(obj._event_response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_response[0]))
            common.validate_format(obj._event_response[0], "None", None, None)
        obj._event_title = (data.get("eventTitle", obj.__undef__), dirty)
        if obj._event_title[0] is not None and obj._event_title[0] is not obj.__undef__:
            assert isinstance(obj._event_title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_title[0]))
            common.validate_format(obj._event_title[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._event_description = (data.get("eventDescription", obj.__undef__), dirty)
        if obj._event_description[0] is not None and obj._event_description[0] is not obj.__undef__:
            assert isinstance(obj._event_description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_description[0]))
            common.validate_format(obj._event_description[0], "None", None, None)
        obj._event_severity = (data.get("eventSeverity", obj.__undef__), dirty)
        if obj._event_severity[0] is not None and obj._event_severity[0] is not obj.__undef__:
            assert isinstance(obj._event_severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_severity[0]))
            assert obj._event_severity[0] in [u'INFORMATIONAL', u'WARNING', u'CRITICAL'], "Expected enum [u'INFORMATIONAL', u'WARNING', u'CRITICAL'] but got %s" % obj._event_severity[0]
            common.validate_format(obj._event_severity[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._event_command_output = (data.get("eventCommandOutput", obj.__undef__), dirty)
        if obj._event_command_output[0] is not None and obj._event_command_output[0] is not obj.__undef__:
            assert isinstance(obj._event_command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_command_output[0]))
            common.validate_format(obj._event_command_output[0], "None", None, None)
        obj._event_action = (data.get("eventAction", obj.__undef__), dirty)
        if obj._event_action[0] is not None and obj._event_action[0] is not obj.__undef__:
            assert isinstance(obj._event_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_action[0]))
            common.validate_format(obj._event_action[0], "None", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._event = (data.get("event", obj.__undef__), dirty)
        if obj._event[0] is not None and obj._event[0] is not obj.__undef__:
            assert isinstance(obj._event[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event[0]))
            common.validate_format(obj._event[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Alert, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_response" == "type" or (self.event_response is not self.__undef__ and not (dirty and not self._event_response[1])):
            dct["eventResponse"] = dictify(self.event_response)
        if "event_title" == "type" or (self.event_title is not self.__undef__ and not (dirty and not self._event_title[1])):
            dct["eventTitle"] = dictify(self.event_title)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "event_description" == "type" or (self.event_description is not self.__undef__ and not (dirty and not self._event_description[1])):
            dct["eventDescription"] = dictify(self.event_description)
        if "event_severity" == "type" or (self.event_severity is not self.__undef__ and not (dirty and not self._event_severity[1])):
            dct["eventSeverity"] = dictify(self.event_severity)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "event_command_output" == "type" or (self.event_command_output is not self.__undef__ and not (dirty and not self._event_command_output[1])):
            dct["eventCommandOutput"] = dictify(self.event_command_output)
        if "event_action" == "type" or (self.event_action is not self.__undef__ and not (dirty and not self._event_action[1])):
            dct["eventAction"] = dictify(self.event_action)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "event" == "type" or (self.event is not self.__undef__ and not (dirty and not self._event[1])):
            dct["event"] = dictify(self.event)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_response = (self._event_response[0], True)
        self._event_title = (self._event_title[0], True)
        self._target = (self._target[0], True)
        self._event_description = (self._event_description[0], True)
        self._event_severity = (self._event_severity[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._event_command_output = (self._event_command_output[0], True)
        self._event_action = (self._event_action[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._target_name = (self._target_name[0], True)
        self._event = (self._event[0], True)

    def is_dirty(self):
        return any([self._event_response[1], self._event_title[1], self._target[1], self._event_description[1], self._event_severity[1], self._timestamp[1], self._event_command_output[1], self._event_action[1], self._target_object_type[1], self._target_name[1], self._event[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Alert):
            return False
        return super(Alert, self).__eq__(other) and \
               self.event_response == other.event_response and \
               self.event_title == other.event_title and \
               self.target == other.target and \
               self.event_description == other.event_description and \
               self.event_severity == other.event_severity and \
               self.timestamp == other.timestamp and \
               self.event_command_output == other.event_command_output and \
               self.event_action == other.event_action and \
               self.target_object_type == other.target_object_type and \
               self.target_name == other.target_name and \
               self.event == other.event

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_response(self):
        """
        Event response

        :rtype: ``basestring``
        """
        return self._event_response[0]

    @event_response.setter
    def event_response(self, value):
        self._event_response = (value, True)

    @property
    def event_title(self):
        """
        Event title

        :rtype: ``basestring``
        """
        return self._event_title[0]

    @event_title.setter
    def event_title(self, value):
        self._event_title = (value, True)

    @property
    def target(self):
        """
        Reference to target object

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def event_description(self):
        """
        Event description

        :rtype: ``basestring``
        """
        return self._event_description[0]

    @event_description.setter
    def event_description(self, value):
        self._event_description = (value, True)

    @property
    def event_severity(self):
        """
        Event severity *(permitted values: INFORMATIONAL, WARNING, CRITICAL)*

        :rtype: ``basestring``
        """
        return self._event_severity[0]

    @event_severity.setter
    def event_severity(self, value):
        self._event_severity = (value, True)

    @property
    def timestamp(self):
        """
        Time at which event occurred

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def event_command_output(self):
        """
        Additional text associated with the event. This text is not localized
        and is only provided for certain alerts. For example, if an alert is
        caused by a post script failure, the output of the post script may be
        included here to assist with debugging the failure.

        :rtype: ``basestring``
        """
        return self._event_command_output[0]

    @event_command_output.setter
    def event_command_output(self, value):
        self._event_command_output = (value, True)

    @property
    def event_action(self):
        """
        Event recommended action

        :rtype: ``basestring``
        """
        return self._event_action[0]

    @event_action.setter
    def event_action(self, value):
        self._event_action = (value, True)

    @property
    def target_object_type(self):
        """
        Type of target object

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def target_name(self):
        """
        Name of target object

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def event(self):
        """
        Event class

        :rtype: ``basestring``
        """
        return self._event[0]

    @event.setter
    def event(self, value):
        self._event = (value, True)

class UserObject(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* Super schema for
    all schemas representing user-visible objects
    """
    def __init__(self, undef_enabled=True):
        super(UserObject, self).__init__()
        self._type = ("UserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "objectName", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UserObject):
            return False
        return super(UserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class DVCUserPreferences(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* A DVC user's
    preferences.
    """
    def __init__(self, undef_enabled=True):
        super(DVCUserPreferences, self).__init__()
        self._type = ("DVCUserPreferences", True)
        self._breakdowns = (self.__undef__, True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCUserPreferences, cls).from_dict(data, dirty, undef_enabled)
        obj._breakdowns = []
        for item in data.get("breakdowns") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._breakdowns.append(item)
        obj._breakdowns = (obj._breakdowns, dirty)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCUserPreferences, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "breakdowns" == "type" or (self.breakdowns is not self.__undef__ and not (dirty and not self._breakdowns[1])):
            dct["breakdowns"] = dictify(self.breakdowns)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._breakdowns = (self._breakdowns[0], True)
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._breakdowns[1], self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCUserPreferences):
            return False
        return super(DVCUserPreferences, self).__eq__(other) and \
               self.breakdowns == other.breakdowns and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def breakdowns(self):
        """
        The properties configured for breaking down application templates.

        :rtype: ``list`` of ``basestring``
        """
        return self._breakdowns[0]

    @breakdowns.setter
    def breakdowns(self, value):
        self._breakdowns = (value, True)

    @property
    def enabled(self):
        """
        Indicates whether DVC is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class Fault(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* A representation
    of a fault, with associated user object.
    """
    def __init__(self, undef_enabled=True):
        super(Fault, self).__init__()
        self._type = ("Fault", True)
        self._status = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._date_resolved = (self.__undef__, True)
        self._resolution_comments = (self.__undef__, True)
        self._date_diagnosed = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._action = (self.__undef__, True)
        self._bundle_id = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._severity = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Fault, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'ACTIVE', u'RESOLVED'], "Expected enum [u'ACTIVE', u'RESOLVED'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._date_resolved = (data.get("dateResolved", obj.__undef__), dirty)
        if obj._date_resolved[0] is not None and obj._date_resolved[0] is not obj.__undef__:
            assert isinstance(obj._date_resolved[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_resolved[0]))
            common.validate_format(obj._date_resolved[0], "date", None, None)
        obj._resolution_comments = (data.get("resolutionComments", obj.__undef__), dirty)
        if obj._resolution_comments[0] is not None and obj._resolution_comments[0] is not obj.__undef__:
            assert isinstance(obj._resolution_comments[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._resolution_comments[0]))
            common.validate_format(obj._resolution_comments[0], "None", None, None)
        obj._date_diagnosed = (data.get("dateDiagnosed", obj.__undef__), dirty)
        if obj._date_diagnosed[0] is not None and obj._date_diagnosed[0] is not obj.__undef__:
            assert isinstance(obj._date_diagnosed[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_diagnosed[0]))
            common.validate_format(obj._date_diagnosed[0], "date", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._bundle_id = (data.get("bundleID", obj.__undef__), dirty)
        if obj._bundle_id[0] is not None and obj._bundle_id[0] is not obj.__undef__:
            assert isinstance(obj._bundle_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bundle_id[0]))
            common.validate_format(obj._bundle_id[0], "None", None, None)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING'], "Expected enum [u'CRITICAL', u'WARNING'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Fault, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "date_resolved" == "type" or (self.date_resolved is not self.__undef__ and not (dirty and not self._date_resolved[1])):
            dct["dateResolved"] = dictify(self.date_resolved)
        if "resolution_comments" == "type" or (self.resolution_comments is not self.__undef__ and not (dirty and not self._resolution_comments[1])):
            dct["resolutionComments"] = dictify(self.resolution_comments)
        if "date_diagnosed" == "type" or (self.date_diagnosed is not self.__undef__ and not (dirty and not self._date_diagnosed[1])):
            dct["dateDiagnosed"] = dictify(self.date_diagnosed)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "bundle_id" == "type" or (self.bundle_id is not self.__undef__ and not (dirty and not self._bundle_id[1])):
            dct["bundleID"] = dictify(self.bundle_id)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._description = (self._description[0], True)
        self._title = (self._title[0], True)
        self._date_resolved = (self._date_resolved[0], True)
        self._resolution_comments = (self._resolution_comments[0], True)
        self._date_diagnosed = (self._date_diagnosed[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._target = (self._target[0], True)
        self._action = (self._action[0], True)
        self._bundle_id = (self._bundle_id[0], True)
        self._target_name = (self._target_name[0], True)
        self._response = (self._response[0], True)
        self._severity = (self._severity[0], True)

    def is_dirty(self):
        return any([self._status[1], self._description[1], self._title[1], self._date_resolved[1], self._resolution_comments[1], self._date_diagnosed[1], self._target_object_type[1], self._target[1], self._action[1], self._bundle_id[1], self._target_name[1], self._response[1], self._severity[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Fault):
            return False
        return super(Fault, self).__eq__(other) and \
               self.status == other.status and \
               self.description == other.description and \
               self.title == other.title and \
               self.date_resolved == other.date_resolved and \
               self.resolution_comments == other.resolution_comments and \
               self.date_diagnosed == other.date_diagnosed and \
               self.target_object_type == other.target_object_type and \
               self.target == other.target and \
               self.action == other.action and \
               self.bundle_id == other.bundle_id and \
               self.target_name == other.target_name and \
               self.response == other.response and \
               self.severity == other.severity

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the fault. This can either be ACTIVE or RESOLVED.
        *(permitted values: ACTIVE, RESOLVED)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def description(self):
        """
        Full description of the fault.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def title(self):
        """
        Summary of the fault.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def date_resolved(self):
        """
        The date when the fault was resolved.

        :rtype: ``basestring``
        """
        return self._date_resolved[0]

    @date_resolved.setter
    def date_resolved(self, value):
        self._date_resolved = (value, True)

    @property
    def resolution_comments(self):
        """
        A comment that describes the fault resolution.

        :rtype: ``basestring``
        """
        return self._resolution_comments[0]

    @resolution_comments.setter
    def resolution_comments(self, value):
        self._resolution_comments = (value, True)

    @property
    def date_diagnosed(self):
        """
        The date when the fault was diagnosed.

        :rtype: ``basestring``
        """
        return self._date_diagnosed[0]

    @date_diagnosed.setter
    def date_diagnosed(self, value):
        self._date_diagnosed = (value, True)

    @property
    def target_object_type(self):
        """
        The user-visible Delphix object that is faulted.

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def target(self):
        """
        The user-visible Delphix object that is faulted.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def action(self):
        """
        A suggested user action.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def bundle_id(self):
        """
        A unique dot delimited identifier associated with the fault.

        :rtype: ``basestring``
        """
        return self._bundle_id[0]

    @bundle_id.setter
    def bundle_id(self, value):
        self._bundle_id = (value, True)

    @property
    def target_name(self):
        """
        The name of the faulted object at the time the fault was diagnosed.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def response(self):
        """
        The automated response taken by the system.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def severity(self):
        """
        The severity of the fault event. This can either be CRITICAL or
        WARNING. *(permitted values: CRITICAL, WARNING)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

class AuditEvent(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* Represents an
    audit event, a permanent record of user activity on the server.
    """
    def __init__(self, undef_enabled=True):
        super(AuditEvent, self).__init__()
        self._type = ("AuditEvent", True)
        self._user_name = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._successful = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._user_agent = (self.__undef__, True)
        self._details = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AuditEvent, cls).from_dict(data, dirty, undef_enabled)
        obj._user_name = (data.get("userName", obj.__undef__), dirty)
        if obj._user_name[0] is not None and obj._user_name[0] is not obj.__undef__:
            assert isinstance(obj._user_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_name[0]))
            common.validate_format(obj._user_name[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._successful = (data.get("successful", obj.__undef__), dirty)
        if obj._successful[0] is not None and obj._successful[0] is not obj.__undef__:
            assert isinstance(obj._successful[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._successful[0]))
            common.validate_format(obj._successful[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._user_agent = (data.get("userAgent", obj.__undef__), dirty)
        if obj._user_agent[0] is not None and obj._user_agent[0] is not obj.__undef__:
            assert isinstance(obj._user_agent[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_agent[0]))
            common.validate_format(obj._user_agent[0], "None", None, None)
        obj._details = (data.get("details", obj.__undef__), dirty)
        if obj._details[0] is not None and obj._details[0] is not obj.__undef__:
            assert isinstance(obj._details[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._details[0]))
            common.validate_format(obj._details[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AuditEvent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "user_name" == "type" or (self.user_name is not self.__undef__ and not (dirty and not self._user_name[1])):
            dct["userName"] = dictify(self.user_name)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "successful" == "type" or (self.successful is not self.__undef__ and not (dirty and not self._successful[1])):
            dct["successful"] = dictify(self.successful)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "user_agent" == "type" or (self.user_agent is not self.__undef__ and not (dirty and not self._user_agent[1])):
            dct["userAgent"] = dictify(self.user_agent)
        if "details" == "type" or (self.details is not self.__undef__ and not (dirty and not self._details[1])):
            dct["details"] = dictify(self.details)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._user_name = (self._user_name[0], True)
        self._title = (self._title[0], True)
        self._successful = (self._successful[0], True)
        self._user = (self._user[0], True)
        self._start_time = (self._start_time[0], True)
        self._user_agent = (self._user_agent[0], True)
        self._details = (self._details[0], True)

    def is_dirty(self):
        return any([self._user_name[1], self._title[1], self._successful[1], self._user[1], self._start_time[1], self._user_agent[1], self._details[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AuditEvent):
            return False
        return super(AuditEvent, self).__eq__(other) and \
               self.user_name == other.user_name and \
               self.title == other.title and \
               self.successful == other.successful and \
               self.user == other.user and \
               self.start_time == other.start_time and \
               self.user_agent == other.user_agent and \
               self.details == other.details

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def user_name(self):
        """
        Name of user that initiated the action.

        :rtype: ``basestring``
        """
        return self._user_name[0]

    @user_name.setter
    def user_name(self, value):
        self._user_name = (value, True)

    @property
    def title(self):
        """
        Audit event title.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def successful(self):
        """
        Indicates whether the action was successful or not.

        :rtype: ``bool``
        """
        return self._successful[0]

    @successful.setter
    def successful(self, value):
        self._successful = (value, True)

    @property
    def user(self):
        """
        User that initiated the action.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def start_time(self):
        """
        The time the event occurred. For long running processes, this
        represents the starting time.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def user_agent(self):
        """
        Name of client software used to initiate the action.

        :rtype: ``basestring``
        """
        return self._user_agent[0]

    @user_agent.setter
    def user_agent(self, value):
        self._user_agent = (value, True)

    @property
    def details(self):
        """
        Plain text description of the audit event.

        :rtype: ``basestring``
        """
        return self._details[0]

    @details.setter
    def details(self, value):
        self._details = (value, True)

class SNMPManager(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* SNMP manager
    configuration
    """
    def __init__(self, undef_enabled=True):
        super(SNMPManager, self).__init__()
        self._type = ("SNMPManager", True)
        self._address = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._last_send_status = (self.__undef__, True)
        self._community_string = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SNMPManager, cls).from_dict(data, dirty, undef_enabled)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._last_send_status = (data.get("lastSendStatus", obj.__undef__), dirty)
        if obj._last_send_status[0] is not None and obj._last_send_status[0] is not obj.__undef__:
            assert isinstance(obj._last_send_status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_send_status[0]))
            assert obj._last_send_status[0] in [u'FAILED', u'SUCCEEDED', u'PENDING'], "Expected enum [u'FAILED', u'SUCCEEDED', u'PENDING'] but got %s" % obj._last_send_status[0]
            common.validate_format(obj._last_send_status[0], "None", None, None)
        obj._community_string = (data.get("communityString", obj.__undef__), dirty)
        if obj._community_string[0] is not None and obj._community_string[0] is not obj.__undef__:
            assert isinstance(obj._community_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._community_string[0]))
            common.validate_format(obj._community_string[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SNMPManager, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "last_send_status" == "type" or (self.last_send_status is not self.__undef__ and not (dirty and not self._last_send_status[1])):
            dct["lastSendStatus"] = dictify(self.last_send_status)
        if dirty and "lastSendStatus" in dct:
            del dct["lastSendStatus"]
        if "community_string" == "type" or (self.community_string is not self.__undef__ and not (dirty and not self._community_string[1])):
            dct["communityString"] = dictify(self.community_string)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._address = (self._address[0], True)
        self._port = (self._port[0], True)
        self._last_send_status = (self._last_send_status[0], True)
        self._community_string = (self._community_string[0], True)

    def is_dirty(self):
        return any([self._address[1], self._port[1], self._last_send_status[1], self._community_string[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SNMPManager):
            return False
        return super(SNMPManager, self).__eq__(other) and \
               self.address == other.address and \
               self.port == other.port and \
               self.last_send_status == other.last_send_status and \
               self.community_string == other.community_string

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def address(self):
        """
        SNMP manager host.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def port(self):
        """
        *(default value: 162)* SNMP manager port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def last_send_status(self):
        """
        *(default value: PENDING)* Describes if the most recent attempt to send
        a trap succeeded or failed. *(permitted values: FAILED, SUCCEEDED,
        PENDING)*

        :rtype: ``basestring``
        """
        return self._last_send_status[0]

    @property
    def community_string(self):
        """
        SNMP manager community string.

        :rtype: ``basestring``
        """
        return self._community_string[0]

    @community_string.setter
    def community_string(self, value):
        self._community_string = (value, True)

class AlertProfile(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* A profile that
    describes a set of actions to take in response to an alert being generated.
    """
    def __init__(self, undef_enabled=True):
        super(AlertProfile, self).__init__()
        self._type = ("AlertProfile", True)
        self._severity_filter = (self.__undef__, True)
        self._target_filter = (self.__undef__, True)
        self._actions = (self.__undef__, True)
        self._event_filter = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertProfile, cls).from_dict(data, dirty, undef_enabled)
        obj._severity_filter = []
        for item in data.get("severityFilter") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            assert item in [u'INFORMATIONAL', u'WARNING', u'CRITICAL'], "Expected enum [u'INFORMATIONAL', u'WARNING', u'CRITICAL'] but got %s" % item
            common.validate_format(item, "None", None, None)
            obj._severity_filter.append(item)
        obj._severity_filter = (obj._severity_filter, dirty)
        obj._target_filter = []
        for item in data.get("targetFilter") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._target_filter.append(item)
        obj._target_filter = (obj._target_filter, dirty)
        obj._actions = []
        for item in data.get("actions") or []:
            obj._actions.append(factory.create_object(item))
            factory.validate_type(obj._actions[-1], "AlertAction")
        obj._actions = (obj._actions, dirty)
        obj._event_filter = []
        for item in data.get("eventFilter") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._event_filter.append(item)
        obj._event_filter = (obj._event_filter, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertProfile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "severity_filter" == "type" or (self.severity_filter is not self.__undef__ and not (dirty and not self._severity_filter[1])):
            dct["severityFilter"] = dictify(self.severity_filter)
        if "target_filter" == "type" or (self.target_filter is not self.__undef__ and not (dirty and not self._target_filter[1])):
            dct["targetFilter"] = dictify(self.target_filter)
        if "actions" == "type" or (self.actions is not self.__undef__ and not (dirty and not self._actions[1])):
            dct["actions"] = dictify(self.actions)
        if "event_filter" == "type" or (self.event_filter is not self.__undef__ and not (dirty and not self._event_filter[1])):
            dct["eventFilter"] = dictify(self.event_filter)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._severity_filter = (self._severity_filter[0], True)
        self._target_filter = (self._target_filter[0], True)
        self._actions = (self._actions[0], True)
        self._event_filter = (self._event_filter[0], True)

    def is_dirty(self):
        return any([self._severity_filter[1], self._target_filter[1], self._actions[1], self._event_filter[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertProfile):
            return False
        return super(AlertProfile, self).__eq__(other) and \
               self.severity_filter == other.severity_filter and \
               self.target_filter == other.target_filter and \
               self.actions == other.actions and \
               self.event_filter == other.event_filter

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def severity_filter(self):
        """
        Optional list of severity levels.  If non-empty, only alerts of the
        given severity are included.

        :rtype: ``list`` of ``basestring``
        """
        return self._severity_filter[0]

    @severity_filter.setter
    def severity_filter(self, value):
        self._severity_filter = (value, True)

    @property
    def target_filter(self):
        """
        Optional list of object references.  If non-empty, only alerts related
        to one of the targets or its children are included.

        :rtype: ``list`` of ``basestring``
        """
        return self._target_filter[0]

    @target_filter.setter
    def target_filter(self, value):
        self._target_filter = (value, True)

    @property
    def actions(self):
        """
        List of actions to take.  Only alerts visible to the user and matching
        the optional filters are included.  If there are multiple actions with
        the same result (such as emailing a user), only one result is acted
        upon.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.AlertAction`
        """
        return self._actions[0]

    @actions.setter
    def actions(self, value):
        self._actions = (value, True)

    @property
    def event_filter(self):
        """
        Optional list of event types.  If non-empty, only alerts of the given
        event type are included.  Each event type is a string representing the
        event class of the corresponding alerts.  Wildcards are supported to
        include classes of events.

        :rtype: ``list`` of ``basestring``
        """
        return self._event_filter[0]

    @event_filter.setter
    def event_filter(self, value):
        self._event_filter = (value, True)

class FaultEffect(PersistentObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PersistentObject` *)* An error
    affecting a user object whose root cause is a fault. A fault effect can
    only be resolved by resolving the fault which is its root cause.
    """
    def __init__(self, undef_enabled=True):
        super(FaultEffect, self).__init__()
        self._type = ("FaultEffect", True)
        self._severity = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._root_cause = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._action = (self.__undef__, True)
        self._bundle_id = (self.__undef__, True)
        self._caused_by = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FaultEffect, cls).from_dict(data, dirty, undef_enabled)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING'], "Expected enum [u'CRITICAL', u'WARNING'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._root_cause = (data.get("rootCause", obj.__undef__), dirty)
        if obj._root_cause[0] is not None and obj._root_cause[0] is not obj.__undef__:
            assert isinstance(obj._root_cause[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._root_cause[0]))
            common.validate_format(obj._root_cause[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._bundle_id = (data.get("bundleID", obj.__undef__), dirty)
        if obj._bundle_id[0] is not None and obj._bundle_id[0] is not obj.__undef__:
            assert isinstance(obj._bundle_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bundle_id[0]))
            common.validate_format(obj._bundle_id[0], "None", None, None)
        obj._caused_by = (data.get("causedBy", obj.__undef__), dirty)
        if obj._caused_by[0] is not None and obj._caused_by[0] is not obj.__undef__:
            assert isinstance(obj._caused_by[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._caused_by[0]))
            common.validate_format(obj._caused_by[0], "objectReference", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FaultEffect, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "root_cause" == "type" or (self.root_cause is not self.__undef__ and not (dirty and not self._root_cause[1])):
            dct["rootCause"] = dictify(self.root_cause)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "bundle_id" == "type" or (self.bundle_id is not self.__undef__ and not (dirty and not self._bundle_id[1])):
            dct["bundleID"] = dictify(self.bundle_id)
        if "caused_by" == "type" or (self.caused_by is not self.__undef__ and not (dirty and not self._caused_by[1])):
            dct["causedBy"] = dictify(self.caused_by)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._severity = (self._severity[0], True)
        self._title = (self._title[0], True)
        self._root_cause = (self._root_cause[0], True)
        self._description = (self._description[0], True)
        self._action = (self._action[0], True)
        self._bundle_id = (self._bundle_id[0], True)
        self._caused_by = (self._caused_by[0], True)
        self._response = (self._response[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._severity[1], self._title[1], self._root_cause[1], self._description[1], self._action[1], self._bundle_id[1], self._caused_by[1], self._response[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FaultEffect):
            return False
        return super(FaultEffect, self).__eq__(other) and \
               self.severity == other.severity and \
               self.title == other.title and \
               self.root_cause == other.root_cause and \
               self.description == other.description and \
               self.action == other.action and \
               self.bundle_id == other.bundle_id and \
               self.caused_by == other.caused_by and \
               self.response == other.response and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def severity(self):
        """
        The severity of the fault effect. This can either be CRITICAL or
        WARNING. *(permitted values: CRITICAL, WARNING)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

    @property
    def title(self):
        """
        Summary of the fault effect.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def root_cause(self):
        """
        The root cause of this fault effect. Resolving the fault effect can
        only occur by resolving its root cause.

        :rtype: ``basestring``
        """
        return self._root_cause[0]

    @root_cause.setter
    def root_cause(self, value):
        self._root_cause = (value, True)

    @property
    def description(self):
        """
        Full description of the fault effect.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def action(self):
        """
        A suggested user action.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def bundle_id(self):
        """
        A unique dot delimited identifier associated with the fault effect.

        :rtype: ``basestring``
        """
        return self._bundle_id[0]

    @bundle_id.setter
    def bundle_id(self, value):
        self._bundle_id = (value, True)

    @property
    def caused_by(self):
        """
        The cause of the fault effect, in case there is a chain of fault
        effects originating from the root cause which resulted in this effect.

        :rtype: ``basestring``
        """
        return self._caused_by[0]

    @caused_by.setter
    def caused_by(self, value):
        self._caused_by = (value, True)

    @property
    def response(self):
        """
        The automated response taken by the system.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def target(self):
        """
        The user-visible Delphix object that has a fault effect.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class NetworkInterface(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Configuration of an IP
    interface.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterface, self).__init__()
        self._type = ("NetworkInterface", True)
        self._mac_address = (self.__undef__, True)
        self._addresses = (self.__undef__, True)
        self._mtu = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._device = (self.__undef__, True)
        self._mtu_range = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterface, cls).from_dict(data, dirty, undef_enabled)
        obj._mac_address = (data.get("macAddress", obj.__undef__), dirty)
        if obj._mac_address[0] is not None and obj._mac_address[0] is not obj.__undef__:
            assert isinstance(obj._mac_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mac_address[0]))
            common.validate_format(obj._mac_address[0], "macAddress", None, None)
        obj._addresses = []
        for item in data.get("addresses") or []:
            obj._addresses.append(factory.create_object(item))
            factory.validate_type(obj._addresses[-1], "InterfaceAddress")
        obj._addresses = (obj._addresses, dirty)
        obj._mtu = (data.get("mtu", obj.__undef__), dirty)
        if obj._mtu[0] is not None and obj._mtu[0] is not obj.__undef__:
            assert isinstance(obj._mtu[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._mtu[0]))
            common.validate_format(obj._mtu[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'OK', u'DOWN', u'FAILED'], "Expected enum [u'OK', u'DOWN', u'FAILED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._device = (data.get("device", obj.__undef__), dirty)
        if obj._device[0] is not None and obj._device[0] is not obj.__undef__:
            assert isinstance(obj._device[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._device[0]))
            common.validate_format(obj._device[0], "None", None, None)
        obj._mtu_range = (data.get("mtuRange", obj.__undef__), dirty)
        if obj._mtu_range[0] is not None and obj._mtu_range[0] is not obj.__undef__:
            assert isinstance(obj._mtu_range[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mtu_range[0]))
            common.validate_format(obj._mtu_range[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterface, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mac_address" == "type" or (self.mac_address is not self.__undef__ and not (dirty and not self._mac_address[1])):
            dct["macAddress"] = dictify(self.mac_address)
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        if "mtu" == "type" or (self.mtu is not self.__undef__ and not (dirty and not self._mtu[1])):
            dct["mtu"] = dictify(self.mtu)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "device" == "type" or (self.device is not self.__undef__ and not (dirty and not self._device[1])):
            dct["device"] = dictify(self.device)
        if "mtu_range" == "type" or (self.mtu_range is not self.__undef__ and not (dirty and not self._mtu_range[1])):
            dct["mtuRange"] = dictify(self.mtu_range)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mac_address = (self._mac_address[0], True)
        self._addresses = (self._addresses[0], True)
        self._mtu = (self._mtu[0], True)
        self._state = (self._state[0], True)
        self._device = (self._device[0], True)
        self._mtu_range = (self._mtu_range[0], True)

    def is_dirty(self):
        return any([self._mac_address[1], self._addresses[1], self._mtu[1], self._state[1], self._device[1], self._mtu_range[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterface):
            return False
        return super(NetworkInterface, self).__eq__(other) and \
               self.mac_address == other.mac_address and \
               self.addresses == other.addresses and \
               self.mtu == other.mtu and \
               self.state == other.state and \
               self.device == other.device and \
               self.mtu_range == other.mtu_range

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mac_address(self):
        """
        The MAC address associated with this interface.

        :rtype: ``basestring``
        """
        return self._mac_address[0]

    @mac_address.setter
    def mac_address(self, value):
        self._mac_address = (value, True)

    @property
    def addresses(self):
        """
        List of IP addresses assigned to the interface.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.InterfaceAddress`
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

    @property
    def mtu(self):
        """
        The maximum transmission unit for this interface.

        :rtype: ``int``
        """
        return self._mtu[0]

    @mtu.setter
    def mtu(self, value):
        self._mtu = (value, True)

    @property
    def state(self):
        """
        The state of the interface. *(permitted values: OK, DOWN, FAILED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def device(self):
        """
        The name of the device over which this interface is configured.

        :rtype: ``basestring``
        """
        return self._device[0]

    @device.setter
    def device(self, value):
        self._device = (value, True)

    @property
    def mtu_range(self):
        """
        The range of possible values for the mtu property.

        :rtype: ``basestring``
        """
        return self._mtu_range[0]

    @mtu_range.setter
    def mtu_range(self, value):
        self._mtu_range = (value, True)

class Policy(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* The base policy type.
    """
    def __init__(self, undef_enabled=True):
        super(Policy, self).__init__()
        self._type = ("Policy", True)
        self._default = (self.__undef__, True)
        self._effective_type = (self.__undef__, True)
        self._customized = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Policy, cls).from_dict(data, dirty, undef_enabled)
        obj._default = (data.get("default", obj.__undef__), dirty)
        if obj._default[0] is not None and obj._default[0] is not obj.__undef__:
            assert isinstance(obj._default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._default[0]))
            common.validate_format(obj._default[0], "None", None, None)
        obj._effective_type = (data.get("effectiveType", obj.__undef__), dirty)
        if obj._effective_type[0] is not None and obj._effective_type[0] is not obj.__undef__:
            assert isinstance(obj._effective_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._effective_type[0]))
            assert obj._effective_type[0] in [u'DIRECT_APPLIED', u'INHERITED'], "Expected enum [u'DIRECT_APPLIED', u'INHERITED'] but got %s" % obj._effective_type[0]
            common.validate_format(obj._effective_type[0], "None", None, None)
        obj._customized = (data.get("customized", obj.__undef__), dirty)
        if obj._customized[0] is not None and obj._customized[0] is not obj.__undef__:
            assert isinstance(obj._customized[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._customized[0]))
            common.validate_format(obj._customized[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Policy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "default" == "type" or (self.default is not self.__undef__ and not (dirty and not self._default[1])):
            dct["default"] = dictify(self.default)
        if "effective_type" == "type" or (self.effective_type is not self.__undef__ and not (dirty and not self._effective_type[1])):
            dct["effectiveType"] = dictify(self.effective_type)
        if "customized" == "type" or (self.customized is not self.__undef__ and not (dirty and not self._customized[1])):
            dct["customized"] = dictify(self.customized)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._default = (self._default[0], True)
        self._effective_type = (self._effective_type[0], True)
        self._customized = (self._customized[0], True)

    def is_dirty(self):
        return any([self._default[1], self._effective_type[1], self._customized[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Policy):
            return False
        return super(Policy, self).__eq__(other) and \
               self.default == other.default and \
               self.effective_type == other.effective_type and \
               self.customized == other.customized

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def default(self):
        """
        True if this is the default policy created when the system is setup.
        Default policies cannot be deleted.

        :rtype: ``bool``
        """
        return self._default[0]

    @default.setter
    def default(self, value):
        self._default = (value, True)

    @property
    def effective_type(self):
        """
        Whether this policy has been directly applied or inherited. See the
        effectivePolicies parameter of the list call for details. *(permitted
        values: DIRECT_APPLIED, INHERITED)*

        :rtype: ``basestring``
        """
        return self._effective_type[0]

    @effective_type.setter
    def effective_type(self, value):
        self._effective_type = (value, True)

    @property
    def customized(self):
        """
        True if this policy is customized specifically for one object.
        Customized policies cannot be shared between objects.

        :rtype: ``bool``
        """
        return self._customized[0]

    @customized.setter
    def customized(self, value):
        self._customized = (value, True)

class X509Certificate(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* X509 Certificate.
    """
    def __init__(self, undef_enabled=True):
        super(X509Certificate, self).__init__()
        self._type = ("X509Certificate", True)
        self._accepted = (self.__undef__, True)
        self._sha1_fingerprint = (self.__undef__, True)
        self._valid_to = (self.__undef__, True)
        self._serial_number = (self.__undef__, True)
        self._issued_by_dn = (self.__undef__, True)
        self._md5_fingerprint = (self.__undef__, True)
        self._valid_from = (self.__undef__, True)
        self._issued_to_dn = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(X509Certificate, cls).from_dict(data, dirty, undef_enabled)
        obj._accepted = (data.get("accepted", obj.__undef__), dirty)
        if obj._accepted[0] is not None and obj._accepted[0] is not obj.__undef__:
            assert isinstance(obj._accepted[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._accepted[0]))
            common.validate_format(obj._accepted[0], "None", None, None)
        obj._sha1_fingerprint = (data.get("sha1Fingerprint", obj.__undef__), dirty)
        if obj._sha1_fingerprint[0] is not None and obj._sha1_fingerprint[0] is not obj.__undef__:
            assert isinstance(obj._sha1_fingerprint[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._sha1_fingerprint[0]))
            common.validate_format(obj._sha1_fingerprint[0], "None", None, None)
        obj._valid_to = (data.get("validTo", obj.__undef__), dirty)
        if obj._valid_to[0] is not None and obj._valid_to[0] is not obj.__undef__:
            assert isinstance(obj._valid_to[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._valid_to[0]))
            common.validate_format(obj._valid_to[0], "None", None, None)
        obj._serial_number = (data.get("serialNumber", obj.__undef__), dirty)
        if obj._serial_number[0] is not None and obj._serial_number[0] is not obj.__undef__:
            assert isinstance(obj._serial_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._serial_number[0]))
            common.validate_format(obj._serial_number[0], "None", None, None)
        obj._issued_by_dn = (data.get("issuedByDN", obj.__undef__), dirty)
        if obj._issued_by_dn[0] is not None and obj._issued_by_dn[0] is not obj.__undef__:
            assert isinstance(obj._issued_by_dn[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._issued_by_dn[0]))
            common.validate_format(obj._issued_by_dn[0], "None", None, None)
        obj._md5_fingerprint = (data.get("md5Fingerprint", obj.__undef__), dirty)
        if obj._md5_fingerprint[0] is not None and obj._md5_fingerprint[0] is not obj.__undef__:
            assert isinstance(obj._md5_fingerprint[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._md5_fingerprint[0]))
            common.validate_format(obj._md5_fingerprint[0], "None", None, None)
        obj._valid_from = (data.get("validFrom", obj.__undef__), dirty)
        if obj._valid_from[0] is not None and obj._valid_from[0] is not obj.__undef__:
            assert isinstance(obj._valid_from[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._valid_from[0]))
            common.validate_format(obj._valid_from[0], "None", None, None)
        obj._issued_to_dn = (data.get("issuedToDN", obj.__undef__), dirty)
        if obj._issued_to_dn[0] is not None and obj._issued_to_dn[0] is not obj.__undef__:
            assert isinstance(obj._issued_to_dn[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._issued_to_dn[0]))
            common.validate_format(obj._issued_to_dn[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(X509Certificate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "accepted" == "type" or (self.accepted is not self.__undef__ and not (dirty and not self._accepted[1])):
            dct["accepted"] = dictify(self.accepted)
        if "sha1_fingerprint" == "type" or (self.sha1_fingerprint is not self.__undef__ and not (dirty and not self._sha1_fingerprint[1])):
            dct["sha1Fingerprint"] = dictify(self.sha1_fingerprint)
        if "valid_to" == "type" or (self.valid_to is not self.__undef__ and not (dirty and not self._valid_to[1])):
            dct["validTo"] = dictify(self.valid_to)
        if "serial_number" == "type" or (self.serial_number is not self.__undef__ and not (dirty and not self._serial_number[1])):
            dct["serialNumber"] = dictify(self.serial_number)
        if "issued_by_dn" == "type" or (self.issued_by_dn is not self.__undef__ and not (dirty and not self._issued_by_dn[1])):
            dct["issuedByDN"] = dictify(self.issued_by_dn)
        if "md5_fingerprint" == "type" or (self.md5_fingerprint is not self.__undef__ and not (dirty and not self._md5_fingerprint[1])):
            dct["md5Fingerprint"] = dictify(self.md5_fingerprint)
        if "valid_from" == "type" or (self.valid_from is not self.__undef__ and not (dirty and not self._valid_from[1])):
            dct["validFrom"] = dictify(self.valid_from)
        if "issued_to_dn" == "type" or (self.issued_to_dn is not self.__undef__ and not (dirty and not self._issued_to_dn[1])):
            dct["issuedToDN"] = dictify(self.issued_to_dn)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._accepted = (self._accepted[0], True)
        self._sha1_fingerprint = (self._sha1_fingerprint[0], True)
        self._valid_to = (self._valid_to[0], True)
        self._serial_number = (self._serial_number[0], True)
        self._issued_by_dn = (self._issued_by_dn[0], True)
        self._md5_fingerprint = (self._md5_fingerprint[0], True)
        self._valid_from = (self._valid_from[0], True)
        self._issued_to_dn = (self._issued_to_dn[0], True)

    def is_dirty(self):
        return any([self._accepted[1], self._sha1_fingerprint[1], self._valid_to[1], self._serial_number[1], self._issued_by_dn[1], self._md5_fingerprint[1], self._valid_from[1], self._issued_to_dn[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, X509Certificate):
            return False
        return super(X509Certificate, self).__eq__(other) and \
               self.accepted == other.accepted and \
               self.sha1_fingerprint == other.sha1_fingerprint and \
               self.valid_to == other.valid_to and \
               self.serial_number == other.serial_number and \
               self.issued_by_dn == other.issued_by_dn and \
               self.md5_fingerprint == other.md5_fingerprint and \
               self.valid_from == other.valid_from and \
               self.issued_to_dn == other.issued_to_dn

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def accepted(self):
        """
        Delphix trusts this certificate .

        :rtype: ``bool``
        """
        return self._accepted[0]

    @accepted.setter
    def accepted(self, value):
        self._accepted = (value, True)

    @property
    def sha1_fingerprint(self):
        """
        SHA-1 fingerprint.

        :rtype: ``basestring``
        """
        return self._sha1_fingerprint[0]

    @sha1_fingerprint.setter
    def sha1_fingerprint(self, value):
        self._sha1_fingerprint = (value, True)

    @property
    def valid_to(self):
        """
        End of validity.

        :rtype: ``basestring``
        """
        return self._valid_to[0]

    @valid_to.setter
    def valid_to(self, value):
        self._valid_to = (value, True)

    @property
    def serial_number(self):
        """
        Certificate serial number.

        :rtype: ``basestring``
        """
        return self._serial_number[0]

    @serial_number.setter
    def serial_number(self, value):
        self._serial_number = (value, True)

    @property
    def issued_by_dn(self):
        """
        Issuer of this certificate.

        :rtype: ``basestring``
        """
        return self._issued_by_dn[0]

    @issued_by_dn.setter
    def issued_by_dn(self, value):
        self._issued_by_dn = (value, True)

    @property
    def md5_fingerprint(self):
        """
        MD5 fingerprint.

        :rtype: ``basestring``
        """
        return self._md5_fingerprint[0]

    @md5_fingerprint.setter
    def md5_fingerprint(self, value):
        self._md5_fingerprint = (value, True)

    @property
    def valid_from(self):
        """
        Start of validity.

        :rtype: ``basestring``
        """
        return self._valid_from[0]

    @valid_from.setter
    def valid_from(self, value):
        self._valid_from = (value, True)

    @property
    def issued_to_dn(self):
        """
        Distinguished name of subject of this certificate.

        :rtype: ``basestring``
        """
        return self._issued_to_dn[0]

    @issued_to_dn.setter
    def issued_to_dn(self, value):
        self._issued_to_dn = (value, True)

class ReplicationSpec(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Replication setup.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationSpec, self).__init__()
        self._type = ("ReplicationSpec", True)
        self._target_credential = (self.__undef__, True)
        self._schedule = (self.__undef__, True)
        self._encrypted = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._objects = (self.__undef__, True)
        self._compressed = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._target_principal = (self.__undef__, True)
        self._target_port = (self.__undef__, True)
        self._target_host = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationSpec, cls).from_dict(data, dirty, undef_enabled)
        if "targetCredential" in data and data["targetCredential"] is not None:
            obj._target_credential = (factory.create_object(data["targetCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._target_credential[0], "PasswordCredential")
        else:
            obj._target_credential = (obj.__undef__, dirty)
        obj._schedule = (data.get("schedule", obj.__undef__), dirty)
        if obj._schedule[0] is not None and obj._schedule[0] is not obj.__undef__:
            assert isinstance(obj._schedule[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._schedule[0]))
            common.validate_format(obj._schedule[0], "None", 1, 256)
        obj._encrypted = (data.get("encrypted", obj.__undef__), dirty)
        if obj._encrypted[0] is not None and obj._encrypted[0] is not obj.__undef__:
            assert isinstance(obj._encrypted[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted[0]))
            common.validate_format(obj._encrypted[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._objects = []
        for item in data.get("objects") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._objects.append(item)
        obj._objects = (obj._objects, dirty)
        obj._compressed = (data.get("compressed", obj.__undef__), dirty)
        if obj._compressed[0] is not None and obj._compressed[0] is not obj.__undef__:
            assert isinstance(obj._compressed[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compressed[0]))
            common.validate_format(obj._compressed[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", 1, 256)
        obj._target_principal = (data.get("targetPrincipal", obj.__undef__), dirty)
        if obj._target_principal[0] is not None and obj._target_principal[0] is not obj.__undef__:
            assert isinstance(obj._target_principal[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_principal[0]))
            common.validate_format(obj._target_principal[0], "None", None, None)
        obj._target_port = (data.get("targetPort", obj.__undef__), dirty)
        if obj._target_port[0] is not None and obj._target_port[0] is not obj.__undef__:
            assert isinstance(obj._target_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._target_port[0]))
            common.validate_format(obj._target_port[0], "None", None, None)
        obj._target_host = (data.get("targetHost", obj.__undef__), dirty)
        if obj._target_host[0] is not None and obj._target_host[0] is not obj.__undef__:
            assert isinstance(obj._target_host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_host[0]))
            common.validate_format(obj._target_host[0], "host", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationSpec, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target_credential" == "type" or (self.target_credential is not self.__undef__ and not (dirty and not self._target_credential[1])):
            dct["targetCredential"] = dictify(self.target_credential)
        if "schedule" == "type" or (self.schedule is not self.__undef__ and not (dirty and not self._schedule[1])):
            dct["schedule"] = dictify(self.schedule)
        if "encrypted" == "type" or (self.encrypted is not self.__undef__ and not (dirty and not self._encrypted[1])):
            dct["encrypted"] = dictify(self.encrypted)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "objects" == "type" or (self.objects is not self.__undef__ and not (dirty and not self._objects[1])):
            dct["objects"] = dictify(self.objects)
        if "compressed" == "type" or (self.compressed is not self.__undef__ and not (dirty and not self._compressed[1])):
            dct["compressed"] = dictify(self.compressed)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "target_principal" == "type" or (self.target_principal is not self.__undef__ and not (dirty and not self._target_principal[1])):
            dct["targetPrincipal"] = dictify(self.target_principal)
        if "target_port" == "type" or (self.target_port is not self.__undef__ and not (dirty and not self._target_port[1])):
            dct["targetPort"] = dictify(self.target_port)
        if "target_host" == "type" or (self.target_host is not self.__undef__ and not (dirty and not self._target_host[1])):
            dct["targetHost"] = dictify(self.target_host)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target_credential = (self._target_credential[0], True)
        self._schedule = (self._schedule[0], True)
        self._encrypted = (self._encrypted[0], True)
        self._enabled = (self._enabled[0], True)
        self._objects = (self._objects[0], True)
        self._compressed = (self._compressed[0], True)
        self._tag = (self._tag[0], True)
        self._target_principal = (self._target_principal[0], True)
        self._target_port = (self._target_port[0], True)
        self._target_host = (self._target_host[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)

    def is_dirty(self):
        return any([self._target_credential[1], self._schedule[1], self._encrypted[1], self._enabled[1], self._objects[1], self._compressed[1], self._tag[1], self._target_principal[1], self._target_port[1], self._target_host[1], self._bandwidth_limit[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationSpec):
            return False
        return super(ReplicationSpec, self).__eq__(other) and \
               self.target_credential == other.target_credential and \
               self.schedule == other.schedule and \
               self.encrypted == other.encrypted and \
               self.enabled == other.enabled and \
               self.objects == other.objects and \
               self.compressed == other.compressed and \
               self.tag == other.tag and \
               self.target_principal == other.target_principal and \
               self.target_port == other.target_port and \
               self.target_host == other.target_host and \
               self.bandwidth_limit == other.bandwidth_limit

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target_credential(self):
        """
        Credential used to authenticate to the replication target host.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._target_credential[0]

    @target_credential.setter
    def target_credential(self, value):
        self._target_credential = (value, True)

    @property
    def schedule(self):
        """
        Replication schedule in the form of a quartz-formatted string.

        :rtype: ``basestring``
        """
        return self._schedule[0]

    @schedule.setter
    def schedule(self, value):
        self._schedule = (value, True)

    @property
    def encrypted(self):
        """
        Encrypt replication network traffic.

        :rtype: ``bool``
        """
        return self._encrypted[0]

    @encrypted.setter
    def encrypted(self, value):
        self._encrypted = (value, True)

    @property
    def enabled(self):
        """
        Indication whether the replication spec schedule is enabled or not.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def objects(self):
        """
        Objects to replicate, in canonical object reference form.

        :rtype: ``list`` of ``basestring``
        """
        return self._objects[0]

    @objects.setter
    def objects(self, value):
        self._objects = (value, True)

    @property
    def compressed(self):
        """
        Compress replication network traffic.

        :rtype: ``bool``
        """
        return self._compressed[0]

    @compressed.setter
    def compressed(self, value):
        self._compressed = (value, True)

    @property
    def tag(self):
        """
        Globally unique identifier for this replication spec.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def target_principal(self):
        """
        Principal name used to authenticate to the replication target host.

        :rtype: ``basestring``
        """
        return self._target_principal[0]

    @target_principal.setter
    def target_principal(self, value):
        self._target_principal = (value, True)

    @property
    def target_port(self):
        """
        *(default value: 8415)* Target TCP port number for the Delphix Session
        Protocol.

        :rtype: ``int``
        """
        return self._target_port[0]

    @target_port.setter
    def target_port(self, value):
        self._target_port = (value, True)

    @property
    def target_host(self):
        """
        Replication target host address.

        :rtype: ``basestring``
        """
        return self._target_host[0]

    @target_host.setter
    def target_host(self, value):
        self._target_host = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for replication network traffic. A value of 0
        means no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

class Role(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Describes a role as
    applied to a user on an object.
    """
    def __init__(self, undef_enabled=True):
        super(Role, self).__init__()
        self._type = ("Role", True)
        self._immutable = (self.__undef__, True)
        self._permissions = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Role, cls).from_dict(data, dirty, undef_enabled)
        obj._immutable = (data.get("immutable", obj.__undef__), dirty)
        if obj._immutable[0] is not None and obj._immutable[0] is not obj.__undef__:
            assert isinstance(obj._immutable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._immutable[0]))
            common.validate_format(obj._immutable[0], "None", None, None)
        obj._permissions = []
        for item in data.get("permissions") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._permissions.append(item)
        obj._permissions = (obj._permissions, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Role, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "immutable" == "type" or (self.immutable is not self.__undef__ and not (dirty and not self._immutable[1])):
            dct["immutable"] = dictify(self.immutable)
        if "permissions" == "type" or (self.permissions is not self.__undef__ and not (dirty and not self._permissions[1])):
            dct["permissions"] = dictify(self.permissions)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._immutable = (self._immutable[0], True)
        self._permissions = (self._permissions[0], True)

    def is_dirty(self):
        return any([self._immutable[1], self._permissions[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Role):
            return False
        return super(Role, self).__eq__(other) and \
               self.immutable == other.immutable and \
               self.permissions == other.permissions

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def immutable(self):
        """
        Determines if the role can be modified or not. Some roles are shipped
        with the Delphix Engine and cannot be changed.

        :rtype: ``bool``
        """
        return self._immutable[0]

    @immutable.setter
    def immutable(self, value):
        self._immutable = (value, True)

    @property
    def permissions(self):
        """
        List of permissions contained in the role.

        :rtype: ``list`` of ``basestring``
        """
        return self._permissions[0]

    @permissions.setter
    def permissions(self, value):
        self._permissions = (value, True)

class NamedUserObject(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Super schema for all
    schemas representing user-visible objects that have a name
    """
    def __init__(self, undef_enabled=True):
        super(NamedUserObject, self).__init__()
        self._type = ("NamedUserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NamedUserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NamedUserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NamedUserObject):
            return False
        return super(NamedUserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class Source(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* A source represents an
    external database instance outside the Delphix system.
    """
    def __init__(self, undef_enabled=True):
        super(Source, self).__init__()
        self._type = ("Source", True)
        self._status = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._virtual = (self.__undef__, True)
        self._staging = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Source, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'DEFAULT', u'PENDING_UPGRADE'], "Expected enum [u'DEFAULT', u'PENDING_UPGRADE'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._virtual = (data.get("virtual", obj.__undef__), dirty)
        if obj._virtual[0] is not None and obj._virtual[0] is not obj.__undef__:
            assert isinstance(obj._virtual[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._virtual[0]))
            common.validate_format(obj._virtual[0], "None", None, None)
        obj._staging = (data.get("staging", obj.__undef__), dirty)
        if obj._staging[0] is not None and obj._staging[0] is not obj.__undef__:
            assert isinstance(obj._staging[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging[0]))
            common.validate_format(obj._staging[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "SourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Source, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "virtual" == "type" or (self.virtual is not self.__undef__ and not (dirty and not self._virtual[1])):
            dct["virtual"] = dictify(self.virtual)
        if "staging" == "type" or (self.staging is not self.__undef__ and not (dirty and not self._staging[1])):
            dct["staging"] = dictify(self.staging)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._container = (self._container[0], True)
        self._description = (self._description[0], True)
        self._enabled = (self._enabled[0], True)
        self._virtual = (self._virtual[0], True)
        self._staging = (self._staging[0], True)
        self._runtime = (self._runtime[0], True)
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._status[1], self._container[1], self._description[1], self._enabled[1], self._virtual[1], self._staging[1], self._runtime[1], self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Source):
            return False
        return super(Source, self).__eq__(other) and \
               self.status == other.status and \
               self.container == other.container and \
               self.description == other.description and \
               self.enabled == other.enabled and \
               self.virtual == other.virtual and \
               self.staging == other.staging and \
               self.runtime == other.runtime and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Status of this source. *(permitted values: DEFAULT, PENDING_UPGRADE)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def container(self):
        """
        Reference to the container being fed by this source, if any.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def description(self):
        """
        A user-provided description of the source.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def enabled(self):
        """
        Flag indicating whether the source is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def virtual(self):
        """
        Flag indicating whether the source is managed by the Delphix system.

        :rtype: ``bool``
        """
        return self._virtual[0]

    @virtual.setter
    def virtual(self, value):
        self._virtual = (value, True)

    @property
    def staging(self):
        """
        Flag indicating whether the source is used as a staging source for pre-
        provisioning. Staging sources are managed by the Delphix system.

        :rtype: ``bool``
        """
        return self._staging[0]

    @staging.setter
    def staging(self, value):
        self._staging = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_3_0.web.vo.SourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class ReadonlyNamedUserObject(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Super schema for all
    schemas representing user-visible objects that have a read-only 'name'
    """
    def __init__(self, undef_enabled=True):
        super(ReadonlyNamedUserObject, self).__init__()
        self._type = ("ReadonlyNamedUserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReadonlyNamedUserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReadonlyNamedUserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if dirty and "name" in dct:
            del dct["name"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReadonlyNamedUserObject):
            return False
        return super(ReadonlyNamedUserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

class LocaleSettings(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* Global locale settings.
    """
    def __init__(self, undef_enabled=True):
        super(LocaleSettings, self).__init__()
        self._type = ("LocaleSettings", True)
        self._locale = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LocaleSettings, cls).from_dict(data, dirty, undef_enabled)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            common.validate_format(obj._locale[0], "None", 5, 5)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LocaleSettings, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._locale = (self._locale[0], True)

    def is_dirty(self):
        return any([self._locale[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LocaleSettings):
            return False
        return super(LocaleSettings, self).__eq__(other) and \
               self.locale == other.locale

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def locale(self):
        """
        *(default value: en_US)* Default locale in the system.

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

class SourceEnvironment(UserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.UserObject` *)* The generic source
    environment schema.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnvironment, self).__init__()
        self._type = ("SourceEnvironment", True)
        self._primary_user = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._description = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._primary_user = (data.get("primaryUser", obj.__undef__), dirty)
        if obj._primary_user[0] is not None and obj._primary_user[0] is not obj.__undef__:
            assert isinstance(obj._primary_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._primary_user[0]))
            common.validate_format(obj._primary_user[0], "objectReference", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "primary_user" == "type" or (self.primary_user is not self.__undef__ and not (dirty and not self._primary_user[1])):
            dct["primaryUser"] = dictify(self.primary_user)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._primary_user = (self._primary_user[0], True)
        self._enabled = (self._enabled[0], True)
        self._description = (self._description[0], True)

    def is_dirty(self):
        return any([self._primary_user[1], self._enabled[1], self._description[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnvironment):
            return False
        return super(SourceEnvironment, self).__eq__(other) and \
               self.primary_user == other.primary_user and \
               self.enabled == other.enabled and \
               self.description == other.description

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def primary_user(self):
        """
        A reference to the primary user for this environment.

        :rtype: ``basestring``
        """
        return self._primary_user[0]

    @primary_user.setter
    def primary_user(self, value):
        self._primary_user = (value, True)

    @property
    def enabled(self):
        """
        Indicates whether the source environment is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def description(self):
        """
        The environment description.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

class HostEnvironment(SourceEnvironment):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceEnvironment` *)* The
    representation of an host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(HostEnvironment, self).__init__()
        self._type = ("HostEnvironment", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostEnvironment):
            return False
        return super(HostEnvironment, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The reference to the associated host.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class OracleCluster(SourceEnvironment):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceEnvironment` *)* The
    representation of an oracle cluster environment object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCluster, self).__init__()
        self._type = ("OracleCluster", True)
        self._remote_listener = (self.__undef__, True)
        self._scan_manual = (self.__undef__, True)
        self._scan = (self.__undef__, True)
        self._cluster_user = (self.__undef__, True)
        self._crs_cluster_name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._crs_cluster_home = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCluster, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_listener = (data.get("remoteListener", obj.__undef__), dirty)
        if obj._remote_listener[0] is not None and obj._remote_listener[0] is not obj.__undef__:
            assert isinstance(obj._remote_listener[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_listener[0]))
            common.validate_format(obj._remote_listener[0], "None", None, 256)
        obj._scan_manual = (data.get("scanManual", obj.__undef__), dirty)
        if obj._scan_manual[0] is not None and obj._scan_manual[0] is not obj.__undef__:
            assert isinstance(obj._scan_manual[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._scan_manual[0]))
            common.validate_format(obj._scan_manual[0], "None", None, None)
        obj._scan = (data.get("scan", obj.__undef__), dirty)
        if obj._scan[0] is not None and obj._scan[0] is not obj.__undef__:
            assert isinstance(obj._scan[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._scan[0]))
            common.validate_format(obj._scan[0], "None", None, 256)
        obj._cluster_user = (data.get("clusterUser", obj.__undef__), dirty)
        if obj._cluster_user[0] is not None and obj._cluster_user[0] is not obj.__undef__:
            assert isinstance(obj._cluster_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_user[0]))
            common.validate_format(obj._cluster_user[0], "objectReference", None, None)
        obj._crs_cluster_name = (data.get("crsClusterName", obj.__undef__), dirty)
        if obj._crs_cluster_name[0] is not None and obj._crs_cluster_name[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_name[0]))
            common.validate_format(obj._crs_cluster_name[0], "None", None, 15)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, 14)
        obj._crs_cluster_home = (data.get("crsClusterHome", obj.__undef__), dirty)
        if obj._crs_cluster_home[0] is not None and obj._crs_cluster_home[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_home[0]))
            common.validate_format(obj._crs_cluster_home[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCluster, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_listener" == "type" or (self.remote_listener is not self.__undef__ and not (dirty and not self._remote_listener[1])):
            dct["remoteListener"] = dictify(self.remote_listener)
        if "scan_manual" == "type" or (self.scan_manual is not self.__undef__ and not (dirty and not self._scan_manual[1])):
            dct["scanManual"] = dictify(self.scan_manual)
        if "scan" == "type" or (self.scan is not self.__undef__ and not (dirty and not self._scan[1])):
            dct["scan"] = dictify(self.scan)
        if "cluster_user" == "type" or (self.cluster_user is not self.__undef__ and not (dirty and not self._cluster_user[1])):
            dct["clusterUser"] = dictify(self.cluster_user)
        if "crs_cluster_name" == "type" or (self.crs_cluster_name is not self.__undef__ and not (dirty and not self._crs_cluster_name[1])):
            dct["crsClusterName"] = dictify(self.crs_cluster_name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "crs_cluster_home" == "type" or (self.crs_cluster_home is not self.__undef__ and not (dirty and not self._crs_cluster_home[1])):
            dct["crsClusterHome"] = dictify(self.crs_cluster_home)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_listener = (self._remote_listener[0], True)
        self._scan_manual = (self._scan_manual[0], True)
        self._scan = (self._scan[0], True)
        self._cluster_user = (self._cluster_user[0], True)
        self._crs_cluster_name = (self._crs_cluster_name[0], True)
        self._version = (self._version[0], True)
        self._crs_cluster_home = (self._crs_cluster_home[0], True)

    def is_dirty(self):
        return any([self._remote_listener[1], self._scan_manual[1], self._scan[1], self._cluster_user[1], self._crs_cluster_name[1], self._version[1], self._crs_cluster_home[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCluster):
            return False
        return super(OracleCluster, self).__eq__(other) and \
               self.remote_listener == other.remote_listener and \
               self.scan_manual == other.scan_manual and \
               self.scan == other.scan and \
               self.cluster_user == other.cluster_user and \
               self.crs_cluster_name == other.crs_cluster_name and \
               self.version == other.version and \
               self.crs_cluster_home == other.crs_cluster_home

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_listener(self):
        """
        The default remote_listener parameter to be used for databases on the
        cluster.

        :rtype: ``basestring``
        """
        return self._remote_listener[0]

    @remote_listener.setter
    def remote_listener(self, value):
        self._remote_listener = (value, True)

    @property
    def scan_manual(self):
        """
        Indicates whether the Single Client Access Name of the cluster is
        manually configured.

        :rtype: ``bool``
        """
        return self._scan_manual[0]

    @scan_manual.setter
    def scan_manual(self, value):
        self._scan_manual = (value, True)

    @property
    def scan(self):
        """
        The Single Client Access Name of the cluster (11.2 and greater clusters
        only).

        :rtype: ``basestring``
        """
        return self._scan[0]

    @scan.setter
    def scan(self, value):
        self._scan = (value, True)

    @property
    def cluster_user(self):
        """
        A reference to the cluster user.

        :rtype: ``basestring``
        """
        return self._cluster_user[0]

    @cluster_user.setter
    def cluster_user(self, value):
        self._cluster_user = (value, True)

    @property
    def crs_cluster_name(self):
        """
        The name of the cluster.

        :rtype: ``basestring``
        """
        return self._crs_cluster_name[0]

    @crs_cluster_name.setter
    def crs_cluster_name(self, value):
        self._crs_cluster_name = (value, True)

    @property
    def version(self):
        """
        The version of the cluster.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def crs_cluster_home(self):
        """
        The location of the cluster installation.

        :rtype: ``basestring``
        """
        return self._crs_cluster_home[0]

    @crs_cluster_home.setter
    def crs_cluster_home(self, value):
        self._crs_cluster_home = (value, True)

class WindowsHostEnvironment(HostEnvironment):
    """
    *(extends* :py:class:`v1_3_0.web.vo.HostEnvironment` *)* The representation
    of a windows host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHostEnvironment, self).__init__()
        self._type = ("WindowsHostEnvironment", True)
        self._proxy = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._proxy = (data.get("proxy", obj.__undef__), dirty)
        if obj._proxy[0] is not None and obj._proxy[0] is not obj.__undef__:
            assert isinstance(obj._proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._proxy[0]))
            common.validate_format(obj._proxy[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "proxy" == "type" or (self.proxy is not self.__undef__ and not (dirty and not self._proxy[1])):
            dct["proxy"] = dictify(self.proxy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._proxy = (self._proxy[0], True)

    def is_dirty(self):
        return any([self._proxy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHostEnvironment):
            return False
        return super(WindowsHostEnvironment, self).__eq__(other) and \
               self.proxy == other.proxy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def proxy(self):
        """
        The reference to the proxy associated with the host.

        :rtype: ``basestring``
        """
        return self._proxy[0]

    @proxy.setter
    def proxy(self, value):
        self._proxy = (value, True)

class UnixHostEnvironment(HostEnvironment):
    """
    *(extends* :py:class:`v1_3_0.web.vo.HostEnvironment` *)* The representation
    of a unix host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHostEnvironment, self).__init__()
        self._type = ("UnixHostEnvironment", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHostEnvironment):
            return False
        return super(UnixHostEnvironment, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class Permission(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* Describes
    a permission to perform an operation on an object in the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(Permission, self).__init__()
        self._type = ("Permission", True)
        self._action_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Permission, cls).from_dict(data, dirty, undef_enabled)
        obj._action_type = (data.get("actionType", obj.__undef__), dirty)
        if obj._action_type[0] is not None and obj._action_type[0] is not obj.__undef__:
            assert isinstance(obj._action_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action_type[0]))
            common.validate_format(obj._action_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Permission, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action_type" == "type" or (self.action_type is not self.__undef__ and not (dirty and not self._action_type[1])):
            dct["actionType"] = dictify(self.action_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action_type = (self._action_type[0], True)

    def is_dirty(self):
        return any([self._action_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Permission):
            return False
        return super(Permission, self).__eq__(other) and \
               self.action_type == other.action_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action_type(self):
        """
        Name of the action governed by the permission.

        :rtype: ``basestring``
        """
        return self._action_type[0]

    @action_type.setter
    def action_type(self, value):
        self._action_type = (value, True)

class SourceConfig(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* The source
    config represents the dynamically discovered attributes of a source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConfig, self).__init__()
        self._type = ("SourceConfig", True)
        self._discovered = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._linking_enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._linking_enabled = (data.get("linkingEnabled", obj.__undef__), dirty)
        if obj._linking_enabled[0] is not None and obj._linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._linking_enabled[0]))
            common.validate_format(obj._linking_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "linking_enabled" == "type" or (self.linking_enabled is not self.__undef__ and not (dirty and not self._linking_enabled[1])):
            dct["linkingEnabled"] = dictify(self.linking_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._repository = (self._repository[0], True)
        self._linking_enabled = (self._linking_enabled[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._environment_user[1], self._repository[1], self._linking_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConfig):
            return False
        return super(SourceConfig, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.environment_user == other.environment_user and \
               self.repository == other.repository and \
               self.linking_enabled == other.linking_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this source was discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def environment_user(self):
        """
        The user used to create and manage the configuration.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def linking_enabled(self):
        """
        *(default value: True)* Whether this source should be used for linking.

        :rtype: ``bool``
        """
        return self._linking_enabled[0]

    @linking_enabled.setter
    def linking_enabled(self, value):
        self._linking_enabled = (value, True)

class LdapServer(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* LDAP
    Server Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(LdapServer, self).__init__()
        self._type = ("LdapServer", True)
        self._host = (self.__undef__, True)
        self._use_ssl = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._auth_method = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LdapServer, cls).from_dict(data, dirty, undef_enabled)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        if "useSSL" not in data:
            raise ValueError("Missing required property \"useSSL\".")
        obj._use_ssl = (data.get("useSSL", obj.__undef__), dirty)
        if obj._use_ssl[0] is not None and obj._use_ssl[0] is not obj.__undef__:
            assert isinstance(obj._use_ssl[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_ssl[0]))
            common.validate_format(obj._use_ssl[0], "None", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "authMethod" not in data:
            raise ValueError("Missing required property \"authMethod\".")
        obj._auth_method = (data.get("authMethod", obj.__undef__), dirty)
        if obj._auth_method[0] is not None and obj._auth_method[0] is not obj.__undef__:
            assert isinstance(obj._auth_method[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_method[0]))
            assert obj._auth_method[0] in [u'SIMPLE', u'DIGEST_MD5'], "Expected enum [u'SIMPLE', u'DIGEST_MD5'] but got %s" % obj._auth_method[0]
            common.validate_format(obj._auth_method[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LdapServer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "use_ssl" == "type" or (self.use_ssl is not self.__undef__ and not (dirty and not self._use_ssl[1])):
            dct["useSSL"] = dictify(self.use_ssl)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "auth_method" == "type" or (self.auth_method is not self.__undef__ and not (dirty and not self._auth_method[1])):
            dct["authMethod"] = dictify(self.auth_method)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._use_ssl = (self._use_ssl[0], True)
        self._port = (self._port[0], True)
        self._auth_method = (self._auth_method[0], True)

    def is_dirty(self):
        return any([self._host[1], self._use_ssl[1], self._port[1], self._auth_method[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LdapServer):
            return False
        return super(LdapServer, self).__eq__(other) and \
               self.host == other.host and \
               self.use_ssl == other.use_ssl and \
               self.port == other.port and \
               self.auth_method == other.auth_method

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        LDAP server host name.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def use_ssl(self):
        """
        Authentiate using SSL.

        :rtype: ``bool``
        """
        return self._use_ssl[0]

    @use_ssl.setter
    def use_ssl(self, value):
        self._use_ssl = (value, True)

    @property
    def port(self):
        """
        LDAP server port.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def auth_method(self):
        """
        LDAP authentication method. *(permitted values: SIMPLE, DIGEST_MD5)*

        :rtype: ``basestring``
        """
        return self._auth_method[0]

    @auth_method.setter
    def auth_method(self, value):
        self._auth_method = (value, True)

class Host(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* The
    representation of a host object.
    """
    def __init__(self, undef_enabled=True):
        super(Host, self).__init__()
        self._type = ("Host", True)
        self._host_configuration = (self.__undef__, True)
        self._date_added = (self.__undef__, True)
        self._addresses = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._host_runtime = (self.__undef__, True)
        self._ssh_port = (self.__undef__, True)
        self._toolkit_path = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Host, cls).from_dict(data, dirty, undef_enabled)
        if "hostConfiguration" in data and data["hostConfiguration"] is not None:
            obj._host_configuration = (factory.create_object(data["hostConfiguration"], "HostConfiguration"), dirty)
            factory.validate_type(obj._host_configuration[0], "HostConfiguration")
        else:
            obj._host_configuration = (obj.__undef__, dirty)
        obj._date_added = (data.get("dateAdded", obj.__undef__), dirty)
        if obj._date_added[0] is not None and obj._date_added[0] is not obj.__undef__:
            assert isinstance(obj._date_added[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_added[0]))
            common.validate_format(obj._date_added[0], "None", None, None)
        obj._addresses = []
        for item in data.get("addresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "host", None, None)
            obj._addresses.append(item)
        obj._addresses = (obj._addresses, dirty)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        if "hostRuntime" in data and data["hostRuntime"] is not None:
            obj._host_runtime = (factory.create_object(data["hostRuntime"], "HostRuntime"), dirty)
            factory.validate_type(obj._host_runtime[0], "HostRuntime")
        else:
            obj._host_runtime = (obj.__undef__, dirty)
        obj._ssh_port = (data.get("sshPort", obj.__undef__), dirty)
        if obj._ssh_port[0] is not None and obj._ssh_port[0] is not obj.__undef__:
            assert isinstance(obj._ssh_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._ssh_port[0]))
            common.validate_format(obj._ssh_port[0], "None", None, None)
        obj._toolkit_path = (data.get("toolkitPath", obj.__undef__), dirty)
        if obj._toolkit_path[0] is not None and obj._toolkit_path[0] is not obj.__undef__:
            assert isinstance(obj._toolkit_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit_path[0]))
            common.validate_format(obj._toolkit_path[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Host, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_configuration" == "type" or (self.host_configuration is not self.__undef__ and not (dirty and not self._host_configuration[1])):
            dct["hostConfiguration"] = dictify(self.host_configuration)
        if "date_added" == "type" or (self.date_added is not self.__undef__ and not (dirty and not self._date_added[1])):
            dct["dateAdded"] = dictify(self.date_added)
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "host_runtime" == "type" or (self.host_runtime is not self.__undef__ and not (dirty and not self._host_runtime[1])):
            dct["hostRuntime"] = dictify(self.host_runtime)
        if "ssh_port" == "type" or (self.ssh_port is not self.__undef__ and not (dirty and not self._ssh_port[1])):
            dct["sshPort"] = dictify(self.ssh_port)
        if "toolkit_path" == "type" or (self.toolkit_path is not self.__undef__ and not (dirty and not self._toolkit_path[1])):
            dct["toolkitPath"] = dictify(self.toolkit_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_configuration = (self._host_configuration[0], True)
        self._date_added = (self._date_added[0], True)
        self._addresses = (self._addresses[0], True)
        self._enabled = (self._enabled[0], True)
        self._host_runtime = (self._host_runtime[0], True)
        self._ssh_port = (self._ssh_port[0], True)
        self._toolkit_path = (self._toolkit_path[0], True)

    def is_dirty(self):
        return any([self._host_configuration[1], self._date_added[1], self._addresses[1], self._enabled[1], self._host_runtime[1], self._ssh_port[1], self._toolkit_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Host):
            return False
        return super(Host, self).__eq__(other) and \
               self.host_configuration == other.host_configuration and \
               self.date_added == other.date_added and \
               self.addresses == other.addresses and \
               self.enabled == other.enabled and \
               self.host_runtime == other.host_runtime and \
               self.ssh_port == other.ssh_port and \
               self.toolkit_path == other.toolkit_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_configuration(self):
        """
        The host configuration object associated with the host.

        :rtype: :py:class:`v1_3_0.web.vo.HostConfiguration`
        """
        return self._host_configuration[0]

    @host_configuration.setter
    def host_configuration(self, value):
        self._host_configuration = (value, True)

    @property
    def date_added(self):
        """
        The date the host was added.

        :rtype: ``basestring``
        """
        return self._date_added[0]

    @date_added.setter
    def date_added(self, value):
        self._date_added = (value, True)

    @property
    def addresses(self):
        """
        The addresses associated with the host.

        :rtype: ``list`` of ``basestring``
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

    @property
    def enabled(self):
        """
        The boolean value indicating whether the host is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def host_runtime(self):
        """
        Runtime properties for this host.

        :rtype: :py:class:`v1_3_0.web.vo.HostRuntime`
        """
        return self._host_runtime[0]

    @host_runtime.setter
    def host_runtime(self, value):
        self._host_runtime = (value, True)

    @property
    def ssh_port(self):
        """
        *(default value: 22)* The port number used to connect to the host via
        SSH.

        :rtype: ``int``
        """
        return self._ssh_port[0]

    @ssh_port.setter
    def ssh_port(self, value):
        self._ssh_port = (value, True)

    @property
    def toolkit_path(self):
        """
        The path for the toolkit that resides on the host.

        :rtype: ``basestring``
        """
        return self._toolkit_path[0]

    @toolkit_path.setter
    def toolkit_path(self, value):
        self._toolkit_path = (value, True)

class Authorization(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* Describes
    a role as applied to a user on an object.
    """
    def __init__(self, undef_enabled=True):
        super(Authorization, self).__init__()
        self._type = ("Authorization", True)
        self._role = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Authorization, cls).from_dict(data, dirty, undef_enabled)
        obj._role = (data.get("role", obj.__undef__), dirty)
        if obj._role[0] is not None and obj._role[0] is not obj.__undef__:
            assert isinstance(obj._role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._role[0]))
            common.validate_format(obj._role[0], "objectReference", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Authorization, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "role" == "type" or (self.role is not self.__undef__ and not (dirty and not self._role[1])):
            dct["role"] = dictify(self.role)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._role = (self._role[0], True)
        self._target = (self._target[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._role[1], self._target[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Authorization):
            return False
        return super(Authorization, self).__eq__(other) and \
               self.role == other.role and \
               self.target == other.target and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def role(self):
        """
        Applied role.

        :rtype: ``basestring``
        """
        return self._role[0]

    @role.setter
    def role(self, value):
        self._role = (value, True)

    @property
    def target(self):
        """
        Reference to the object that the authorization applies to.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def user(self):
        """
        Reference to the user that the authorization applies to.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class SourceRepository(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ReadonlyNamedUserObject` *)* A source
    repository represents a container for the source config.
    """
    def __init__(self, undef_enabled=True):
        super(SourceRepository, self).__init__()
        self._type = ("SourceRepository", True)
        self._environment = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._staging = (self.__undef__, True)
        self._linking_enabled = (self.__undef__, True)
        self._provisioning_enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._staging = (data.get("staging", obj.__undef__), dirty)
        if obj._staging[0] is not None and obj._staging[0] is not obj.__undef__:
            assert isinstance(obj._staging[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging[0]))
            common.validate_format(obj._staging[0], "None", None, None)
        obj._linking_enabled = (data.get("linkingEnabled", obj.__undef__), dirty)
        if obj._linking_enabled[0] is not None and obj._linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._linking_enabled[0]))
            common.validate_format(obj._linking_enabled[0], "None", None, None)
        obj._provisioning_enabled = (data.get("provisioningEnabled", obj.__undef__), dirty)
        if obj._provisioning_enabled[0] is not None and obj._provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisioning_enabled[0]))
            common.validate_format(obj._provisioning_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "staging" == "type" or (self.staging is not self.__undef__ and not (dirty and not self._staging[1])):
            dct["staging"] = dictify(self.staging)
        if "linking_enabled" == "type" or (self.linking_enabled is not self.__undef__ and not (dirty and not self._linking_enabled[1])):
            dct["linkingEnabled"] = dictify(self.linking_enabled)
        if "provisioning_enabled" == "type" or (self.provisioning_enabled is not self.__undef__ and not (dirty and not self._provisioning_enabled[1])):
            dct["provisioningEnabled"] = dictify(self.provisioning_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._version = (self._version[0], True)
        self._staging = (self._staging[0], True)
        self._linking_enabled = (self._linking_enabled[0], True)
        self._provisioning_enabled = (self._provisioning_enabled[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._version[1], self._staging[1], self._linking_enabled[1], self._provisioning_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceRepository):
            return False
        return super(SourceRepository, self).__eq__(other) and \
               self.environment == other.environment and \
               self.version == other.version and \
               self.staging == other.staging and \
               self.linking_enabled == other.linking_enabled and \
               self.provisioning_enabled == other.provisioning_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Reference to the environment containing this repository.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def version(self):
        """
        Version of the repository.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def staging(self):
        """
        Flag indicating whether this repository can be used by the Delphix
        Engine for internal processing

        :rtype: ``bool``
        """
        return self._staging[0]

    @staging.setter
    def staging(self, value):
        self._staging = (value, True)

    @property
    def linking_enabled(self):
        """
        *(default value: True)* Flag indicating whether the repository should
        be used for linking.

        :rtype: ``bool``
        """
        return self._linking_enabled[0]

    @linking_enabled.setter
    def linking_enabled(self, value):
        self._linking_enabled = (value, True)

    @property
    def provisioning_enabled(self):
        """
        *(default value: True)* Flag indicating whether the repository should
        be used for provisioning.

        :rtype: ``bool``
        """
        return self._provisioning_enabled[0]

    @provisioning_enabled.setter
    def provisioning_enabled(self, value):
        self._provisioning_enabled = (value, True)

class PgSQLInstall(SourceRepository):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRepository` *)* A PostgreSQL
    installation.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLInstall, self).__init__()
        self._type = ("PgSQLInstall", True)
        self._installation_path = (self.__undef__, True)
        self._segment_size = (self.__undef__, True)
        self._variant = (self.__undef__, True)
        self._discovered = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._bits = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLInstall, cls).from_dict(data, dirty, undef_enabled)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, 1024)
        obj._segment_size = (data.get("segmentSize", obj.__undef__), dirty)
        if obj._segment_size[0] is not None and obj._segment_size[0] is not obj.__undef__:
            assert isinstance(obj._segment_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._segment_size[0]))
            assert obj._segment_size[0] in [1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864], "Expected enum [1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864] but got %s" % obj._segment_size[0]
            common.validate_format(obj._segment_size[0], "None", None, None)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'PostgreSQL', u'EnterpriseDB'], "Expected enum [u'PostgreSQL', u'EnterpriseDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "pgsqlVersion", None, None)
        obj._bits = (data.get("bits", obj.__undef__), dirty)
        if obj._bits[0] is not None and obj._bits[0] is not obj.__undef__:
            assert isinstance(obj._bits[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bits[0]))
            assert obj._bits[0] in [32, 64], "Expected enum [32, 64] but got %s" % obj._bits[0]
            common.validate_format(obj._bits[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLInstall, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "segment_size" == "type" or (self.segment_size is not self.__undef__ and not (dirty and not self._segment_size[1])):
            dct["segmentSize"] = dictify(self.segment_size)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "bits" == "type" or (self.bits is not self.__undef__ and not (dirty and not self._bits[1])):
            dct["bits"] = dictify(self.bits)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._installation_path = (self._installation_path[0], True)
        self._segment_size = (self._segment_size[0], True)
        self._variant = (self._variant[0], True)
        self._discovered = (self._discovered[0], True)
        self._version = (self._version[0], True)
        self._bits = (self._bits[0], True)

    def is_dirty(self):
        return any([self._installation_path[1], self._segment_size[1], self._variant[1], self._discovered[1], self._version[1], self._bits[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLInstall):
            return False
        return super(PgSQLInstall, self).__eq__(other) and \
               self.installation_path == other.installation_path and \
               self.segment_size == other.segment_size and \
               self.variant == other.variant and \
               self.discovered == other.discovered and \
               self.version == other.version and \
               self.bits == other.bits

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def installation_path(self):
        """
        Directory path where the installation is located.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def segment_size(self):
        """
        Size of the WAL segments (in bytes) generated by PostgreSQL binaries.
        *(permitted values: 1048576, 2097152, 4194304, 8388608, 16777216,
        33554432, 67108864)*

        :rtype: ``int``
        """
        return self._segment_size[0]

    @segment_size.setter
    def segment_size(self, value):
        self._segment_size = (value, True)

    @property
    def variant(self):
        """
        Variant of the repository. *(permitted values: PostgreSQL,
        EnterpriseDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

    @property
    def discovered(self):
        """
        Flag indicating whether the installation was discovered or manually
        entered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def version(self):
        """
        Version of the repository.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def bits(self):
        """
        32 or 64 bit installation. *(permitted values: 32, 64)*

        :rtype: ``int``
        """
        return self._bits[0]

    @bits.setter
    def bits(self, value):
        self._bits = (value, True)

class MSSqlInstance(SourceRepository):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRepository` *)* The MSSQL source
    repository.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlInstance, self).__init__()
        self._type = ("MSSqlInstance", True)
        self._installation_path = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)
        self._server_name = (self.__undef__, True)
        self._instance_owner = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, None)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        obj._server_name = (data.get("serverName", obj.__undef__), dirty)
        if obj._server_name[0] is not None and obj._server_name[0] is not obj.__undef__:
            assert isinstance(obj._server_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server_name[0]))
            common.validate_format(obj._server_name[0], "None", None, None)
        obj._instance_owner = (data.get("instanceOwner", obj.__undef__), dirty)
        if obj._instance_owner[0] is not None and obj._instance_owner[0] is not obj.__undef__:
            assert isinstance(obj._instance_owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_owner[0]))
            common.validate_format(obj._instance_owner[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        if "server_name" == "type" or (self.server_name is not self.__undef__ and not (dirty and not self._server_name[1])):
            dct["serverName"] = dictify(self.server_name)
        if "instance_owner" == "type" or (self.instance_owner is not self.__undef__ and not (dirty and not self._instance_owner[1])):
            dct["instanceOwner"] = dictify(self.instance_owner)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._installation_path = (self._installation_path[0], True)
        self._internal_version = (self._internal_version[0], True)
        self._server_name = (self._server_name[0], True)
        self._instance_owner = (self._instance_owner[0], True)
        self._instance_name = (self._instance_name[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._installation_path[1], self._internal_version[1], self._server_name[1], self._instance_owner[1], self._instance_name[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlInstance):
            return False
        return super(MSSqlInstance, self).__eq__(other) and \
               self.installation_path == other.installation_path and \
               self.internal_version == other.internal_version and \
               self.server_name == other.server_name and \
               self.instance_owner == other.instance_owner and \
               self.instance_name == other.instance_name and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def installation_path(self):
        """
        The MSSQL instance home.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def internal_version(self):
        """
        Internal version of the MSSQL instance.

        :rtype: ``int``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

    @property
    def server_name(self):
        """
        The Servername of the MSSQL instance.

        :rtype: ``basestring``
        """
        return self._server_name[0]

    @server_name.setter
    def server_name(self, value):
        self._server_name = (value, True)

    @property
    def instance_owner(self):
        """
        Account the MSSQL instance is running as.

        :rtype: ``basestring``
        """
        return self._instance_owner[0]

    @instance_owner.setter
    def instance_owner(self, value):
        self._instance_owner = (value, True)

    @property
    def instance_name(self):
        """
        The name of the MSSQL instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

    @property
    def port(self):
        """
        The network port for connecting to the MSSQL instance.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class AppDataRepository(SourceRepository):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRepository` *)* An AppData
    repository.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataRepository, self).__init__()
        self._type = ("AppDataRepository", True)
        self._toolkit = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._toolkit = (data.get("toolkit", obj.__undef__), dirty)
        if obj._toolkit[0] is not None and obj._toolkit[0] is not obj.__undef__:
            assert isinstance(obj._toolkit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit[0]))
            common.validate_format(obj._toolkit[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "toolkit" == "type" or (self.toolkit is not self.__undef__ and not (dirty and not self._toolkit[1])):
            dct["toolkit"] = dictify(self.toolkit)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._toolkit = (self._toolkit[0], True)

    def is_dirty(self):
        return any([self._toolkit[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataRepository):
            return False
        return super(AppDataRepository, self).__eq__(other) and \
               self.toolkit == other.toolkit

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def toolkit(self):
        """
        The toolkit associated with this repository.

        :rtype: ``basestring``
        """
        return self._toolkit[0]

    @toolkit.setter
    def toolkit(self, value):
        self._toolkit = (value, True)

class OracleInstall(SourceRepository):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRepository` *)* The Oracle source
    repository.
    """
    def __init__(self, undef_enabled=True):
        super(OracleInstall, self).__init__()
        self._type = ("OracleInstall", True)
        self._user_name = (self.__undef__, True)
        self._installation_home = (self.__undef__, True)
        self._user_id = (self.__undef__, True)
        self._logsync_possible = (self.__undef__, True)
        self._discovered = (self.__undef__, True)
        self._group_name = (self.__undef__, True)
        self._oracle_base = (self.__undef__, True)
        self._bits = (self.__undef__, True)
        self._group_id = (self.__undef__, True)
        self._rac = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleInstall, cls).from_dict(data, dirty, undef_enabled)
        obj._user_name = (data.get("userName", obj.__undef__), dirty)
        if obj._user_name[0] is not None and obj._user_name[0] is not obj.__undef__:
            assert isinstance(obj._user_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_name[0]))
            common.validate_format(obj._user_name[0], "None", None, None)
        obj._installation_home = (data.get("installationHome", obj.__undef__), dirty)
        if obj._installation_home[0] is not None and obj._installation_home[0] is not obj.__undef__:
            assert isinstance(obj._installation_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_home[0]))
            common.validate_format(obj._installation_home[0], "None", None, 256)
        obj._user_id = (data.get("userId", obj.__undef__), dirty)
        if obj._user_id[0] is not None and obj._user_id[0] is not obj.__undef__:
            assert isinstance(obj._user_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user_id[0]))
            common.validate_format(obj._user_id[0], "None", None, None)
        obj._logsync_possible = (data.get("logsyncPossible", obj.__undef__), dirty)
        if obj._logsync_possible[0] is not None and obj._logsync_possible[0] is not obj.__undef__:
            assert isinstance(obj._logsync_possible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._logsync_possible[0]))
            common.validate_format(obj._logsync_possible[0], "None", None, None)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._group_name = (data.get("groupName", obj.__undef__), dirty)
        if obj._group_name[0] is not None and obj._group_name[0] is not obj.__undef__:
            assert isinstance(obj._group_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group_name[0]))
            common.validate_format(obj._group_name[0], "None", None, None)
        obj._oracle_base = (data.get("oracleBase", obj.__undef__), dirty)
        if obj._oracle_base[0] is not None and obj._oracle_base[0] is not obj.__undef__:
            assert isinstance(obj._oracle_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._oracle_base[0]))
            common.validate_format(obj._oracle_base[0], "None", None, None)
        obj._bits = (data.get("bits", obj.__undef__), dirty)
        if obj._bits[0] is not None and obj._bits[0] is not obj.__undef__:
            assert isinstance(obj._bits[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bits[0]))
            common.validate_format(obj._bits[0], "None", None, None)
        obj._group_id = (data.get("groupId", obj.__undef__), dirty)
        if obj._group_id[0] is not None and obj._group_id[0] is not obj.__undef__:
            assert isinstance(obj._group_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._group_id[0]))
            common.validate_format(obj._group_id[0], "None", None, None)
        obj._rac = (data.get("rac", obj.__undef__), dirty)
        if obj._rac[0] is not None and obj._rac[0] is not obj.__undef__:
            assert isinstance(obj._rac[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._rac[0]))
            common.validate_format(obj._rac[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleInstall, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "user_name" == "type" or (self.user_name is not self.__undef__ and not (dirty and not self._user_name[1])):
            dct["userName"] = dictify(self.user_name)
        if "installation_home" == "type" or (self.installation_home is not self.__undef__ and not (dirty and not self._installation_home[1])):
            dct["installationHome"] = dictify(self.installation_home)
        if "user_id" == "type" or (self.user_id is not self.__undef__ and not (dirty and not self._user_id[1])):
            dct["userId"] = dictify(self.user_id)
        if "logsync_possible" == "type" or (self.logsync_possible is not self.__undef__ and not (dirty and not self._logsync_possible[1])):
            dct["logsyncPossible"] = dictify(self.logsync_possible)
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "group_name" == "type" or (self.group_name is not self.__undef__ and not (dirty and not self._group_name[1])):
            dct["groupName"] = dictify(self.group_name)
        if "oracle_base" == "type" or (self.oracle_base is not self.__undef__ and not (dirty and not self._oracle_base[1])):
            dct["oracleBase"] = dictify(self.oracle_base)
        if "bits" == "type" or (self.bits is not self.__undef__ and not (dirty and not self._bits[1])):
            dct["bits"] = dictify(self.bits)
        if "group_id" == "type" or (self.group_id is not self.__undef__ and not (dirty and not self._group_id[1])):
            dct["groupId"] = dictify(self.group_id)
        if "rac" == "type" or (self.rac is not self.__undef__ and not (dirty and not self._rac[1])):
            dct["rac"] = dictify(self.rac)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._user_name = (self._user_name[0], True)
        self._installation_home = (self._installation_home[0], True)
        self._user_id = (self._user_id[0], True)
        self._logsync_possible = (self._logsync_possible[0], True)
        self._discovered = (self._discovered[0], True)
        self._group_name = (self._group_name[0], True)
        self._oracle_base = (self._oracle_base[0], True)
        self._bits = (self._bits[0], True)
        self._group_id = (self._group_id[0], True)
        self._rac = (self._rac[0], True)

    def is_dirty(self):
        return any([self._user_name[1], self._installation_home[1], self._user_id[1], self._logsync_possible[1], self._discovered[1], self._group_name[1], self._oracle_base[1], self._bits[1], self._group_id[1], self._rac[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleInstall):
            return False
        return super(OracleInstall, self).__eq__(other) and \
               self.user_name == other.user_name and \
               self.installation_home == other.installation_home and \
               self.user_id == other.user_id and \
               self.logsync_possible == other.logsync_possible and \
               self.discovered == other.discovered and \
               self.group_name == other.group_name and \
               self.oracle_base == other.oracle_base and \
               self.bits == other.bits and \
               self.group_id == other.group_id and \
               self.rac == other.rac

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def user_name(self):
        """
        User name of the user that owns the install.

        :rtype: ``basestring``
        """
        return self._user_name[0]

    @user_name.setter
    def user_name(self, value):
        self._user_name = (value, True)

    @property
    def installation_home(self):
        """
        The Oracle install home.

        :rtype: ``basestring``
        """
        return self._installation_home[0]

    @installation_home.setter
    def installation_home(self, value):
        self._installation_home = (value, True)

    @property
    def user_id(self):
        """
        User ID of the user that owns the install.

        :rtype: ``int``
        """
        return self._user_id[0]

    @user_id.setter
    def user_id(self, value):
        self._user_id = (value, True)

    @property
    def logsync_possible(self):
        """
        Flag indicating whether this repository can use LogSync.

        :rtype: ``bool``
        """
        return self._logsync_possible[0]

    @logsync_possible.setter
    def logsync_possible(self, value):
        self._logsync_possible = (value, True)

    @property
    def discovered(self):
        """
        Flag indicating whether the install was discovered or manually entered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def group_name(self):
        """
        Group name of the user that owns the install.

        :rtype: ``basestring``
        """
        return self._group_name[0]

    @group_name.setter
    def group_name(self, value):
        self._group_name = (value, True)

    @property
    def oracle_base(self):
        """
        The Oracle base where database binaries are located.

        :rtype: ``basestring``
        """
        return self._oracle_base[0]

    @oracle_base.setter
    def oracle_base(self, value):
        self._oracle_base = (value, True)

    @property
    def bits(self):
        """
        32 or 64 bits.

        :rtype: ``int``
        """
        return self._bits[0]

    @bits.setter
    def bits(self, value):
        self._bits = (value, True)

    @property
    def group_id(self):
        """
        Group ID of the user that owns the install.

        :rtype: ``int``
        """
        return self._group_id[0]

    @group_id.setter
    def group_id(self, value):
        self._group_id = (value, True)

    @property
    def rac(self):
        """
        Flag indicating whether the install supports Oracle RAC.

        :rtype: ``bool``
        """
        return self._rac[0]

    @rac.setter
    def rac(self, value):
        self._rac = (value, True)

class UnixHost(Host):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Host` *)* The representation of a Unix
    host object.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHost, self).__init__()
        self._type = ("UnixHost", True)
        self._toolkit_path = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHost, cls).from_dict(data, dirty, undef_enabled)
        obj._toolkit_path = (data.get("toolkitPath", obj.__undef__), dirty)
        if obj._toolkit_path[0] is not None and obj._toolkit_path[0] is not obj.__undef__:
            assert isinstance(obj._toolkit_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit_path[0]))
            common.validate_format(obj._toolkit_path[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHost, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "toolkit_path" == "type" or (self.toolkit_path is not self.__undef__ and not (dirty and not self._toolkit_path[1])):
            dct["toolkitPath"] = dictify(self.toolkit_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._toolkit_path = (self._toolkit_path[0], True)

    def is_dirty(self):
        return any([self._toolkit_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHost):
            return False
        return super(UnixHost, self).__eq__(other) and \
               self.toolkit_path == other.toolkit_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def toolkit_path(self):
        """
        The path for the toolkit that resides on the host.

        :rtype: ``basestring``
        """
        return self._toolkit_path[0]

    @toolkit_path.setter
    def toolkit_path(self, value):
        self._toolkit_path = (value, True)

class WindowsHost(Host):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Host` *)* The representation of a
    Windows host object.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHost, self).__init__()
        self._type = ("WindowsHost", True)
        self._connector_authentication_key = (self.__undef__, True)
        self._connector_port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHost, cls).from_dict(data, dirty, undef_enabled)
        obj._connector_authentication_key = (data.get("connectorAuthenticationKey", obj.__undef__), dirty)
        if obj._connector_authentication_key[0] is not None and obj._connector_authentication_key[0] is not obj.__undef__:
            assert isinstance(obj._connector_authentication_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_authentication_key[0]))
            common.validate_format(obj._connector_authentication_key[0], "None", None, None)
        obj._connector_port = (data.get("connectorPort", obj.__undef__), dirty)
        if obj._connector_port[0] is not None and obj._connector_port[0] is not obj.__undef__:
            assert isinstance(obj._connector_port[0], float), ("Expected one of [u'number'], but got %s" % type(obj._connector_port[0]))
            common.validate_format(obj._connector_port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHost, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connector_authentication_key" == "type" or (self.connector_authentication_key is not self.__undef__ and not (dirty and not self._connector_authentication_key[1])):
            dct["connectorAuthenticationKey"] = dictify(self.connector_authentication_key)
        if "connector_port" == "type" or (self.connector_port is not self.__undef__ and not (dirty and not self._connector_port[1])):
            dct["connectorPort"] = dictify(self.connector_port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connector_authentication_key = (self._connector_authentication_key[0], True)
        self._connector_port = (self._connector_port[0], True)

    def is_dirty(self):
        return any([self._connector_authentication_key[1], self._connector_port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHost):
            return False
        return super(WindowsHost, self).__eq__(other) and \
               self.connector_authentication_key == other.connector_authentication_key and \
               self.connector_port == other.connector_port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connector_authentication_key(self):
        """
        Unique per Delphix key used to authenticate with the remote Delphix
        Connector.

        :rtype: ``basestring``
        """
        return self._connector_authentication_key[0]

    @connector_authentication_key.setter
    def connector_authentication_key(self, value):
        self._connector_authentication_key = (value, True)

    @property
    def connector_port(self):
        """
        The port that the connector connects on.

        :rtype: ``float``
        """
        return self._connector_port[0]

    @connector_port.setter
    def connector_port(self, value):
        self._connector_port = (value, True)

class PgSQLDBClusterConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConfig` *)* Configuration
    information for a PostgreSQL database cluster.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBClusterConfig, self).__init__()
        self._type = ("PgSQLDBClusterConfig", True)
        self._credentials = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._cluster_data_directory = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBClusterConfig, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        obj._cluster_data_directory = (data.get("clusterDataDirectory", obj.__undef__), dirty)
        if obj._cluster_data_directory[0] is not None and obj._cluster_data_directory[0] is not obj.__undef__:
            assert isinstance(obj._cluster_data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_data_directory[0]))
            common.validate_format(obj._cluster_data_directory[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBClusterConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "cluster_data_directory" == "type" or (self.cluster_data_directory is not self.__undef__ and not (dirty and not self._cluster_data_directory[1])):
            dct["clusterDataDirectory"] = dictify(self.cluster_data_directory)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._cluster_data_directory = (self._cluster_data_directory[0], True)
        self._port = (self._port[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._connection_database[1], self._cluster_data_directory[1], self._port[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBClusterConfig):
            return False
        return super(PgSQLDBClusterConfig, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.connection_database == other.connection_database and \
               self.cluster_data_directory == other.cluster_data_directory and \
               self.port == other.port and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the database cluster user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def connection_database(self):
        """
        The database that must be used to run SQL queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def cluster_data_directory(self):
        """
        The data directory for the PostgreSQL cluster.

        :rtype: ``basestring``
        """
        return self._cluster_data_directory[0]

    @cluster_data_directory.setter
    def cluster_data_directory(self, value):
        self._cluster_data_directory = (value, True)

    @property
    def port(self):
        """
        The port on which the PostgresSQL server for the cluster is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleDBConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConfig` *)* The source config
    represents the dynamically discovered attributes of an Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDBConfig, self).__init__()
        self._type = ("OracleDBConfig", True)
        self._database_name = (self.__undef__, True)
        self._non_sys_credentials = (self.__undef__, True)
        self._non_sys_user = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._unique_name = (self.__undef__, True)
        self._services = (self.__undef__, True)
        self._credentials = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 8)
        if "nonSysCredentials" in data and data["nonSysCredentials"] is not None:
            obj._non_sys_credentials = (factory.create_object(data["nonSysCredentials"], "Credential"), dirty)
            factory.validate_type(obj._non_sys_credentials[0], "Credential")
        else:
            obj._non_sys_credentials = (obj.__undef__, dirty)
        obj._non_sys_user = (data.get("nonSysUser", obj.__undef__), dirty)
        if obj._non_sys_user[0] is not None and obj._non_sys_user[0] is not obj.__undef__:
            assert isinstance(obj._non_sys_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._non_sys_user[0]))
            common.validate_format(obj._non_sys_user[0], "None", None, 30)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 30)
        obj._unique_name = (data.get("uniqueName", obj.__undef__), dirty)
        if obj._unique_name[0] is not None and obj._unique_name[0] is not obj.__undef__:
            assert isinstance(obj._unique_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._unique_name[0]))
            common.validate_format(obj._unique_name[0], "None", None, 30)
        obj._services = []
        for item in data.get("services") or []:
            obj._services.append(factory.create_object(item))
            factory.validate_type(obj._services[-1], "OracleService")
        obj._services = (obj._services, dirty)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        if "non_sys_credentials" == "type" or (self.non_sys_credentials is not self.__undef__ and not (dirty and not self._non_sys_credentials[1])):
            dct["nonSysCredentials"] = dictify(self.non_sys_credentials)
        if "non_sys_user" == "type" or (self.non_sys_user is not self.__undef__ and not (dirty and not self._non_sys_user[1])):
            dct["nonSysUser"] = dictify(self.non_sys_user)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "unique_name" == "type" or (self.unique_name is not self.__undef__ and not (dirty and not self._unique_name[1])):
            dct["uniqueName"] = dictify(self.unique_name)
        if "services" == "type" or (self.services is not self.__undef__ and not (dirty and not self._services[1])):
            dct["services"] = dictify(self.services)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_name = (self._database_name[0], True)
        self._non_sys_credentials = (self._non_sys_credentials[0], True)
        self._non_sys_user = (self._non_sys_user[0], True)
        self._user = (self._user[0], True)
        self._unique_name = (self._unique_name[0], True)
        self._services = (self._services[0], True)
        self._credentials = (self._credentials[0], True)

    def is_dirty(self):
        return any([self._database_name[1], self._non_sys_credentials[1], self._non_sys_user[1], self._user[1], self._unique_name[1], self._services[1], self._credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDBConfig):
            return False
        return super(OracleDBConfig, self).__eq__(other) and \
               self.database_name == other.database_name and \
               self.non_sys_credentials == other.non_sys_credentials and \
               self.non_sys_user == other.non_sys_user and \
               self.user == other.user and \
               self.unique_name == other.unique_name and \
               self.services == other.services and \
               self.credentials == other.credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

    @property
    def non_sys_credentials(self):
        """
        The password of a database user that does not have administrative
        privileges.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._non_sys_credentials[0]

    @non_sys_credentials.setter
    def non_sys_credentials(self, value):
        self._non_sys_credentials = (value, True)

    @property
    def non_sys_user(self):
        """
        The username of a database user that does not have administrative
        privileges.

        :rtype: ``basestring``
        """
        return self._non_sys_user[0]

    @non_sys_user.setter
    def non_sys_user(self, value):
        self._non_sys_user = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def unique_name(self):
        """
        The unique name.

        :rtype: ``basestring``
        """
        return self._unique_name[0]

    @unique_name.setter
    def unique_name(self, value):
        self._unique_name = (value, True)

    @property
    def services(self):
        """
        The list of database services.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleService`
        """
        return self._services[0]

    @services.setter
    def services(self, value):
        self._services = (value, True)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

class AppDataSourceConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConfig` *)* Source config for
    AppDataToolkits.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceConfig, self).__init__()
        self._type = ("AppDataSourceConfig", True)
        self._excludes = (self.__undef__, True)
        self._follow_symlinks = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._path = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._excludes = []
        for item in data.get("excludes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._excludes.append(item)
        obj._excludes = (obj._excludes, dirty)
        obj._follow_symlinks = []
        for item in data.get("followSymlinks") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._follow_symlinks.append(item)
        obj._follow_symlinks = (obj._follow_symlinks, dirty)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "excludes" == "type" or (self.excludes is not self.__undef__ and not (dirty and not self._excludes[1])):
            dct["excludes"] = dictify(self.excludes)
        if "follow_symlinks" == "type" or (self.follow_symlinks is not self.__undef__ and not (dirty and not self._follow_symlinks[1])):
            dct["followSymlinks"] = dictify(self.follow_symlinks)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._excludes = (self._excludes[0], True)
        self._follow_symlinks = (self._follow_symlinks[0], True)
        self._name = (self._name[0], True)
        self._path = (self._path[0], True)

    def is_dirty(self):
        return any([self._excludes[1], self._follow_symlinks[1], self._name[1], self._path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceConfig):
            return False
        return super(AppDataSourceConfig, self).__eq__(other) and \
               self.excludes == other.excludes and \
               self.follow_symlinks == other.follow_symlinks and \
               self.name == other.name and \
               self.path == other.path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def excludes(self):
        """
        List of subdirectories in the source to exclude when running rsync.
        These paths are relative to the root of the source directory.

        :rtype: ``list`` of ``basestring``
        """
        return self._excludes[0]

    @excludes.setter
    def excludes(self, value):
        self._excludes = (value, True)

    @property
    def follow_symlinks(self):
        """
        List of symlinks in the source to follow when running rsync. These
        paths are relative to the root of the source directory. All other
        symlinks are preserved.

        :rtype: ``list`` of ``basestring``
        """
        return self._follow_symlinks[0]

    @follow_symlinks.setter
    def follow_symlinks(self, value):
        self._follow_symlinks = (value, True)

    @property
    def name(self):
        """
        The name of the config.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def path(self):
        """
        The path to the data to be synced.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

class MSSqlDBConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConfig` *)* Configuration
    information for a MSSQL Source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDBConfig, self).__init__()
        self._type = ("MSSqlDBConfig", True)
        self._credentials = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDBConfig, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 128)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._user = (self._user[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._user[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDBConfig):
            return False
        return super(MSSqlDBConfig, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.user == other.user and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class MSSqlSIConfig(MSSqlDBConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.MSSqlDBConfig` *)* Configuration
    information for a single instance MSSQL Source
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSIConfig, self).__init__()
        self._type = ("MSSqlSIConfig", True)
        self._instance = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSIConfig, cls).from_dict(data, dirty, undef_enabled)
        if "instance" in data and data["instance"] is not None:
            obj._instance = (factory.create_object(data["instance"], "MSSqlInstanceConfig"), dirty)
            factory.validate_type(obj._instance[0], "MSSqlInstanceConfig")
        else:
            obj._instance = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSIConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance" == "type" or (self.instance is not self.__undef__ and not (dirty and not self._instance[1])):
            dct["instance"] = dictify(self.instance)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance = (self._instance[0], True)

    def is_dirty(self):
        return any([self._instance[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSIConfig):
            return False
        return super(MSSqlSIConfig, self).__eq__(other) and \
               self.instance == other.instance

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance(self):
        """
        The MSSQL instance.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlInstanceConfig`
        """
        return self._instance[0]

    @instance.setter
    def instance(self, value):
        self._instance = (value, True)

class OracleSIConfig(OracleDBConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleDBConfig` *)* The representation
    of a single-instance Oracle DB configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSIConfig, self).__init__()
        self._type = ("OracleSIConfig", True)
        self._instance = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSIConfig, cls).from_dict(data, dirty, undef_enabled)
        if "instance" in data and data["instance"] is not None:
            obj._instance = (factory.create_object(data["instance"], "OracleInstance"), dirty)
            factory.validate_type(obj._instance[0], "OracleInstance")
        else:
            obj._instance = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSIConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance" == "type" or (self.instance is not self.__undef__ and not (dirty and not self._instance[1])):
            dct["instance"] = dictify(self.instance)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance = (self._instance[0], True)

    def is_dirty(self):
        return any([self._instance[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSIConfig):
            return False
        return super(OracleSIConfig, self).__eq__(other) and \
               self.instance == other.instance

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance(self):
        """
        The Oracle instance.

        :rtype: :py:class:`v1_3_0.web.vo.OracleInstance`
        """
        return self._instance[0]

    @instance.setter
    def instance(self, value):
        self._instance = (value, True)

class OracleRACConfig(OracleDBConfig):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleDBConfig` *)* Representation of
    the properties specific to a RAC Oracle DB configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACConfig, self).__init__()
        self._type = ("OracleRACConfig", True)
        self._instances = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._instances = []
        for item in data.get("instances") or []:
            obj._instances.append(factory.create_object(item))
            factory.validate_type(obj._instances[-1], "OracleRACInstance")
        obj._instances = (obj._instances, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instances = (self._instances[0], True)

    def is_dirty(self):
        return any([self._instances[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACConfig):
            return False
        return super(OracleRACConfig, self).__eq__(other) and \
               self.instances == other.instances

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instances(self):
        """
        The list of RAC instances for this RAC configuration.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleRACInstance`
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

class PgSQLSource(Source):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Source` *)* A PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSource, self).__init__()
        self._type = ("PgSQLSource", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSource):
            return False
        return super(PgSQLSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleSource(Source):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Source` *)* An Oracle source
    """
    def __init__(self, undef_enabled=True):
        super(OracleSource, self).__init__()
        self._type = ("OracleSource", True)
        self._runtime = (self.__undef__, True)
        self._role = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._role = (data.get("role", obj.__undef__), dirty)
        if obj._role[0] is not None and obj._role[0] is not obj.__undef__:
            assert isinstance(obj._role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._role[0]))
            assert obj._role[0] in [u'PHYSICAL_STANDBY', u'PRIMARY', u'UNKNOWN'], "Expected enum [u'PHYSICAL_STANDBY', u'PRIMARY', u'UNKNOWN'] but got %s" % obj._role[0]
            common.validate_format(obj._role[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "role" == "type" or (self.role is not self.__undef__ and not (dirty and not self._role[1])):
            dct["role"] = dictify(self.role)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)
        self._role = (self._role[0], True)

    def is_dirty(self):
        return any([self._runtime[1], self._role[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSource):
            return False
        return super(OracleSource, self).__eq__(other) and \
               self.runtime == other.runtime and \
               self.role == other.role

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties for this Oracle source.

        :rtype: :py:class:`v1_3_0.web.vo.OracleSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def role(self):
        """
        Operating role of the database. *(permitted values: PHYSICAL_STANDBY,
        PRIMARY, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._role[0]

    @role.setter
    def role(self, value):
        self._role = (value, True)

class MSSqlSource(Source):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Source` *)* A MSSQL source
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSource, self).__init__()
        self._type = ("MSSqlSource", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSource):
            return False
        return super(MSSqlSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataSource(Source):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Source` *)* An AppData source
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSource, self).__init__()
        self._type = ("AppDataSource", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSource):
            return False
        return super(AppDataSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataVirtualSource(AppDataSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AppDataSource` *)* A virtual AppData
    source
    """
    def __init__(self, undef_enabled=True):
        super(AppDataVirtualSource, self).__init__()
        self._type = ("AppDataVirtualSource", True)
        self._operations = (self.__undef__, True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._parameters = []
        for item in data.get("parameters") or []:
            obj._parameters.append(factory.create_object(item))
            factory.validate_type(obj._parameters[-1], "DynamicParameterValue")
        obj._parameters = (obj._parameters, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataVirtualSource):
            return False
        return super(AppDataVirtualSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_3_0.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def parameters(self):
        """
        The list of exact source parameters is dynamically generated based on
        the type of application data being manipulated.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.DynamicParameterValue`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class AppDataLinkedSource(AppDataSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AppDataSource` *)* An AppData linked
    source
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkedSource, self).__init__()
        self._type = ("AppDataLinkedSource", True)
        self._post_script = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._post_script = (self._post_script[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._post_script[1], self._pre_script[1], self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkedSource):
            return False
        return super(AppDataLinkedSource, self).__eq__(other) and \
               self.post_script == other.post_script and \
               self.pre_script == other.pre_script and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def post_script(self):
        """
        The path to a script on the target host to run after SnapSync.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

    @property
    def pre_script(self):
        """
        The path to a script on the target host to run before SnapSync.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class MSSqlVirtualSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.MSSqlSource` *)* A virtual MSSQL source
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlVirtualSource, self).__init__()
        self._type = ("MSSqlVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._post_script = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 256)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._post_script = (self._post_script[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._mount_base[1], self._pre_script[1], self._file_mapping_rules[1], self._post_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlVirtualSource):
            return False
        return super(MSSqlVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.mount_base == other.mount_base and \
               self.pre_script == other.pre_script and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.post_script == other.post_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MSSQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def mount_base(self):
        """
        The base mountpoint for the iSCSI lun mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided powershell script or executable to run prior to
        provisioning.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def post_script(self):
        """
        A user-provided powershell script or executable to run after
        provisioning.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

class MSSqlLinkedSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.MSSqlSource` *)* A linked MSSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkedSource, self).__init__()
        self._type = ("MSSqlLinkedSource", True)
        self._external_file_path = (self.__undef__, True)
        self._post_script = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)
        self._backup_location_credentials = (self.__undef__, True)
        self._backup_location_user = (self.__undef__, True)
        self._shared_backup_location = (self.__undef__, True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        if "backupLocationCredentials" in data and data["backupLocationCredentials"] is not None:
            obj._backup_location_credentials = (factory.create_object(data["backupLocationCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._backup_location_credentials[0], "PasswordCredential")
        else:
            obj._backup_location_credentials = (obj.__undef__, dirty)
        obj._backup_location_user = (data.get("backupLocationUser", obj.__undef__), dirty)
        if obj._backup_location_user[0] is not None and obj._backup_location_user[0] is not obj.__undef__:
            assert isinstance(obj._backup_location_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_location_user[0]))
            common.validate_format(obj._backup_location_user[0], "None", None, 256)
        obj._shared_backup_location = (data.get("sharedBackupLocation", obj.__undef__), dirty)
        if obj._shared_backup_location[0] is not None and obj._shared_backup_location[0] is not obj.__undef__:
            assert isinstance(obj._shared_backup_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._shared_backup_location[0]))
            common.validate_format(obj._shared_backup_location[0], "None", None, 260)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        if "backup_location_credentials" == "type" or (self.backup_location_credentials is not self.__undef__ and not (dirty and not self._backup_location_credentials[1])):
            dct["backupLocationCredentials"] = dictify(self.backup_location_credentials)
        if "backup_location_user" == "type" or (self.backup_location_user is not self.__undef__ and not (dirty and not self._backup_location_user[1])):
            dct["backupLocationUser"] = dictify(self.backup_location_user)
        if "shared_backup_location" == "type" or (self.shared_backup_location is not self.__undef__ and not (dirty and not self._shared_backup_location[1])):
            dct["sharedBackupLocation"] = dictify(self.shared_backup_location)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._external_file_path = (self._external_file_path[0], True)
        self._post_script = (self._post_script[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._staging_source = (self._staging_source[0], True)
        self._backup_location_credentials = (self._backup_location_credentials[0], True)
        self._backup_location_user = (self._backup_location_user[0], True)
        self._shared_backup_location = (self._shared_backup_location[0], True)
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._external_file_path[1], self._post_script[1], self._pre_script[1], self._staging_source[1], self._backup_location_credentials[1], self._backup_location_user[1], self._shared_backup_location[1], self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkedSource):
            return False
        return super(MSSqlLinkedSource, self).__eq__(other) and \
               self.external_file_path == other.external_file_path and \
               self.post_script == other.post_script and \
               self.pre_script == other.pre_script and \
               self.staging_source == other.staging_source and \
               self.backup_location_credentials == other.backup_location_credentials and \
               self.backup_location_user == other.backup_location_user and \
               self.shared_backup_location == other.shared_backup_location and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def post_script(self):
        """
        A user-provided powershell script or executable to run after snapsync.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided powershell script or executable to run prior to
        snapsync.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for pre-provisioning of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

    @property
    def backup_location_credentials(self):
        """
        The password for accessing the shared backup location.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._backup_location_credentials[0]

    @backup_location_credentials.setter
    def backup_location_credentials(self, value):
        self._backup_location_credentials = (value, True)

    @property
    def backup_location_user(self):
        """
        The user for accessing the shared backup location.

        :rtype: ``basestring``
        """
        return self._backup_location_user[0]

    @backup_location_user.setter
    def backup_location_user(self, value):
        self._backup_location_user = (value, True)

    @property
    def shared_backup_location(self):
        """
        Shared source database backup location.

        :rtype: ``basestring``
        """
        return self._shared_backup_location[0]

    @shared_backup_location.setter
    def shared_backup_location(self, value):
        self._shared_backup_location = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class MSSqlStagingSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.MSSqlSource` *)* An MSSQL staging
    source used for pre-provisioning
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlStagingSource, self).__init__()
        self._type = ("MSSqlStagingSource", True)
        self._mount_base = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._post_script = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, None)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._post_script = (self._post_script[0], True)

    def is_dirty(self):
        return any([self._mount_base[1], self._pre_script[1], self._post_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlStagingSource):
            return False
        return super(MSSqlStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base and \
               self.pre_script == other.pre_script and \
               self.post_script == other.post_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mountpoint for the iSCSI lun mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided powershell script or executable to run prior to
        restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def post_script(self):
        """
        A user-provided powershell script or executable to run after restoring
        from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

class OracleVirtualSource(OracleSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleSource` *)* A virtual Oracle
    source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleVirtualSource, self).__init__()
        self._type = ("OracleVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._node_listener_list = (self.__undef__, True)
        self._manual_provisioning = (self.__undef__, True)
        self._config_template = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._node_listener_list = []
        for item in data.get("nodeListenerList") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._node_listener_list.append(item)
        obj._node_listener_list = (obj._node_listener_list, dirty)
        obj._manual_provisioning = (data.get("manualProvisioning", obj.__undef__), dirty)
        if obj._manual_provisioning[0] is not None and obj._manual_provisioning[0] is not obj.__undef__:
            assert isinstance(obj._manual_provisioning[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._manual_provisioning[0]))
            common.validate_format(obj._manual_provisioning[0], "None", None, None)
        obj._config_template = (data.get("configTemplate", obj.__undef__), dirty)
        if obj._config_template[0] is not None and obj._config_template[0] is not obj.__undef__:
            assert isinstance(obj._config_template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config_template[0]))
            common.validate_format(obj._config_template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "node_listener_list" == "type" or (self.node_listener_list is not self.__undef__ and not (dirty and not self._node_listener_list[1])):
            dct["nodeListenerList"] = dictify(self.node_listener_list)
        if "manual_provisioning" == "type" or (self.manual_provisioning is not self.__undef__ and not (dirty and not self._manual_provisioning[1])):
            dct["manualProvisioning"] = dictify(self.manual_provisioning)
        if "config_template" == "type" or (self.config_template is not self.__undef__ and not (dirty and not self._config_template[1])):
            dct["configTemplate"] = dictify(self.config_template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._node_listener_list = (self._node_listener_list[0], True)
        self._manual_provisioning = (self._manual_provisioning[0], True)
        self._config_template = (self._config_template[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._file_mapping_rules[1], self._mount_base[1], self._node_listener_list[1], self._manual_provisioning[1], self._config_template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleVirtualSource):
            return False
        return super(OracleVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.node_listener_list == other.node_listener_list and \
               self.manual_provisioning == other.manual_provisioning and \
               self.config_template == other.config_template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        Oracle database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_3_0.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mountpoint to use for NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def node_listener_list(self):
        """
        A list of object references of Oracle Node Listeners selected for this
        Virtual Database. Delphix picks one default listener from the target
        environment if this list is empty at virtual database provision time.

        :rtype: ``list`` of ``basestring``
        """
        return self._node_listener_list[0]

    @node_listener_list.setter
    def node_listener_list(self, value):
        self._node_listener_list = (value, True)

    @property
    def manual_provisioning(self):
        """
        Flag indicating whether the database should be provisioned in manual
        mode.

        :rtype: ``bool``
        """
        return self._manual_provisioning[0]

    @manual_provisioning.setter
    def manual_provisioning(self, value):
        self._manual_provisioning = (value, True)

    @property
    def config_template(self):
        """
        Optional database template to use for provisioning and refresh. If set,
        configParams will be ignored on provision or refresh.

        :rtype: ``basestring``
        """
        return self._config_template[0]

    @config_template.setter
    def config_template(self, value):
        self._config_template = (value, True)

class OracleLinkedSource(OracleSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleSource` *)* A linked Oracle
    source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLinkedSource, self).__init__()
        self._type = ("OracleLinkedSource", True)
        self._number_of_connections = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._files_per_set = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._backup_level_enabled = (self.__undef__, True)
        self._post_script = (self.__undef__, True)
        self._rman_channels = (self.__undef__, True)
        self._encrypted_linking_enabled = (self.__undef__, True)
        self._compressed_linking_enabled = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._check_logical = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._number_of_connections = (data.get("numberOfConnections", obj.__undef__), dirty)
        if obj._number_of_connections[0] is not None and obj._number_of_connections[0] is not obj.__undef__:
            assert isinstance(obj._number_of_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._number_of_connections[0]))
            common.validate_format(obj._number_of_connections[0], "None", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._files_per_set = (data.get("filesPerSet", obj.__undef__), dirty)
        if obj._files_per_set[0] is not None and obj._files_per_set[0] is not obj.__undef__:
            assert isinstance(obj._files_per_set[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._files_per_set[0]))
            common.validate_format(obj._files_per_set[0], "None", None, None)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._backup_level_enabled = (data.get("backupLevelEnabled", obj.__undef__), dirty)
        if obj._backup_level_enabled[0] is not None and obj._backup_level_enabled[0] is not obj.__undef__:
            assert isinstance(obj._backup_level_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._backup_level_enabled[0]))
            common.validate_format(obj._backup_level_enabled[0], "None", None, None)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        obj._rman_channels = (data.get("rmanChannels", obj.__undef__), dirty)
        if obj._rman_channels[0] is not None and obj._rman_channels[0] is not obj.__undef__:
            assert isinstance(obj._rman_channels[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._rman_channels[0]))
            common.validate_format(obj._rman_channels[0], "None", None, None)
        obj._encrypted_linking_enabled = (data.get("encryptedLinkingEnabled", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled[0] is not None and obj._encrypted_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled[0]))
            common.validate_format(obj._encrypted_linking_enabled[0], "None", None, None)
        obj._compressed_linking_enabled = (data.get("compressedLinkingEnabled", obj.__undef__), dirty)
        if obj._compressed_linking_enabled[0] is not None and obj._compressed_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._compressed_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compressed_linking_enabled[0]))
            common.validate_format(obj._compressed_linking_enabled[0], "None", None, None)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._check_logical = (data.get("checkLogical", obj.__undef__), dirty)
        if obj._check_logical[0] is not None and obj._check_logical[0] is not obj.__undef__:
            assert isinstance(obj._check_logical[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._check_logical[0]))
            common.validate_format(obj._check_logical[0], "None", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "number_of_connections" == "type" or (self.number_of_connections is not self.__undef__ and not (dirty and not self._number_of_connections[1])):
            dct["numberOfConnections"] = dictify(self.number_of_connections)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "files_per_set" == "type" or (self.files_per_set is not self.__undef__ and not (dirty and not self._files_per_set[1])):
            dct["filesPerSet"] = dictify(self.files_per_set)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "backup_level_enabled" == "type" or (self.backup_level_enabled is not self.__undef__ and not (dirty and not self._backup_level_enabled[1])):
            dct["backupLevelEnabled"] = dictify(self.backup_level_enabled)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        if "rman_channels" == "type" or (self.rman_channels is not self.__undef__ and not (dirty and not self._rman_channels[1])):
            dct["rmanChannels"] = dictify(self.rman_channels)
        if "encrypted_linking_enabled" == "type" or (self.encrypted_linking_enabled is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled[1])):
            dct["encryptedLinkingEnabled"] = dictify(self.encrypted_linking_enabled)
        if "compressed_linking_enabled" == "type" or (self.compressed_linking_enabled is not self.__undef__ and not (dirty and not self._compressed_linking_enabled[1])):
            dct["compressedLinkingEnabled"] = dictify(self.compressed_linking_enabled)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "check_logical" == "type" or (self.check_logical is not self.__undef__ and not (dirty and not self._check_logical[1])):
            dct["checkLogical"] = dictify(self.check_logical)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._number_of_connections = (self._number_of_connections[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._files_per_set = (self._files_per_set[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._backup_level_enabled = (self._backup_level_enabled[0], True)
        self._post_script = (self._post_script[0], True)
        self._rman_channels = (self._rman_channels[0], True)
        self._encrypted_linking_enabled = (self._encrypted_linking_enabled[0], True)
        self._compressed_linking_enabled = (self._compressed_linking_enabled[0], True)
        self._config = (self._config[0], True)
        self._check_logical = (self._check_logical[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)

    def is_dirty(self):
        return any([self._number_of_connections[1], self._external_file_path[1], self._files_per_set[1], self._pre_script[1], self._backup_level_enabled[1], self._post_script[1], self._rman_channels[1], self._encrypted_linking_enabled[1], self._compressed_linking_enabled[1], self._config[1], self._check_logical[1], self._bandwidth_limit[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLinkedSource):
            return False
        return super(OracleLinkedSource, self).__eq__(other) and \
               self.number_of_connections == other.number_of_connections and \
               self.external_file_path == other.external_file_path and \
               self.files_per_set == other.files_per_set and \
               self.pre_script == other.pre_script and \
               self.backup_level_enabled == other.backup_level_enabled and \
               self.post_script == other.post_script and \
               self.rman_channels == other.rman_channels and \
               self.encrypted_linking_enabled == other.encrypted_linking_enabled and \
               self.compressed_linking_enabled == other.compressed_linking_enabled and \
               self.config == other.config and \
               self.check_logical == other.check_logical and \
               self.bandwidth_limit == other.bandwidth_limit

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def number_of_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use
        during SnapSync.

        :rtype: ``int``
        """
        return self._number_of_connections[0]

    @number_of_connections.setter
    def number_of_connections(self, value):
        self._number_of_connections = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def files_per_set(self):
        """
        *(default value: 5)* Number of data files to include in each RMAN
        backup set.

        :rtype: ``int``
        """
        return self._files_per_set[0]

    @files_per_set.setter
    def files_per_set(self, value):
        self._files_per_set = (value, True)

    @property
    def pre_script(self):
        """
        Pre script path.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def backup_level_enabled(self):
        """
        Defines whether backup level is enabled.

        :rtype: ``bool``
        """
        return self._backup_level_enabled[0]

    @backup_level_enabled.setter
    def backup_level_enabled(self, value):
        self._backup_level_enabled = (value, True)

    @property
    def post_script(self):
        """
        Post script path.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

    @property
    def rman_channels(self):
        """
        *(default value: 2)* Number of parallel channels to use.

        :rtype: ``int``
        """
        return self._rman_channels[0]

    @rman_channels.setter
    def rman_channels(self, value):
        self._rman_channels = (value, True)

    @property
    def encrypted_linking_enabled(self):
        """
        True if SnapSync data from the source should be retrieved through an
        encrypted                 connection. Enabling this feature can
        decrease the performance of SnapSync from the source
        but has no impact on the performance of VDBs created from the retrieved
        data.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled[0]

    @encrypted_linking_enabled.setter
    def encrypted_linking_enabled(self, value):
        self._encrypted_linking_enabled = (value, True)

    @property
    def compressed_linking_enabled(self):
        """
        *(default value: True)* True if SnapSync data from the source should be
        compressed over the network. Enabling                 this feature will
        reduce network bandwidth consumption and may significantly improve
        throughput,                 especially over slow network.

        :rtype: ``bool``
        """
        return self._compressed_linking_enabled[0]

    @compressed_linking_enabled.setter
    def compressed_linking_enabled(self, value):
        self._compressed_linking_enabled = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def check_logical(self):
        """
        True if extended block checking should be used for this linked
        database.

        :rtype: ``bool``
        """
        return self._check_logical[0]

    @check_logical.setter
    def check_logical(self, value):
        self._check_logical = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for SnapSync and LogSync network traffic. A
        value of 0 means                 no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

class PgSQLStagingSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PgSQLSource` *)* A PostgreSQL staging
    source used for pre-provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLStagingSource, self).__init__()
        self._type = ("PgSQLStagingSource", True)
        self._mount_base = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)

    def is_dirty(self):
        return any([self._mount_base[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLStagingSource):
            return False
        return super(PgSQLStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mountpoint for the NFS mounts on the pre-provisioning host.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

class PgSQLVirtualSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PgSQLSource` *)* A virtual PostgreSQL
    source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLVirtualSource, self).__init__()
        self._type = ("PgSQLVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._ident_entries = (self.__undef__, True)
        self._hba_entries = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._ident_entries = []
        for item in data.get("identEntries") or []:
            obj._ident_entries.append(factory.create_object(item))
            factory.validate_type(obj._ident_entries[-1], "PgSQLIdentEntry")
        obj._ident_entries = (obj._ident_entries, dirty)
        obj._hba_entries = []
        for item in data.get("hbaEntries") or []:
            obj._hba_entries.append(factory.create_object(item))
            factory.validate_type(obj._hba_entries[-1], "PgSQLHBAEntry")
        obj._hba_entries = (obj._hba_entries, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "ident_entries" == "type" or (self.ident_entries is not self.__undef__ and not (dirty and not self._ident_entries[1])):
            dct["identEntries"] = dictify(self.ident_entries)
        if "hba_entries" == "type" or (self.hba_entries is not self.__undef__ and not (dirty and not self._hba_entries[1])):
            dct["hbaEntries"] = dictify(self.hba_entries)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._ident_entries = (self._ident_entries[0], True)
        self._hba_entries = (self._hba_entries[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._file_mapping_rules[1], self._mount_base[1], self._ident_entries[1], self._hba_entries[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLVirtualSource):
            return False
        return super(PgSQLVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.ident_entries == other.ident_entries and \
               self.hba_entries == other.hba_entries

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        PostgreSQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_3_0.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mountpoint to use for NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def ident_entries(self):
        """
        Entries in the PostgreSQL username map file (pg_ident.conf).

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.PgSQLIdentEntry`
        """
        return self._ident_entries[0]

    @ident_entries.setter
    def ident_entries(self, value):
        self._ident_entries = (value, True)

    @property
    def hba_entries(self):
        """
        Entries in the PostgreSQL host-based authentication file (pg_hba.conf).

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.PgSQLHBAEntry`
        """
        return self._hba_entries[0]

    @hba_entries.setter
    def hba_entries(self, value):
        self._hba_entries = (value, True)

class PgSQLLinkedSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PgSQLSource` *)* A linked PostgreSQL
    source
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLLinkedSource, self).__init__()
        self._type = ("PgSQLLinkedSource", True)
        self._post_script = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._post_script = (self._post_script[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._staging_source = (self._staging_source[0], True)

    def is_dirty(self):
        return any([self._post_script[1], self._pre_script[1], self._external_file_path[1], self._staging_source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLLinkedSource):
            return False
        return super(PgSQLLinkedSource, self).__eq__(other) and \
               self.post_script == other.post_script and \
               self.pre_script == other.pre_script and \
               self.external_file_path == other.external_file_path and \
               self.staging_source == other.staging_source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def post_script(self):
        """
        A user-provided script to run after performing a sync.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided script to run prior to performing a sync

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def external_file_path(self):
        """
        External file path

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for pre-provisioning of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

class Group(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Database group
    """
    def __init__(self, undef_enabled=True):
        super(Group, self).__init__()
        self._type = ("Group", True)
        self._description = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Group, cls).from_dict(data, dirty, undef_enabled)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Group, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._description = (self._description[0], True)

    def is_dirty(self):
        return any([self._description[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Group):
            return False
        return super(Group, self).__eq__(other) and \
               self.description == other.description

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def description(self):
        """
        Optional description for the group

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

class Domain(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Represents the
    root container of all objects on the system.
    """
    def __init__(self, undef_enabled=True):
        super(Domain, self).__init__()
        self._type = ("Domain", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Domain, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Domain, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Domain):
            return False
        return super(Domain, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCBranch(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* A branch
    represents a distinct timeline for data sources in an application.
    """
    def __init__(self, undef_enabled=True):
        super(DVCBranch, self).__init__()
        self._type = ("DVCBranch", True)
        self._application = (self.__undef__, True)
        self._parent_bookmark = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCBranch, cls).from_dict(data, dirty, undef_enabled)
        obj._application = (data.get("application", obj.__undef__), dirty)
        if obj._application[0] is not None and obj._application[0] is not obj.__undef__:
            assert isinstance(obj._application[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application[0]))
            common.validate_format(obj._application[0], "objectReference", None, None)
        obj._parent_bookmark = (data.get("parentBookmark", obj.__undef__), dirty)
        if obj._parent_bookmark[0] is not None and obj._parent_bookmark[0] is not obj.__undef__:
            assert isinstance(obj._parent_bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_bookmark[0]))
            common.validate_format(obj._parent_bookmark[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCBranch, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "application" == "type" or (self.application is not self.__undef__ and not (dirty and not self._application[1])):
            dct["application"] = dictify(self.application)
        if "parent_bookmark" == "type" or (self.parent_bookmark is not self.__undef__ and not (dirty and not self._parent_bookmark[1])):
            dct["parentBookmark"] = dictify(self.parent_bookmark)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._application = (self._application[0], True)
        self._parent_bookmark = (self._parent_bookmark[0], True)

    def is_dirty(self):
        return any([self._application[1], self._parent_bookmark[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCBranch):
            return False
        return super(DVCBranch, self).__eq__(other) and \
               self.application == other.application and \
               self.parent_bookmark == other.parent_bookmark

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def application(self):
        """
        A reference to the application this branch was created on.

        :rtype: ``basestring``
        """
        return self._application[0]

    @application.setter
    def application(self, value):
        self._application = (value, True)

    @property
    def parent_bookmark(self):
        """
        A reference to the bookmark this branch was created from.

        :rtype: ``basestring``
        """
        return self._parent_bookmark[0]

    @parent_bookmark.setter
    def parent_bookmark(self, value):
        self._parent_bookmark = (value, True)

class User(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Delphix users.
    """
    def __init__(self, undef_enabled=True):
        super(User, self).__init__()
        self._type = ("User", True)
        self._credential = (self.__undef__, True)
        self._authentication_type = (self.__undef__, True)
        self._first_name = (self.__undef__, True)
        self._public_key = (self.__undef__, True)
        self._locale = (self.__undef__, True)
        self._last_name = (self.__undef__, True)
        self._home_phone_number = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._user_type = (self.__undef__, True)
        self._session_timeout = (self.__undef__, True)
        self._email_address = (self.__undef__, True)
        self._password_update_requested = (self.__undef__, True)
        self._principal = (self.__undef__, True)
        self._mobile_phone_number = (self.__undef__, True)
        self._work_phone_number = (self.__undef__, True)
        self._is_default = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(User, cls).from_dict(data, dirty, undef_enabled)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credential[0], "PasswordCredential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._authentication_type = (data.get("authenticationType", obj.__undef__), dirty)
        if obj._authentication_type[0] is not None and obj._authentication_type[0] is not obj.__undef__:
            assert isinstance(obj._authentication_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._authentication_type[0]))
            assert obj._authentication_type[0] in [u'LDAP', u'NATIVE'], "Expected enum [u'LDAP', u'NATIVE'] but got %s" % obj._authentication_type[0]
            common.validate_format(obj._authentication_type[0], "None", None, None)
        obj._first_name = (data.get("firstName", obj.__undef__), dirty)
        if obj._first_name[0] is not None and obj._first_name[0] is not obj.__undef__:
            assert isinstance(obj._first_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._first_name[0]))
            common.validate_format(obj._first_name[0], "None", None, 64)
        obj._public_key = (data.get("publicKey", obj.__undef__), dirty)
        if obj._public_key[0] is not None and obj._public_key[0] is not obj.__undef__:
            assert isinstance(obj._public_key[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._public_key[0]))
            common.validate_format(obj._public_key[0], "None", None, None)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            assert obj._locale[0] in [u'en_US'], "Expected enum [u'en_US'] but got %s" % obj._locale[0]
            common.validate_format(obj._locale[0], "None", None, 16)
        obj._last_name = (data.get("lastName", obj.__undef__), dirty)
        if obj._last_name[0] is not None and obj._last_name[0] is not obj.__undef__:
            assert isinstance(obj._last_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_name[0]))
            common.validate_format(obj._last_name[0], "None", None, 64)
        obj._home_phone_number = (data.get("homePhoneNumber", obj.__undef__), dirty)
        if obj._home_phone_number[0] is not None and obj._home_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._home_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._home_phone_number[0]))
            common.validate_format(obj._home_phone_number[0], "None", None, 32)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._user_type = (data.get("userType", obj.__undef__), dirty)
        if obj._user_type[0] is not None and obj._user_type[0] is not obj.__undef__:
            assert isinstance(obj._user_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_type[0]))
            assert obj._user_type[0] in [u'SYSTEM', u'DOMAIN'], "Expected enum [u'SYSTEM', u'DOMAIN'] but got %s" % obj._user_type[0]
            common.validate_format(obj._user_type[0], "None", None, None)
        obj._session_timeout = (data.get("sessionTimeout", obj.__undef__), dirty)
        if obj._session_timeout[0] is not None and obj._session_timeout[0] is not obj.__undef__:
            assert isinstance(obj._session_timeout[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._session_timeout[0]))
            common.validate_format(obj._session_timeout[0], "None", None, None)
        obj._email_address = (data.get("emailAddress", obj.__undef__), dirty)
        if obj._email_address[0] is not None and obj._email_address[0] is not obj.__undef__:
            assert isinstance(obj._email_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._email_address[0]))
            common.validate_format(obj._email_address[0], "email", None, 256)
        obj._password_update_requested = (data.get("passwordUpdateRequested", obj.__undef__), dirty)
        if obj._password_update_requested[0] is not None and obj._password_update_requested[0] is not obj.__undef__:
            assert isinstance(obj._password_update_requested[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._password_update_requested[0]))
            common.validate_format(obj._password_update_requested[0], "None", None, None)
        obj._principal = (data.get("principal", obj.__undef__), dirty)
        if obj._principal[0] is not None and obj._principal[0] is not obj.__undef__:
            assert isinstance(obj._principal[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._principal[0]))
            common.validate_format(obj._principal[0], "None", None, None)
        obj._mobile_phone_number = (data.get("mobilePhoneNumber", obj.__undef__), dirty)
        if obj._mobile_phone_number[0] is not None and obj._mobile_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._mobile_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mobile_phone_number[0]))
            common.validate_format(obj._mobile_phone_number[0], "None", None, 32)
        obj._work_phone_number = (data.get("workPhoneNumber", obj.__undef__), dirty)
        if obj._work_phone_number[0] is not None and obj._work_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._work_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._work_phone_number[0]))
            common.validate_format(obj._work_phone_number[0], "None", None, 32)
        obj._is_default = (data.get("isDefault", obj.__undef__), dirty)
        if obj._is_default[0] is not None and obj._is_default[0] is not obj.__undef__:
            assert isinstance(obj._is_default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._is_default[0]))
            common.validate_format(obj._is_default[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(User, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "authentication_type" == "type" or (self.authentication_type is not self.__undef__ and not (dirty and not self._authentication_type[1])):
            dct["authenticationType"] = dictify(self.authentication_type)
        if "first_name" == "type" or (self.first_name is not self.__undef__ and not (dirty and not self._first_name[1])):
            dct["firstName"] = dictify(self.first_name)
        if "public_key" == "type" or (self.public_key is not self.__undef__ and not (dirty and not self._public_key[1])):
            dct["publicKey"] = dictify(self.public_key)
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        if "last_name" == "type" or (self.last_name is not self.__undef__ and not (dirty and not self._last_name[1])):
            dct["lastName"] = dictify(self.last_name)
        if "home_phone_number" == "type" or (self.home_phone_number is not self.__undef__ and not (dirty and not self._home_phone_number[1])):
            dct["homePhoneNumber"] = dictify(self.home_phone_number)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "user_type" == "type" or (self.user_type is not self.__undef__ and not (dirty and not self._user_type[1])):
            dct["userType"] = dictify(self.user_type)
        if "session_timeout" == "type" or (self.session_timeout is not self.__undef__ and not (dirty and not self._session_timeout[1])):
            dct["sessionTimeout"] = dictify(self.session_timeout)
        if "email_address" == "type" or (self.email_address is not self.__undef__ and not (dirty and not self._email_address[1])):
            dct["emailAddress"] = dictify(self.email_address)
        if "password_update_requested" == "type" or (self.password_update_requested is not self.__undef__ and not (dirty and not self._password_update_requested[1])):
            dct["passwordUpdateRequested"] = dictify(self.password_update_requested)
        if "principal" == "type" or (self.principal is not self.__undef__ and not (dirty and not self._principal[1])):
            dct["principal"] = dictify(self.principal)
        if "mobile_phone_number" == "type" or (self.mobile_phone_number is not self.__undef__ and not (dirty and not self._mobile_phone_number[1])):
            dct["mobilePhoneNumber"] = dictify(self.mobile_phone_number)
        if "work_phone_number" == "type" or (self.work_phone_number is not self.__undef__ and not (dirty and not self._work_phone_number[1])):
            dct["workPhoneNumber"] = dictify(self.work_phone_number)
        if "is_default" == "type" or (self.is_default is not self.__undef__ and not (dirty and not self._is_default[1])):
            dct["isDefault"] = dictify(self.is_default)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credential = (self._credential[0], True)
        self._authentication_type = (self._authentication_type[0], True)
        self._first_name = (self._first_name[0], True)
        self._public_key = (self._public_key[0], True)
        self._locale = (self._locale[0], True)
        self._last_name = (self._last_name[0], True)
        self._home_phone_number = (self._home_phone_number[0], True)
        self._enabled = (self._enabled[0], True)
        self._user_type = (self._user_type[0], True)
        self._session_timeout = (self._session_timeout[0], True)
        self._email_address = (self._email_address[0], True)
        self._password_update_requested = (self._password_update_requested[0], True)
        self._principal = (self._principal[0], True)
        self._mobile_phone_number = (self._mobile_phone_number[0], True)
        self._work_phone_number = (self._work_phone_number[0], True)
        self._is_default = (self._is_default[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._credential[1], self._authentication_type[1], self._first_name[1], self._public_key[1], self._locale[1], self._last_name[1], self._home_phone_number[1], self._enabled[1], self._user_type[1], self._session_timeout[1], self._email_address[1], self._password_update_requested[1], self._principal[1], self._mobile_phone_number[1], self._work_phone_number[1], self._is_default[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, User):
            return False
        return super(User, self).__eq__(other) and \
               self.credential == other.credential and \
               self.authentication_type == other.authentication_type and \
               self.first_name == other.first_name and \
               self.public_key == other.public_key and \
               self.locale == other.locale and \
               self.last_name == other.last_name and \
               self.home_phone_number == other.home_phone_number and \
               self.enabled == other.enabled and \
               self.user_type == other.user_type and \
               self.session_timeout == other.session_timeout and \
               self.email_address == other.email_address and \
               self.password_update_requested == other.password_update_requested and \
               self.principal == other.principal and \
               self.mobile_phone_number == other.mobile_phone_number and \
               self.work_phone_number == other.work_phone_number and \
               self.is_default == other.is_default and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credential(self):
        """
        Credential used for authentication.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def authentication_type(self):
        """
        User authentication type. *(permitted values: LDAP, NATIVE)*

        :rtype: ``basestring``
        """
        return self._authentication_type[0]

    @authentication_type.setter
    def authentication_type(self, value):
        self._authentication_type = (value, True)

    @property
    def first_name(self):
        """
        First name of user.

        :rtype: ``basestring``
        """
        return self._first_name[0]

    @first_name.setter
    def first_name(self, value):
        self._first_name = (value, True)

    @property
    def public_key(self):
        """
        Public key used for authentication.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._public_key[0]

    @public_key.setter
    def public_key(self, value):
        self._public_key = (value, True)

    @property
    def locale(self):
        """
        *(default value: en_US)* Preferred locale. *(permitted values: en_US)*

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

    @property
    def last_name(self):
        """
        Last name of user.

        :rtype: ``basestring``
        """
        return self._last_name[0]

    @last_name.setter
    def last_name(self, value):
        self._last_name = (value, True)

    @property
    def home_phone_number(self):
        """
        Home phone number of user.

        :rtype: ``basestring``
        """
        return self._home_phone_number[0]

    @home_phone_number.setter
    def home_phone_number(self, value):
        self._home_phone_number = (value, True)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the user is currently enabled and can
        log into the system.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def user_type(self):
        """
        *(default value: DOMAIN)* Type of user. *(permitted values: SYSTEM,
        DOMAIN)*

        :rtype: ``basestring``
        """
        return self._user_type[0]

    @user_type.setter
    def user_type(self, value):
        self._user_type = (value, True)

    @property
    def session_timeout(self):
        """
        *(default value: 30)* Session timeout in minutes.

        :rtype: ``int``
        """
        return self._session_timeout[0]

    @session_timeout.setter
    def session_timeout(self, value):
        self._session_timeout = (value, True)

    @property
    def email_address(self):
        """
        Email address for the user.

        :rtype: ``basestring``
        """
        return self._email_address[0]

    @email_address.setter
    def email_address(self, value):
        self._email_address = (value, True)

    @property
    def password_update_requested(self):
        """
        True if the user's password should be updated.

        :rtype: ``bool``
        """
        return self._password_update_requested[0]

    @password_update_requested.setter
    def password_update_requested(self, value):
        self._password_update_requested = (value, True)

    @property
    def principal(self):
        """
        Principal name used for authentication.

        :rtype: ``basestring``
        """
        return self._principal[0]

    @principal.setter
    def principal(self, value):
        self._principal = (value, True)

    @property
    def mobile_phone_number(self):
        """
        Mobile phone number of user.

        :rtype: ``basestring``
        """
        return self._mobile_phone_number[0]

    @mobile_phone_number.setter
    def mobile_phone_number(self, value):
        self._mobile_phone_number = (value, True)

    @property
    def work_phone_number(self):
        """
        Work phone number of user.

        :rtype: ``basestring``
        """
        return self._work_phone_number[0]

    @work_phone_number.setter
    def work_phone_number(self, value):
        self._work_phone_number = (value, True)

    @property
    def is_default(self):
        """
        True if this is the default user and cannot be deleted.

        :rtype: ``bool``
        """
        return self._is_default[0]

    @is_default.setter
    def is_default(self, value):
        self._is_default = (value, True)

    @property
    def name(self):
        """
        Name of user.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class Namespace(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Object namespace
    for target-side replication.
    """
    def __init__(self, undef_enabled=True):
        super(Namespace, self).__init__()
        self._type = ("Namespace", True)
        self._namespace_type = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._tag = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Namespace, cls).from_dict(data, dirty, undef_enabled)
        obj._namespace_type = (data.get("namespaceType", obj.__undef__), dirty)
        if obj._namespace_type[0] is not None and obj._namespace_type[0] is not obj.__undef__:
            assert isinstance(obj._namespace_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._namespace_type[0]))
            assert obj._namespace_type[0] in [u'REPLICATION'], "Expected enum [u'REPLICATION'] but got %s" % obj._namespace_type[0]
            common.validate_format(obj._namespace_type[0], "None", None, None)
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Namespace, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "namespace_type" == "type" or (self.namespace_type is not self.__undef__ and not (dirty and not self._namespace_type[1])):
            dct["namespaceType"] = dictify(self.namespace_type)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._namespace_type = (self._namespace_type[0], True)
        self._source = (self._source[0], True)
        self._tag = (self._tag[0], True)

    def is_dirty(self):
        return any([self._namespace_type[1], self._source[1], self._tag[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Namespace):
            return False
        return super(Namespace, self).__eq__(other) and \
               self.namespace_type == other.namespace_type and \
               self.source == other.source and \
               self.tag == other.tag

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def namespace_type(self):
        """
        Type of object namespace. *(permitted values: REPLICATION)*

        :rtype: ``basestring``
        """
        return self._namespace_type[0]

    @namespace_type.setter
    def namespace_type(self, value):
        self._namespace_type = (value, True)

    @property
    def source(self):
        """
        For replication, the source host IP address.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def tag(self):
        """
        A unique identifier for the source data stream.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

class EnvironmentUser(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* The representation
    of an environment user object.
    """
    def __init__(self, undef_enabled=True):
        super(EnvironmentUser, self).__init__()
        self._type = ("EnvironmentUser", True)
        self._environment = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._user_id = (self.__undef__, True)
        self._group_id = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnvironmentUser, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._user_id = (data.get("userId", obj.__undef__), dirty)
        if obj._user_id[0] is not None and obj._user_id[0] is not obj.__undef__:
            assert isinstance(obj._user_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user_id[0]))
            common.validate_format(obj._user_id[0], "None", None, None)
        obj._group_id = (data.get("groupId", obj.__undef__), dirty)
        if obj._group_id[0] is not None and obj._group_id[0] is not obj.__undef__:
            assert isinstance(obj._group_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._group_id[0]))
            common.validate_format(obj._group_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnvironmentUser, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "user_id" == "type" or (self.user_id is not self.__undef__ and not (dirty and not self._user_id[1])):
            dct["userId"] = dictify(self.user_id)
        if "group_id" == "type" or (self.group_id is not self.__undef__ and not (dirty and not self._group_id[1])):
            dct["groupId"] = dictify(self.group_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._credential = (self._credential[0], True)
        self._user_id = (self._user_id[0], True)
        self._group_id = (self._group_id[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._credential[1], self._user_id[1], self._group_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnvironmentUser):
            return False
        return super(EnvironmentUser, self).__eq__(other) and \
               self.environment == other.environment and \
               self.credential == other.credential and \
               self.user_id == other.user_id and \
               self.group_id == other.group_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        A reference to the associated environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def credential(self):
        """
        The credential for the environment user.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def user_id(self):
        """
        User ID of the user.

        :rtype: ``int``
        """
        return self._user_id[0]

    @user_id.setter
    def user_id(self, value):
        self._user_id = (value, True)

    @property
    def group_id(self):
        """
        Group ID of the user.

        :rtype: ``int``
        """
        return self._group_id[0]

    @group_id.setter
    def group_id(self, value):
        self._group_id = (value, True)

class Job(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Represents a job
    object
    """
    def __init__(self, undef_enabled=True):
        super(Job, self).__init__()
        self._type = ("Job", True)
        self._update_time = (self.__undef__, True)
        self._job_state = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._suspendable = (self.__undef__, True)
        self._cancelable = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._action_type = (self.__undef__, True)
        self._percent_complete = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._parent_action_state = (self.__undef__, True)
        self._email_addresses = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._events = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Job, cls).from_dict(data, dirty, undef_enabled)
        obj._update_time = (data.get("updateTime", obj.__undef__), dirty)
        if obj._update_time[0] is not None and obj._update_time[0] is not obj.__undef__:
            assert isinstance(obj._update_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._update_time[0]))
            common.validate_format(obj._update_time[0], "date", None, None)
        obj._job_state = (data.get("jobState", obj.__undef__), dirty)
        if obj._job_state[0] is not None and obj._job_state[0] is not obj.__undef__:
            assert isinstance(obj._job_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._job_state[0]))
            assert obj._job_state[0] in [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED'], "Expected enum [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED'] but got %s" % obj._job_state[0]
            common.validate_format(obj._job_state[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._suspendable = (data.get("suspendable", obj.__undef__), dirty)
        if obj._suspendable[0] is not None and obj._suspendable[0] is not obj.__undef__:
            assert isinstance(obj._suspendable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._suspendable[0]))
            common.validate_format(obj._suspendable[0], "None", None, None)
        obj._cancelable = (data.get("cancelable", obj.__undef__), dirty)
        if obj._cancelable[0] is not None and obj._cancelable[0] is not obj.__undef__:
            assert isinstance(obj._cancelable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cancelable[0]))
            common.validate_format(obj._cancelable[0], "None", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._action_type = (data.get("actionType", obj.__undef__), dirty)
        if obj._action_type[0] is not None and obj._action_type[0] is not obj.__undef__:
            assert isinstance(obj._action_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action_type[0]))
            common.validate_format(obj._action_type[0], "None", None, None)
        obj._percent_complete = (data.get("percentComplete", obj.__undef__), dirty)
        if obj._percent_complete[0] is not None and obj._percent_complete[0] is not obj.__undef__:
            assert isinstance(obj._percent_complete[0], float), ("Expected one of [u'number'], but got %s" % type(obj._percent_complete[0]))
            common.validate_format(obj._percent_complete[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._parent_action_state = (data.get("parentActionState", obj.__undef__), dirty)
        if obj._parent_action_state[0] is not None and obj._parent_action_state[0] is not obj.__undef__:
            assert isinstance(obj._parent_action_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_action_state[0]))
            assert obj._parent_action_state[0] in [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'], "Expected enum [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'] but got %s" % obj._parent_action_state[0]
            common.validate_format(obj._parent_action_state[0], "None", None, None)
        obj._email_addresses = []
        for item in data.get("emailAddresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._email_addresses.append(item)
        obj._email_addresses = (obj._email_addresses, dirty)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._events = []
        for item in data.get("events") or []:
            obj._events.append(factory.create_object(item))
            factory.validate_type(obj._events[-1], "JobEvent")
        obj._events = (obj._events, dirty)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Job, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "update_time" == "type" or (self.update_time is not self.__undef__ and not (dirty and not self._update_time[1])):
            dct["updateTime"] = dictify(self.update_time)
        if "job_state" == "type" or (self.job_state is not self.__undef__ and not (dirty and not self._job_state[1])):
            dct["jobState"] = dictify(self.job_state)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "suspendable" == "type" or (self.suspendable is not self.__undef__ and not (dirty and not self._suspendable[1])):
            dct["suspendable"] = dictify(self.suspendable)
        if "cancelable" == "type" or (self.cancelable is not self.__undef__ and not (dirty and not self._cancelable[1])):
            dct["cancelable"] = dictify(self.cancelable)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "action_type" == "type" or (self.action_type is not self.__undef__ and not (dirty and not self._action_type[1])):
            dct["actionType"] = dictify(self.action_type)
        if "percent_complete" == "type" or (self.percent_complete is not self.__undef__ and not (dirty and not self._percent_complete[1])):
            dct["percentComplete"] = dictify(self.percent_complete)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "parent_action_state" == "type" or (self.parent_action_state is not self.__undef__ and not (dirty and not self._parent_action_state[1])):
            dct["parentActionState"] = dictify(self.parent_action_state)
        if "email_addresses" == "type" or (self.email_addresses is not self.__undef__ and not (dirty and not self._email_addresses[1])):
            dct["emailAddresses"] = dictify(self.email_addresses)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "events" == "type" or (self.events is not self.__undef__ and not (dirty and not self._events[1])):
            dct["events"] = dictify(self.events)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._update_time = (self._update_time[0], True)
        self._job_state = (self._job_state[0], True)
        self._target = (self._target[0], True)
        self._title = (self._title[0], True)
        self._suspendable = (self._suspendable[0], True)
        self._cancelable = (self._cancelable[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._action_type = (self._action_type[0], True)
        self._percent_complete = (self._percent_complete[0], True)
        self._start_time = (self._start_time[0], True)
        self._parent_action_state = (self._parent_action_state[0], True)
        self._email_addresses = (self._email_addresses[0], True)
        self._target_name = (self._target_name[0], True)
        self._events = (self._events[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._update_time[1], self._job_state[1], self._target[1], self._title[1], self._suspendable[1], self._cancelable[1], self._target_object_type[1], self._action_type[1], self._percent_complete[1], self._start_time[1], self._parent_action_state[1], self._email_addresses[1], self._target_name[1], self._events[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Job):
            return False
        return super(Job, self).__eq__(other) and \
               self.update_time == other.update_time and \
               self.job_state == other.job_state and \
               self.target == other.target and \
               self.title == other.title and \
               self.suspendable == other.suspendable and \
               self.cancelable == other.cancelable and \
               self.target_object_type == other.target_object_type and \
               self.action_type == other.action_type and \
               self.percent_complete == other.percent_complete and \
               self.start_time == other.start_time and \
               self.parent_action_state == other.parent_action_state and \
               self.email_addresses == other.email_addresses and \
               self.target_name == other.target_name and \
               self.events == other.events and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def update_time(self):
        """
        Time the job was last updated.

        :rtype: ``basestring``
        """
        return self._update_time[0]

    @update_time.setter
    def update_time(self, value):
        self._update_time = (value, True)

    @property
    def job_state(self):
        """
        State of the job *(permitted values: INITIAL, RUNNING, SUSPENDED,
        CANCELED, COMPLETED, FAILED)*

        :rtype: ``basestring``
        """
        return self._job_state[0]

    @job_state.setter
    def job_state(self, value):
        self._job_state = (value, True)

    @property
    def target(self):
        """
        Object reference of the target

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def title(self):
        """
        Title of the job.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def suspendable(self):
        """
        Whether this job can be suspended.

        :rtype: ``bool``
        """
        return self._suspendable[0]

    @suspendable.setter
    def suspendable(self, value):
        self._suspendable = (value, True)

    @property
    def cancelable(self):
        """
        Whether this job can be canceled.

        :rtype: ``bool``
        """
        return self._cancelable[0]

    @cancelable.setter
    def cancelable(self, value):
        self._cancelable = (value, True)

    @property
    def target_object_type(self):
        """
        Object type of the target.

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def action_type(self):
        """
        Action type of the Job

        :rtype: ``basestring``
        """
        return self._action_type[0]

    @action_type.setter
    def action_type(self, value):
        self._action_type = (value, True)

    @property
    def percent_complete(self):
        """
        Completion percentage. This value is a copy of the last event's
        percentComplete. It will be 0 if there are no job events or if the
        events field is not populated while fetching the job.

        :rtype: ``float``
        """
        return self._percent_complete[0]

    @percent_complete.setter
    def percent_complete(self, value):
        self._percent_complete = (value, True)

    @property
    def start_time(self):
        """
        Time the job was created. Note that this is not the time when the job
        started executing.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def parent_action_state(self):
        """
        State of this job's parent action. This value is populated only if the
        job is fetched via the plain get API call. *(permitted values:
        EXECUTING, WAITING, COMPLETED, FAILED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._parent_action_state[0]

    @parent_action_state.setter
    def parent_action_state(self, value):
        self._parent_action_state = (value, True)

    @property
    def email_addresses(self):
        """
        Email addresses to be notified on job notification alerts.

        :rtype: ``list`` of ``basestring``
        """
        return self._email_addresses[0]

    @email_addresses.setter
    def email_addresses(self, value):
        self._email_addresses = (value, True)

    @property
    def target_name(self):
        """
        A cached copy of the target object name.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def events(self):
        """
        A list of time-sorted past JobEvent objects associated with this job.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.JobEvent`
        """
        return self._events[0]

    @events.setter
    def events(self, value):
        self._events = (value, True)

    @property
    def user(self):
        """
        User that initiated the action

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class SystemVersion(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Describes a
    Delphix software revision.
    """
    def __init__(self, undef_enabled=True):
        super(SystemVersion, self).__init__()
        self._type = ("SystemVersion", True)
        self._status = (self.__undef__, True)
        self._build_date = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._min_version = (self.__undef__, True)
        self._os_version = (self.__undef__, True)
        self._reboot_needed = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemVersion, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._build_date = (data.get("buildDate", obj.__undef__), dirty)
        if obj._build_date[0] is not None and obj._build_date[0] is not obj.__undef__:
            assert isinstance(obj._build_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_date[0]))
            common.validate_format(obj._build_date[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._min_version = (data.get("minVersion", obj.__undef__), dirty)
        if obj._min_version[0] is not None and obj._min_version[0] is not obj.__undef__:
            assert isinstance(obj._min_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._min_version[0]))
            common.validate_format(obj._min_version[0], "None", None, None)
        obj._os_version = (data.get("osVersion", obj.__undef__), dirty)
        if obj._os_version[0] is not None and obj._os_version[0] is not obj.__undef__:
            assert isinstance(obj._os_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os_version[0]))
            common.validate_format(obj._os_version[0], "None", None, None)
        obj._reboot_needed = (data.get("rebootNeeded", obj.__undef__), dirty)
        if obj._reboot_needed[0] is not None and obj._reboot_needed[0] is not obj.__undef__:
            assert isinstance(obj._reboot_needed[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._reboot_needed[0]))
            common.validate_format(obj._reboot_needed[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemVersion, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "build_date" == "type" or (self.build_date is not self.__undef__ and not (dirty and not self._build_date[1])):
            dct["buildDate"] = dictify(self.build_date)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "min_version" == "type" or (self.min_version is not self.__undef__ and not (dirty and not self._min_version[1])):
            dct["minVersion"] = dictify(self.min_version)
        if "os_version" == "type" or (self.os_version is not self.__undef__ and not (dirty and not self._os_version[1])):
            dct["osVersion"] = dictify(self.os_version)
        if "reboot_needed" == "type" or (self.reboot_needed is not self.__undef__ and not (dirty and not self._reboot_needed[1])):
            dct["rebootNeeded"] = dictify(self.reboot_needed)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._build_date = (self._build_date[0], True)
        self._version = (self._version[0], True)
        self._min_version = (self._min_version[0], True)
        self._os_version = (self._os_version[0], True)
        self._reboot_needed = (self._reboot_needed[0], True)

    def is_dirty(self):
        return any([self._status[1], self._build_date[1], self._version[1], self._min_version[1], self._os_version[1], self._reboot_needed[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemVersion):
            return False
        return super(SystemVersion, self).__eq__(other) and \
               self.status == other.status and \
               self.build_date == other.build_date and \
               self.version == other.version and \
               self.min_version == other.min_version and \
               self.os_version == other.os_version and \
               self.reboot_needed == other.reboot_needed

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The state of the version

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def build_date(self):
        """
        Date on which the version was built

        :rtype: ``basestring``
        """
        return self._build_date[0]

    @build_date.setter
    def build_date(self, value):
        self._build_date = (value, True)

    @property
    def version(self):
        """
        The Delphix version number

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def min_version(self):
        """
        The minimum required Delphix version in order to upgrade

        :rtype: ``basestring``
        """
        return self._min_version[0]

    @min_version.setter
    def min_version(self, value):
        self._min_version = (value, True)

    @property
    def os_version(self):
        """
        The DelphixOS version number

        :rtype: ``basestring``
        """
        return self._os_version[0]

    @os_version.setter
    def os_version(self, value):
        self._os_version = (value, True)

    @property
    def reboot_needed(self):
        """
        A system reboot is needed to apply this version

        :rtype: ``bool``
        """
        return self._reboot_needed[0]

    @reboot_needed.setter
    def reboot_needed(self, value):
        self._reboot_needed = (value, True)

class DVCBookmark(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* A named entity
    that represents a point in time for all of the data sources in an
    application.
    """
    def __init__(self, undef_enabled=True):
        super(DVCBookmark, self).__init__()
        self._type = ("DVCBookmark", True)
        self._container = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._tags = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._shared = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCBookmark, cls).from_dict(data, dirty, undef_enabled)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._tags = []
        for item in data.get("tags") or []:
            obj._tags.append(factory.create_object(item))
            factory.validate_type(obj._tags[-1], "DVCBookmarkTag")
        obj._tags = (obj._tags, dirty)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._shared = (data.get("shared", obj.__undef__), dirty)
        if obj._shared[0] is not None and obj._shared[0] is not obj.__undef__:
            assert isinstance(obj._shared[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._shared[0]))
            common.validate_format(obj._shared[0], "None", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "tags" == "type" or (self.tags is not self.__undef__ and not (dirty and not self._tags[1])):
            dct["tags"] = dictify(self.tags)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "shared" == "type" or (self.shared is not self.__undef__ and not (dirty and not self._shared[1])):
            dct["shared"] = dictify(self.shared)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._description = (self._description[0], True)
        self._tags = (self._tags[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._branch = (self._branch[0], True)
        self._shared = (self._shared[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._container[1], self._description[1], self._tags[1], self._timestamp[1], self._branch[1], self._shared[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCBookmark):
            return False
        return super(DVCBookmark, self).__eq__(other) and \
               self.container == other.container and \
               self.description == other.description and \
               self.tags == other.tags and \
               self.timestamp == other.timestamp and \
               self.branch == other.branch and \
               self.shared == other.shared and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The application container this bookmark was created on. This will be
        null if the bookmark was created on an application template.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def description(self):
        """
        Description of this bookmark.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def tags(self):
        """
        A set of user-defined labels for this bookmark.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.DVCBookmarkTag`
        """
        return self._tags[0]

    @tags.setter
    def tags(self, value):
        self._tags = (value, True)

    @property
    def timestamp(self):
        """
        The time when this bookmark was created.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def branch(self):
        """
        A reference to the DVC application branch this bookmark applies to.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def shared(self):
        """
        True if this bookmark is shared.

        :rtype: ``bool``
        """
        return self._shared[0]

    @shared.setter
    def shared(self, value):
        self._shared = (value, True)

    @property
    def template(self):
        """
        The application template this bookmark was created on or the template
        of the application container this bookmark was created on.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class AppDataToolkit(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An installed
    AppData toolkit.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataToolkit, self).__init__()
        self._type = ("AppDataToolkit", True)
        self._name = (self.__undef__, True)
        self._stop = (self.__undef__, True)
        self._start = (self.__undef__, True)
        self._snapshot = (self.__undef__, True)
        self._pretty_name = (self.__undef__, True)
        self._provision = (self.__undef__, True)
        self._provision_parameters = (self.__undef__, True)
        self._status_script = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataToolkit, cls).from_dict(data, dirty, undef_enabled)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        obj._stop = []
        for item in data.get("stop") or []:
            obj._stop.append(factory.create_object(item))
            factory.validate_type(obj._stop[-1], "Operation")
        obj._stop = (obj._stop, dirty)
        obj._start = []
        for item in data.get("start") or []:
            obj._start.append(factory.create_object(item))
            factory.validate_type(obj._start[-1], "Operation")
        obj._start = (obj._start, dirty)
        obj._snapshot = []
        for item in data.get("snapshot") or []:
            obj._snapshot.append(factory.create_object(item))
            factory.validate_type(obj._snapshot[-1], "Operation")
        obj._snapshot = (obj._snapshot, dirty)
        if "prettyName" not in data:
            raise ValueError("Missing required property \"prettyName\".")
        obj._pretty_name = (data.get("prettyName", obj.__undef__), dirty)
        if obj._pretty_name[0] is not None and obj._pretty_name[0] is not obj.__undef__:
            assert isinstance(obj._pretty_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pretty_name[0]))
            common.validate_format(obj._pretty_name[0], "None", None, 256)
        obj._provision = []
        for item in data.get("provision") or []:
            obj._provision.append(factory.create_object(item))
            factory.validate_type(obj._provision[-1], "Operation")
        obj._provision = (obj._provision, dirty)
        obj._provision_parameters = []
        for item in data.get("provisionParameters") or []:
            obj._provision_parameters.append(factory.create_object(item))
            factory.validate_type(obj._provision_parameters[-1], "AppDataParameter")
        obj._provision_parameters = (obj._provision_parameters, dirty)
        obj._status_script = (data.get("statusScript", obj.__undef__), dirty)
        if obj._status_script[0] is not None and obj._status_script[0] is not obj.__undef__:
            assert isinstance(obj._status_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status_script[0]))
            common.validate_format(obj._status_script[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataToolkit, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "stop" == "type" or (self.stop is not self.__undef__ and not (dirty and not self._stop[1])):
            dct["stop"] = dictify(self.stop)
        if "start" == "type" or (self.start is not self.__undef__ and not (dirty and not self._start[1])):
            dct["start"] = dictify(self.start)
        if "snapshot" == "type" or (self.snapshot is not self.__undef__ and not (dirty and not self._snapshot[1])):
            dct["snapshot"] = dictify(self.snapshot)
        if "pretty_name" == "type" or (self.pretty_name is not self.__undef__ and not (dirty and not self._pretty_name[1])):
            dct["prettyName"] = dictify(self.pretty_name)
        if "provision" == "type" or (self.provision is not self.__undef__ and not (dirty and not self._provision[1])):
            dct["provision"] = dictify(self.provision)
        if "provision_parameters" == "type" or (self.provision_parameters is not self.__undef__ and not (dirty and not self._provision_parameters[1])):
            dct["provisionParameters"] = dictify(self.provision_parameters)
        if "status_script" == "type" or (self.status_script is not self.__undef__ and not (dirty and not self._status_script[1])):
            dct["statusScript"] = dictify(self.status_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)
        self._stop = (self._stop[0], True)
        self._start = (self._start[0], True)
        self._snapshot = (self._snapshot[0], True)
        self._pretty_name = (self._pretty_name[0], True)
        self._provision = (self._provision[0], True)
        self._provision_parameters = (self._provision_parameters[0], True)
        self._status_script = (self._status_script[0], True)

    def is_dirty(self):
        return any([self._name[1], self._stop[1], self._start[1], self._snapshot[1], self._pretty_name[1], self._provision[1], self._provision_parameters[1], self._status_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataToolkit):
            return False
        return super(AppDataToolkit, self).__eq__(other) and \
               self.name == other.name and \
               self.stop == other.stop and \
               self.start == other.start and \
               self.snapshot == other.snapshot and \
               self.pretty_name == other.pretty_name and \
               self.provision == other.provision and \
               self.provision_parameters == other.provision_parameters and \
               self.status_script == other.status_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        A unique and descriptive name for the toolkit.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def stop(self):
        """
        A list of operations to run when stopping a virtual copy of the
        application. The environment for all operations will contain the
        provision parameters.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._stop[0]

    @stop.setter
    def stop(self, value):
        self._stop = (value, True)

    @property
    def start(self):
        """
        A list of operations to run when starting a virtual copy of the
        application. The environment for all operations will contain the
        provision parameters.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._start[0]

    @start.setter
    def start(self, value):
        self._start = (value, True)

    @property
    def snapshot(self):
        """
        A list of operations to run before taking a snapshot of a virtual copy
        of the application. The environment for all operations will contain the
        provision parameters.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._snapshot[0]

    @snapshot.setter
    def snapshot(self, value):
        self._snapshot = (value, True)

    @property
    def pretty_name(self):
        """
        A human readable name for the toolkit.

        :rtype: ``basestring``
        """
        return self._pretty_name[0]

    @pretty_name.setter
    def pretty_name(self, value):
        self._pretty_name = (value, True)

    @property
    def provision(self):
        """
        A list of operations to run when provisioning a virtual copy of the
        application. The environment for all operations will contain the
        provision parameters.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Operation`
        """
        return self._provision[0]

    @provision.setter
    def provision(self, value):
        self._provision = (value, True)

    @property
    def provision_parameters(self):
        """
        Dynamic parameters the user must enter as input when provisioning a
        virtual copy of this AppData type.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.AppDataParameter`
        """
        return self._provision_parameters[0]

    @provision_parameters.setter
    def provision_parameters(self, value):
        self._provision_parameters = (value, True)

    @property
    def status_script(self):
        """
        The script to run to determine if a virtual copy of the application is
        running. The script should exit with exit code of 0 if the application
        is running, 128 if the application is not running, and any other exit
        code if the script encounters an unexpected error. The script is passed
        the provision parameters as input.

        :rtype: ``basestring``
        """
        return self._status_script[0]

    @status_script.setter
    def status_script(self, value):
        self._status_script = (value, True)

class Container(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* A container
    holding data.
    """
    def __init__(self, undef_enabled=True):
        super(Container, self).__init__()
        self._type = ("Container", True)
        self._group = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._current_timeflow = (self.__undef__, True)
        self._performance_mode = (self.__undef__, True)
        self._masked = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._provision_container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Container, cls).from_dict(data, dirty, undef_enabled)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        obj._current_timeflow = (data.get("currentTimeflow", obj.__undef__), dirty)
        if obj._current_timeflow[0] is not None and obj._current_timeflow[0] is not obj.__undef__:
            assert isinstance(obj._current_timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_timeflow[0]))
            common.validate_format(obj._current_timeflow[0], "objectReference", None, None)
        obj._performance_mode = (data.get("performanceMode", obj.__undef__), dirty)
        if obj._performance_mode[0] is not None and obj._performance_mode[0] is not obj.__undef__:
            assert isinstance(obj._performance_mode[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._performance_mode[0]))
            common.validate_format(obj._performance_mode[0], "None", None, None)
        obj._masked = (data.get("masked", obj.__undef__), dirty)
        if obj._masked[0] is not None and obj._masked[0] is not obj.__undef__:
            assert isinstance(obj._masked[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._masked[0]))
            common.validate_format(obj._masked[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "DBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "DBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._provision_container = (data.get("provisionContainer", obj.__undef__), dirty)
        if obj._provision_container[0] is not None and obj._provision_container[0] is not obj.__undef__:
            assert isinstance(obj._provision_container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._provision_container[0]))
            common.validate_format(obj._provision_container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Container, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "current_timeflow" == "type" or (self.current_timeflow is not self.__undef__ and not (dirty and not self._current_timeflow[1])):
            dct["currentTimeflow"] = dictify(self.current_timeflow)
        if "performance_mode" == "type" or (self.performance_mode is not self.__undef__ and not (dirty and not self._performance_mode[1])):
            dct["performanceMode"] = dictify(self.performance_mode)
        if "masked" == "type" or (self.masked is not self.__undef__ and not (dirty and not self._masked[1])):
            dct["masked"] = dictify(self.masked)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "provision_container" == "type" or (self.provision_container is not self.__undef__ and not (dirty and not self._provision_container[1])):
            dct["provisionContainer"] = dictify(self.provision_container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._group = (self._group[0], True)
        self._description = (self._description[0], True)
        self._current_timeflow = (self._current_timeflow[0], True)
        self._performance_mode = (self._performance_mode[0], True)
        self._masked = (self._masked[0], True)
        self._runtime = (self._runtime[0], True)
        self._provision_container = (self._provision_container[0], True)

    def is_dirty(self):
        return any([self._group[1], self._description[1], self._current_timeflow[1], self._performance_mode[1], self._masked[1], self._runtime[1], self._provision_container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Container):
            return False
        return super(Container, self).__eq__(other) and \
               self.group == other.group and \
               self.description == other.description and \
               self.current_timeflow == other.current_timeflow and \
               self.performance_mode == other.performance_mode and \
               self.masked == other.masked and \
               self.runtime == other.runtime and \
               self.provision_container == other.provision_container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def group(self):
        """
        A reference to the group containing this container.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

    @property
    def description(self):
        """
        Optional user-provided description for the container.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def current_timeflow(self):
        """
        A reference to the currently active timeflow for this container.

        :rtype: ``basestring``
        """
        return self._current_timeflow[0]

    @current_timeflow.setter
    def current_timeflow(self, value):
        self._current_timeflow = (value, True)

    @property
    def performance_mode(self):
        """
        Whether to enable high performance mode.

        :rtype: ``bool``
        """
        return self._performance_mode[0]

    @performance_mode.setter
    def performance_mode(self, value):
        self._performance_mode = (value, True)

    @property
    def masked(self):
        """
        Whether this container has the masked bit set.

        :rtype: ``bool``
        """
        return self._masked[0]

    @masked.setter
    def masked(self, value):
        self._masked = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_3_0.web.vo.DBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def provision_container(self):
        """
        A reference to the container this container was provisioned from.

        :rtype: ``basestring``
        """
        return self._provision_container[0]

    @provision_container.setter
    def provision_container(self, value):
        self._provision_container = (value, True)

class OrphanFilesystem(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An orphan
    filesystem is used to represent a data dependency on a filesystem that has
    been logically deleted.
    """
    def __init__(self, undef_enabled=True):
        super(OrphanFilesystem, self).__init__()
        self._type = ("OrphanFilesystem", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OrphanFilesystem, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OrphanFilesystem, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OrphanFilesystem):
            return False
        return super(OrphanFilesystem, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OrphanSnapshot(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An orphan snapshot
    is used to represent a data dependency on a snapshot that has been
    logically deleted.
    """
    def __init__(self, undef_enabled=True):
        super(OrphanSnapshot, self).__init__()
        self._type = ("OrphanSnapshot", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OrphanSnapshot, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OrphanSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OrphanSnapshot):
            return False
        return super(OrphanSnapshot, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DatabaseTemplate(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Parameter
    configuration for virtual databases.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseTemplate, self).__init__()
        self._type = ("DatabaseTemplate", True)
        self._description = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._source_type = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseTemplate, cls).from_dict(data, dirty, undef_enabled)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._parameters = (data.get("parameters", obj.__undef__), dirty)
        if obj._parameters[0] is not None and obj._parameters[0] is not obj.__undef__:
            assert isinstance(obj._parameters[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._parameters[0]))
            common.validate_format(obj._parameters[0], "None", None, None)
        obj._source_type = (data.get("sourceType", obj.__undef__), dirty)
        if obj._source_type[0] is not None and obj._source_type[0] is not obj.__undef__:
            assert isinstance(obj._source_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_type[0]))
            assert obj._source_type[0] in [u'OracleVirtualSource', u'MSSqlVirtualSource', u'PgSQLVirtualSource'], "Expected enum [u'OracleVirtualSource', u'MSSqlVirtualSource', u'PgSQLVirtualSource'] but got %s" % obj._source_type[0]
            common.validate_format(obj._source_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "source_type" == "type" or (self.source_type is not self.__undef__ and not (dirty and not self._source_type[1])):
            dct["sourceType"] = dictify(self.source_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._description = (self._description[0], True)
        self._parameters = (self._parameters[0], True)
        self._source_type = (self._source_type[0], True)

    def is_dirty(self):
        return any([self._description[1], self._parameters[1], self._source_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseTemplate):
            return False
        return super(DatabaseTemplate, self).__eq__(other) and \
               self.description == other.description and \
               self.parameters == other.parameters and \
               self.source_type == other.source_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def description(self):
        """
        User provided description for this template.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def parameters(self):
        """
        A name/value map of string configuration parameters.

        :rtype: ``dict``
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def source_type(self):
        """
        The type of the source associated with the template. *(permitted
        values: OracleVirtualSource, MSSqlVirtualSource, PgSQLVirtualSource)*

        :rtype: ``basestring``
        """
        return self._source_type[0]

    @source_type.setter
    def source_type(self, value):
        self._source_type = (value, True)

class StatisticSlice(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Collects a slice
    of a multidimensional analytics statistic.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticSlice, self).__init__()
        self._type = ("StatisticSlice", True)
        self._collection_interval = (self.__undef__, True)
        self._axis_constraints = (self.__undef__, True)
        self._statistic_type = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._collection_axes = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticSlice, cls).from_dict(data, dirty, undef_enabled)
        obj._collection_interval = (data.get("collectionInterval", obj.__undef__), dirty)
        if obj._collection_interval[0] is not None and obj._collection_interval[0] is not obj.__undef__:
            assert isinstance(obj._collection_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._collection_interval[0]))
            common.validate_format(obj._collection_interval[0], "None", None, None)
        obj._axis_constraints = []
        for item in data.get("axisConstraints") or []:
            obj._axis_constraints.append(factory.create_object(item))
            factory.validate_type(obj._axis_constraints[-1], "AxisConstraint")
        obj._axis_constraints = (obj._axis_constraints, dirty)
        obj._statistic_type = (data.get("statisticType", obj.__undef__), dirty)
        if obj._statistic_type[0] is not None and obj._statistic_type[0] is not obj.__undef__:
            assert isinstance(obj._statistic_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._statistic_type[0]))
            common.validate_format(obj._statistic_type[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'RUNNING', u'PAUSED', u'FAILED'], "Expected enum [u'RUNNING', u'PAUSED', u'FAILED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._collection_axes = []
        for item in data.get("collectionAxes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._collection_axes.append(item)
        obj._collection_axes = (obj._collection_axes, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticSlice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "collection_interval" == "type" or (self.collection_interval is not self.__undef__ and not (dirty and not self._collection_interval[1])):
            dct["collectionInterval"] = dictify(self.collection_interval)
        if "axis_constraints" == "type" or (self.axis_constraints is not self.__undef__ and not (dirty and not self._axis_constraints[1])):
            dct["axisConstraints"] = dictify(self.axis_constraints)
        if "statistic_type" == "type" or (self.statistic_type is not self.__undef__ and not (dirty and not self._statistic_type[1])):
            dct["statisticType"] = dictify(self.statistic_type)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "collection_axes" == "type" or (self.collection_axes is not self.__undef__ and not (dirty and not self._collection_axes[1])):
            dct["collectionAxes"] = dictify(self.collection_axes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._collection_interval = (self._collection_interval[0], True)
        self._axis_constraints = (self._axis_constraints[0], True)
        self._statistic_type = (self._statistic_type[0], True)
        self._state = (self._state[0], True)
        self._collection_axes = (self._collection_axes[0], True)

    def is_dirty(self):
        return any([self._collection_interval[1], self._axis_constraints[1], self._statistic_type[1], self._state[1], self._collection_axes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticSlice):
            return False
        return super(StatisticSlice, self).__eq__(other) and \
               self.collection_interval == other.collection_interval and \
               self.axis_constraints == other.axis_constraints and \
               self.statistic_type == other.statistic_type and \
               self.state == other.state and \
               self.collection_axes == other.collection_axes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def collection_interval(self):
        """
        The minimum interval between each reading for this statistic.

        :rtype: ``int``
        """
        return self._collection_interval[0]

    @collection_interval.setter
    def collection_interval(self, value):
        self._collection_interval = (value, True)

    @property
    def axis_constraints(self):
        """
        Axis constraints act as per-axis filters on data that is being
        collected.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.AxisConstraint`
        """
        return self._axis_constraints[0]

    @axis_constraints.setter
    def axis_constraints(self, value):
        self._axis_constraints = (value, True)

    @property
    def statistic_type(self):
        """
        The type name for the data this can collect.

        :rtype: ``basestring``
        """
        return self._statistic_type[0]

    @statistic_type.setter
    def statistic_type(self, value):
        self._statistic_type = (value, True)

    @property
    def state(self):
        """
        Collection state of the slice. *(permitted values: RUNNING, PAUSED,
        FAILED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def collection_axes(self):
        """
        The set of axes to collect (usually these are not constrained axes).

        :rtype: ``list`` of ``basestring``
        """
        return self._collection_axes[0]

    @collection_axes.setter
    def collection_axes(self, value):
        self._collection_axes = (value, True)

class StorageDevice(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* A storage device
    on the system.
    """
    def __init__(self, undef_enabled=True):
        super(StorageDevice, self).__init__()
        self._type = ("StorageDevice", True)
        self._configured = (self.__undef__, True)
        self._vendor = (self.__undef__, True)
        self._model = (self.__undef__, True)
        self._serial = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageDevice, cls).from_dict(data, dirty, undef_enabled)
        obj._configured = (data.get("configured", obj.__undef__), dirty)
        if obj._configured[0] is not None and obj._configured[0] is not obj.__undef__:
            assert isinstance(obj._configured[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._configured[0]))
            common.validate_format(obj._configured[0], "None", None, None)
        obj._vendor = (data.get("vendor", obj.__undef__), dirty)
        if obj._vendor[0] is not None and obj._vendor[0] is not obj.__undef__:
            assert isinstance(obj._vendor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._vendor[0]))
            common.validate_format(obj._vendor[0], "None", None, None)
        obj._model = (data.get("model", obj.__undef__), dirty)
        if obj._model[0] is not None and obj._model[0] is not obj.__undef__:
            assert isinstance(obj._model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._model[0]))
            common.validate_format(obj._model[0], "None", None, None)
        obj._serial = (data.get("serial", obj.__undef__), dirty)
        if obj._serial[0] is not None and obj._serial[0] is not obj.__undef__:
            assert isinstance(obj._serial[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._serial[0]))
            common.validate_format(obj._serial[0], "None", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageDevice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "configured" == "type" or (self.configured is not self.__undef__ and not (dirty and not self._configured[1])):
            dct["configured"] = dictify(self.configured)
        if "vendor" == "type" or (self.vendor is not self.__undef__ and not (dirty and not self._vendor[1])):
            dct["vendor"] = dictify(self.vendor)
        if "model" == "type" or (self.model is not self.__undef__ and not (dirty and not self._model[1])):
            dct["model"] = dictify(self.model)
        if "serial" == "type" or (self.serial is not self.__undef__ and not (dirty and not self._serial[1])):
            dct["serial"] = dictify(self.serial)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._configured = (self._configured[0], True)
        self._vendor = (self._vendor[0], True)
        self._model = (self._model[0], True)
        self._serial = (self._serial[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._configured[1], self._vendor[1], self._model[1], self._serial[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageDevice):
            return False
        return super(StorageDevice, self).__eq__(other) and \
               self.configured == other.configured and \
               self.vendor == other.vendor and \
               self.model == other.model and \
               self.serial == other.serial and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def configured(self):
        """
        True if the device is currently configured in the system.

        :rtype: ``bool``
        """
        return self._configured[0]

    @configured.setter
    def configured(self, value):
        self._configured = (value, True)

    @property
    def vendor(self):
        """
        Vendor ID of the device.

        :rtype: ``basestring``
        """
        return self._vendor[0]

    @vendor.setter
    def vendor(self, value):
        self._vendor = (value, True)

    @property
    def model(self):
        """
        Model ID of the device.

        :rtype: ``basestring``
        """
        return self._model[0]

    @model.setter
    def model(self, value):
        self._model = (value, True)

    @property
    def serial(self):
        """
        Serial number of the device.

        :rtype: ``basestring``
        """
        return self._serial[0]

    @serial.setter
    def serial(self, value):
        self._serial = (value, True)

    @property
    def size(self):
        """
        Physical size of the device, in bytes.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class DVCApplication(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An application
    comprised of a set of data sources and configuration information.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplication, self).__init__()
        self._type = ("DVCApplication", True)
        self._current_branch = (self.__undef__, True)
        self._notes = (self.__undef__, True)
        self._last_updated = (self.__undef__, True)
        self._properties = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplication, cls).from_dict(data, dirty, undef_enabled)
        obj._current_branch = (data.get("currentBranch", obj.__undef__), dirty)
        if obj._current_branch[0] is not None and obj._current_branch[0] is not obj.__undef__:
            assert isinstance(obj._current_branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_branch[0]))
            common.validate_format(obj._current_branch[0], "objectReference", None, None)
        obj._notes = (data.get("notes", obj.__undef__), dirty)
        if obj._notes[0] is not None and obj._notes[0] is not obj.__undef__:
            assert isinstance(obj._notes[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._notes[0]))
            common.validate_format(obj._notes[0], "None", None, 4096)
        obj._last_updated = (data.get("lastUpdated", obj.__undef__), dirty)
        if obj._last_updated[0] is not None and obj._last_updated[0] is not obj.__undef__:
            assert isinstance(obj._last_updated[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_updated[0]))
            common.validate_format(obj._last_updated[0], "date", None, None)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplication, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "current_branch" == "type" or (self.current_branch is not self.__undef__ and not (dirty and not self._current_branch[1])):
            dct["currentBranch"] = dictify(self.current_branch)
        if "notes" == "type" or (self.notes is not self.__undef__ and not (dirty and not self._notes[1])):
            dct["notes"] = dictify(self.notes)
        if "last_updated" == "type" or (self.last_updated is not self.__undef__ and not (dirty and not self._last_updated[1])):
            dct["lastUpdated"] = dictify(self.last_updated)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._current_branch = (self._current_branch[0], True)
        self._notes = (self._notes[0], True)
        self._last_updated = (self._last_updated[0], True)
        self._properties = (self._properties[0], True)

    def is_dirty(self):
        return any([self._current_branch[1], self._notes[1], self._last_updated[1], self._properties[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplication):
            return False
        return super(DVCApplication, self).__eq__(other) and \
               self.current_branch == other.current_branch and \
               self.notes == other.notes and \
               self.last_updated == other.last_updated and \
               self.properties == other.properties

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def current_branch(self):
        """
        The active branch of the application.

        :rtype: ``basestring``
        """
        return self._current_branch[0]

    @current_branch.setter
    def current_branch(self, value):
        self._current_branch = (value, True)

    @property
    def notes(self):
        """
        Notes for this application.

        :rtype: ``basestring``
        """
        return self._notes[0]

    @notes.setter
    def notes(self, value):
        self._notes = (value, True)

    @property
    def last_updated(self):
        """
        Timestamp of the last update to the application.

        :rtype: ``basestring``
        """
        return self._last_updated[0]

    @last_updated.setter
    def last_updated(self, value):
        self._last_updated = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this application.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

class TimeflowSnapshot(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Snapshot of a
    point within a timeflow that is used as the basis for provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowSnapshot, self).__init__()
        self._type = ("TimeflowSnapshot", True)
        self._missing_non_logged_data = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._creation_time = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._first_change_point = (self.__undef__, True)
        self._consistency = (self.__undef__, True)
        self._timezone = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._retention = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowSnapshot, cls).from_dict(data, dirty, undef_enabled)
        obj._missing_non_logged_data = (data.get("missingNonLoggedData", obj.__undef__), dirty)
        if obj._missing_non_logged_data[0] is not None and obj._missing_non_logged_data[0] is not obj.__undef__:
            assert isinstance(obj._missing_non_logged_data[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._missing_non_logged_data[0]))
            common.validate_format(obj._missing_non_logged_data[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._creation_time = (data.get("creationTime", obj.__undef__), dirty)
        if obj._creation_time[0] is not None and obj._creation_time[0] is not obj.__undef__:
            assert isinstance(obj._creation_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._creation_time[0]))
            common.validate_format(obj._creation_time[0], "None", None, None)
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "TimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "TimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        obj._consistency = (data.get("consistency", obj.__undef__), dirty)
        if obj._consistency[0] is not None and obj._consistency[0] is not obj.__undef__:
            assert isinstance(obj._consistency[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._consistency[0]))
            common.validate_format(obj._consistency[0], "None", None, None)
        obj._timezone = (data.get("timezone", obj.__undef__), dirty)
        if obj._timezone[0] is not None and obj._timezone[0] is not obj.__undef__:
            assert isinstance(obj._timezone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timezone[0]))
            common.validate_format(obj._timezone[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "SnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._retention = (data.get("retention", obj.__undef__), dirty)
        if obj._retention[0] is not None and obj._retention[0] is not obj.__undef__:
            assert isinstance(obj._retention[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._retention[0]))
            common.validate_format(obj._retention[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "missing_non_logged_data" == "type" or (self.missing_non_logged_data is not self.__undef__ and not (dirty and not self._missing_non_logged_data[1])):
            dct["missingNonLoggedData"] = dictify(self.missing_non_logged_data)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "creation_time" == "type" or (self.creation_time is not self.__undef__ and not (dirty and not self._creation_time[1])):
            dct["creationTime"] = dictify(self.creation_time)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "consistency" == "type" or (self.consistency is not self.__undef__ and not (dirty and not self._consistency[1])):
            dct["consistency"] = dictify(self.consistency)
        if "timezone" == "type" or (self.timezone is not self.__undef__ and not (dirty and not self._timezone[1])):
            dct["timezone"] = dictify(self.timezone)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "retention" == "type" or (self.retention is not self.__undef__ and not (dirty and not self._retention[1])):
            dct["retention"] = dictify(self.retention)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._missing_non_logged_data = (self._missing_non_logged_data[0], True)
        self._container = (self._container[0], True)
        self._creation_time = (self._creation_time[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._version = (self._version[0], True)
        self._first_change_point = (self._first_change_point[0], True)
        self._consistency = (self._consistency[0], True)
        self._timezone = (self._timezone[0], True)
        self._runtime = (self._runtime[0], True)
        self._retention = (self._retention[0], True)

    def is_dirty(self):
        return any([self._missing_non_logged_data[1], self._container[1], self._creation_time[1], self._timeflow[1], self._latest_change_point[1], self._version[1], self._first_change_point[1], self._consistency[1], self._timezone[1], self._runtime[1], self._retention[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowSnapshot):
            return False
        return super(TimeflowSnapshot, self).__eq__(other) and \
               self.missing_non_logged_data == other.missing_non_logged_data and \
               self.container == other.container and \
               self.creation_time == other.creation_time and \
               self.timeflow == other.timeflow and \
               self.latest_change_point == other.latest_change_point and \
               self.version == other.version and \
               self.first_change_point == other.first_change_point and \
               self.consistency == other.consistency and \
               self.timezone == other.timezone and \
               self.runtime == other.runtime and \
               self.retention == other.retention

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def missing_non_logged_data(self):
        """
        Boolean value indicating if a virtual database provisioned from this
        snapshot will be missing nologging changes.

        :rtype: ``bool``
        """
        return self._missing_non_logged_data[0]

    @missing_non_logged_data.setter
    def missing_non_logged_data(self, value):
        self._missing_non_logged_data = (value, True)

    @property
    def container(self):
        """
        Reference to the database of which this timeflow is a part.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def creation_time(self):
        """
        Point in time at which this snapshot was created.  This may be
        different from the time corresponding to the timeflow.

        :rtype: ``basestring``
        """
        return self._creation_time[0]

    @creation_time.setter
    def creation_time(self, value):
        self._creation_time = (value, True)

    @property
    def timeflow(self):
        """
        Timeflow of which this snapshot is a part.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent timeflow represented by
        this snapshot.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def version(self):
        """
        Version of database source repository at the time the snapshot was
        taken.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def first_change_point(self):
        """
        The location within the parent timeflow at which this snapshot was
        initiated. No recovery earlier than this point needs to be applied in
        order to provision a database from this snapshot.  If
        "firstChangePoint" equals "latestChangePoint", then no recovery needs
        to be applied in order to provision a database.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def consistency(self):
        """
        A value in the set {CONSISTENT, INCONSISTENT, CRASH_CONSISTENT}
        indicating what type of recovery strategies must be invoked when
        provisioning from this snapshot.

        :rtype: ``basestring``
        """
        return self._consistency[0]

    @consistency.setter
    def consistency(self, value):
        self._consistency = (value, True)

    @property
    def timezone(self):
        """
        Time zone of the source database at the time the snapshot was taken.

        :rtype: ``basestring``
        """
        return self._timezone[0]

    @timezone.setter
    def timezone(self, value):
        self._timezone = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_3_0.web.vo.SnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def retention(self):
        """
        Retention policy, in days. A value of -1 indicates the snapshot should
        be kept forever.

        :rtype: ``int``
        """
        return self._retention[0]

    @retention.setter
    def retention(self, value):
        self._retention = (value, True)

class DVCOperation(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An operation that
    occurred on a DVC application.
    """
    def __init__(self, undef_enabled=True):
        super(DVCOperation, self).__init__()
        self._type = ("DVCOperation", True)
        self._data_parent = (self.__undef__, True)
        self._data_time = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._bookmark = (self.__undef__, True)
        self._application = (self.__undef__, True)
        self._valid = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._operation = (self.__undef__, True)
        self._end_time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCOperation, cls).from_dict(data, dirty, undef_enabled)
        if "dataParent" in data and data["dataParent"] is not None:
            obj._data_parent = (factory.create_object(data["dataParent"], "DVCDataParent"), dirty)
            factory.validate_type(obj._data_parent[0], "DVCDataParent")
        else:
            obj._data_parent = (obj.__undef__, dirty)
        obj._data_time = (data.get("dataTime", obj.__undef__), dirty)
        if obj._data_time[0] is not None and obj._data_time[0] is not obj.__undef__:
            assert isinstance(obj._data_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_time[0]))
            common.validate_format(obj._data_time[0], "date", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._application = (data.get("application", obj.__undef__), dirty)
        if obj._application[0] is not None and obj._application[0] is not obj.__undef__:
            assert isinstance(obj._application[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application[0]))
            common.validate_format(obj._application[0], "objectReference", None, None)
        obj._valid = (data.get("valid", obj.__undef__), dirty)
        if obj._valid[0] is not None and obj._valid[0] is not obj.__undef__:
            assert isinstance(obj._valid[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._valid[0]))
            common.validate_format(obj._valid[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._operation = (data.get("operation", obj.__undef__), dirty)
        if obj._operation[0] is not None and obj._operation[0] is not obj.__undef__:
            assert isinstance(obj._operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._operation[0]))
            assert obj._operation[0] in [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'DELETE_BRANCH', u'CREATE_BOOKMARK', u'DELETE_BOOKMARK', u'ENABLE', u'DISABLE', u'CHECKOUT', u'SWITCH_OFF', u'RECOVER'], "Expected enum [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'DELETE_BRANCH', u'CREATE_BOOKMARK', u'DELETE_BOOKMARK', u'ENABLE', u'DISABLE', u'CHECKOUT', u'SWITCH_OFF', u'RECOVER'] but got %s" % obj._operation[0]
            common.validate_format(obj._operation[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_parent" == "type" or (self.data_parent is not self.__undef__ and not (dirty and not self._data_parent[1])):
            dct["dataParent"] = dictify(self.data_parent)
        if "data_time" == "type" or (self.data_time is not self.__undef__ and not (dirty and not self._data_time[1])):
            dct["dataTime"] = dictify(self.data_time)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "application" == "type" or (self.application is not self.__undef__ and not (dirty and not self._application[1])):
            dct["application"] = dictify(self.application)
        if "valid" == "type" or (self.valid is not self.__undef__ and not (dirty and not self._valid[1])):
            dct["valid"] = dictify(self.valid)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_parent = (self._data_parent[0], True)
        self._data_time = (self._data_time[0], True)
        self._description = (self._description[0], True)
        self._bookmark = (self._bookmark[0], True)
        self._application = (self._application[0], True)
        self._valid = (self._valid[0], True)
        self._start_time = (self._start_time[0], True)
        self._branch = (self._branch[0], True)
        self._operation = (self._operation[0], True)
        self._end_time = (self._end_time[0], True)

    def is_dirty(self):
        return any([self._data_parent[1], self._data_time[1], self._description[1], self._bookmark[1], self._application[1], self._valid[1], self._start_time[1], self._branch[1], self._operation[1], self._end_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCOperation):
            return False
        return super(DVCOperation, self).__eq__(other) and \
               self.data_parent == other.data_parent and \
               self.data_time == other.data_time and \
               self.description == other.description and \
               self.bookmark == other.bookmark and \
               self.application == other.application and \
               self.valid == other.valid and \
               self.start_time == other.start_time and \
               self.branch == other.branch and \
               self.operation == other.operation and \
               self.end_time == other.end_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_parent(self):
        """
        The data parent of the operation.

        :rtype: :py:class:`v1_3_0.web.vo.DVCDataParent`
        """
        return self._data_parent[0]

    @data_parent.setter
    def data_parent(self, value):
        self._data_parent = (value, True)

    @property
    def data_time(self):
        """
        The time that the data represented by this operation was active.

        :rtype: ``basestring``
        """
        return self._data_time[0]

    @data_time.setter
    def data_time(self, value):
        self._data_time = (value, True)

    @property
    def description(self):
        """
        Plain text description of the operation.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def bookmark(self):
        """
        The bookmark that was created.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def application(self):
        """
        The application that this operation was performed on.

        :rtype: ``basestring``
        """
        return self._application[0]

    @application.setter
    def application(self, value):
        self._application = (value, True)

    @property
    def valid(self):
        """
        Represents whether the data at this point is valid.

        :rtype: ``bool``
        """
        return self._valid[0]

    @valid.setter
    def valid(self, value):
        self._valid = (value, True)

    @property
    def start_time(self):
        """
        The time the operation started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def branch(self):
        """
        The branch that this operation was performed on.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def operation(self):
        """
        The operation performed. *(permitted values: REFRESH, RESET,
        CREATE_BRANCH, DELETE_BRANCH, CREATE_BOOKMARK, DELETE_BOOKMARK, ENABLE,
        DISABLE, CHECKOUT, SWITCH_OFF, RECOVER)*

        :rtype: ``basestring``
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

    @property
    def end_time(self):
        """
        The time the operation finished. It will be null if the operation is in
        progress.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

class Timeflow(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* Data for a
    particular historical timeline within a database.
    """
    def __init__(self, undef_enabled=True):
        super(Timeflow, self).__init__()
        self._type = ("Timeflow", True)
        self._parent_point = (self.__undef__, True)
        self._parent_snapshot = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Timeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "TimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        obj._parent_snapshot = (data.get("parentSnapshot", obj.__undef__), dirty)
        if obj._parent_snapshot[0] is not None and obj._parent_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._parent_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_snapshot[0]))
            common.validate_format(obj._parent_snapshot[0], "objectReference", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Timeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        if "parent_snapshot" == "type" or (self.parent_snapshot is not self.__undef__ and not (dirty and not self._parent_snapshot[1])):
            dct["parentSnapshot"] = dictify(self.parent_snapshot)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)
        self._parent_snapshot = (self._parent_snapshot[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._parent_point[1], self._parent_snapshot[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Timeflow):
            return False
        return super(Timeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point and \
               self.parent_snapshot == other.parent_snapshot and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent timeflow from which this timeflow was
        provisioned. This will not be present for timeflows derived from linked
        sources.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

    @property
    def parent_snapshot(self):
        """
        Reference to the parent snapshot that serves as the provisioning base
        for this object. This may be different from the snapshot within the
        parent point, and is only present for virtual timeflows.

        :rtype: ``basestring``
        """
        return self._parent_snapshot[0]

    @parent_snapshot.setter
    def parent_snapshot(self, value):
        self._parent_snapshot = (value, True)

    @property
    def container(self):
        """
        Reference to the data container (database) for this timeflow.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class TimeflowBookmark(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* A timeflow
    bookmark is a user defined name for a timeflow point (location or timestamp
    within a timeflow).
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowBookmark, self).__init__()
        self._type = ("TimeflowBookmark", True)
        self._timestamp = (self.__undef__, True)
        self._retention_proof = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._location = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowBookmark, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._retention_proof = (data.get("retentionProof", obj.__undef__), dirty)
        if obj._retention_proof[0] is not None and obj._retention_proof[0] is not obj.__undef__:
            assert isinstance(obj._retention_proof[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._retention_proof[0]))
            common.validate_format(obj._retention_proof[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, 64)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "retention_proof" == "type" or (self.retention_proof is not self.__undef__ and not (dirty and not self._retention_proof[1])):
            dct["retentionProof"] = dictify(self.retention_proof)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._retention_proof = (self._retention_proof[0], True)
        self._tag = (self._tag[0], True)
        self._location = (self._location[0], True)
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._retention_proof[1], self._tag[1], self._location[1], self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowBookmark):
            return False
        return super(TimeflowBookmark, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.retention_proof == other.retention_proof and \
               self.tag == other.tag and \
               self.location == other.location and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the timeflow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def retention_proof(self):
        """
        Indicates whether retention should be allowed to clean up the timeflow
        bookmark and associated data.

        :rtype: ``bool``
        """
        return self._retention_proof[0]

    @retention_proof.setter
    def retention_proof(self, value):
        self._retention_proof = (value, True)

    @property
    def tag(self):
        """
        A tag for the bookmark that can be used to group timeflow bookmarks
        together or qualify the type of the bookmark.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def location(self):
        """
        The timeflow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

    @property
    def timeflow(self):
        """
        Reference to the timeflow for this bookmark.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class OracleListener(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* An Oracle
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleListener, self).__init__()
        self._type = ("OracleListener", True)
        self._discovered = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._end_points = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleListener, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._end_points = []
        for item in data.get("endPoints") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "hostnameAndPort", None, None)
            obj._end_points.append(item)
        obj._end_points = (obj._end_points, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "end_points" == "type" or (self.end_points is not self.__undef__ and not (dirty and not self._end_points[1])):
            dct["endPoints"] = dictify(self.end_points)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._environment = (self._environment[0], True)
        self._end_points = (self._end_points[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._environment[1], self._end_points[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleListener):
            return False
        return super(OracleListener, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.environment == other.environment and \
               self.end_points == other.end_points

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this listener was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def environment(self):
        """
        Reference to the environment this listener is associated with.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def end_points(self):
        """
        The list of end points for this listener.

        :rtype: ``list`` of ``basestring``
        """
        return self._end_points[0]

    @end_points.setter
    def end_points(self, value):
        self._end_points = (value, True)

class DVCDataSource(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* The data source
    used for Data Version Control applications.
    """
    def __init__(self, undef_enabled=True):
        super(DVCDataSource, self).__init__()
        self._type = ("DVCDataSource", True)
        self._container = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._application = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._properties = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCDataSource, cls).from_dict(data, dirty, undef_enabled)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._application = (data.get("application", obj.__undef__), dirty)
        if obj._application[0] is not None and obj._application[0] is not obj.__undef__:
            assert isinstance(obj._application[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application[0]))
            common.validate_format(obj._application[0], "objectReference", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SourceConnectionInfo"), dirty)
            factory.validate_type(obj._runtime[0], "SourceConnectionInfo")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCDataSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "application" == "type" or (self.application is not self.__undef__ and not (dirty and not self._application[1])):
            dct["application"] = dictify(self.application)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._description = (self._description[0], True)
        self._enabled = (self._enabled[0], True)
        self._application = (self._application[0], True)
        self._runtime = (self._runtime[0], True)
        self._properties = (self._properties[0], True)

    def is_dirty(self):
        return any([self._container[1], self._description[1], self._enabled[1], self._application[1], self._runtime[1], self._properties[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCDataSource):
            return False
        return super(DVCDataSource, self).__eq__(other) and \
               self.container == other.container and \
               self.description == other.description and \
               self.enabled == other.enabled and \
               self.application == other.application and \
               self.runtime == other.runtime and \
               self.properties == other.properties

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        A reference to the underlying container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def description(self):
        """
        A description of this data source.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def enabled(self):
        """
        Flag indicating whether the source is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def application(self):
        """
        A reference to the DVC application to which this source belongs.

        :rtype: ``basestring``
        """
        return self._application[0]

    @application.setter
    def application(self, value):
        self._application = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this data source.

        :rtype: :py:class:`v1_3_0.web.vo.SourceConnectionInfo`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this data source.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

class OracleClusterNode(NamedUserObject):
    """
    *(extends* :py:class:`v1_3_0.web.vo.NamedUserObject` *)* The representation
    of an oracle cluster node object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterNode, self).__init__()
        self._type = ("OracleClusterNode", True)
        self._discovered = (self.__undef__, True)
        self._cluster = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._virtual_i_ps = (self.__undef__, True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterNode, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._cluster = (data.get("cluster", obj.__undef__), dirty)
        if obj._cluster[0] is not None and obj._cluster[0] is not obj.__undef__:
            assert isinstance(obj._cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster[0]))
            common.validate_format(obj._cluster[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._virtual_i_ps = []
        for item in data.get("virtualIPs") or []:
            obj._virtual_i_ps.append(factory.create_object(item))
            factory.validate_type(obj._virtual_i_ps[-1], "OracleVirtualIP")
        obj._virtual_i_ps = (obj._virtual_i_ps, dirty)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterNode, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "virtual_i_ps" == "type" or (self.virtual_i_ps is not self.__undef__ and not (dirty and not self._virtual_i_ps[1])):
            dct["virtualIPs"] = dictify(self.virtual_i_ps)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._cluster = (self._cluster[0], True)
        self._host = (self._host[0], True)
        self._virtual_i_ps = (self._virtual_i_ps[0], True)
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._cluster[1], self._host[1], self._virtual_i_ps[1], self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterNode):
            return False
        return super(OracleClusterNode, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.cluster == other.cluster and \
               self.host == other.host and \
               self.virtual_i_ps == other.virtual_i_ps and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Indicates whether the node is discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def cluster(self):
        """
        The reference to the parent cluster environment.

        :rtype: ``basestring``
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def host(self):
        """
        The reference to the associated host object.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def virtual_i_ps(self):
        """
        The list of virtual IPs belonging to this node.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleVirtualIP`
        """
        return self._virtual_i_ps[0]

    @virtual_i_ps.setter
    def virtual_i_ps(self, value):
        self._virtual_i_ps = (value, True)

    @property
    def enabled(self):
        """
        Indicates whether the node is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class OracleScanListener(OracleListener):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleListener` *)* An Oracle scan
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleScanListener, self).__init__()
        self._type = ("OracleScanListener", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleScanListener, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleScanListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleScanListener):
            return False
        return super(OracleScanListener, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleNodeListener(OracleListener):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OracleListener` *)* An Oracle node
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleNodeListener, self).__init__()
        self._type = ("OracleNodeListener", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleNodeListener, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleNodeListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleNodeListener):
            return False
        return super(OracleNodeListener, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        Reference to the host this listener is associated with.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class AppDataTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Timeflow` *)* Timeflow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataTimeflow, self).__init__()
        self._type = ("AppDataTimeflow", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataTimeflow, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataTimeflow):
            return False
        return super(AppDataTimeflow, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a PostgreSQL container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLTimeflow, self).__init__()
        self._type = ("PgSQLTimeflow", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLTimeflow, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLTimeflow):
            return False
        return super(PgSQLTimeflow, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Timeflow` *)* Timeflow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleTimeflow, self).__init__()
        self._type = ("OracleTimeflow", True)
        self._incarnation_id = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTimeflow, cls).from_dict(data, dirty, undef_enabled)
        obj._incarnation_id = (data.get("incarnationID", obj.__undef__), dirty)
        if obj._incarnation_id[0] is not None and obj._incarnation_id[0] is not obj.__undef__:
            assert isinstance(obj._incarnation_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._incarnation_id[0]))
            common.validate_format(obj._incarnation_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "incarnation_id" == "type" or (self.incarnation_id is not self.__undef__ and not (dirty and not self._incarnation_id[1])):
            dct["incarnationID"] = dictify(self.incarnation_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._incarnation_id = (self._incarnation_id[0], True)

    def is_dirty(self):
        return any([self._incarnation_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTimeflow):
            return False
        return super(OracleTimeflow, self).__eq__(other) and \
               self.incarnation_id == other.incarnation_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def incarnation_id(self):
        """
        Oracle-specific incarnation identifier for this timeflow

        :rtype: ``basestring``
        """
        return self._incarnation_id[0]

    @incarnation_id.setter
    def incarnation_id(self, value):
        self._incarnation_id = (value, True)

class MSSqlTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Timeflow` *)* Timeflow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlTimeflow, self).__init__()
        self._type = ("MSSqlTimeflow", True)
        self._database_guid = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlTimeflow, cls).from_dict(data, dirty, undef_enabled)
        obj._database_guid = (data.get("databaseGuid", obj.__undef__), dirty)
        if obj._database_guid[0] is not None and obj._database_guid[0] is not obj.__undef__:
            assert isinstance(obj._database_guid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_guid[0]))
            common.validate_format(obj._database_guid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_guid" == "type" or (self.database_guid is not self.__undef__ and not (dirty and not self._database_guid[1])):
            dct["databaseGuid"] = dictify(self.database_guid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_guid = (self._database_guid[0], True)

    def is_dirty(self):
        return any([self._database_guid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlTimeflow):
            return False
        return super(MSSqlTimeflow, self).__eq__(other) and \
               self.database_guid == other.database_guid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_guid(self):
        """
        MSSQL-specific recovery branch identifier for this timeflow

        :rtype: ``basestring``
        """
        return self._database_guid[0]

    @database_guid.setter
    def database_guid(self, value):
        self._database_guid = (value, True)

class PgSQLSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a PostgreSQL TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSnapshot, self).__init__()
        self._type = ("PgSQLSnapshot", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSnapshot, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSnapshot):
            return False
        return super(PgSQLSnapshot, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowSnapshot` *)* Snapshot of an
    AppData TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSnapshot, self).__init__()
        self._type = ("AppDataSnapshot", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSnapshot, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSnapshot):
            return False
        return super(AppDataSnapshot, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a MSSQL timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSnapshot, self).__init__()
        self._type = ("MSSqlSnapshot", True)
        self._runtime = (self.__undef__, True)
        self._backup_set_uuid = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MSSqlSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MSSqlSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._backup_set_uuid = (data.get("backupSetUUID", obj.__undef__), dirty)
        if obj._backup_set_uuid[0] is not None and obj._backup_set_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_set_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_set_uuid[0]))
            common.validate_format(obj._backup_set_uuid[0], "None", None, None)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "backup_set_uuid" == "type" or (self.backup_set_uuid is not self.__undef__ and not (dirty and not self._backup_set_uuid[1])):
            dct["backupSetUUID"] = dictify(self.backup_set_uuid)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)
        self._backup_set_uuid = (self._backup_set_uuid[0], True)
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._runtime[1], self._backup_set_uuid[1], self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSnapshot):
            return False
        return super(MSSqlSnapshot, self).__eq__(other) and \
               self.runtime == other.runtime and \
               self.backup_set_uuid == other.backup_set_uuid and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def backup_set_uuid(self):
        """
        UUID of the source database backup that was restored for this snapshot.

        :rtype: ``basestring``
        """
        return self._backup_set_uuid[0]

    @backup_set_uuid.setter
    def backup_set_uuid(self, value):
        self._backup_set_uuid = (value, True)

    @property
    def internal_version(self):
        """
        Internal version of the source database at the time the snapshot was
        taken.

        :rtype: ``int``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class OracleSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of an Oracle timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSnapshot, self).__init__()
        self._type = ("OracleSnapshot", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSnapshot):
            return False
        return super(OracleSnapshot, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_3_0.web.vo.OracleSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class DVCApplicationTemplate(DVCApplication):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCApplication` *)* An application
    template is a collection of data sourcess and configuration representing an
    application that can be provisioned to DVC users.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplicationTemplate, self).__init__()
        self._type = ("DVCApplicationTemplate", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplicationTemplate, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplicationTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplicationTemplate):
            return False
        return super(DVCApplicationTemplate, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DVCApplicationContainer(DVCApplication):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCApplication` *)* A container
    represents an application template provisioned for a specific user.
    """
    def __init__(self, undef_enabled=True):
        super(DVCApplicationContainer, self).__init__()
        self._type = ("DVCApplicationContainer", True)
        self._owner = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCApplicationContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._owner = (data.get("owner", obj.__undef__), dirty)
        if obj._owner[0] is not None and obj._owner[0] is not obj.__undef__:
            assert isinstance(obj._owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._owner[0]))
            common.validate_format(obj._owner[0], "objectReference", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'ENABLED', u'DISABLED', u'DELETING', u'FAULTED'], "Expected enum [u'ENABLED', u'DISABLED', u'DELETING', u'FAULTED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCApplicationContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owner" == "type" or (self.owner is not self.__undef__ and not (dirty and not self._owner[1])):
            dct["owner"] = dictify(self.owner)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owner = (self._owner[0], True)
        self._state = (self._state[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._owner[1], self._state[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCApplicationContainer):
            return False
        return super(DVCApplicationContainer, self).__eq__(other) and \
               self.owner == other.owner and \
               self.state == other.state and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owner(self):
        """
        A reference to the user that owns this application container.

        :rtype: ``basestring``
        """
        return self._owner[0]

    @owner.setter
    def owner(self, value):
        self._owner = (value, True)

    @property
    def state(self):
        """
        The state of the application container. *(permitted values: ENABLED,
        DISABLED, DELETING, FAULTED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def template(self):
        """
        The application template that this application container was
        provisioned from.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class ConfiguredStorageDevice(StorageDevice):
    """
    *(extends* :py:class:`v1_3_0.web.vo.StorageDevice` *)* A storage device
    configured as usable storage.
    """
    def __init__(self, undef_enabled=True):
        super(ConfiguredStorageDevice, self).__init__()
        self._type = ("ConfiguredStorageDevice", True)
        self._boot_device = (self.__undef__, True)
        self._used_size = (self.__undef__, True)
        self._expandable_size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ConfiguredStorageDevice, cls).from_dict(data, dirty, undef_enabled)
        obj._boot_device = (data.get("bootDevice", obj.__undef__), dirty)
        if obj._boot_device[0] is not None and obj._boot_device[0] is not obj.__undef__:
            assert isinstance(obj._boot_device[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._boot_device[0]))
            common.validate_format(obj._boot_device[0], "None", None, None)
        obj._used_size = (data.get("usedSize", obj.__undef__), dirty)
        if obj._used_size[0] is not None and obj._used_size[0] is not obj.__undef__:
            assert isinstance(obj._used_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._used_size[0]))
            common.validate_format(obj._used_size[0], "None", None, None)
        obj._expandable_size = (data.get("expandableSize", obj.__undef__), dirty)
        if obj._expandable_size[0] is not None and obj._expandable_size[0] is not obj.__undef__:
            assert isinstance(obj._expandable_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._expandable_size[0]))
            common.validate_format(obj._expandable_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ConfiguredStorageDevice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "boot_device" == "type" or (self.boot_device is not self.__undef__ and not (dirty and not self._boot_device[1])):
            dct["bootDevice"] = dictify(self.boot_device)
        if "used_size" == "type" or (self.used_size is not self.__undef__ and not (dirty and not self._used_size[1])):
            dct["usedSize"] = dictify(self.used_size)
        if "expandable_size" == "type" or (self.expandable_size is not self.__undef__ and not (dirty and not self._expandable_size[1])):
            dct["expandableSize"] = dictify(self.expandable_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._boot_device = (self._boot_device[0], True)
        self._used_size = (self._used_size[0], True)
        self._expandable_size = (self._expandable_size[0], True)

    def is_dirty(self):
        return any([self._boot_device[1], self._used_size[1], self._expandable_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ConfiguredStorageDevice):
            return False
        return super(ConfiguredStorageDevice, self).__eq__(other) and \
               self.boot_device == other.boot_device and \
               self.used_size == other.used_size and \
               self.expandable_size == other.expandable_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def boot_device(self):
        """
        Boolean value indicating if this is a boot device.

        :rtype: ``bool``
        """
        return self._boot_device[0]

    @boot_device.setter
    def boot_device(self, value):
        self._boot_device = (value, True)

    @property
    def used_size(self):
        """
        Size of allocated space on the device.

        :rtype: ``float``
        """
        return self._used_size[0]

    @used_size.setter
    def used_size(self, value):
        self._used_size = (value, True)

    @property
    def expandable_size(self):
        """
        Amount of additional space that would be made available, if the device
        is expanded.

        :rtype: ``float``
        """
        return self._expandable_size[0]

    @expandable_size.setter
    def expandable_size(self, value):
        self._expandable_size = (value, True)

class DatabaseContainer(Container):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Container` *)* A container holding
    database data.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseContainer, self).__init__()
        self._type = ("DatabaseContainer", True)
        self._os = (self.__undef__, True)
        self._processor = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            common.validate_format(obj._os[0], "None", None, None)
        obj._processor = (data.get("processor", obj.__undef__), dirty)
        if obj._processor[0] is not None and obj._processor[0] is not obj.__undef__:
            assert isinstance(obj._processor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._processor[0]))
            common.validate_format(obj._processor[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "SourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "SourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        if "processor" == "type" or (self.processor is not self.__undef__ and not (dirty and not self._processor[1])):
            dct["processor"] = dictify(self.processor)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._os = (self._os[0], True)
        self._processor = (self._processor[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)

    def is_dirty(self):
        return any([self._os[1], self._processor[1], self._sourcing_policy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseContainer):
            return False
        return super(DatabaseContainer, self).__eq__(other) and \
               self.os == other.os and \
               self.processor == other.processor and \
               self.sourcing_policy == other.sourcing_policy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def os(self):
        """
        Native operating system of the original database source system.

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

    @property
    def processor(self):
        """
        Native processor type of the original database source system.

        :rtype: ``basestring``
        """
        return self._processor[0]

    @processor.setter
    def processor(self, value):
        self._processor = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing logsync and snapsync across sources.

        :rtype: :py:class:`v1_3_0.web.vo.SourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

class AppDataContainer(Container):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Container` *)* Data container for
    AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataContainer, self).__init__()
        self._type = ("AppDataContainer", True)
        self._os = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            common.validate_format(obj._os[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._os = (self._os[0], True)

    def is_dirty(self):
        return any([self._os[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataContainer):
            return False
        return super(AppDataContainer, self).__eq__(other) and \
               self.os == other.os

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def os(self):
        """
        Native operating system of the original data source system.

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

class MSSqlDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatabaseContainer` *)* A MSSQL Database
    Container
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDatabaseContainer, self).__init__()
        self._type = ("MSSqlDatabaseContainer", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MSSqlDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MSSqlDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDatabaseContainer):
            return False
        return super(MSSqlDatabaseContainer, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class PgSQLDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatabaseContainer` *)* A PostgreSQL
    Database Container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDatabaseContainer, self).__init__()
        self._type = ("PgSQLDatabaseContainer", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "PgSQLDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "PgSQLDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDatabaseContainer):
            return False
        return super(PgSQLDatabaseContainer, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class OracleDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DatabaseContainer` *)* Data container
    for Oracle databases, both linked and virtual.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseContainer, self).__init__()
        self._type = ("OracleDatabaseContainer", True)
        self._diagnose_no_logging_faults = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)
        self._endianness = (self.__undef__, True)
        self._pre_provisioning_enabled = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._cross_platform_ready = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._diagnose_no_logging_faults = (data.get("diagnoseNoLoggingFaults", obj.__undef__), dirty)
        if obj._diagnose_no_logging_faults[0] is not None and obj._diagnose_no_logging_faults[0] is not obj.__undef__:
            assert isinstance(obj._diagnose_no_logging_faults[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._diagnose_no_logging_faults[0]))
            common.validate_format(obj._diagnose_no_logging_faults[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "OracleSourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "OracleSourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        obj._endianness = (data.get("endianness", obj.__undef__), dirty)
        if obj._endianness[0] is not None and obj._endianness[0] is not obj.__undef__:
            assert isinstance(obj._endianness[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._endianness[0]))
            assert obj._endianness[0] in [u'BIG_ENDIAN', u'LITTLE_ENDIAN'], "Expected enum [u'BIG_ENDIAN', u'LITTLE_ENDIAN'] but got %s" % obj._endianness[0]
            common.validate_format(obj._endianness[0], "None", None, None)
        obj._pre_provisioning_enabled = (data.get("preProvisioningEnabled", obj.__undef__), dirty)
        if obj._pre_provisioning_enabled[0] is not None and obj._pre_provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._pre_provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._pre_provisioning_enabled[0]))
            common.validate_format(obj._pre_provisioning_enabled[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._cross_platform_ready = (data.get("crossPlatformReady", obj.__undef__), dirty)
        if obj._cross_platform_ready[0] is not None and obj._cross_platform_ready[0] is not obj.__undef__:
            assert isinstance(obj._cross_platform_ready[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cross_platform_ready[0]))
            common.validate_format(obj._cross_platform_ready[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "diagnose_no_logging_faults" == "type" or (self.diagnose_no_logging_faults is not self.__undef__ and not (dirty and not self._diagnose_no_logging_faults[1])):
            dct["diagnoseNoLoggingFaults"] = dictify(self.diagnose_no_logging_faults)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        if "endianness" == "type" or (self.endianness is not self.__undef__ and not (dirty and not self._endianness[1])):
            dct["endianness"] = dictify(self.endianness)
        if "pre_provisioning_enabled" == "type" or (self.pre_provisioning_enabled is not self.__undef__ and not (dirty and not self._pre_provisioning_enabled[1])):
            dct["preProvisioningEnabled"] = dictify(self.pre_provisioning_enabled)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "cross_platform_ready" == "type" or (self.cross_platform_ready is not self.__undef__ and not (dirty and not self._cross_platform_ready[1])):
            dct["crossPlatformReady"] = dictify(self.cross_platform_ready)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._diagnose_no_logging_faults = (self._diagnose_no_logging_faults[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)
        self._endianness = (self._endianness[0], True)
        self._pre_provisioning_enabled = (self._pre_provisioning_enabled[0], True)
        self._runtime = (self._runtime[0], True)
        self._cross_platform_ready = (self._cross_platform_ready[0], True)

    def is_dirty(self):
        return any([self._diagnose_no_logging_faults[1], self._sourcing_policy[1], self._endianness[1], self._pre_provisioning_enabled[1], self._runtime[1], self._cross_platform_ready[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseContainer):
            return False
        return super(OracleDatabaseContainer, self).__eq__(other) and \
               self.diagnose_no_logging_faults == other.diagnose_no_logging_faults and \
               self.sourcing_policy == other.sourcing_policy and \
               self.endianness == other.endianness and \
               self.pre_provisioning_enabled == other.pre_provisioning_enabled and \
               self.runtime == other.runtime and \
               self.cross_platform_ready == other.cross_platform_ready

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def diagnose_no_logging_faults(self):
        """
        *(default value: True)* If true, NOLOGGING operations on this container
        are treated as faults and cannot be resolved manually. Otherwise, these
        operations are ignored

        :rtype: ``bool``
        """
        return self._diagnose_no_logging_faults[0]

    @diagnose_no_logging_faults.setter
    def diagnose_no_logging_faults(self, value):
        self._diagnose_no_logging_faults = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing logsync and snapsync across sources.

        :rtype: :py:class:`v1_3_0.web.vo.OracleSourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

    @property
    def endianness(self):
        """
        Native endianness of the original database source system. *(permitted
        values: BIG_ENDIAN, LITTLE_ENDIAN)*

        :rtype: ``basestring``
        """
        return self._endianness[0]

    @endianness.setter
    def endianness(self, value):
        self._endianness = (value, True)

    @property
    def pre_provisioning_enabled(self):
        """
        If true, pre-provisioning will be performed after every sync

        :rtype: ``bool``
        """
        return self._pre_provisioning_enabled[0]

    @pre_provisioning_enabled.setter
    def pre_provisioning_enabled(self, value):
        self._pre_provisioning_enabled = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_3_0.web.vo.OracleDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def cross_platform_ready(self):
        """
        Indicates whether or not this container is ready for cross-platform
        provisioning.

        :rtype: ``bool``
        """
        return self._cross_platform_ready[0]

    @cross_platform_ready.setter
    def cross_platform_ready(self, value):
        self._cross_platform_ready = (value, True)

class SchedulePolicy(Policy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Policy` *)* The base type for all
    schedule policies.
    """
    def __init__(self, undef_enabled=True):
        super(SchedulePolicy, self).__init__()
        self._type = ("SchedulePolicy", True)
        self._schedule_list = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SchedulePolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._schedule_list = []
        for item in data.get("scheduleList") or []:
            obj._schedule_list.append(factory.create_object(item))
            factory.validate_type(obj._schedule_list[-1], "Schedule")
        obj._schedule_list = (obj._schedule_list, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SchedulePolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "schedule_list" == "type" or (self.schedule_list is not self.__undef__ and not (dirty and not self._schedule_list[1])):
            dct["scheduleList"] = dictify(self.schedule_list)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._schedule_list = (self._schedule_list[0], True)

    def is_dirty(self):
        return any([self._schedule_list[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SchedulePolicy):
            return False
        return super(SchedulePolicy, self).__eq__(other) and \
               self.schedule_list == other.schedule_list

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def schedule_list(self):
        """
        List of Schedule objects representing when the policy will execute.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.Schedule`
        """
        return self._schedule_list[0]

    @schedule_list.setter
    def schedule_list(self, value):
        self._schedule_list = (value, True)

class ReservationPolicy(Policy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Policy` *)* This policy guarantees a
    certain amount of space for the given object (group or database).
    """
    def __init__(self, undef_enabled=True):
        super(ReservationPolicy, self).__init__()
        self._type = ("ReservationPolicy", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReservationPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReservationPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReservationPolicy):
            return False
        return super(ReservationPolicy, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        Size of the reservation, in bytes.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class QuotaPolicy(Policy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Policy` *)* This policy limits the
    maximum amount of space an object (group or database) can use.
    """
    def __init__(self, undef_enabled=True):
        super(QuotaPolicy, self).__init__()
        self._type = ("QuotaPolicy", True)
        self._crit_threshold = (self.__undef__, True)
        self._warn_threshold = (self.__undef__, True)
        self._crit_alert_time = (self.__undef__, True)
        self._warn_alert_time = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(QuotaPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._crit_threshold = (data.get("critThreshold", obj.__undef__), dirty)
        if obj._crit_threshold[0] is not None and obj._crit_threshold[0] is not obj.__undef__:
            assert isinstance(obj._crit_threshold[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._crit_threshold[0]))
            common.validate_format(obj._crit_threshold[0], "None", None, None)
        obj._warn_threshold = (data.get("warnThreshold", obj.__undef__), dirty)
        if obj._warn_threshold[0] is not None and obj._warn_threshold[0] is not obj.__undef__:
            assert isinstance(obj._warn_threshold[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._warn_threshold[0]))
            common.validate_format(obj._warn_threshold[0], "None", None, None)
        obj._crit_alert_time = (data.get("critAlertTime", obj.__undef__), dirty)
        if obj._crit_alert_time[0] is not None and obj._crit_alert_time[0] is not obj.__undef__:
            assert isinstance(obj._crit_alert_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crit_alert_time[0]))
            common.validate_format(obj._crit_alert_time[0], "date", None, None)
        obj._warn_alert_time = (data.get("warnAlertTime", obj.__undef__), dirty)
        if obj._warn_alert_time[0] is not None and obj._warn_alert_time[0] is not obj.__undef__:
            assert isinstance(obj._warn_alert_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._warn_alert_time[0]))
            common.validate_format(obj._warn_alert_time[0], "date", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(QuotaPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "crit_threshold" == "type" or (self.crit_threshold is not self.__undef__ and not (dirty and not self._crit_threshold[1])):
            dct["critThreshold"] = dictify(self.crit_threshold)
        if "warn_threshold" == "type" or (self.warn_threshold is not self.__undef__ and not (dirty and not self._warn_threshold[1])):
            dct["warnThreshold"] = dictify(self.warn_threshold)
        if "crit_alert_time" == "type" or (self.crit_alert_time is not self.__undef__ and not (dirty and not self._crit_alert_time[1])):
            dct["critAlertTime"] = dictify(self.crit_alert_time)
        if "warn_alert_time" == "type" or (self.warn_alert_time is not self.__undef__ and not (dirty and not self._warn_alert_time[1])):
            dct["warnAlertTime"] = dictify(self.warn_alert_time)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._crit_threshold = (self._crit_threshold[0], True)
        self._warn_threshold = (self._warn_threshold[0], True)
        self._crit_alert_time = (self._crit_alert_time[0], True)
        self._warn_alert_time = (self._warn_alert_time[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._crit_threshold[1], self._warn_threshold[1], self._crit_alert_time[1], self._warn_alert_time[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, QuotaPolicy):
            return False
        return super(QuotaPolicy, self).__eq__(other) and \
               self.crit_threshold == other.crit_threshold and \
               self.warn_threshold == other.warn_threshold and \
               self.crit_alert_time == other.crit_alert_time and \
               self.warn_alert_time == other.warn_alert_time and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def crit_threshold(self):
        """
        *(default value: 90)* Threshold, in percent, at which point a critical
        alert is generated.

        :rtype: ``int``
        """
        return self._crit_threshold[0]

    @crit_threshold.setter
    def crit_threshold(self, value):
        self._crit_threshold = (value, True)

    @property
    def warn_threshold(self):
        """
        *(default value: 80)* Threshold, in percent, at which point a warning
        alert is generated.

        :rtype: ``int``
        """
        return self._warn_threshold[0]

    @warn_threshold.setter
    def warn_threshold(self, value):
        self._warn_threshold = (value, True)

    @property
    def crit_alert_time(self):
        """
        Last time a critical alert was generated.

        :rtype: ``basestring``
        """
        return self._crit_alert_time[0]

    @crit_alert_time.setter
    def crit_alert_time(self, value):
        self._crit_alert_time = (value, True)

    @property
    def warn_alert_time(self):
        """
        Last time a warning alert was generated.

        :rtype: ``basestring``
        """
        return self._warn_alert_time[0]

    @warn_alert_time.setter
    def warn_alert_time(self, value):
        self._warn_alert_time = (value, True)

    @property
    def size(self):
        """
        Size of the quota or reservation, in bytes.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class RetentionPolicy(Policy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Policy` *)* This policy controls what
    data (log and snapshot) is kept.
    """
    def __init__(self, undef_enabled=True):
        super(RetentionPolicy, self).__init__()
        self._type = ("RetentionPolicy", True)
        self._day_of_week = (self.__undef__, True)
        self._log_duration = (self.__undef__, True)
        self._num_of_yearly = (self.__undef__, True)
        self._num_of_monthly = (self.__undef__, True)
        self._num_of_daily = (self.__undef__, True)
        self._day_of_year = (self.__undef__, True)
        self._data_duration = (self.__undef__, True)
        self._num_of_weekly = (self.__undef__, True)
        self._data_unit = (self.__undef__, True)
        self._log_unit = (self.__undef__, True)
        self._day_of_month = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RetentionPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._day_of_week = (data.get("dayOfWeek", obj.__undef__), dirty)
        if obj._day_of_week[0] is not None and obj._day_of_week[0] is not obj.__undef__:
            assert isinstance(obj._day_of_week[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._day_of_week[0]))
            assert obj._day_of_week[0] in [u'MONDAY', u'TUESDAY', u'WEDNESDAY', u'THURSDAY', u'FRIDAY', u'SATURDAY', u'SUNDAY'], "Expected enum [u'MONDAY', u'TUESDAY', u'WEDNESDAY', u'THURSDAY', u'FRIDAY', u'SATURDAY', u'SUNDAY'] but got %s" % obj._day_of_week[0]
            common.validate_format(obj._day_of_week[0], "None", None, None)
        obj._log_duration = (data.get("logDuration", obj.__undef__), dirty)
        if obj._log_duration[0] is not None and obj._log_duration[0] is not obj.__undef__:
            assert isinstance(obj._log_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._log_duration[0]))
            common.validate_format(obj._log_duration[0], "None", None, None)
        obj._num_of_yearly = (data.get("numOfYearly", obj.__undef__), dirty)
        if obj._num_of_yearly[0] is not None and obj._num_of_yearly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_yearly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_yearly[0]))
            common.validate_format(obj._num_of_yearly[0], "None", None, None)
        obj._num_of_monthly = (data.get("numOfMonthly", obj.__undef__), dirty)
        if obj._num_of_monthly[0] is not None and obj._num_of_monthly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_monthly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_monthly[0]))
            common.validate_format(obj._num_of_monthly[0], "None", None, None)
        obj._num_of_daily = (data.get("numOfDaily", obj.__undef__), dirty)
        if obj._num_of_daily[0] is not None and obj._num_of_daily[0] is not obj.__undef__:
            assert isinstance(obj._num_of_daily[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_daily[0]))
            common.validate_format(obj._num_of_daily[0], "None", None, None)
        obj._day_of_year = (data.get("dayOfYear", obj.__undef__), dirty)
        if obj._day_of_year[0] is not None and obj._day_of_year[0] is not obj.__undef__:
            assert isinstance(obj._day_of_year[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._day_of_year[0]))
            common.validate_format(obj._day_of_year[0], "None", None, 32)
        obj._data_duration = (data.get("dataDuration", obj.__undef__), dirty)
        if obj._data_duration[0] is not None and obj._data_duration[0] is not obj.__undef__:
            assert isinstance(obj._data_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._data_duration[0]))
            common.validate_format(obj._data_duration[0], "None", None, None)
        obj._num_of_weekly = (data.get("numOfWeekly", obj.__undef__), dirty)
        if obj._num_of_weekly[0] is not None and obj._num_of_weekly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_weekly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_weekly[0]))
            common.validate_format(obj._num_of_weekly[0], "None", None, None)
        obj._data_unit = (data.get("dataUnit", obj.__undef__), dirty)
        if obj._data_unit[0] is not None and obj._data_unit[0] is not obj.__undef__:
            assert isinstance(obj._data_unit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_unit[0]))
            assert obj._data_unit[0] in [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'], "Expected enum [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'] but got %s" % obj._data_unit[0]
            common.validate_format(obj._data_unit[0], "None", None, None)
        obj._log_unit = (data.get("logUnit", obj.__undef__), dirty)
        if obj._log_unit[0] is not None and obj._log_unit[0] is not obj.__undef__:
            assert isinstance(obj._log_unit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._log_unit[0]))
            assert obj._log_unit[0] in [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'], "Expected enum [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'] but got %s" % obj._log_unit[0]
            common.validate_format(obj._log_unit[0], "None", None, None)
        obj._day_of_month = (data.get("dayOfMonth", obj.__undef__), dirty)
        if obj._day_of_month[0] is not None and obj._day_of_month[0] is not obj.__undef__:
            assert isinstance(obj._day_of_month[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._day_of_month[0]))
            common.validate_format(obj._day_of_month[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RetentionPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "day_of_week" == "type" or (self.day_of_week is not self.__undef__ and not (dirty and not self._day_of_week[1])):
            dct["dayOfWeek"] = dictify(self.day_of_week)
        if "log_duration" == "type" or (self.log_duration is not self.__undef__ and not (dirty and not self._log_duration[1])):
            dct["logDuration"] = dictify(self.log_duration)
        if "num_of_yearly" == "type" or (self.num_of_yearly is not self.__undef__ and not (dirty and not self._num_of_yearly[1])):
            dct["numOfYearly"] = dictify(self.num_of_yearly)
        if "num_of_monthly" == "type" or (self.num_of_monthly is not self.__undef__ and not (dirty and not self._num_of_monthly[1])):
            dct["numOfMonthly"] = dictify(self.num_of_monthly)
        if "num_of_daily" == "type" or (self.num_of_daily is not self.__undef__ and not (dirty and not self._num_of_daily[1])):
            dct["numOfDaily"] = dictify(self.num_of_daily)
        if "day_of_year" == "type" or (self.day_of_year is not self.__undef__ and not (dirty and not self._day_of_year[1])):
            dct["dayOfYear"] = dictify(self.day_of_year)
        if "data_duration" == "type" or (self.data_duration is not self.__undef__ and not (dirty and not self._data_duration[1])):
            dct["dataDuration"] = dictify(self.data_duration)
        if "num_of_weekly" == "type" or (self.num_of_weekly is not self.__undef__ and not (dirty and not self._num_of_weekly[1])):
            dct["numOfWeekly"] = dictify(self.num_of_weekly)
        if "data_unit" == "type" or (self.data_unit is not self.__undef__ and not (dirty and not self._data_unit[1])):
            dct["dataUnit"] = dictify(self.data_unit)
        if "log_unit" == "type" or (self.log_unit is not self.__undef__ and not (dirty and not self._log_unit[1])):
            dct["logUnit"] = dictify(self.log_unit)
        if "day_of_month" == "type" or (self.day_of_month is not self.__undef__ and not (dirty and not self._day_of_month[1])):
            dct["dayOfMonth"] = dictify(self.day_of_month)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._day_of_week = (self._day_of_week[0], True)
        self._log_duration = (self._log_duration[0], True)
        self._num_of_yearly = (self._num_of_yearly[0], True)
        self._num_of_monthly = (self._num_of_monthly[0], True)
        self._num_of_daily = (self._num_of_daily[0], True)
        self._day_of_year = (self._day_of_year[0], True)
        self._data_duration = (self._data_duration[0], True)
        self._num_of_weekly = (self._num_of_weekly[0], True)
        self._data_unit = (self._data_unit[0], True)
        self._log_unit = (self._log_unit[0], True)
        self._day_of_month = (self._day_of_month[0], True)

    def is_dirty(self):
        return any([self._day_of_week[1], self._log_duration[1], self._num_of_yearly[1], self._num_of_monthly[1], self._num_of_daily[1], self._day_of_year[1], self._data_duration[1], self._num_of_weekly[1], self._data_unit[1], self._log_unit[1], self._day_of_month[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RetentionPolicy):
            return False
        return super(RetentionPolicy, self).__eq__(other) and \
               self.day_of_week == other.day_of_week and \
               self.log_duration == other.log_duration and \
               self.num_of_yearly == other.num_of_yearly and \
               self.num_of_monthly == other.num_of_monthly and \
               self.num_of_daily == other.num_of_daily and \
               self.day_of_year == other.day_of_year and \
               self.data_duration == other.data_duration and \
               self.num_of_weekly == other.num_of_weekly and \
               self.data_unit == other.data_unit and \
               self.log_unit == other.log_unit and \
               self.day_of_month == other.day_of_month

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def day_of_week(self):
        """
        Day of week upon which to enforce weekly snapshot retention.
        *(permitted values: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
        SATURDAY, SUNDAY)*

        :rtype: ``basestring``
        """
        return self._day_of_week[0]

    @day_of_week.setter
    def day_of_week(self, value):
        self._day_of_week = (value, True)

    @property
    def log_duration(self):
        """
        Amount of time (in logUnit units) to keep log data.

        :rtype: ``int``
        """
        return self._log_duration[0]

    @log_duration.setter
    def log_duration(self, value):
        self._log_duration = (value, True)

    @property
    def num_of_yearly(self):
        """
        Number of yearly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_yearly[0]

    @num_of_yearly.setter
    def num_of_yearly(self, value):
        self._num_of_yearly = (value, True)

    @property
    def num_of_monthly(self):
        """
        Number of monthly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_monthly[0]

    @num_of_monthly.setter
    def num_of_monthly(self, value):
        self._num_of_monthly = (value, True)

    @property
    def num_of_daily(self):
        """
        Number of daily snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_daily[0]

    @num_of_daily.setter
    def num_of_daily(self, value):
        self._num_of_daily = (value, True)

    @property
    def day_of_year(self):
        """
        Day of year upon which to enforce yearly snapshot retention, expressed
        a month / day string. E.g. "Jan 1"

        :rtype: ``basestring``
        """
        return self._day_of_year[0]

    @day_of_year.setter
    def day_of_year(self, value):
        self._day_of_year = (value, True)

    @property
    def data_duration(self):
        """
        Amount of time (in dataUnit units) to keep source data.

        :rtype: ``int``
        """
        return self._data_duration[0]

    @data_duration.setter
    def data_duration(self, value):
        self._data_duration = (value, True)

    @property
    def num_of_weekly(self):
        """
        Number of weekly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_weekly[0]

    @num_of_weekly.setter
    def num_of_weekly(self, value):
        self._num_of_weekly = (value, True)

    @property
    def data_unit(self):
        """
        Time unit for dataDuration. *(permitted values: DAY, WEEK, MONTH,
        QUARTER, YEAR)*

        :rtype: ``basestring``
        """
        return self._data_unit[0]

    @data_unit.setter
    def data_unit(self, value):
        self._data_unit = (value, True)

    @property
    def log_unit(self):
        """
        Time unit for logDuration. *(permitted values: DAY, WEEK, MONTH,
        QUARTER, YEAR)*

        :rtype: ``basestring``
        """
        return self._log_unit[0]

    @log_unit.setter
    def log_unit(self, value):
        self._log_unit = (value, True)

    @property
    def day_of_month(self):
        """
        Day of month upon which to enforce monthly snapshot retention.

        :rtype: ``int``
        """
        return self._day_of_month[0]

    @day_of_month.setter
    def day_of_month(self, value):
        self._day_of_month = (value, True)

class RefreshPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SchedulePolicy` *)* This policy
    refreshes a container according to a schedule.
    """
    def __init__(self, undef_enabled=True):
        super(RefreshPolicy, self).__init__()
        self._type = ("RefreshPolicy", True)
        self._provision_source = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RefreshPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._provision_source = (data.get("provisionSource", obj.__undef__), dirty)
        if obj._provision_source[0] is not None and obj._provision_source[0] is not obj.__undef__:
            assert isinstance(obj._provision_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._provision_source[0]))
            assert obj._provision_source[0] in [u'LATEST_SNAPSHOT', u'LATEST_TIME_FLOW_LOG'], "Expected enum [u'LATEST_SNAPSHOT', u'LATEST_TIME_FLOW_LOG'] but got %s" % obj._provision_source[0]
            common.validate_format(obj._provision_source[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RefreshPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provision_source" == "type" or (self.provision_source is not self.__undef__ and not (dirty and not self._provision_source[1])):
            dct["provisionSource"] = dictify(self.provision_source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provision_source = (self._provision_source[0], True)

    def is_dirty(self):
        return any([self._provision_source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RefreshPolicy):
            return False
        return super(RefreshPolicy, self).__eq__(other) and \
               self.provision_source == other.provision_source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provision_source(self):
        """
        Provision source, either the latest time or latest snapshot.
        *(permitted values: LATEST_SNAPSHOT, LATEST_TIME_FLOW_LOG)*

        :rtype: ``basestring``
        """
        return self._provision_source[0]

    @provision_source.setter
    def provision_source(self, value):
        self._provision_source = (value, True)

class SyncPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SchedulePolicy` *)* This policy syncs a
    container (runs SnapSync) according to the given schedule.
    """
    def __init__(self, undef_enabled=True):
        super(SyncPolicy, self).__init__()
        self._type = ("SyncPolicy", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyncPolicy, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyncPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyncPolicy):
            return False
        return super(SyncPolicy, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SnapshotPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SchedulePolicy` *)* This policy creates
    snapshots of a container with externally managed sources (virtual
    databases) according to a schedule.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotPolicy, self).__init__()
        self._type = ("SnapshotPolicy", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotPolicy, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotPolicy):
            return False
        return super(SnapshotPolicy, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class BaseSystemCapacityData(AggregateCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AggregateCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(BaseSystemCapacityData, self).__init__()
        self._type = ("BaseSystemCapacityData", True)
        self._total_space = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._total_space = (data.get("totalSpace", obj.__undef__), dirty)
        if obj._total_space[0] is not None and obj._total_space[0] is not obj.__undef__:
            assert isinstance(obj._total_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total_space[0]))
            common.validate_format(obj._total_space[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "total_space" == "type" or (self.total_space is not self.__undef__ and not (dirty and not self._total_space[1])):
            dct["totalSpace"] = dictify(self.total_space)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._total_space = (self._total_space[0], True)

    def is_dirty(self):
        return any([self._total_space[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseSystemCapacityData):
            return False
        return super(BaseSystemCapacityData, self).__eq__(other) and \
               self.total_space == other.total_space

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def total_space(self):
        """
        Total storage space (used and unused).

        :rtype: ``float``
        """
        return self._total_space[0]

    @total_space.setter
    def total_space(self, value):
        self._total_space = (value, True)

class BaseGroupCapacityData(AggregateCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AggregateCapacityData` *)* Capacity
    data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(BaseGroupCapacityData, self).__init__()
        self._type = ("BaseGroupCapacityData", True)
        self._group = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._group = (self._group[0], True)

    def is_dirty(self):
        return any([self._group[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseGroupCapacityData):
            return False
        return super(BaseGroupCapacityData, self).__eq__(other) and \
               self.group == other.group

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def group(self):
        """
        Which group these stats represent.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

class CurrentGroupCapacityData(BaseGroupCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseGroupCapacityData` *)* Capacity
    data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentGroupCapacityData, self).__init__()
        self._type = ("CurrentGroupCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentGroupCapacityData):
            return False
        return super(CurrentGroupCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class HistoricalGroupCapacityData(BaseGroupCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseGroupCapacityData` *)* Historical
    capacity data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalGroupCapacityData, self).__init__()
        self._type = ("HistoricalGroupCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalGroupCapacityData):
            return False
        return super(HistoricalGroupCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class HistoricalSystemCapacityData(BaseSystemCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseSystemCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalSystemCapacityData, self).__init__()
        self._type = ("HistoricalSystemCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalSystemCapacityData):
            return False
        return super(HistoricalSystemCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class CurrentSystemCapacityData(BaseSystemCapacityData):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BaseSystemCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentSystemCapacityData, self).__init__()
        self._type = ("CurrentSystemCapacityData", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentSystemCapacityData):
            return False
        return super(CurrentSystemCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ErrorResult(CallResult):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CallResult` *)* Result of a failed API
    call.
    """
    def __init__(self, undef_enabled=True):
        super(ErrorResult, self).__init__()
        self._type = ("ErrorResult", True)
        self._error = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ErrorResult, cls).from_dict(data, dirty, undef_enabled)
        if "error" in data and data["error"] is not None:
            obj._error = (factory.create_object(data["error"], "APIError"), dirty)
            factory.validate_type(obj._error[0], "APIError")
        else:
            obj._error = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ErrorResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "error" == "type" or (self.error is not self.__undef__ and not (dirty and not self._error[1])):
            dct["error"] = dictify(self.error)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._error = (self._error[0], True)

    def is_dirty(self):
        return any([self._error[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ErrorResult):
            return False
        return super(ErrorResult, self).__eq__(other) and \
               self.error == other.error

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def error(self):
        """
        Specifics of the error that occurred during API call execution.

        :rtype: :py:class:`v1_3_0.web.vo.APIError`
        """
        return self._error[0]

    @error.setter
    def error(self, value):
        self._error = (value, True)

class OKResult(CallResult):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CallResult` *)* Result of a successful
    API call.
    """
    def __init__(self, undef_enabled=True):
        super(OKResult, self).__init__()
        self._type = ("OKResult", True)
        self._action = (self.__undef__, True)
        self._job = (self.__undef__, True)
        self._result = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OKResult, cls).from_dict(data, dirty, undef_enabled)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "objectReference", None, None)
        obj._job = (data.get("job", obj.__undef__), dirty)
        if obj._job[0] is not None and obj._job[0] is not obj.__undef__:
            assert isinstance(obj._job[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._job[0]))
            common.validate_format(obj._job[0], "objectReference", None, None)
        obj._result = (data.get("result", obj.__undef__), dirty)
        if obj._result[0] is not None and obj._result[0] is not obj.__undef__:
            assert isinstance(obj._result[0], dict) or isinstance(obj._result[0], list) or isinstance(obj._result[0], basestring), ("Expected one of [u'object', u'array', u'string'], but got %s" % type(obj._result[0]))
            common.validate_format(obj._result[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OKResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "job" == "type" or (self.job is not self.__undef__ and not (dirty and not self._job[1])):
            dct["job"] = dictify(self.job)
        if "result" == "type" or (self.result is not self.__undef__ and not (dirty and not self._result[1])):
            dct["result"] = dictify(self.result)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action = (self._action[0], True)
        self._job = (self._job[0], True)
        self._result = (self._result[0], True)

    def is_dirty(self):
        return any([self._action[1], self._job[1], self._result[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OKResult):
            return False
        return super(OKResult, self).__eq__(other) and \
               self.action == other.action and \
               self.job == other.job and \
               self.result == other.result

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action(self):
        """
        Reference to the action associated with the operation, if any.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def job(self):
        """
        Reference to the job started by the operation, if any.

        :rtype: ``basestring``
        """
        return self._job[0]

    @job.setter
    def job(self, value):
        self._job = (value, True)

    @property
    def result(self):
        """
        Result of the operation. This will be specific to the API being
        invoked.

        :rtype: ``dict`` *or* ``list`` *or* ``basestring``
        """
        return self._result[0]

    @result.setter
    def result(self, value):
        self._result = (value, True)

class DataResult(OKResult):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OKResult` *)* Result of a successful
    API call containing a reference to a downloadable resource.
    """
    def __init__(self, undef_enabled=True):
        super(DataResult, self).__init__()
        self._type = ("DataResult", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DataResult, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DataResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DataResult):
            return False
        return super(DataResult, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ListResult(OKResult):
    """
    *(extends* :py:class:`v1_3_0.web.vo.OKResult` *)* Result of a successful
    API call returning a list.
    """
    def __init__(self, undef_enabled=True):
        super(ListResult, self).__init__()
        self._type = ("ListResult", True)
        self._overflow = (self.__undef__, True)
        self._total = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ListResult, cls).from_dict(data, dirty, undef_enabled)
        obj._overflow = (data.get("overflow", obj.__undef__), dirty)
        if obj._overflow[0] is not None and obj._overflow[0] is not obj.__undef__:
            assert isinstance(obj._overflow[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._overflow[0]))
            common.validate_format(obj._overflow[0], "None", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ListResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "overflow" == "type" or (self.overflow is not self.__undef__ and not (dirty and not self._overflow[1])):
            dct["overflow"] = dictify(self.overflow)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._overflow = (self._overflow[0], True)
        self._total = (self._total[0], True)

    def is_dirty(self):
        return any([self._overflow[1], self._total[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ListResult):
            return False
        return super(ListResult, self).__eq__(other) and \
               self.overflow == other.overflow and \
               self.total == other.total

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def overflow(self):
        """
        True if the total number of matching items is too large to be
        calculated.

        :rtype: ``bool``
        """
        return self._overflow[0]

    @overflow.setter
    def overflow(self, value):
        self._overflow = (value, True)

    @property
    def total(self):
        """
        The number of items in the entire result set.

        :rtype: ``int``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

class PublicKeyCredential(Credential):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Credential` *)* The public key based
    security credential.
    """
    def __init__(self, undef_enabled=True):
        super(PublicKeyCredential, self).__init__()
        self._type = ("PublicKeyCredential", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PublicKeyCredential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PublicKeyCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PublicKeyCredential):
            return False
        return super(PublicKeyCredential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PasswordCredential(Credential):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Credential` *)* The password based
    security credential.
    """
    def __init__(self, undef_enabled=True):
        super(PasswordCredential, self).__init__()
        self._type = ("PasswordCredential", True)
        self._password = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PasswordCredential, cls).from_dict(data, dirty, undef_enabled)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", 1, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PasswordCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._password = (self._password[0], True)

    def is_dirty(self):
        return any([self._password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PasswordCredential):
            return False
        return super(PasswordCredential, self).__eq__(other) and \
               self.password == other.password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def password(self):
        """
        The password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

class SystemKeyCredential(PublicKeyCredential):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PublicKeyCredential` *)* The system
    public key based security credential.
    """
    def __init__(self, undef_enabled=True):
        super(SystemKeyCredential, self).__init__()
        self._type = ("SystemKeyCredential", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemKeyCredential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemKeyCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemKeyCredential):
            return False
        return super(SystemKeyCredential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class KeyPairCredential(PublicKeyCredential):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PublicKeyCredential` *)* The public key
    based security credential consisting of a user specified key pair.
    """
    def __init__(self, undef_enabled=True):
        super(KeyPairCredential, self).__init__()
        self._type = ("KeyPairCredential", True)
        self._public_key = (self.__undef__, True)
        self._private_key = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(KeyPairCredential, cls).from_dict(data, dirty, undef_enabled)
        if "publicKey" not in data:
            raise ValueError("Missing required property \"publicKey\".")
        obj._public_key = (data.get("publicKey", obj.__undef__), dirty)
        if obj._public_key[0] is not None and obj._public_key[0] is not obj.__undef__:
            assert isinstance(obj._public_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._public_key[0]))
            common.validate_format(obj._public_key[0], "password", None, None)
        if "privateKey" not in data:
            raise ValueError("Missing required property \"privateKey\".")
        obj._private_key = (data.get("privateKey", obj.__undef__), dirty)
        if obj._private_key[0] is not None and obj._private_key[0] is not obj.__undef__:
            assert isinstance(obj._private_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._private_key[0]))
            common.validate_format(obj._private_key[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(KeyPairCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "public_key" == "type" or (self.public_key is not self.__undef__ and not (dirty and not self._public_key[1])):
            dct["publicKey"] = dictify(self.public_key)
        if "private_key" == "type" or (self.private_key is not self.__undef__ and not (dirty and not self._private_key[1])):
            dct["privateKey"] = dictify(self.private_key)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._public_key = (self._public_key[0], True)
        self._private_key = (self._private_key[0], True)

    def is_dirty(self):
        return any([self._public_key[1], self._private_key[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, KeyPairCredential):
            return False
        return super(KeyPairCredential, self).__eq__(other) and \
               self.public_key == other.public_key and \
               self.private_key == other.private_key

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def public_key(self):
        """
        The public key in the key pair.

        :rtype: ``basestring``
        """
        return self._public_key[0]

    @public_key.setter
    def public_key(self, value):
        self._public_key = (value, True)

    @property
    def private_key(self):
        """
        The private key in the key pair.

        :rtype: ``basestring``
        """
        return self._private_key[0]

    @private_key.setter
    def private_key(self, value):
        self._private_key = (value, True)

class SystemInfo(PublicSystemInfo):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PublicSystemInfo` *)* Retrieve system-
    wide properties and manage the state of the system.
    """
    def __init__(self, undef_enabled=True):
        super(SystemInfo, self).__init__()
        self._type = ("SystemInfo", True)
        self._processors = (self.__undef__, True)
        self._storage_total = (self.__undef__, True)
        self._ssh_public_key = (self.__undef__, True)
        self._hostname = (self.__undef__, True)
        self._memory_size = (self.__undef__, True)
        self._platform = (self.__undef__, True)
        self._storage_used = (self.__undef__, True)
        self._uuid = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._processors = []
        for item in data.get("processors") or []:
            obj._processors.append(factory.create_object(item))
            factory.validate_type(obj._processors[-1], "CPUInfo")
        obj._processors = (obj._processors, dirty)
        obj._storage_total = (data.get("storageTotal", obj.__undef__), dirty)
        if obj._storage_total[0] is not None and obj._storage_total[0] is not obj.__undef__:
            assert isinstance(obj._storage_total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._storage_total[0]))
            common.validate_format(obj._storage_total[0], "None", None, None)
        obj._ssh_public_key = (data.get("sshPublicKey", obj.__undef__), dirty)
        if obj._ssh_public_key[0] is not None and obj._ssh_public_key[0] is not obj.__undef__:
            assert isinstance(obj._ssh_public_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ssh_public_key[0]))
            common.validate_format(obj._ssh_public_key[0], "None", None, None)
        obj._hostname = (data.get("hostname", obj.__undef__), dirty)
        if obj._hostname[0] is not None and obj._hostname[0] is not obj.__undef__:
            assert isinstance(obj._hostname[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._hostname[0]))
            common.validate_format(obj._hostname[0], "hostname", None, None)
        obj._memory_size = (data.get("memorySize", obj.__undef__), dirty)
        if obj._memory_size[0] is not None and obj._memory_size[0] is not obj.__undef__:
            assert isinstance(obj._memory_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._memory_size[0]))
            common.validate_format(obj._memory_size[0], "None", None, None)
        obj._platform = (data.get("platform", obj.__undef__), dirty)
        if obj._platform[0] is not None and obj._platform[0] is not obj.__undef__:
            assert isinstance(obj._platform[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._platform[0]))
            common.validate_format(obj._platform[0], "None", None, None)
        obj._storage_used = (data.get("storageUsed", obj.__undef__), dirty)
        if obj._storage_used[0] is not None and obj._storage_used[0] is not obj.__undef__:
            assert isinstance(obj._storage_used[0], float), ("Expected one of [u'number'], but got %s" % type(obj._storage_used[0]))
            common.validate_format(obj._storage_used[0], "None", None, None)
        obj._uuid = (data.get("uuid", obj.__undef__), dirty)
        if obj._uuid[0] is not None and obj._uuid[0] is not obj.__undef__:
            assert isinstance(obj._uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._uuid[0]))
            common.validate_format(obj._uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "processors" == "type" or (self.processors is not self.__undef__ and not (dirty and not self._processors[1])):
            dct["processors"] = dictify(self.processors)
        if "storage_total" == "type" or (self.storage_total is not self.__undef__ and not (dirty and not self._storage_total[1])):
            dct["storageTotal"] = dictify(self.storage_total)
        if "ssh_public_key" == "type" or (self.ssh_public_key is not self.__undef__ and not (dirty and not self._ssh_public_key[1])):
            dct["sshPublicKey"] = dictify(self.ssh_public_key)
        if "hostname" == "type" or (self.hostname is not self.__undef__ and not (dirty and not self._hostname[1])):
            dct["hostname"] = dictify(self.hostname)
        if "memory_size" == "type" or (self.memory_size is not self.__undef__ and not (dirty and not self._memory_size[1])):
            dct["memorySize"] = dictify(self.memory_size)
        if "platform" == "type" or (self.platform is not self.__undef__ and not (dirty and not self._platform[1])):
            dct["platform"] = dictify(self.platform)
        if "storage_used" == "type" or (self.storage_used is not self.__undef__ and not (dirty and not self._storage_used[1])):
            dct["storageUsed"] = dictify(self.storage_used)
        if "uuid" == "type" or (self.uuid is not self.__undef__ and not (dirty and not self._uuid[1])):
            dct["uuid"] = dictify(self.uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._processors = (self._processors[0], True)
        self._storage_total = (self._storage_total[0], True)
        self._ssh_public_key = (self._ssh_public_key[0], True)
        self._hostname = (self._hostname[0], True)
        self._memory_size = (self._memory_size[0], True)
        self._platform = (self._platform[0], True)
        self._storage_used = (self._storage_used[0], True)
        self._uuid = (self._uuid[0], True)

    def is_dirty(self):
        return any([self._processors[1], self._storage_total[1], self._ssh_public_key[1], self._hostname[1], self._memory_size[1], self._platform[1], self._storage_used[1], self._uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemInfo):
            return False
        return super(SystemInfo, self).__eq__(other) and \
               self.processors == other.processors and \
               self.storage_total == other.storage_total and \
               self.ssh_public_key == other.ssh_public_key and \
               self.hostname == other.hostname and \
               self.memory_size == other.memory_size and \
               self.platform == other.platform and \
               self.storage_used == other.storage_used and \
               self.uuid == other.uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def processors(self):
        """
        Processors on the system.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.CPUInfo`
        """
        return self._processors[0]

    @processors.setter
    def processors(self, value):
        self._processors = (value, True)

    @property
    def storage_total(self):
        """
        Total amount of raw storage allocated for dSources, VDBs, and system
        metadata. Zero if storage has not yet been configured.

        :rtype: ``float``
        """
        return self._storage_total[0]

    @storage_total.setter
    def storage_total(self, value):
        self._storage_total = (value, True)

    @property
    def ssh_public_key(self):
        """
        SSH public key to be added to SSH authorized_keys for environment users
        using the SystemKeyCredential authorization mechanism.

        :rtype: ``basestring``
        """
        return self._ssh_public_key[0]

    @ssh_public_key.setter
    def ssh_public_key(self, value):
        self._ssh_public_key = (value, True)

    @property
    def hostname(self):
        """
        System hostname.

        :rtype: ``basestring``
        """
        return self._hostname[0]

    @hostname.setter
    def hostname(self, value):
        self._hostname = (value, True)

    @property
    def memory_size(self):
        """
        Total memory on the system, in bytes.

        :rtype: ``float``
        """
        return self._memory_size[0]

    @memory_size.setter
    def memory_size(self, value):
        self._memory_size = (value, True)

    @property
    def platform(self):
        """
        Description of the current system platform.

        :rtype: ``basestring``
        """
        return self._platform[0]

    @platform.setter
    def platform(self, value):
        self._platform = (value, True)

    @property
    def storage_used(self):
        """
        Amount of raw storage used by dSources, VDBs and system metadata.

        :rtype: ``float``
        """
        return self._storage_used[0]

    @storage_used.setter
    def storage_used(self, value):
        self._storage_used = (value, True)

    @property
    def uuid(self):
        """
        Globally unique identifier for this software installation.

        :rtype: ``basestring``
        """
        return self._uuid[0]

    @uuid.setter
    def uuid(self, value):
        self._uuid = (value, True)

class OracleDeleteParameters(DeleteParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DeleteParameters` *)* The parameters
    passed in for an Oracle database delete operation.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDeleteParameters, self).__init__()
        self._type = ("OracleDeleteParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDeleteParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDeleteParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDeleteParameters):
            return False
        return super(OracleDeleteParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the delete operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the delete
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class AppDataExportParameters(ExportParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ExportParameters` *)* The parameters to
    use as input to export AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataExportParameters, self).__init__()
        self._type = ("AppDataExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "AppDataFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "AppDataFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataExportParameters):
            return False
        return super(AppDataExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class DbExportParameters(ExportParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ExportParameters` *)* The parameters to
    use as input for export requests.
    """
    def __init__(self, undef_enabled=True):
        super(DbExportParameters, self).__init__()
        self._type = ("DbExportParameters", True)
        self._config_params = (self.__undef__, True)
        self._recover_database = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DbExportParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        obj._recover_database = (data.get("recoverDatabase", obj.__undef__), dirty)
        if obj._recover_database[0] is not None and obj._recover_database[0] is not obj.__undef__:
            assert isinstance(obj._recover_database[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._recover_database[0]))
            common.validate_format(obj._recover_database[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DbExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "recover_database" == "type" or (self.recover_database is not self.__undef__ and not (dirty and not self._recover_database[1])):
            dct["recoverDatabase"] = dictify(self.recover_database)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._recover_database = (self._recover_database[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._recover_database[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DbExportParameters):
            return False
        return super(DbExportParameters, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.recover_database == other.recover_database

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        Database-specific configuration parameters.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def recover_database(self):
        """
        *(default value: True)* If specified, then take the exported database
        through recovery procedures, if necessary, to reach a consistent point.

        :rtype: ``bool``
        """
        return self._recover_database[0]

    @recover_database.setter
    def recover_database(self, value):
        self._recover_database = (value, True)

class MSSqlExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DbExportParameters` *)* The parameters
    to use as input to export MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlExportParameters, self).__init__()
        self._type = ("MSSqlExportParameters", True)
        self._recovery_model = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlExportParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._recovery_model = (data.get("recoveryModel", obj.__undef__), dirty)
        if obj._recovery_model[0] is not None and obj._recovery_model[0] is not obj.__undef__:
            assert isinstance(obj._recovery_model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._recovery_model[0]))
            assert obj._recovery_model[0] in [u'SIMPLE', u'BULK_LOGGED', u'FULL'], "Expected enum [u'SIMPLE', u'BULK_LOGGED', u'FULL'] but got %s" % obj._recovery_model[0]
            common.validate_format(obj._recovery_model[0], "None", None, None)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MSSqlDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MSSqlDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "recovery_model" == "type" or (self.recovery_model is not self.__undef__ and not (dirty and not self._recovery_model[1])):
            dct["recoveryModel"] = dictify(self.recovery_model)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._recovery_model = (self._recovery_model[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._recovery_model[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlExportParameters):
            return False
        return super(MSSqlExportParameters, self).__eq__(other) and \
               self.recovery_model == other.recovery_model and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def recovery_model(self):
        """
        *(default value: FULL)* Recovery model of the database. *(permitted
        values: SIMPLE, BULK_LOGGED, FULL)*

        :rtype: ``basestring``
        """
        return self._recovery_model[0]

    @recovery_model.setter
    def recovery_model(self, value):
        self._recovery_model = (value, True)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class OracleExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DbExportParameters` *)* The parameters
    to use as input to export oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleExportParameters, self).__init__()
        self._type = ("OracleExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._open_database = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        obj._open_database = (data.get("openDatabase", obj.__undef__), dirty)
        if obj._open_database[0] is not None and obj._open_database[0] is not obj.__undef__:
            assert isinstance(obj._open_database[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._open_database[0]))
            common.validate_format(obj._open_database[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "open_database" == "type" or (self.open_database is not self.__undef__ and not (dirty and not self._open_database[1])):
            dct["openDatabase"] = dictify(self.open_database)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._open_database = (self._open_database[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._open_database[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleExportParameters):
            return False
        return super(OracleExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.open_database == other.open_database

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_3_0.web.vo.OracleDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def open_database(self):
        """
        *(default value: True)* Flag indicating whether to open the database
        after recovery. This can have a true value only if 'recoverDatabase' is
        true.

        :rtype: ``bool``
        """
        return self._open_database[0]

    @open_database.setter
    def open_database(self, value):
        self._open_database = (value, True)

class PgSQLExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DbExportParameters` *)* The parameters
    to use as input to export PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLExportParameters, self).__init__()
        self._type = ("PgSQLExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._ident_entries = (self.__undef__, True)
        self._hba_entries = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "PgSQLDBClusterConfig"), dirty)
            factory.validate_type(obj._source_config[0], "PgSQLDBClusterConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        obj._ident_entries = []
        for item in data.get("identEntries") or []:
            obj._ident_entries.append(factory.create_object(item))
            factory.validate_type(obj._ident_entries[-1], "PgSQLIdentEntry")
        obj._ident_entries = (obj._ident_entries, dirty)
        obj._hba_entries = []
        for item in data.get("hbaEntries") or []:
            obj._hba_entries.append(factory.create_object(item))
            factory.validate_type(obj._hba_entries[-1], "PgSQLHBAEntry")
        obj._hba_entries = (obj._hba_entries, dirty)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "TimeflowFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "TimeflowFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "ident_entries" == "type" or (self.ident_entries is not self.__undef__ and not (dirty and not self._ident_entries[1])):
            dct["identEntries"] = dictify(self.ident_entries)
        if "hba_entries" == "type" or (self.hba_entries is not self.__undef__ and not (dirty and not self._hba_entries[1])):
            dct["hbaEntries"] = dictify(self.hba_entries)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._ident_entries = (self._ident_entries[0], True)
        self._hba_entries = (self._hba_entries[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._ident_entries[1], self._hba_entries[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLExportParameters):
            return False
        return super(PgSQLExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.ident_entries == other.ident_entries and \
               self.hba_entries == other.hba_entries and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported database.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLDBClusterConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def ident_entries(self):
        """
        Entries in the PostgreSQL username map file (pg_ident.conf).

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.PgSQLIdentEntry`
        """
        return self._ident_entries[0]

    @ident_entries.setter
    def ident_entries(self, value):
        self._ident_entries = (value, True)

    @property
    def hba_entries(self):
        """
        Entries in the PostgreSQL host-based authentication file (pg_hba.conf).

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.PgSQLHBAEntry`
        """
        return self._hba_entries[0]

    @hba_entries.setter
    def hba_entries(self, value):
        self._hba_entries = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class MSSqlSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of a MSSQL timeflow snapshot
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSnapshotRuntime, self).__init__()
        self._type = ("MSSqlSnapshotRuntime", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSnapshotRuntime):
            return False
        return super(MSSqlSnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of an Oracle timeflow snapshot
    """
    def __init__(self, undef_enabled=True):
        super(OracleSnapshotRuntime, self).__init__()
        self._type = ("OracleSnapshotRuntime", True)
        self._missing_logs = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._missing_logs = []
        for item in data.get("missingLogs") or []:
            obj._missing_logs.append(factory.create_object(item))
            factory.validate_type(obj._missing_logs[-1], "OracleLog")
        obj._missing_logs = (obj._missing_logs, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "missing_logs" == "type" or (self.missing_logs is not self.__undef__ and not (dirty and not self._missing_logs[1])):
            dct["missingLogs"] = dictify(self.missing_logs)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._missing_logs = (self._missing_logs[0], True)

    def is_dirty(self):
        return any([self._missing_logs[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSnapshotRuntime):
            return False
        return super(OracleSnapshotRuntime, self).__eq__(other) and \
               self.missing_logs == other.missing_logs

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def missing_logs(self):
        """
        List of missing log files for this snapshot, if any.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleLog`
        """
        return self._missing_logs[0]

    @missing_logs.setter
    def missing_logs(self, value):
        self._missing_logs = (value, True)

class AppDataSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of AppData TimeFlow snapshots
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSnapshotRuntime, self).__init__()
        self._type = ("AppDataSnapshotRuntime", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSnapshotRuntime):
            return False
        return super(AppDataSnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleClusterCreateParameters(SourceEnvironmentCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceEnvironmentCreateParameters` *)*
    The parameters used for the oracle cluster create operation.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterCreateParameters, self).__init__()
        self._type = ("OracleClusterCreateParameters", True)
        self._cluster = (self.__undef__, True)
        self._nodes = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "cluster" in data and data["cluster"] is not None:
            obj._cluster = (factory.create_object(data["cluster"], "OracleCluster"), dirty)
            factory.validate_type(obj._cluster[0], "OracleCluster")
        else:
            obj._cluster = (obj.__undef__, dirty)
        obj._nodes = []
        for item in data.get("nodes") or []:
            obj._nodes.append(factory.create_object(item))
            factory.validate_type(obj._nodes[-1], "OracleClusterNodeCreateParameters")
        obj._nodes = (obj._nodes, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "nodes" == "type" or (self.nodes is not self.__undef__ and not (dirty and not self._nodes[1])):
            dct["nodes"] = dictify(self.nodes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cluster = (self._cluster[0], True)
        self._nodes = (self._nodes[0], True)

    def is_dirty(self):
        return any([self._cluster[1], self._nodes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterCreateParameters):
            return False
        return super(OracleClusterCreateParameters, self).__eq__(other) and \
               self.cluster == other.cluster and \
               self.nodes == other.nodes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cluster(self):
        """
        The representation of the cluster object.

        :rtype: :py:class:`v1_3_0.web.vo.OracleCluster`
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def nodes(self):
        """
        The list of nodes in the cluster.

        :rtype: ``list`` of
            :py:class:`v1_3_0.web.vo.OracleClusterNodeCreateParameters`
        """
        return self._nodes[0]

    @nodes.setter
    def nodes(self, value):
        self._nodes = (value, True)

class HostEnvironmentCreateParameters(SourceEnvironmentCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceEnvironmentCreateParameters` *)*
    The parameters used for the host environment create operation.
    """
    def __init__(self, undef_enabled=True):
        super(HostEnvironmentCreateParameters, self).__init__()
        self._type = ("HostEnvironmentCreateParameters", True)
        self._host_parameters = (self.__undef__, True)
        self._host_environment = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostEnvironmentCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "hostParameters" in data and data["hostParameters"] is not None:
            obj._host_parameters = (factory.create_object(data["hostParameters"], "HostCreateParameters"), dirty)
            factory.validate_type(obj._host_parameters[0], "HostCreateParameters")
        else:
            obj._host_parameters = (obj.__undef__, dirty)
        if "hostEnvironment" in data and data["hostEnvironment"] is not None:
            obj._host_environment = (factory.create_object(data["hostEnvironment"], "HostEnvironment"), dirty)
            factory.validate_type(obj._host_environment[0], "HostEnvironment")
        else:
            obj._host_environment = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostEnvironmentCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_parameters" == "type" or (self.host_parameters is not self.__undef__ and not (dirty and not self._host_parameters[1])):
            dct["hostParameters"] = dictify(self.host_parameters)
        if "host_environment" == "type" or (self.host_environment is not self.__undef__ and not (dirty and not self._host_environment[1])):
            dct["hostEnvironment"] = dictify(self.host_environment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_parameters = (self._host_parameters[0], True)
        self._host_environment = (self._host_environment[0], True)

    def is_dirty(self):
        return any([self._host_parameters[1], self._host_environment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostEnvironmentCreateParameters):
            return False
        return super(HostEnvironmentCreateParameters, self).__eq__(other) and \
               self.host_parameters == other.host_parameters and \
               self.host_environment == other.host_environment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_parameters(self):
        """
        The host parameters used to add a host.

        :rtype: :py:class:`v1_3_0.web.vo.HostCreateParameters`
        """
        return self._host_parameters[0]

    @host_parameters.setter
    def host_parameters(self, value):
        self._host_parameters = (value, True)

    @property
    def host_environment(self):
        """
        The host environment.

        :rtype: :py:class:`v1_3_0.web.vo.HostEnvironment`
        """
        return self._host_environment[0]

    @host_environment.setter
    def host_environment(self, value):
        self._host_environment = (value, True)

class XppStatus(Checklist):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Checklist` *)* The current cross-
    platform provisioning status of a container.
    """
    def __init__(self, undef_enabled=True):
        super(XppStatus, self).__init__()
        self._type = ("XppStatus", True)
        self._last_run_status = (self.__undef__, True)
        self._staging_status = (self.__undef__, True)
        self._target_status = (self.__undef__, True)
        self._validate_status = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppStatus, cls).from_dict(data, dirty, undef_enabled)
        if "lastRunStatus" in data and data["lastRunStatus"] is not None:
            obj._last_run_status = (factory.create_object(data["lastRunStatus"], "XppLastRunStatus"), dirty)
            factory.validate_type(obj._last_run_status[0], "XppLastRunStatus")
        else:
            obj._last_run_status = (obj.__undef__, dirty)
        if "stagingStatus" in data and data["stagingStatus"] is not None:
            obj._staging_status = (factory.create_object(data["stagingStatus"], "XppStagingStatus"), dirty)
            factory.validate_type(obj._staging_status[0], "XppStagingStatus")
        else:
            obj._staging_status = (obj.__undef__, dirty)
        if "targetStatus" in data and data["targetStatus"] is not None:
            obj._target_status = (factory.create_object(data["targetStatus"], "XppTargetStatus"), dirty)
            factory.validate_type(obj._target_status[0], "XppTargetStatus")
        else:
            obj._target_status = (obj.__undef__, dirty)
        if "validateStatus" in data and data["validateStatus"] is not None:
            obj._validate_status = (factory.create_object(data["validateStatus"], "XppValidateStatus"), dirty)
            factory.validate_type(obj._validate_status[0], "XppValidateStatus")
        else:
            obj._validate_status = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_run_status" == "type" or (self.last_run_status is not self.__undef__ and not (dirty and not self._last_run_status[1])):
            dct["lastRunStatus"] = dictify(self.last_run_status)
        if "staging_status" == "type" or (self.staging_status is not self.__undef__ and not (dirty and not self._staging_status[1])):
            dct["stagingStatus"] = dictify(self.staging_status)
        if "target_status" == "type" or (self.target_status is not self.__undef__ and not (dirty and not self._target_status[1])):
            dct["targetStatus"] = dictify(self.target_status)
        if "validate_status" == "type" or (self.validate_status is not self.__undef__ and not (dirty and not self._validate_status[1])):
            dct["validateStatus"] = dictify(self.validate_status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_run_status = (self._last_run_status[0], True)
        self._staging_status = (self._staging_status[0], True)
        self._target_status = (self._target_status[0], True)
        self._validate_status = (self._validate_status[0], True)

    def is_dirty(self):
        return any([self._last_run_status[1], self._staging_status[1], self._target_status[1], self._validate_status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppStatus):
            return False
        return super(XppStatus, self).__eq__(other) and \
               self.last_run_status == other.last_run_status and \
               self.staging_status == other.staging_status and \
               self.target_status == other.target_status and \
               self.validate_status == other.validate_status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_run_status(self):
        """
        Status of the last cross-platform provision of the container.

        :rtype: :py:class:`v1_3_0.web.vo.XppLastRunStatus`
        """
        return self._last_run_status[0]

    @last_run_status.setter
    def last_run_status(self, value):
        self._last_run_status = (value, True)

    @property
    def staging_status(self):
        """
        Status of the cross-platform provisioning staging environment.

        :rtype: :py:class:`v1_3_0.web.vo.XppStagingStatus`
        """
        return self._staging_status[0]

    @staging_status.setter
    def staging_status(self, value):
        self._staging_status = (value, True)

    @property
    def target_status(self):
        """
        Status of the cross-platform provisioning target environment.

        :rtype: :py:class:`v1_3_0.web.vo.XppTargetStatus`
        """
        return self._target_status[0]

    @target_status.setter
    def target_status(self, value):
        self._target_status = (value, True)

    @property
    def validate_status(self):
        """
        cross-platform provisioning validation status of the container.

        :rtype: :py:class:`v1_3_0.web.vo.XppValidateStatus`
        """
        return self._validate_status[0]

    @validate_status.setter
    def validate_status(self, value):
        self._validate_status = (value, True)

class DVCTimestampDataParent(DVCDataParent):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCDataParent` *)* The timestamp data
    parent of a REFRESH or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(DVCTimestampDataParent, self).__init__()
        self._type = ("DVCTimestampDataParent", True)
        self._branch_name = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCTimestampDataParent, cls).from_dict(data, dirty, undef_enabled)
        obj._branch_name = (data.get("branchName", obj.__undef__), dirty)
        if obj._branch_name[0] is not None and obj._branch_name[0] is not obj.__undef__:
            assert isinstance(obj._branch_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch_name[0]))
            common.validate_format(obj._branch_name[0], "None", None, 256)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCTimestampDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "branch_name" == "type" or (self.branch_name is not self.__undef__ and not (dirty and not self._branch_name[1])):
            dct["branchName"] = dictify(self.branch_name)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._branch_name = (self._branch_name[0], True)
        self._branch = (self._branch[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._branch_name[1], self._branch[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCTimestampDataParent):
            return False
        return super(DVCTimestampDataParent, self).__eq__(other) and \
               self.branch_name == other.branch_name and \
               self.branch == other.branch and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def branch_name(self):
        """
        This will always contain the name of the branch, even if it has been
        deleted.

        :rtype: ``basestring``
        """
        return self._branch_name[0]

    @branch_name.setter
    def branch_name(self, value):
        self._branch_name = (value, True)

    @property
    def branch(self):
        """
        The branch this operation's data came from. This will be null if the
        branch has been deleted.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def time(self):
        """
        The data time on the branch that this operation's data came from.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class DVCBookmarkDataParent(DVCDataParent):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DVCDataParent` *)* The bookmark data
    parent of a REFRESH or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(DVCBookmarkDataParent, self).__init__()
        self._type = ("DVCBookmarkDataParent", True)
        self._bookmark = (self.__undef__, True)
        self._bookmark_name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DVCBookmarkDataParent, cls).from_dict(data, dirty, undef_enabled)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._bookmark_name = (data.get("bookmarkName", obj.__undef__), dirty)
        if obj._bookmark_name[0] is not None and obj._bookmark_name[0] is not obj.__undef__:
            assert isinstance(obj._bookmark_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark_name[0]))
            common.validate_format(obj._bookmark_name[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DVCBookmarkDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "bookmark_name" == "type" or (self.bookmark_name is not self.__undef__ and not (dirty and not self._bookmark_name[1])):
            dct["bookmarkName"] = dictify(self.bookmark_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._bookmark_name = (self._bookmark_name[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._bookmark_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DVCBookmarkDataParent):
            return False
        return super(DVCBookmarkDataParent, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.bookmark_name == other.bookmark_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The bookmark that this operation's data came from. This will be null if
        the bookmark has been deleted.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def bookmark_name(self):
        """
        This will always contain the name of the bookmark, even if it has been
        deleted.

        :rtype: ``basestring``
        """
        return self._bookmark_name[0]

    @bookmark_name.setter
    def bookmark_name(self, value):
        self._bookmark_name = (value, True)

class IntegerConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* Constraints placed
    on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerConstraint, self).__init__()
        self._type = ("IntegerConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerConstraint):
            return False
        return super(IntegerConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class BooleanConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* Constraints placed
    on a boolean axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(BooleanConstraint, self).__init__()
        self._type = ("BooleanConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BooleanConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BooleanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BooleanConstraint):
            return False
        return super(BooleanConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PathConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* Constraint placed
    on a filesystem path axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(PathConstraint, self).__init__()
        self._type = ("PathConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PathConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PathConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PathConstraint):
            return False
        return super(PathConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class EnumConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* Constraints placed
    on an enumeration axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(EnumConstraint, self).__init__()
        self._type = ("EnumConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnumConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnumConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnumConstraint):
            return False
        return super(EnumConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class StringConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* Constraint placed
    on a string axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(StringConstraint, self).__init__()
        self._type = ("StringConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StringConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StringConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StringConstraint):
            return False
        return super(StringConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NullConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AxisConstraint` *)* If an axis has this
    type of constraint, it means that no constraints can be placed on this
    axis. This constraint type does nothing and has no descendent types.
    """
    def __init__(self, undef_enabled=True):
        super(NullConstraint, self).__init__()
        self._type = ("NullConstraint", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NullConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NullConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NullConstraint):
            return False
        return super(NullConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class StringEqualConstraint(StringConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.StringConstraint` *)* Constraint placed
    on a string axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(StringEqualConstraint, self).__init__()
        self._type = ("StringEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StringEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StringEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StringEqualConstraint):
            return False
        return super(StringEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must match this string.

        :rtype: ``basestring``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class EnumEqualConstraint(EnumConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.EnumConstraint` *)* Constraints placed
    on an enumeration axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(EnumEqualConstraint, self).__init__()
        self._type = ("EnumEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnumEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnumEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnumEqualConstraint):
            return False
        return super(EnumEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must be equal to the specified value.

        :rtype: ``basestring``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class PathDescendantConstraint(PathConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.PathConstraint` *)* Constraint placed
    on a filesystem path axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(PathDescendantConstraint, self).__init__()
        self._type = ("PathDescendantConstraint", True)
        self._descendant_of = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PathDescendantConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._descendant_of = (data.get("descendantOf", obj.__undef__), dirty)
        if obj._descendant_of[0] is not None and obj._descendant_of[0] is not obj.__undef__:
            assert isinstance(obj._descendant_of[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._descendant_of[0]))
            common.validate_format(obj._descendant_of[0], "unixpath", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PathDescendantConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "descendant_of" == "type" or (self.descendant_of is not self.__undef__ and not (dirty and not self._descendant_of[1])):
            dct["descendantOf"] = dictify(self.descendant_of)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._descendant_of = (self._descendant_of[0], True)

    def is_dirty(self):
        return any([self._descendant_of[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PathDescendantConstraint):
            return False
        return super(PathDescendantConstraint, self).__eq__(other) and \
               self.descendant_of == other.descendant_of

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def descendant_of(self):
        """
        The axis values must be a descendant of this path.

        :rtype: ``basestring``
        """
        return self._descendant_of[0]

    @descendant_of.setter
    def descendant_of(self, value):
        self._descendant_of = (value, True)

class BooleanEqualConstraint(BooleanConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.BooleanConstraint` *)* Constraints
    placed on a boolean axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(BooleanEqualConstraint, self).__init__()
        self._type = ("BooleanEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BooleanEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BooleanEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BooleanEqualConstraint):
            return False
        return super(BooleanEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must be equal to the boolean argument.

        :rtype: ``bool``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class IntegerLessThanConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerLessThanConstraint, self).__init__()
        self._type = ("IntegerLessThanConstraint", True)
        self._less_than = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerLessThanConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._less_than = (data.get("lessThan", obj.__undef__), dirty)
        if obj._less_than[0] is not None and obj._less_than[0] is not obj.__undef__:
            assert isinstance(obj._less_than[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._less_than[0]))
            common.validate_format(obj._less_than[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerLessThanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "less_than" == "type" or (self.less_than is not self.__undef__ and not (dirty and not self._less_than[1])):
            dct["lessThan"] = dictify(self.less_than)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._less_than = (self._less_than[0], True)

    def is_dirty(self):
        return any([self._less_than[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerLessThanConstraint):
            return False
        return super(IntegerLessThanConstraint, self).__eq__(other) and \
               self.less_than == other.less_than

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def less_than(self):
        """
        The axis values must be less than than this value.

        :rtype: ``int``
        """
        return self._less_than[0]

    @less_than.setter
    def less_than(self, value):
        self._less_than = (value, True)

class IntegerGreaterThanConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerGreaterThanConstraint, self).__init__()
        self._type = ("IntegerGreaterThanConstraint", True)
        self._greater_than = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerGreaterThanConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._greater_than = (data.get("greaterThan", obj.__undef__), dirty)
        if obj._greater_than[0] is not None and obj._greater_than[0] is not obj.__undef__:
            assert isinstance(obj._greater_than[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._greater_than[0]))
            common.validate_format(obj._greater_than[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerGreaterThanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "greater_than" == "type" or (self.greater_than is not self.__undef__ and not (dirty and not self._greater_than[1])):
            dct["greaterThan"] = dictify(self.greater_than)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._greater_than = (self._greater_than[0], True)

    def is_dirty(self):
        return any([self._greater_than[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerGreaterThanConstraint):
            return False
        return super(IntegerGreaterThanConstraint, self).__eq__(other) and \
               self.greater_than == other.greater_than

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def greater_than(self):
        """
        The axis values must be greater than this value.

        :rtype: ``int``
        """
        return self._greater_than[0]

    @greater_than.setter
    def greater_than(self, value):
        self._greater_than = (value, True)

class IntegerEqualConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerEqualConstraint, self).__init__()
        self._type = ("IntegerEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerEqualConstraint):
            return False
        return super(IntegerEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must equal this value.

        :rtype: ``int``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class XPPCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for cross-platform
    provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(XPPCompatibilityParameters, self).__init__()
        self._type = ("XPPCompatibilityParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XPPCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XPPCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XPPCompatibilityParameters):
            return False
        return super(XPPCompatibilityParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point to use as a source of compatibility information.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class MigrateCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for migration.
    """
    def __init__(self, undef_enabled=True):
        super(MigrateCompatibilityParameters, self).__init__()
        self._type = ("MigrateCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MigrateCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MigrateCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MigrateCompatibilityParameters):
            return False
        return super(MigrateCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class StagingCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for staging.
    """
    def __init__(self, undef_enabled=True):
        super(StagingCompatibilityParameters, self).__init__()
        self._type = ("StagingCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StagingCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StagingCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StagingCompatibilityParameters):
            return False
        return super(StagingCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class ProvisionCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(ProvisionCompatibilityParameters, self).__init__()
        self._type = ("ProvisionCompatibilityParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProvisionCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProvisionCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProvisionCompatibilityParameters):
            return False
        return super(ProvisionCompatibilityParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The timeflow point to use as a source of compatibility information.

        :rtype: :py:class:`v1_3_0.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class UpgradeCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for upgrading.
    """
    def __init__(self, undef_enabled=True):
        super(UpgradeCompatibilityParameters, self).__init__()
        self._type = ("UpgradeCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UpgradeCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UpgradeCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UpgradeCompatibilityParameters):
            return False
        return super(UpgradeCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class OracleSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of an Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourceRuntime, self).__init__()
        self._type = ("OracleSourceRuntime", True)
        self._database_stats = (self.__undef__, True)
        self._bct_enabled = (self.__undef__, True)
        self._active_instances = (self.__undef__, True)
        self._database_mode = (self.__undef__, True)
        self._archivelog_enabled = (self.__undef__, True)
        self._last_non_logged_location = (self.__undef__, True)
        self._dnfs_enabled = (self.__undef__, True)
        self._rac_enabled = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._database_stats = []
        for item in data.get("databaseStats") or []:
            obj._database_stats.append(factory.create_object(item))
            factory.validate_type(obj._database_stats[-1], "OracleDatabaseStatsSection")
        obj._database_stats = (obj._database_stats, dirty)
        obj._bct_enabled = (data.get("bctEnabled", obj.__undef__), dirty)
        if obj._bct_enabled[0] is not None and obj._bct_enabled[0] is not obj.__undef__:
            assert isinstance(obj._bct_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._bct_enabled[0]))
            common.validate_format(obj._bct_enabled[0], "None", None, None)
        obj._active_instances = []
        for item in data.get("activeInstances") or []:
            obj._active_instances.append(factory.create_object(item))
            factory.validate_type(obj._active_instances[-1], "OracleActiveInstance")
        obj._active_instances = (obj._active_instances, dirty)
        obj._database_mode = (data.get("databaseMode", obj.__undef__), dirty)
        if obj._database_mode[0] is not None and obj._database_mode[0] is not obj.__undef__:
            assert isinstance(obj._database_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_mode[0]))
            assert obj._database_mode[0] in [u'READ_WRITE', u'READ_ONLY', u'STANDBY_READ_ONLY', u'MOUNTED_ONLY', u'UNKNOWN'], "Expected enum [u'READ_WRITE', u'READ_ONLY', u'STANDBY_READ_ONLY', u'MOUNTED_ONLY', u'UNKNOWN'] but got %s" % obj._database_mode[0]
            common.validate_format(obj._database_mode[0], "None", None, None)
        obj._archivelog_enabled = (data.get("archivelogEnabled", obj.__undef__), dirty)
        if obj._archivelog_enabled[0] is not None and obj._archivelog_enabled[0] is not obj.__undef__:
            assert isinstance(obj._archivelog_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._archivelog_enabled[0]))
            common.validate_format(obj._archivelog_enabled[0], "None", None, None)
        obj._last_non_logged_location = (data.get("lastNonLoggedLocation", obj.__undef__), dirty)
        if obj._last_non_logged_location[0] is not None and obj._last_non_logged_location[0] is not obj.__undef__:
            assert isinstance(obj._last_non_logged_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_non_logged_location[0]))
            common.validate_format(obj._last_non_logged_location[0], "None", None, None)
        obj._dnfs_enabled = (data.get("dnfsEnabled", obj.__undef__), dirty)
        if obj._dnfs_enabled[0] is not None and obj._dnfs_enabled[0] is not obj.__undef__:
            assert isinstance(obj._dnfs_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._dnfs_enabled[0]))
            common.validate_format(obj._dnfs_enabled[0], "None", None, None)
        obj._rac_enabled = (data.get("racEnabled", obj.__undef__), dirty)
        if obj._rac_enabled[0] is not None and obj._rac_enabled[0] is not obj.__undef__:
            assert isinstance(obj._rac_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._rac_enabled[0]))
            common.validate_format(obj._rac_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_stats" == "type" or (self.database_stats is not self.__undef__ and not (dirty and not self._database_stats[1])):
            dct["databaseStats"] = dictify(self.database_stats)
        if "bct_enabled" == "type" or (self.bct_enabled is not self.__undef__ and not (dirty and not self._bct_enabled[1])):
            dct["bctEnabled"] = dictify(self.bct_enabled)
        if "active_instances" == "type" or (self.active_instances is not self.__undef__ and not (dirty and not self._active_instances[1])):
            dct["activeInstances"] = dictify(self.active_instances)
        if "database_mode" == "type" or (self.database_mode is not self.__undef__ and not (dirty and not self._database_mode[1])):
            dct["databaseMode"] = dictify(self.database_mode)
        if "archivelog_enabled" == "type" or (self.archivelog_enabled is not self.__undef__ and not (dirty and not self._archivelog_enabled[1])):
            dct["archivelogEnabled"] = dictify(self.archivelog_enabled)
        if "last_non_logged_location" == "type" or (self.last_non_logged_location is not self.__undef__ and not (dirty and not self._last_non_logged_location[1])):
            dct["lastNonLoggedLocation"] = dictify(self.last_non_logged_location)
        if "dnfs_enabled" == "type" or (self.dnfs_enabled is not self.__undef__ and not (dirty and not self._dnfs_enabled[1])):
            dct["dnfsEnabled"] = dictify(self.dnfs_enabled)
        if "rac_enabled" == "type" or (self.rac_enabled is not self.__undef__ and not (dirty and not self._rac_enabled[1])):
            dct["racEnabled"] = dictify(self.rac_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_stats = (self._database_stats[0], True)
        self._bct_enabled = (self._bct_enabled[0], True)
        self._active_instances = (self._active_instances[0], True)
        self._database_mode = (self._database_mode[0], True)
        self._archivelog_enabled = (self._archivelog_enabled[0], True)
        self._last_non_logged_location = (self._last_non_logged_location[0], True)
        self._dnfs_enabled = (self._dnfs_enabled[0], True)
        self._rac_enabled = (self._rac_enabled[0], True)

    def is_dirty(self):
        return any([self._database_stats[1], self._bct_enabled[1], self._active_instances[1], self._database_mode[1], self._archivelog_enabled[1], self._last_non_logged_location[1], self._dnfs_enabled[1], self._rac_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourceRuntime):
            return False
        return super(OracleSourceRuntime, self).__eq__(other) and \
               self.database_stats == other.database_stats and \
               self.bct_enabled == other.bct_enabled and \
               self.active_instances == other.active_instances and \
               self.database_mode == other.database_mode and \
               self.archivelog_enabled == other.archivelog_enabled and \
               self.last_non_logged_location == other.last_non_logged_location and \
               self.dnfs_enabled == other.dnfs_enabled and \
               self.rac_enabled == other.rac_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_stats(self):
        """
        Table of key database performance statistics.

        :rtype: ``list`` of
            :py:class:`v1_3_0.web.vo.OracleDatabaseStatsSection`
        """
        return self._database_stats[0]

    @database_stats.setter
    def database_stats(self, value):
        self._database_stats = (value, True)

    @property
    def bct_enabled(self):
        """
        True if block change tracking is enabled.

        :rtype: ``bool``
        """
        return self._bct_enabled[0]

    @bct_enabled.setter
    def bct_enabled(self, value):
        self._bct_enabled = (value, True)

    @property
    def active_instances(self):
        """
        List of active database instances for the source.

        :rtype: ``list`` of :py:class:`v1_3_0.web.vo.OracleActiveInstance`
        """
        return self._active_instances[0]

    @active_instances.setter
    def active_instances(self, value):
        self._active_instances = (value, True)

    @property
    def database_mode(self):
        """
        *(default value: UNKNOWN)* Operating mode of the database. *(permitted
        values: READ_WRITE, READ_ONLY, STANDBY_READ_ONLY, MOUNTED_ONLY,
        UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._database_mode[0]

    @database_mode.setter
    def database_mode(self, value):
        self._database_mode = (value, True)

    @property
    def archivelog_enabled(self):
        """
        True if the database is running in ARCHIVELOG mode.

        :rtype: ``bool``
        """
        return self._archivelog_enabled[0]

    @archivelog_enabled.setter
    def archivelog_enabled(self, value):
        self._archivelog_enabled = (value, True)

    @property
    def last_non_logged_location(self):
        """
        Highest SCN at which non-logged changes were generated.

        :rtype: ``basestring``
        """
        return self._last_non_logged_location[0]

    @last_non_logged_location.setter
    def last_non_logged_location(self, value):
        self._last_non_logged_location = (value, True)

    @property
    def dnfs_enabled(self):
        """
        True if the database has Oracle Direct NFS client enabled.

        :rtype: ``bool``
        """
        return self._dnfs_enabled[0]

    @dnfs_enabled.setter
    def dnfs_enabled(self, value):
        self._dnfs_enabled = (value, True)

    @property
    def rac_enabled(self):
        """
        True for a RAC source database.

        :rtype: ``bool``
        """
        return self._rac_enabled[0]

    @rac_enabled.setter
    def rac_enabled(self, value):
        self._rac_enabled = (value, True)

class MSSqlSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a MSSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSourceRuntime, self).__init__()
        self._type = ("MSSqlSourceRuntime", True)
        self._recovery_model = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._recovery_model = (data.get("recoveryModel", obj.__undef__), dirty)
        if obj._recovery_model[0] is not None and obj._recovery_model[0] is not obj.__undef__:
            assert isinstance(obj._recovery_model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._recovery_model[0]))
            assert obj._recovery_model[0] in [u'SIMPLE', u'BULK_LOGGED', u'FULL', u'UNKNOWN'], "Expected enum [u'SIMPLE', u'BULK_LOGGED', u'FULL', u'UNKNOWN'] but got %s" % obj._recovery_model[0]
            common.validate_format(obj._recovery_model[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "recovery_model" == "type" or (self.recovery_model is not self.__undef__ and not (dirty and not self._recovery_model[1])):
            dct["recoveryModel"] = dictify(self.recovery_model)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._recovery_model = (self._recovery_model[0], True)

    def is_dirty(self):
        return any([self._recovery_model[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSourceRuntime):
            return False
        return super(MSSqlSourceRuntime, self).__eq__(other) and \
               self.recovery_model == other.recovery_model

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def recovery_model(self):
        """
        *(default value: UNKNOWN)* Recovery model of the database. *(permitted
        values: SIMPLE, BULK_LOGGED, FULL, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._recovery_model[0]

    @recovery_model.setter
    def recovery_model(self, value):
        self._recovery_model = (value, True)

class AppDataSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of an AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceRuntime, self).__init__()
        self._type = ("AppDataSourceRuntime", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceRuntime):
            return False
        return super(AppDataSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSourceRuntime, self).__init__()
        self._type = ("PgSQLSourceRuntime", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSourceRuntime):
            return False
        return super(PgSQLSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleSourcingPolicy(SourcingPolicy):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourcingPolicy` *)* Database policies
    for managing snapsync and logsync across sources for an Oracle container
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourcingPolicy, self).__init__()
        self._type = ("OracleSourcingPolicy", True)
        self._logsync_mode = (self.__undef__, True)
        self._logsync_interval = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourcingPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._logsync_mode = (data.get("logsyncMode", obj.__undef__), dirty)
        if obj._logsync_mode[0] is not None and obj._logsync_mode[0] is not obj.__undef__:
            assert isinstance(obj._logsync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._logsync_mode[0]))
            assert obj._logsync_mode[0] in [u'ARCHIVE_ONLY_MODE', u'ARCHIVE_REDO_MODE', u'UNDEFINED'], "Expected enum [u'ARCHIVE_ONLY_MODE', u'ARCHIVE_REDO_MODE', u'UNDEFINED'] but got %s" % obj._logsync_mode[0]
            common.validate_format(obj._logsync_mode[0], "None", None, None)
        obj._logsync_interval = (data.get("logsyncInterval", obj.__undef__), dirty)
        if obj._logsync_interval[0] is not None and obj._logsync_interval[0] is not obj.__undef__:
            assert isinstance(obj._logsync_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._logsync_interval[0]))
            common.validate_format(obj._logsync_interval[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourcingPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "logsync_mode" == "type" or (self.logsync_mode is not self.__undef__ and not (dirty and not self._logsync_mode[1])):
            dct["logsyncMode"] = dictify(self.logsync_mode)
        if "logsync_interval" == "type" or (self.logsync_interval is not self.__undef__ and not (dirty and not self._logsync_interval[1])):
            dct["logsyncInterval"] = dictify(self.logsync_interval)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._logsync_mode = (self._logsync_mode[0], True)
        self._logsync_interval = (self._logsync_interval[0], True)

    def is_dirty(self):
        return any([self._logsync_mode[1], self._logsync_interval[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourcingPolicy):
            return False
        return super(OracleSourcingPolicy, self).__eq__(other) and \
               self.logsync_mode == other.logsync_mode and \
               self.logsync_interval == other.logsync_interval

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def logsync_mode(self):
        """
        *(default value: UNDEFINED)* Logsync operation mode for this database.
        *(permitted values: ARCHIVE_ONLY_MODE, ARCHIVE_REDO_MODE, UNDEFINED)*

        :rtype: ``basestring``
        """
        return self._logsync_mode[0]

    @logsync_mode.setter
    def logsync_mode(self, value):
        self._logsync_mode = (value, True)

    @property
    def logsync_interval(self):
        """
        *(default value: 5)* Interval between logsync requests, in seconds.

        :rtype: ``int``
        """
        return self._logsync_interval[0]

    @logsync_interval.setter
    def logsync_interval(self, value):
        self._logsync_interval = (value, True)

class AppDataFilesystemLayout(FilesystemLayout):
    """
    *(extends* :py:class:`v1_3_0.web.vo.FilesystemLayout` *)* A filesystem
    layout that matches the filesystem of a Delphix TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataFilesystemLayout, self).__init__()
        self._type = ("AppDataFilesystemLayout", True)
        self._target_directory = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataFilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        if "targetDirectory" not in data:
            raise ValueError("Missing required property \"targetDirectory\".")
        obj._target_directory = (data.get("targetDirectory", obj.__undef__), dirty)
        if obj._target_directory[0] is not None and obj._target_directory[0] is not obj.__undef__:
            assert isinstance(obj._target_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_directory[0]))
            common.validate_format(obj._target_directory[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataFilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target_directory" == "type" or (self.target_directory is not self.__undef__ and not (dirty and not self._target_directory[1])):
            dct["targetDirectory"] = dictify(self.target_directory)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target_directory = (self._target_directory[0], True)

    def is_dirty(self):
        return any([self._target_directory[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataFilesystemLayout):
            return False
        return super(AppDataFilesystemLayout, self).__eq__(other) and \
               self.target_directory == other.target_directory

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target_directory(self):
        """
        The base directory to use for the exported database.

        :rtype: ``basestring``
        """
        return self._target_directory[0]

    @target_directory.setter
    def target_directory(self, value):
        self._target_directory = (value, True)

class TimeflowFilesystemLayout(FilesystemLayout):
    """
    *(extends* :py:class:`v1_3_0.web.vo.FilesystemLayout` *)* A filesystem
    layout that matches the filesystem of a Delphix Timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowFilesystemLayout, self).__init__()
        self._type = ("TimeflowFilesystemLayout", True)
        self._target_directory = (self.__undef__, True)
        self._data_directory = (self.__undef__, True)
        self._archive_directory = (self.__undef__, True)
        self._external_directory = (self.__undef__, True)
        self._temp_directory = (self.__undef__, True)
        self._script_directory = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowFilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        obj._target_directory = (data.get("targetDirectory", obj.__undef__), dirty)
        if obj._target_directory[0] is not None and obj._target_directory[0] is not obj.__undef__:
            assert isinstance(obj._target_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_directory[0]))
            common.validate_format(obj._target_directory[0], "None", None, None)
        obj._data_directory = (data.get("dataDirectory", obj.__undef__), dirty)
        if obj._data_directory[0] is not None and obj._data_directory[0] is not obj.__undef__:
            assert isinstance(obj._data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_directory[0]))
            common.validate_format(obj._data_directory[0], "None", None, None)
        obj._archive_directory = (data.get("archiveDirectory", obj.__undef__), dirty)
        if obj._archive_directory[0] is not None and obj._archive_directory[0] is not obj.__undef__:
            assert isinstance(obj._archive_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._archive_directory[0]))
            common.validate_format(obj._archive_directory[0], "None", None, None)
        obj._external_directory = (data.get("externalDirectory", obj.__undef__), dirty)
        if obj._external_directory[0] is not None and obj._external_directory[0] is not obj.__undef__:
            assert isinstance(obj._external_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_directory[0]))
            common.validate_format(obj._external_directory[0], "None", None, None)
        obj._temp_directory = (data.get("tempDirectory", obj.__undef__), dirty)
        if obj._temp_directory[0] is not None and obj._temp_directory[0] is not obj.__undef__:
            assert isinstance(obj._temp_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._temp_directory[0]))
            common.validate_format(obj._temp_directory[0], "None", None, None)
        obj._script_directory = (data.get("scriptDirectory", obj.__undef__), dirty)
        if obj._script_directory[0] is not None and obj._script_directory[0] is not obj.__undef__:
            assert isinstance(obj._script_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._script_directory[0]))
            common.validate_format(obj._script_directory[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowFilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target_directory" == "type" or (self.target_directory is not self.__undef__ and not (dirty and not self._target_directory[1])):
            dct["targetDirectory"] = dictify(self.target_directory)
        if "data_directory" == "type" or (self.data_directory is not self.__undef__ and not (dirty and not self._data_directory[1])):
            dct["dataDirectory"] = dictify(self.data_directory)
        if "archive_directory" == "type" or (self.archive_directory is not self.__undef__ and not (dirty and not self._archive_directory[1])):
            dct["archiveDirectory"] = dictify(self.archive_directory)
        if "external_directory" == "type" or (self.external_directory is not self.__undef__ and not (dirty and not self._external_directory[1])):
            dct["externalDirectory"] = dictify(self.external_directory)
        if "temp_directory" == "type" or (self.temp_directory is not self.__undef__ and not (dirty and not self._temp_directory[1])):
            dct["tempDirectory"] = dictify(self.temp_directory)
        if "script_directory" == "type" or (self.script_directory is not self.__undef__ and not (dirty and not self._script_directory[1])):
            dct["scriptDirectory"] = dictify(self.script_directory)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target_directory = (self._target_directory[0], True)
        self._data_directory = (self._data_directory[0], True)
        self._archive_directory = (self._archive_directory[0], True)
        self._external_directory = (self._external_directory[0], True)
        self._temp_directory = (self._temp_directory[0], True)
        self._script_directory = (self._script_directory[0], True)

    def is_dirty(self):
        return any([self._target_directory[1], self._data_directory[1], self._archive_directory[1], self._external_directory[1], self._temp_directory[1], self._script_directory[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowFilesystemLayout):
            return False
        return super(TimeflowFilesystemLayout, self).__eq__(other) and \
               self.target_directory == other.target_directory and \
               self.data_directory == other.data_directory and \
               self.archive_directory == other.archive_directory and \
               self.external_directory == other.external_directory and \
               self.temp_directory == other.temp_directory and \
               self.script_directory == other.script_directory

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target_directory(self):
        """
        The base directory to use for the exported database.

        :rtype: ``basestring``
        """
        return self._target_directory[0]

    @target_directory.setter
    def target_directory(self, value):
        self._target_directory = (value, True)

    @property
    def data_directory(self):
        """
        The directory for data files.

        :rtype: ``basestring``
        """
        return self._data_directory[0]

    @data_directory.setter
    def data_directory(self, value):
        self._data_directory = (value, True)

    @property
    def archive_directory(self):
        """
        The directory for archive files.

        :rtype: ``basestring``
        """
        return self._archive_directory[0]

    @archive_directory.setter
    def archive_directory(self, value):
        self._archive_directory = (value, True)

    @property
    def external_directory(self):
        """
        The directory for external files.

        :rtype: ``basestring``
        """
        return self._external_directory[0]

    @external_directory.setter
    def external_directory(self, value):
        self._external_directory = (value, True)

    @property
    def temp_directory(self):
        """
        The directory for temporary files.

        :rtype: ``basestring``
        """
        return self._temp_directory[0]

    @temp_directory.setter
    def temp_directory(self, value):
        self._temp_directory = (value, True)

    @property
    def script_directory(self):
        """
        The directory for script files.

        :rtype: ``basestring``
        """
        return self._script_directory[0]

    @script_directory.setter
    def script_directory(self, value):
        self._script_directory = (value, True)

class IoOpsDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Datapoint` *)* An analytics datapoint
    generated by the DISK_OPS, DxFS_OPS, DxFS_IO_QUEUE_OPS, iSCSI_OPS, NFS_OPS,
    or VFS_OPS statistic types.
    """
    def __init__(self, undef_enabled=True):
        super(IoOpsDatapoint, self).__init__()
        self._type = ("IoOpsDatapoint", True)
        self._count = (self.__undef__, True)
        self._latency = (self.__undef__, True)
        self._avg_latency = (self.__undef__, True)
        self._throughput = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IoOpsDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._count = (data.get("count", obj.__undef__), dirty)
        if obj._count[0] is not None and obj._count[0] is not obj.__undef__:
            assert isinstance(obj._count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._count[0]))
            common.validate_format(obj._count[0], "None", None, None)
        obj._latency = (data.get("latency", obj.__undef__), dirty)
        if obj._latency[0] is not None and obj._latency[0] is not obj.__undef__:
            assert isinstance(obj._latency[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._latency[0]))
            common.validate_format(obj._latency[0], "None", None, None)
        obj._avg_latency = (data.get("avgLatency", obj.__undef__), dirty)
        if obj._avg_latency[0] is not None and obj._avg_latency[0] is not obj.__undef__:
            assert isinstance(obj._avg_latency[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._avg_latency[0]))
            common.validate_format(obj._avg_latency[0], "None", None, None)
        obj._throughput = (data.get("throughput", obj.__undef__), dirty)
        if obj._throughput[0] is not None and obj._throughput[0] is not obj.__undef__:
            assert isinstance(obj._throughput[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._throughput[0]))
            common.validate_format(obj._throughput[0], "None", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IoOpsDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "count" == "type" or (self.count is not self.__undef__ and not (dirty and not self._count[1])):
            dct["count"] = dictify(self.count)
        if "latency" == "type" or (self.latency is not self.__undef__ and not (dirty and not self._latency[1])):
            dct["latency"] = dictify(self.latency)
        if "avg_latency" == "type" or (self.avg_latency is not self.__undef__ and not (dirty and not self._avg_latency[1])):
            dct["avgLatency"] = dictify(self.avg_latency)
        if "throughput" == "type" or (self.throughput is not self.__undef__ and not (dirty and not self._throughput[1])):
            dct["throughput"] = dictify(self.throughput)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._count = (self._count[0], True)
        self._latency = (self._latency[0], True)
        self._avg_latency = (self._avg_latency[0], True)
        self._throughput = (self._throughput[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._count[1], self._latency[1], self._avg_latency[1], self._throughput[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IoOpsDatapoint):
            return False
        return super(IoOpsDatapoint, self).__eq__(other) and \
               self.count == other.count and \
               self.latency == other.latency and \
               self.avg_latency == other.avg_latency and \
               self.throughput == other.throughput and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def count(self):
        """
        Number of I/O operations.

        :rtype: ``int``
        """
        return self._count[0]

    @count.setter
    def count(self, value):
        self._count = (value, True)

    @property
    def latency(self):
        """
        I/O latencies in nanoseconds.

        :rtype: ``dict``
        """
        return self._latency[0]

    @latency.setter
    def latency(self, value):
        self._latency = (value, True)

    @property
    def avg_latency(self):
        """
        Average I/O latency in nanoseconds.

        :rtype: ``int``
        """
        return self._avg_latency[0]

    @avg_latency.setter
    def avg_latency(self, value):
        self._avg_latency = (value, True)

    @property
    def throughput(self):
        """
        I/O throughput in bytes.

        :rtype: ``int``
        """
        return self._throughput[0]

    @throughput.setter
    def throughput(self, value):
        self._throughput = (value, True)

    @property
    def size(self):
        """
        I/O sizes in bytes.

        :rtype: ``dict``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class CpuUtilDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Datapoint` *)* An analytics datapoint
    generated by the CPU_UTIL statistic type.
    """
    def __init__(self, undef_enabled=True):
        super(CpuUtilDatapoint, self).__init__()
        self._type = ("CpuUtilDatapoint", True)
        self._dtrace = (self.__undef__, True)
        self._idle = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._kernel = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CpuUtilDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._dtrace = (data.get("dtrace", obj.__undef__), dirty)
        if obj._dtrace[0] is not None and obj._dtrace[0] is not obj.__undef__:
            assert isinstance(obj._dtrace[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._dtrace[0]))
            common.validate_format(obj._dtrace[0], "None", None, None)
        obj._idle = (data.get("idle", obj.__undef__), dirty)
        if obj._idle[0] is not None and obj._idle[0] is not obj.__undef__:
            assert isinstance(obj._idle[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._idle[0]))
            common.validate_format(obj._idle[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        obj._kernel = (data.get("kernel", obj.__undef__), dirty)
        if obj._kernel[0] is not None and obj._kernel[0] is not obj.__undef__:
            assert isinstance(obj._kernel[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._kernel[0]))
            common.validate_format(obj._kernel[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CpuUtilDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "dtrace" == "type" or (self.dtrace is not self.__undef__ and not (dirty and not self._dtrace[1])):
            dct["dtrace"] = dictify(self.dtrace)
        if "idle" == "type" or (self.idle is not self.__undef__ and not (dirty and not self._idle[1])):
            dct["idle"] = dictify(self.idle)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "kernel" == "type" or (self.kernel is not self.__undef__ and not (dirty and not self._kernel[1])):
            dct["kernel"] = dictify(self.kernel)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._dtrace = (self._dtrace[0], True)
        self._idle = (self._idle[0], True)
        self._user = (self._user[0], True)
        self._kernel = (self._kernel[0], True)

    def is_dirty(self):
        return any([self._dtrace[1], self._idle[1], self._user[1], self._kernel[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CpuUtilDatapoint):
            return False
        return super(CpuUtilDatapoint, self).__eq__(other) and \
               self.dtrace == other.dtrace and \
               self.idle == other.idle and \
               self.user == other.user and \
               self.kernel == other.kernel

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def dtrace(self):
        """
        DTrace time in milliseconds (subset of time in kernel).

        :rtype: ``int``
        """
        return self._dtrace[0]

    @dtrace.setter
    def dtrace(self, value):
        self._dtrace = (value, True)

    @property
    def idle(self):
        """
        Idle time in milliseconds.

        :rtype: ``int``
        """
        return self._idle[0]

    @idle.setter
    def idle(self, value):
        self._idle = (value, True)

    @property
    def user(self):
        """
        User time in milliseconds.

        :rtype: ``int``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def kernel(self):
        """
        Kernel time in milliseconds.

        :rtype: ``int``
        """
        return self._kernel[0]

    @kernel.setter
    def kernel(self, value):
        self._kernel = (value, True)

class NetworkInterfaceUtilDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_3_0.web.vo.Datapoint` *)* An analytics datapoint
    generated by the NETWORK_INTERFACE_UTIL statistic type.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterfaceUtilDatapoint, self).__init__()
        self._type = ("NetworkInterfaceUtilDatapoint", True)
        self._in_bytes = (self.__undef__, True)
        self._out_packets = (self.__undef__, True)
        self._in_packets = (self.__undef__, True)
        self._out_bytes = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterfaceUtilDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._in_bytes = (data.get("inBytes", obj.__undef__), dirty)
        if obj._in_bytes[0] is not None and obj._in_bytes[0] is not obj.__undef__:
            assert isinstance(obj._in_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_bytes[0]))
            common.validate_format(obj._in_bytes[0], "None", None, None)
        obj._out_packets = (data.get("outPackets", obj.__undef__), dirty)
        if obj._out_packets[0] is not None and obj._out_packets[0] is not obj.__undef__:
            assert isinstance(obj._out_packets[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._out_packets[0]))
            common.validate_format(obj._out_packets[0], "None", None, None)
        obj._in_packets = (data.get("inPackets", obj.__undef__), dirty)
        if obj._in_packets[0] is not None and obj._in_packets[0] is not obj.__undef__:
            assert isinstance(obj._in_packets[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_packets[0]))
            common.validate_format(obj._in_packets[0], "None", None, None)
        obj._out_bytes = (data.get("outBytes", obj.__undef__), dirty)
        if obj._out_bytes[0] is not None and obj._out_bytes[0] is not obj.__undef__:
            assert isinstance(obj._out_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._out_bytes[0]))
            common.validate_format(obj._out_bytes[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterfaceUtilDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "in_bytes" == "type" or (self.in_bytes is not self.__undef__ and not (dirty and not self._in_bytes[1])):
            dct["inBytes"] = dictify(self.in_bytes)
        if "out_packets" == "type" or (self.out_packets is not self.__undef__ and not (dirty and not self._out_packets[1])):
            dct["outPackets"] = dictify(self.out_packets)
        if "in_packets" == "type" or (self.in_packets is not self.__undef__ and not (dirty and not self._in_packets[1])):
            dct["inPackets"] = dictify(self.in_packets)
        if "out_bytes" == "type" or (self.out_bytes is not self.__undef__ and not (dirty and not self._out_bytes[1])):
            dct["outBytes"] = dictify(self.out_bytes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._in_bytes = (self._in_bytes[0], True)
        self._out_packets = (self._out_packets[0], True)
        self._in_packets = (self._in_packets[0], True)
        self._out_bytes = (self._out_bytes[0], True)

    def is_dirty(self):
        return any([self._in_bytes[1], self._out_packets[1], self._in_packets[1], self._out_bytes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterfaceUtilDatapoint):
            return False
        return super(NetworkInterfaceUtilDatapoint, self).__eq__(other) and \
               self.in_bytes == other.in_bytes and \
               self.out_packets == other.out_packets and \
               self.in_packets == other.in_packets and \
               self.out_bytes == other.out_bytes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def in_bytes(self):
        """
        Bytes received on the interface.

        :rtype: ``int``
        """
        return self._in_bytes[0]

    @in_bytes.setter
    def in_bytes(self, value):
        self._in_bytes = (value, True)

    @property
    def out_packets(self):
        """
        Packets transmitted on the interface.

        :rtype: ``int``
        """
        return self._out_packets[0]

    @out_packets.setter
    def out_packets(self, value):
        self._out_packets = (value, True)

    @property
    def in_packets(self):
        """
        Packets received on the interface.

        :rtype: ``int``
        """
        return self._in_packets[0]

    @in_packets.setter
    def in_packets(self, value):
        self._in_packets = (value, True)

    @property
    def out_bytes(self):
        """
        Bytes transmitted on the interface.

        :rtype: ``int``
        """
        return self._out_bytes[0]

    @out_bytes.setter
    def out_bytes(self, value):
        self._out_bytes = (value, True)

class AppDataProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataProvisionParameters, self).__init__()
        self._type = ("AppDataProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "AppDataVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "AppDataVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataProvisionParameters):
            return False
        return super(AppDataProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_3_0.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class OracleProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleProvisionParameters, self).__init__()
        self._type = ("OracleProvisionParameters", True)
        self._username = (self.__undef__, True)
        self._source_config = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._open_resetlogs = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "OracleDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "OracleDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "OracleVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._open_resetlogs = (data.get("openResetlogs", obj.__undef__), dirty)
        if obj._open_resetlogs[0] is not None and obj._open_resetlogs[0] is not obj.__undef__:
            assert isinstance(obj._open_resetlogs[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._open_resetlogs[0]))
            common.validate_format(obj._open_resetlogs[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "open_resetlogs" == "type" or (self.open_resetlogs is not self.__undef__ and not (dirty and not self._open_resetlogs[1])):
            dct["openResetlogs"] = dictify(self.open_resetlogs)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._source_config = (self._source_config[0], True)
        self._container = (self._container[0], True)
        self._credential = (self._credential[0], True)
        self._source = (self._source[0], True)
        self._open_resetlogs = (self._open_resetlogs[0], True)

    def is_dirty(self):
        return any([self._username[1], self._source_config[1], self._container[1], self._credential[1], self._source[1], self._open_resetlogs[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleProvisionParameters):
            return False
        return super(OracleProvisionParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.source_config == other.source_config and \
               self.container == other.container and \
               self.credential == other.credential and \
               self.source == other.source and \
               self.open_resetlogs == other.open_resetlogs

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_3_0.web.vo.OracleDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_3_0.web.vo.OracleDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_3_0.web.vo.OracleVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def open_resetlogs(self):
        """
        *(default value: True)* Flag indicating whether to open the database
        after provision.

        :rtype: ``bool``
        """
        return self._open_resetlogs[0]

    @open_resetlogs.setter
    def open_resetlogs(self, value):
        self._open_resetlogs = (value, True)

class MSSqlProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlProvisionParameters, self).__init__()
        self._type = ("MSSqlProvisionParameters", True)
        self._source_config = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._recovery_model = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MSSqlDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MSSqlDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MSSqlDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MSSqlDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "MSSqlVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "MSSqlVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._recovery_model = (data.get("recoveryModel", obj.__undef__), dirty)
        if obj._recovery_model[0] is not None and obj._recovery_model[0] is not obj.__undef__:
            assert isinstance(obj._recovery_model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._recovery_model[0]))
            assert obj._recovery_model[0] in [u'SIMPLE', u'BULK_LOGGED', u'FULL'], "Expected enum [u'SIMPLE', u'BULK_LOGGED', u'FULL'] but got %s" % obj._recovery_model[0]
            common.validate_format(obj._recovery_model[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "recovery_model" == "type" or (self.recovery_model is not self.__undef__ and not (dirty and not self._recovery_model[1])):
            dct["recoveryModel"] = dictify(self.recovery_model)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._container = (self._container[0], True)
        self._source = (self._source[0], True)
        self._recovery_model = (self._recovery_model[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._container[1], self._source[1], self._recovery_model[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlProvisionParameters):
            return False
        return super(MSSqlProvisionParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.container == other.container and \
               self.source == other.source and \
               self.recovery_model == other.recovery_model

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def recovery_model(self):
        """
        *(default value: SIMPLE)* Recovery model of the database. *(permitted
        values: SIMPLE, BULK_LOGGED, FULL)*

        :rtype: ``basestring``
        """
        return self._recovery_model[0]

    @recovery_model.setter
    def recovery_model(self, value):
        self._recovery_model = (value, True)

class PgSQLProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLProvisionParameters, self).__init__()
        self._type = ("PgSQLProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "PgSQLVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "PgSQLVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "PgSQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "PgSQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "PgSQLDBClusterConfig"), dirty)
            factory.validate_type(obj._source_config[0], "PgSQLDBClusterConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLProvisionParameters):
            return False
        return super(PgSQLProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config for the source.

        :rtype: :py:class:`v1_3_0.web.vo.PgSQLDBClusterConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class OracleAttachSourceParameters(AttachSourceParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AttachSourceParameters` *)* Represents
    the Oracle specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(OracleAttachSourceParameters, self).__init__()
        self._type = ("OracleAttachSourceParameters", True)
        self._source = (self.__undef__, True)
        self._link_now = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleAttachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleLinkedSource"), dirty)
            factory.validate_type(obj._source[0], "OracleLinkedSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._link_now = (data.get("linkNow", obj.__undef__), dirty)
        if obj._link_now[0] is not None and obj._link_now[0] is not obj.__undef__:
            assert isinstance(obj._link_now[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._link_now[0]))
            common.validate_format(obj._link_now[0], "None", None, None)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleAttachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "link_now" == "type" or (self.link_now is not self.__undef__ and not (dirty and not self._link_now[1])):
            dct["linkNow"] = dictify(self.link_now)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._link_now = (self._link_now[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)

    def is_dirty(self):
        return any([self._source[1], self._link_now[1], self._environment_user[1], self._db_user[1], self._db_credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleAttachSourceParameters):
            return False
        return super(OracleAttachSourceParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.link_now == other.link_now and \
               self.environment_user == other.environment_user and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing source
        config.

        :rtype: :py:class:`v1_3_0.web.vo.OracleLinkedSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def link_now(self):
        """
        True if snapshot should be performed after attach is completed.

        :rtype: ``bool``
        """
        return self._link_now[0]

    @link_now.setter
    def link_now(self, value):
        self._link_now = (value, True)

    @property
    def environment_user(self):
        """
        Information about the os user to use for attaching source.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def db_user(self):
        """
        The name of the DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The password for the DB user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

class PgSQLAttachSourceParameters(AttachSourceParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AttachSourceParameters` *)* Represents
    the PostgreSQL specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLAttachSourceParameters, self).__init__()
        self._type = ("PgSQLAttachSourceParameters", True)
        self._ppt_host_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLAttachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLAttachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._db_user = (self._db_user[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._ppt_host_user[1], self._db_credentials[1], self._connection_database[1], self._db_user[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLAttachSourceParameters):
            return False
        return super(PgSQLAttachSourceParameters, self).__eq__(other) and \
               self.ppt_host_user == other.ppt_host_user and \
               self.db_credentials == other.db_credentials and \
               self.connection_database == other.connection_database and \
               self.db_user == other.db_user and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ppt_host_user(self):
        """
        OS user on the staging host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def db_credentials(self):
        """
        The PostgreSQL login password for the source DB user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def connection_database(self):
        """
        *(default value: postgres)* The database that must be used to run SQL
        queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def db_user(self):
        """
        The PostgreSQL login username for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def ppt_repository(self):
        """
        The PostgreSQL instance on the staging environment to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class MSSqlAttachSourceParameters(AttachSourceParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.AttachSourceParameters` *)* Represents
    the MSSQL specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlAttachSourceParameters, self).__init__()
        self._type = ("MSSqlAttachSourceParameters", True)
        self._ppt_host_user = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlAttachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "MSSqlLinkedSource"), dirty)
            factory.validate_type(obj._source[0], "MSSqlLinkedSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlAttachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._source = (self._source[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._ppt_host_user[1], self._source[1], self._staging_post_script[1], self._db_user[1], self._db_credentials[1], self._source_host_user[1], self._staging_pre_script[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlAttachSourceParameters):
            return False
        return super(MSSqlAttachSourceParameters, self).__eq__(other) and \
               self.ppt_host_user == other.ppt_host_user and \
               self.source == other.source and \
               self.staging_post_script == other.staging_post_script and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials and \
               self.source_host_user == other.source_host_user and \
               self.staging_pre_script == other.staging_pre_script and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ppt_host_user(self):
        """
        OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def source(self):
        """
        Source to link the container to. This must reference an existing linked
        source config.

        :rtype: :py:class:`v1_3_0.web.vo.MSSqlLinkedSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def staging_post_script(self):
        """
        The path to a user-provided powershell script or executable to run
        after restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def db_user(self):
        """
        The SQL Server login username for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The SQL Server login password for the source DB user.

        :rtype: :py:class:`v1_3_0.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def source_host_user(self):
        """
        OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def staging_pre_script(self):
        """
        The path to a user-provided powershell script or executable to run
        prior to restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def ppt_repository(self):
        """
        The SQL Server instance on the staging environment to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class WindowsHostCreateParameters(HostCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.HostCreateParameters` *)* The
    parameters used for the add Windows host operation.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHostCreateParameters, self).__init__()
        self._type = ("WindowsHostCreateParameters", True)
        self._connector_keystore = (self.__undef__, True)
        self._connector_certificate_password = (self.__undef__, True)
        self._connector_keystore_password = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._connector_keystore = (data.get("connectorKeystore", obj.__undef__), dirty)
        if obj._connector_keystore[0] is not None and obj._connector_keystore[0] is not obj.__undef__:
            assert isinstance(obj._connector_keystore[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_keystore[0]))
            common.validate_format(obj._connector_keystore[0], "None", None, None)
        obj._connector_certificate_password = (data.get("connectorCertificatePassword", obj.__undef__), dirty)
        if obj._connector_certificate_password[0] is not None and obj._connector_certificate_password[0] is not obj.__undef__:
            assert isinstance(obj._connector_certificate_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_certificate_password[0]))
            common.validate_format(obj._connector_certificate_password[0], "None", None, None)
        obj._connector_keystore_password = (data.get("connectorKeystorePassword", obj.__undef__), dirty)
        if obj._connector_keystore_password[0] is not None and obj._connector_keystore_password[0] is not obj.__undef__:
            assert isinstance(obj._connector_keystore_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_keystore_password[0]))
            common.validate_format(obj._connector_keystore_password[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connector_keystore" == "type" or (self.connector_keystore is not self.__undef__ and not (dirty and not self._connector_keystore[1])):
            dct["connectorKeystore"] = dictify(self.connector_keystore)
        if "connector_certificate_password" == "type" or (self.connector_certificate_password is not self.__undef__ and not (dirty and not self._connector_certificate_password[1])):
            dct["connectorCertificatePassword"] = dictify(self.connector_certificate_password)
        if "connector_keystore_password" == "type" or (self.connector_keystore_password is not self.__undef__ and not (dirty and not self._connector_keystore_password[1])):
            dct["connectorKeystorePassword"] = dictify(self.connector_keystore_password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connector_keystore = (self._connector_keystore[0], True)
        self._connector_certificate_password = (self._connector_certificate_password[0], True)
        self._connector_keystore_password = (self._connector_keystore_password[0], True)

    def is_dirty(self):
        return any([self._connector_keystore[1], self._connector_certificate_password[1], self._connector_keystore_password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHostCreateParameters):
            return False
        return super(WindowsHostCreateParameters, self).__eq__(other) and \
               self.connector_keystore == other.connector_keystore and \
               self.connector_certificate_password == other.connector_certificate_password and \
               self.connector_keystore_password == other.connector_keystore_password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connector_keystore(self):
        """
        Byte array of the Java Keystore data.

        :rtype: ``basestring``
        """
        return self._connector_keystore[0]

    @connector_keystore.setter
    def connector_keystore(self, value):
        self._connector_keystore = (value, True)

    @property
    def connector_certificate_password(self):
        """
        Password for the certificate in the Java Keystore.

        :rtype: ``basestring``
        """
        return self._connector_certificate_password[0]

    @connector_certificate_password.setter
    def connector_certificate_password(self, value):
        self._connector_certificate_password = (value, True)

    @property
    def connector_keystore_password(self):
        """
        Password for the Java Keystore data.

        :rtype: ``basestring``
        """
        return self._connector_keystore_password[0]

    @connector_keystore_password.setter
    def connector_keystore_password(self, value):
        self._connector_keystore_password = (value, True)

class UnixHostCreateParameters(HostCreateParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.HostCreateParameters` *)* The
    parameters used for the add Unix host operation.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHostCreateParameters, self).__init__()
        self._type = ("UnixHostCreateParameters", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHostCreateParameters):
            return False
        return super(UnixHostCreateParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLDBClusterConfigConnectivity(SourceConfigConnectivity):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SourceConfigConnectivity` *)* Mechanism
    to test JDBC connectivity to PostgreSQL DB clusters.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBClusterConfigConnectivity, self).__init__()
        self._type = ("PgSQLDBClusterConfigConnectivity", True)
        self._connection_database = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBClusterConfigConnectivity, cls).from_dict(data, dirty, undef_enabled)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBClusterConfigConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connection_database = (self._connection_database[0], True)

    def is_dirty(self):
        return any([self._connection_database[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBClusterConfigConnectivity):
            return False
        return super(PgSQLDBClusterConfigConnectivity, self).__eq__(other) and \
               self.connection_database == other.connection_database

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connection_database(self):
        """
        The database that must be used to run SQL queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

class ChecklistItemDetail(ChecklistItem):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ChecklistItem` *)* Fields to indicate
    detailed status for a specific checklist item.
    """
    def __init__(self, undef_enabled=True):
        super(ChecklistItemDetail, self).__init__()
        self._type = ("ChecklistItemDetail", True)
        self._status = (self.__undef__, True)
        self._message = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ChecklistItemDetail, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'SUCCESS', u'WARNING', u'ERROR'], "Expected enum [u'SUCCESS', u'WARNING', u'ERROR'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._message = (data.get("message", obj.__undef__), dirty)
        if obj._message[0] is not None and obj._message[0] is not obj.__undef__:
            assert isinstance(obj._message[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message[0]))
            common.validate_format(obj._message[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ChecklistItemDetail, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "message" == "type" or (self.message is not self.__undef__ and not (dirty and not self._message[1])):
            dct["message"] = dictify(self.message)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._message = (self._message[0], True)
        self._description = (self._description[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._status[1], self._message[1], self._description[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ChecklistItemDetail):
            return False
        return super(ChecklistItemDetail, self).__eq__(other) and \
               self.status == other.status and \
               self.message == other.message and \
               self.description == other.description and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Status of this item. *(permitted values: SUCCESS, WARNING, ERROR)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def message(self):
        """
        Status message, if applicable.

        :rtype: ``basestring``
        """
        return self._message[0]

    @message.setter
    def message(self, value):
        self._message = (value, True)

    @property
    def description(self):
        """
        Description of this status item.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def name(self):
        """
        The status item name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class XppLastRunStatus(ChecklistItem):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ChecklistItem` *)* Status of the last
    cross-platform provision of the container.
    """
    def __init__(self, undef_enabled=True):
        super(XppLastRunStatus, self).__init__()
        self._type = ("XppLastRunStatus", True)
        self._job = (self.__undef__, True)
        self._error_message = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppLastRunStatus, cls).from_dict(data, dirty, undef_enabled)
        if "job" in data and data["job"] is not None:
            obj._job = (factory.create_object(data["job"], "Job"), dirty)
            factory.validate_type(obj._job[0], "Job")
        else:
            obj._job = (obj.__undef__, dirty)
        obj._error_message = (data.get("errorMessage", obj.__undef__), dirty)
        if obj._error_message[0] is not None and obj._error_message[0] is not obj.__undef__:
            assert isinstance(obj._error_message[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._error_message[0]))
            common.validate_format(obj._error_message[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppLastRunStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "job" == "type" or (self.job is not self.__undef__ and not (dirty and not self._job[1])):
            dct["job"] = dictify(self.job)
        if "error_message" == "type" or (self.error_message is not self.__undef__ and not (dirty and not self._error_message[1])):
            dct["errorMessage"] = dictify(self.error_message)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._job = (self._job[0], True)
        self._error_message = (self._error_message[0], True)

    def is_dirty(self):
        return any([self._job[1], self._error_message[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppLastRunStatus):
            return False
        return super(XppLastRunStatus, self).__eq__(other) and \
               self.job == other.job and \
               self.error_message == other.error_message

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def job(self):
        """
        Last cross-platform provision job run on the container.

        :rtype: :py:class:`v1_3_0.web.vo.Job`
        """
        return self._job[0]

    @job.setter
    def job(self, value):
        self._job = (value, True)

    @property
    def error_message(self):
        """
        Error message associated with the last run, if any.

        :rtype: ``basestring``
        """
        return self._error_message[0]

    @error_message.setter
    def error_message(self, value):
        self._error_message = (value, True)

class XppValidateStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ChecklistItemDetail` *)* cross-platform
    provisioning validation status of the container.
    """
    def __init__(self, undef_enabled=True):
        super(XppValidateStatus, self).__init__()
        self._type = ("XppValidateStatus", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppValidateStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppValidateStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppValidateStatus):
            return False
        return super(XppValidateStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class XppStagingStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ChecklistItemDetail` *)* Status of the
    cross-platform provisioning staging environment.
    """
    def __init__(self, undef_enabled=True):
        super(XppStagingStatus, self).__init__()
        self._type = ("XppStagingStatus", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppStagingStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppStagingStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppStagingStatus):
            return False
        return super(XppStagingStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class XppTargetStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_3_0.web.vo.ChecklistItemDetail` *)* Status of the
    cross-platform provisioning target environment.
    """
    def __init__(self, undef_enabled=True):
        super(XppTargetStatus, self).__init__()
        self._type = ("XppTargetStatus", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppTargetStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppTargetStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppTargetStatus):
            return False
        return super(XppTargetStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SyncParameters` *)* The parameters to
    use as input to sync PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSyncParameters, self).__init__()
        self._type = ("PgSQLSyncParameters", True)
        self._redo_base_backup = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._redo_base_backup = (data.get("redoBaseBackup", obj.__undef__), dirty)
        if obj._redo_base_backup[0] is not None and obj._redo_base_backup[0] is not obj.__undef__:
            assert isinstance(obj._redo_base_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._redo_base_backup[0]))
            common.validate_format(obj._redo_base_backup[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "redo_base_backup" == "type" or (self.redo_base_backup is not self.__undef__ and not (dirty and not self._redo_base_backup[1])):
            dct["redoBaseBackup"] = dictify(self.redo_base_backup)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._redo_base_backup = (self._redo_base_backup[0], True)

    def is_dirty(self):
        return any([self._redo_base_backup[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSyncParameters):
            return False
        return super(PgSQLSyncParameters, self).__eq__(other) and \
               self.redo_base_backup == other.redo_base_backup

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def redo_base_backup(self):
        """
        Whether or not to take another full backup of the source database.

        :rtype: ``bool``
        """
        return self._redo_base_backup[0]

    @redo_base_backup.setter
    def redo_base_backup(self, value):
        self._redo_base_backup = (value, True)

class MSSqlSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.SyncParameters` *)* The parameters to
    use as input to sync MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSyncParameters, self).__init__()
        self._type = ("MSSqlSyncParameters", True)
        self._load_from_backup = (self.__undef__, True)
        self._backup_uuid = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._load_from_backup = (data.get("loadFromBackup", obj.__undef__), dirty)
        if obj._load_from_backup[0] is not None and obj._load_from_backup[0] is not obj.__undef__:
            assert isinstance(obj._load_from_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._load_from_backup[0]))
            common.validate_format(obj._load_from_backup[0], "None", None, None)
        obj._backup_uuid = (data.get("backupUUID", obj.__undef__), dirty)
        if obj._backup_uuid[0] is not None and obj._backup_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_uuid[0]))
            common.validate_format(obj._backup_uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "load_from_backup" == "type" or (self.load_from_backup is not self.__undef__ and not (dirty and not self._load_from_backup[1])):
            dct["loadFromBackup"] = dictify(self.load_from_backup)
        if "backup_uuid" == "type" or (self.backup_uuid is not self.__undef__ and not (dirty and not self._backup_uuid[1])):
            dct["backupUUID"] = dictify(self.backup_uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._load_from_backup = (self._load_from_backup[0], True)
        self._backup_uuid = (self._backup_uuid[0], True)

    def is_dirty(self):
        return any([self._load_from_backup[1], self._backup_uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSyncParameters):
            return False
        return super(MSSqlSyncParameters, self).__eq__(other) and \
               self.load_from_backup == other.load_from_backup and \
               self.backup_uuid == other.backup_uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def load_from_backup(self):
        """
        When set, this parameter overrides the loadFromBackup property in the
        container's sourcing policy. When set to true, Delphix will restore
        from an already existing database backup. If the backupUUID is set,
        that specific backup will be restored. Otherwise the most recent full
        or differential database backup will be restored. When set to false,
        Delphix will take a copy-only full backup and restore from that.

        :rtype: ``bool``
        """
        return self._load_from_backup[0]

    @load_from_backup.setter
    def load_from_backup(self, value):
        self._load_from_backup = (value, True)

    @property
    def backup_uuid(self):
        """
        The UUID of the full or differential backup of the source database to
        restore from. The backup should be present in the shared backup
        location for the source database. This property is relevant only if
        when loading from an existing backup.

        :rtype: ``basestring``
        """
        return self._backup_uuid[0]

    @backup_uuid.setter
    def backup_uuid(self, value):
        self._backup_uuid = (value, True)

class OracleRefreshParameters(RefreshParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.RefreshParameters` *)* The parameters
    to use as input to refresh Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRefreshParameters, self).__init__()
        self._type = ("OracleRefreshParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRefreshParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRefreshParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRefreshParameters):
            return False
        return super(OracleRefreshParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the refresh operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the refresh
        operation as.

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class DynamicEnumParameter(DynamicParameter):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DynamicParameter` *)* A dynamic
    parameter definition for enum values.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicEnumParameter, self).__init__()
        self._type = ("DynamicEnumParameter", True)
        self._enum_values = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicEnumParameter, cls).from_dict(data, dirty, undef_enabled)
        if "enumValues" not in data:
            raise ValueError("Missing required property \"enumValues\".")
        obj._enum_values = []
        for item in data.get("enumValues") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._enum_values.append(item)
        obj._enum_values = (obj._enum_values, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicEnumParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enum_values" == "type" or (self.enum_values is not self.__undef__ and not (dirty and not self._enum_values[1])):
            dct["enumValues"] = dictify(self.enum_values)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enum_values = (self._enum_values[0], True)

    def is_dirty(self):
        return any([self._enum_values[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicEnumParameter):
            return False
        return super(DynamicEnumParameter, self).__eq__(other) and \
               self.enum_values == other.enum_values

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enum_values(self):
        """
        Set of valid inputs for argument.

        :rtype: ``list`` of ``basestring``
        """
        return self._enum_values[0]

    @enum_values.setter
    def enum_values(self, value):
        self._enum_values = (value, True)

class DynamicStringParameter(DynamicParameter):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DynamicParameter` *)* A dynamic
    parameter definition for password values.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicStringParameter, self).__init__()
        self._type = ("DynamicStringParameter", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicStringParameter, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicStringParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicStringParameter):
            return False
        return super(DynamicStringParameter, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DynamicBooleanParameter(DynamicParameter):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DynamicParameter` *)* A dynamic
    parameter definition for boolean values.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicBooleanParameter, self).__init__()
        self._type = ("DynamicBooleanParameter", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicBooleanParameter, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicBooleanParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicBooleanParameter):
            return False
        return super(DynamicBooleanParameter, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DynamicIntegerParameter(DynamicParameter):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DynamicParameter` *)* A dynamic
    parameter definition for integer values.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicIntegerParameter, self).__init__()
        self._type = ("DynamicIntegerParameter", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicIntegerParameter, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicIntegerParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicIntegerParameter):
            return False
        return super(DynamicIntegerParameter, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class DynamicPasswordParameter(DynamicParameter):
    """
    *(extends* :py:class:`v1_3_0.web.vo.DynamicParameter` *)* A dynamic
    parameter definition for password values.
    """
    def __init__(self, undef_enabled=True):
        super(DynamicPasswordParameter, self).__init__()
        self._type = ("DynamicPasswordParameter", True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DynamicPasswordParameter, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DynamicPasswordParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DynamicPasswordParameter):
            return False
        return super(DynamicPasswordParameter, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class TimeflowRepairSSH(TimeflowRepairParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowRepairParameters` *)*
    Parameters to repair log files within a timeflow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRepairSSH, self).__init__()
        self._type = ("TimeflowRepairSSH", True)
        self._directory = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._username = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRepairSSH, cls).from_dict(data, dirty, undef_enabled)
        if "directory" not in data:
            raise ValueError("Missing required property \"directory\".")
        obj._directory = (data.get("directory", obj.__undef__), dirty)
        if obj._directory[0] is not None and obj._directory[0] is not obj.__undef__:
            assert isinstance(obj._directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._directory[0]))
            common.validate_format(obj._directory[0], "None", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRepairSSH, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "directory" == "type" or (self.directory is not self.__undef__ and not (dirty and not self._directory[1])):
            dct["directory"] = dictify(self.directory)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._directory = (self._directory[0], True)
        self._credentials = (self._credentials[0], True)
        self._host = (self._host[0], True)
        self._username = (self._username[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._directory[1], self._credentials[1], self._host[1], self._username[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRepairSSH):
            return False
        return super(TimeflowRepairSSH, self).__eq__(other) and \
               self.directory == other.directory and \
               self.credentials == other.credentials and \
               self.host == other.host and \
               self.username == other.username and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def directory(self):
        """
        Directory on the remote server where the missing log files reside.

        :rtype: ``basestring``
        """
        return self._directory[0]

    @directory.setter
    def directory(self, value):
        self._directory = (value, True)

    @property
    def credentials(self):
        """
        User credentials. If not provided will use environment credentials for
        'username' on 'host'

        :rtype: :py:class:`v1_3_0.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def host(self):
        """
        Remote host to connect to.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def username(self):
        """
        User name to authenticate as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def port(self):
        """
        *(default value: 22)* SSH port to connect to

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class TimeflowPointBookmarkTag(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPointParameters` *)* Timeflow
    point based on a timeflow bookmark tag.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointBookmarkTag, self).__init__()
        self._type = ("TimeflowPointBookmarkTag", True)
        self._tag = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointBookmarkTag, cls).from_dict(data, dirty, undef_enabled)
        if "tag" not in data:
            raise ValueError("Missing required property \"tag\".")
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, None)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointBookmarkTag, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._tag = (self._tag[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._tag[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointBookmarkTag):
            return False
        return super(TimeflowPointBookmarkTag, self).__eq__(other) and \
               self.tag == other.tag and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def tag(self):
        """
        The name of the tag.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class TimeflowPointTimestamp(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPointParameters` *)* Timeflow
    point based on a timestamp.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointTimestamp, self).__init__()
        self._type = ("TimeflowPointTimestamp", True)
        self._timestamp = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointTimestamp, cls).from_dict(data, dirty, undef_enabled)
        if "timestamp" not in data:
            raise ValueError("Missing required property \"timestamp\".")
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointTimestamp, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointTimestamp):
            return False
        return super(TimeflowPointTimestamp, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the timeflow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def timeflow(self):
        """
        Reference to timeflow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class TimeflowPointLocation(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPointParameters` *)* Timeflow
    point based on a database-specific identifier (SCN, LSN, etc).
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointLocation, self).__init__()
        self._type = ("TimeflowPointLocation", True)
        self._timeflow = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointLocation, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        if "location" not in data:
            raise ValueError("Missing required property \"location\".")
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointLocation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._timeflow[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointLocation):
            return False
        return super(TimeflowPointLocation, self).__eq__(other) and \
               self.timeflow == other.timeflow and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to timeflow containing this location.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def location(self):
        """
        The timeflow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

class TimeflowPointBookmark(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPointParameters` *)* Timeflow
    point based on a timeflow bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointBookmark, self).__init__()
        self._type = ("TimeflowPointBookmark", True)
        self._bookmark = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointBookmark, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" not in data:
            raise ValueError("Missing required property \"bookmark\".")
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)

    def is_dirty(self):
        return any([self._bookmark[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointBookmark):
            return False
        return super(TimeflowPointBookmark, self).__eq__(other) and \
               self.bookmark == other.bookmark

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        Reference to the bookmark.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

class TimeflowPointSemantic(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_3_0.web.vo.TimeflowPointParameters` *)* Timeflow
    point based on a semantic reference.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointSemantic, self).__init__()
        self._type = ("TimeflowPointSemantic", True)
        self._container = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.3.0"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointSemantic, cls).from_dict(data, dirty, undef_enabled)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            assert obj._location[0] in [u'LATEST_POINT', u'LATEST_SNAPSHOT'], "Expected enum [u'LATEST_POINT', u'LATEST_SNAPSHOT'] but got %s" % obj._location[0]
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointSemantic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._container[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointSemantic):
            return False
        return super(TimeflowPointSemantic, self).__eq__(other) and \
               self.container == other.container and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def location(self):
        """
        *(default value: LATEST_POINT)* A semantic description of a timeflow
        location. *(permitted values: LATEST_POINT, LATEST_SNAPSHOT)*

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

