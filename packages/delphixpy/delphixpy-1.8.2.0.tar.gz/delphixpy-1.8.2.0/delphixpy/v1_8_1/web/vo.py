#
# Copyright 2017 by Delphix
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# This class has been automatically generated from:
#     /delphix-json.json
#     /delphix-typed-object.json
#     /delphix-schema-draft-v4.json
#     /delphix-ase-backup-location.json
#     /delphix-js-data-source-create-parameters.json
#     /delphix-storage-initialization-parameters.json
#     /delphix-detach-source-parameters.json
#     /delphix-js-data-container-active-branch-parameters.json
#     /delphix-timeflow-repair-parameters.json
#     /delphix-analytics-statistic.json
#     /delphix-host-runtime.json
#     /delphix-oracle-character-set.json
#     /delphix-storage-test-result.json
#     /delphix-oracle-timeflow-log.json
#     /delphix-mssql-base-cluster-instance.json
#     /delphix-host-machine.json
#     /delphix-js-operation-endpoint-parameters.json
#     /delphix-proxy-service.json
#     /delphix-add-live-source-parameters.json
#     /delphix-api-error.json
#     /delphix-oracle-cluster-node-create-parameters.json
#     /delphix-oracle-file-specification.json
#     /delphix-interface-address.json
#     /delphix-appdata-additional-mount-point.json
#     /delphix-refresh-parameters.json
#     /delphix-apply-version-parameters.json
#     /delphix-timeflow-point-parameters.json
#     /delphix-network-route.json
#     /delphix-sync-parameters.json
#     /delphix-source-environment-create-parameters.json
#     /delphix-proxy-configuration.json
#     /delphix-checklist-item.json
#     /delphix-snapshotspaceparameters.json
#     /delphix-connectivity-sourceconfig.json
#     /delphix-js-user-usage-data.json
#     /delphix-oracle-database-stats-section.json
#     /delphix-base-platform-parameters.json
#     /delphix-host-create-parameters.json
#     /delphix-network-test-parameters.json
#     /delphix-fraction-plug-parameters.json
#     /delphix-source-runtime.json
#     /delphix-registration-parameters.json
#     /delphix-js-branch-create-parameters.json
#     /delphix-timeflow-range-parameters.json
#     /delphix-preprovisioning-runtime.json
#     /delphix-create-masking-job-transformation-parameters.json
#     /delphix-ase-host-environment-parameters.json
#     /delphix-time-range-parameters.json
#     /delphix-js-data-container-delete-parameters.json
#     /delphix-host-os.json
#     /delphix-storage-device-removal-verify-result.json
#     /delphix-analytics-datapoint.json
#     /delphix-snmp-config.json
#     /delphix-filesystem-layout.json
#     /delphix-smtp-config.json
#     /delphix-js-branch-usage-data.json
#     /delphix-sourcing-policy.json
#     /delphix-database-template-config.json
#     /delphix-supportaccessstate.json
#     /delphix-compatible-repositories-parameters.json
#     /delphix-purge-logs-parameters.json
#     /delphix-snapshot-space-result.json
#     /delphix-create-transformation-parameters.json
#     /delphix-mysql-replication-coordinates.json
#     /delphix-oracle-active-instance.json
#     /delphix-auth-filter-parameters.json
#     /delphix-syslog-config.json
#     /delphix-analytics-axis-constraint.json
#     /delphix-schedule.json
#     /delphix-saml-info.json
#     /delphix-checklist.json
#     /delphix-network-route-lookup-parameters.json
#     /delphix-compatible-repositories-result.json
#     /delphix-file-mapping-parameters.json
#     /delphix-mssql-failover-cluster-drive-letter.json
#     /delphix-notification.json
#     /delphix-snapshot-runtime.json
#     /delphix-js-bookmark-usage-data.json
#     /delphix-file-processing-result.json
#     /delphix-version.json
#     /delphix-log-fetch-ssh.json
#     /delphix-delete-parameters.json
#     /delphix-attach-data.json
#     /delphix-about.json
#     /delphix-global-linking-settings.json
#     /delphix-dsp-options.json
#     /delphix-host-configuration.json
#     /delphix-certificate-fetch-parameters.json
#     /delphix-js-bookmark-tag-usage-data.json
#     /delphix-system-initialization-parameters.json
#     /delphix-oracle-database-statistic.json
#     /delphix-credential.json
#     /delphix-js-source-data-timestamp-parameters.json
#     /delphix-js-timeline-point-parameters.json
#     /delphix-user-auth-info.json
#     /delphix-toolkit-locale.json
#     /delphix-connectivity-ssh.json
#     /delphix-job-event.json
#     /delphix-linked-source-operations.json
#     /delphix-js-data-container-modify-owner-parameters.json
#     /delphix-call-result.json
#     /delphix-oracle-export.json
#     /delphix-fault-resolve-parameters.json
#     /delphix-capacity-aggregate-data.json
#     /delphix-ase-instance-config.json
#     /delphix-persistent-object.json
#     /delphix-oracle-instance.json
#     /delphix-pgsql-hba-entry.json
#     /delphix-ldap-info.json
#     /delphix-compatibility-criteria.json
#     /delphix-appdata-cached-mount-point.json
#     /delphix-capacity-snapshot-data.json
#     /delphix-js-data-layout-create-parameters.json
#     /delphix-analytics-statistic-axis.json
#     /delphix-js-bookmark-create-parameters.json
#     /delphix-storage-test-parameters.json
#     /delphix-virtual-source-operations.json
#     /delphix-scrub-status.json
#     /delphix-capacity-breakdown.json
#     /delphix-source-disable-parameters.json
#     /delphix-timeflow-range.json
#     /delphix-operation.json
#     /delphix-js-container-usage-data.json
#     /delphix-policy-create-and-apply-parameters.json
#     /delphix-source-connection-info.json
#     /delphix-source-start-parameters.json
#     /delphix-registration-info.json
#     /delphix-link-data.json
#     /delphix-pgsql-ident-entry.json
#     /delphix-syslog-server.json
#     /delphix-timeflow-bookmark-create-parameters.json
#     /delphix-loginrequest.json
#     /delphix-ntp-config.json
#     /delphix-replication-spec-runtime.json
#     /delphix-oracle-service.json
#     /delphix-host-privilege-elevation-settings.json
#     /delphix-oracle-virtual-ip.json
#     /delphix-registration-status.json
#     /delphix-version-info.json
#     /delphix-attach-source-parameters.json
#     /delphix-security-config.json
#     /delphix-oracle-log.json
#     /delphix-cpu-info.json
#     /delphix-phone-home-service.json
#     /delphix-export-parameters.json
#     /delphix-capacity-base-consumer-data.json
#     /delphix-traceroute-info.json
#     /delphix-workflow-function-definition.json
#     /delphix-js-source-data-timestamp.json
#     /delphix-support-bundle-upload-parameters.json
#     /delphix-schema.json
#     /delphix-oracle-custom-env-var.json
#     /delphix-js-template-usage-data.json
#     /delphix-db-container-runtime.json
#     /delphix-analytics-datapoint-set.json
#     /delphix-mssql-base-cluster-listener.json
#     /delphix-auth-filter-result.json
#     /delphix-virtual-dataset-creation-parameters.json
#     /delphix-network-throughput-test-engine-login.json
#     /delphix-diagnosis-result.json
#     /delphix-analytics-datapoint-stream.json
#     /delphix-session.json
#     /delphix-connectivity-connector.json
#     /delphix-source-stop-parameters.json
#     /delphix-pgsql-db-config.json
#     /delphix-validate-smtp-parameters.json
#     /delphix-purge-logs-result.json
#     /delphix-time-config.json
#     /delphix-saml-auth-parameters.json
#     /delphix-dns-config.json
#     /delphix-link-parameters.json
#     /delphix-storage-device-removal-status.json
#     /delphix-source-upgrade-parameters.json
#     /delphix-timeflow-point.json
#     /delphix-mysql-version.json
#     /delphix-timezone.json
#     /delphix-credential-update-parameters.json
#     /delphix-switch-timeflow-parameters.json
#     /delphix-toolkit-virtual-source.json
#     /delphix-policy-apply-target-parameters.json
#     /delphix-js-data-parent.json
#     /delphix-js-data-child.json
#     /delphix-file-mapping-result.json
#     /delphix-alert-filter.json
#     /delphix-js-data-container-undo-parameters.json
#     /delphix-toolkit-linked-source.json
#     /delphix-js-operation-endpoint.json
#     /delphix-namespace-failover-parameters.json
#     /delphix-source-enable-parameters.json
#     /delphix-alert-action.json
#     /delphix-toolkit-discovery-definition.json
#     /delphix-rollback-parameters.json
#     /delphix-connectivity-jdbc.json
#     /delphix-oracle-rollback-parameters.json
#     /delphix-alert-action-email.json
#     /delphix-alert-action-email-list.json
#     /delphix-alert-action-email-user.json
#     /delphix-oracle-enable-parameters.json
#     /delphix-toolkit-linked-staged-source.json
#     /delphix-toolkit-linked-direct-source.json
#     /delphix-alert-and-filter.json
#     /delphix-alert-severity-filter.json
#     /delphix-alert-not-filter.json
#     /delphix-alert-target-filter.json
#     /delphix-alert-owner-filter.json
#     /delphix-alert-event-filter.json
#     /delphix-alert-or-filter.json
#     /delphix-js-timestamp-data-parent.json
#     /delphix-js-bookmark-data-parent.json
#     /delphix-mssql-timeflow-point.json
#     /delphix-oracle-timeflow-point.json
#     /delphix-pgsql-timeflow-point.json
#     /delphix-appdata-timeflow-point.json
#     /delphix-ase-timeflow-point.json
#     /delphix-mysql-timeflow-point.json
#     /delphix-mssql-linked-source-upgrade-parameters.json
#     /delphix-oracle-stop-parameters.json
#     /delphix-analytics-network-interface-util-datapoint-stream.json
#     /delphix-analytics-vfs-ops-datapoint-stream.json
#     /delphix-analytics-dxfs-ops-datapoint-stream.json
#     /delphix-analytics-iscsi-ops-datapoint-stream.json
#     /delphix-analytics-cpu-util-datapoint-stream.json
#     /delphix-analytics-tcp-stats-datapoint-stream.json
#     /delphix-analytics-disk-ops-datapoint-stream.json
#     /delphix-analytics-nfs-ops-datapoint-stream.json
#     /delphix-analytics-dxfs-io-queue-ops-datapoint-stream.json
#     /delphix-empty-dataset-creation-parameters.json
#     /delphix-provision-parameters.json
#     /delphix-restoration-dataset-parameters.json
#     /delphix-appdata-restoration-dataset-creation-parameters.json
#     /delphix-appdata-provision-parameters.json
#     /delphix-pgsql-provision-parameters.json
#     /delphix-mysql-provision-parameters.json
#     /delphix-ase-provision-parameters.json
#     /delphix-oracle-provision-parameters.json
#     /delphix-mssql-provision-parameters.json
#     /delphix-oracle-database-creation-parameters.json
#     /delphix-appdata-empty-vfiles-creation-parameters.json
#     /delphix-mssql-failover-cluster-listener.json
#     /delphix-mssql-availability-group-listener.json
#     /delphix-pgsql-db-container-runtime.json
#     /delphix-ase-db-container-runtime.json
#     /delphix-appdata-container-runtime.json
#     /delphix-mssql-db-container-runtime.json
#     /delphix-mysql-db-container-runtime.json
#     /delphix-oracle-db-container-runtime.json
#     /delphix-oracle-custom-env-var-file.json
#     /delphix-oracle-custom-env-var-pair.json
#     /delphix-oracle-custom-env-var-si-pair.json
#     /delphix-oracle-custom-env-var-rac-pair.json
#     /delphix-oracle-custom-env-var-si-file.json
#     /delphix-oracle-custom-env-var-rac-file.json
#     /delphix-capacity-historical-consumer-data.json
#     /delphix-capacity-current-consumer-data.json
#     /delphix-appdata-export-parameters.json
#     /delphix-db-export-parameters.json
#     /delphix-mssql-export-parameters.json
#     /delphix-oracle-export-parameters.json
#     /delphix-mysql-export-parameters.json
#     /delphix-pgsql-export-parameters.json
#     /delphix-ase-export-parameters.json
#     /delphix-mssql-link-data.json
#     /delphix-pgsql-link-data.json
#     /delphix-ase-link-data.json
#     /delphix-oracle-base-link-data.json
#     /delphix-mysql-link-data.json
#     /delphix-appdata-link-data.json
#     /delphix-appdata-direct-link-data.json
#     /delphix-appdata-staged-link-data.json
#     /delphix-oracle-link-data.json
#     /delphix-oracle-pdb-link-data.json
#     /delphix-oracle-start-parameters.json
#     /delphix-mssql-source-connection-info.json
#     /delphix-mysql-source-connection-info.json
#     /delphix-appdata-source-connection-info.json
#     /delphix-pgsql-source-connection-info.json
#     /delphix-oracle-source-connection-info.json
#     /delphix-ase-source-connection-info.json
#     /delphix-oracle-si-source-connection-info.json
#     /delphix-oracle-rac-source-connection-info.json
#     /delphix-source-operation.json
#     /delphix-run-masking-job-operation.json
#     /delphix-run-command-on-source-operation.json
#     /delphix-run-expect-on-source-operation.json
#     /delphix-run-bash-on-source-operation.json
#     /delphix-run-powershell-on-source-operation.json
#     /delphix-oracle-disable-parameters.json
#     /delphix-analytics-statistic-enum-axis.json
#     /delphix-js-data-container-create-parameters.json
#     /delphix-js-data-template-create-parameters.json
#     /delphix-pgsql-compatibility-criteria.json
#     /delphix-ase-compatibility-criteria.json
#     /delphix-mysql-compatibility-criteria.json
#     /delphix-mssql-compatibility-criteria.json
#     /delphix-oracle-compatibility-criteria.json
#     /delphix-oracle-rac-instance.json
#     /delphix-action.json
#     /delphix-alert.json
#     /delphix-user-object.json
#     /delphix-fault.json
#     /delphix-js-bookmark-checkout-count.json
#     /delphix-snmp-manager.json
#     /delphix-js-usage-data.json
#     /delphix-host-privilege-elevation-profile-script.json
#     /delphix-host-privilege-elevation-profile.json
#     /delphix-alert-profile.json
#     /delphix-fault-effect.json
#     /delphix-js-weekly-operation-count.json
#     /delphix-js-daily-operation-duration.json
#     /delphix-replication-source-state.json
#     /delphix-network-interface.json
#     /delphix-replication-object-specification.json
#     /delphix-policy.json
#     /delphix-x509certificate.json
#     /delphix-named-user-object.json
#     /delphix-replicationspec.json
#     /delphix-transformation.json
#     /delphix-masking-job.json
#     /delphix-role.json
#     /delphix-source.json
#     /delphix-locale-settings.json
#     /delphix-readonly-named-user-object.json
#     /delphix-masking-service-config.json
#     /delphix-source-environment.json
#     /delphix-serialization-point.json
#     /delphix-replication-target-state.json
#     /delphix-windows-cluster.json
#     /delphix-oracle-cluster.json
#     /delphix-host-environment.json
#     /delphix-windows-host-environment.json
#     /delphix-unix-host-environment.json
#     /delphix-domain.json
#     /delphix-permission.json
#     /delphix-source-config.json
#     /delphix-ldap-server.json
#     /delphix-storage-test.json
#     /delphix-host.json
#     /delphix-authorization.json
#     /delphix-source-repository.json
#     /delphix-saml-service-provider.json
#     /delphix-timeflow-snapshot.json
#     /delphix-network-test.json
#     /delphix-network-throughput-test-base.json
#     /delphix-network-latency-test.json
#     /delphix-network-throughput-test.json
#     /delphix-network-dsp-test.json
#     /delphix-pgsql-snapshot.json
#     /delphix-appdata-snapshot.json
#     /delphix-mssql-snapshot.json
#     /delphix-mysql-snapshot.json
#     /delphix-oracle-snapshot.json
#     /delphix-ase-snapshot.json
#     /delphix-mssql-repository.json
#     /delphix-appdata-source-repository.json
#     /delphix-pgsql-install.json
#     /delphix-oracle-install.json
#     /delphix-mysql-install.json
#     /delphix-ase-instance.json
#     /delphix-mssql-instance.json
#     /delphix-mssql-base-cluster-repository.json
#     /delphix-mssql-failover-cluster-repository.json
#     /delphix-mssql-availability-group.json
#     /delphix-unix-host.json
#     /delphix-windows-host.json
#     /delphix-ase-db-config.json
#     /delphix-pgsql-db-cluster-config.json
#     /delphix-oracle-base-db-config.json
#     /delphix-mysql-server-config.json
#     /delphix-appdata-source-config.json
#     /delphix-mssql-db-config.json
#     /delphix-mssql-si-config.json
#     /delphix-mssql-failover-cluster-db-config.json
#     /delphix-mssql-availability-group-db-config.json
#     /delphix-appdata-staged-source-config.json
#     /delphix-appdata-direct-source-config.json
#     /delphix-oracle-pdb-config.json
#     /delphix-oracle-db-config.json
#     /delphix-oracle-si-config.json
#     /delphix-oracle-rac-config.json
#     /delphix-ase-si-config.json
#     /delphix-pgsql-source.json
#     /delphix-oracle-source.json
#     /delphix-mssql-source.json
#     /delphix-ase-source.json
#     /delphix-mysql-source.json
#     /delphix-appdata-source.json
#     /delphix-appdata-linked-source.json
#     /delphix-appdata-managed-source.json
#     /delphix-appdata-restoration-source.json
#     /delphix-appdata-virtual-source.json
#     /delphix-appdata-linked-direct-source.json
#     /delphix-appdata-linked-staged-source.json
#     /delphix-mysql-virtual-source.json
#     /delphix-mysql-linked-source.json
#     /delphix-mysql-staging-source.json
#     /delphix-ase-virtual-source.json
#     /delphix-ase-linked-source.json
#     /delphix-ase-staging-source.json
#     /delphix-mssql-virtual-source.json
#     /delphix-mssql-linked-source.json
#     /delphix-mssql-staging-source.json
#     /delphix-oracle-virtual-source.json
#     /delphix-oracle-linked-source.json
#     /delphix-oracle-live-source.json
#     /delphix-oracle-warehouse-source.json
#     /delphix-pgsql-staging-source.json
#     /delphix-pgsql-virtual-source.json
#     /delphix-pgsql-linked-source.json
#     /delphix-js-data-layout.json
#     /delphix-toolkit.json
#     /delphix-source-repository-template.json
#     /delphix-user.json
#     /delphix-namespace.json
#     /delphix-operation-template.json
#     /delphix-js-bookmark.json
#     /delphix-source-environment-user.json
#     /delphix-job.json
#     /delphix-windows-cluster-node.json
#     /delphix-upgrade-version.json
#     /delphix-container.json
#     /delphix-js-branch.json
#     /delphix-database-template.json
#     /delphix-analytics-statistic-slice.json
#     /delphix-storage-device.json
#     /delphix-js-operation.json
#     /delphix-group.json
#     /delphix-js-data-source.json
#     /delphix-timeflow.json
#     /delphix-timeflow-bookmark.json
#     /delphix-oracle-listener.json
#     /delphix-oracle-cluster-node.json
#     /delphix-oracle-scan-listener.json
#     /delphix-oracle-node-listener.json
#     /delphix-pgsql-timeflow.json
#     /delphix-ase-timeflow.json
#     /delphix-appdata-base-timeflow.json
#     /delphix-mysql-timeflow.json
#     /delphix-oracle-timeflow.json
#     /delphix-mssql-timeflow.json
#     /delphix-appdata-timeflow.json
#     /delphix-appdata-windows-timeflow.json
#     /delphix-configured-storage-device.json
#     /delphix-db-container.json
#     /delphix-mssql-db-container.json
#     /delphix-mysql-db-container.json
#     /delphix-pgsql-db-container.json
#     /delphix-oracle-db-container.json
#     /delphix-appdata-container.json
#     /delphix-ase-db-container.json
#     /delphix-js-data-container.json
#     /delphix-js-data-template.json
#     /delphix-schedule-policy.json
#     /delphix-quota-policy.json
#     /delphix-retention-policy.json
#     /delphix-refresh-policy.json
#     /delphix-sync-policy.json
#     /delphix-snapshot-policy.json
#     /delphix-replication-list.json
#     /delphix-replication-secure-list.json
#     /delphix-capacity-base-group-data.json
#     /delphix-capacity-base-system-data.json
#     /delphix-capacity-historical-system-data.json
#     /delphix-capacity-current-system-data.json
#     /delphix-capacity-current-group-data.json
#     /delphix-capacity-historical-group-data.json
#     /delphix-ok-result.json
#     /delphix-error-result.json
#     /delphix-data-result.json
#     /delphix-list-result.json
#     /delphix-js-timeline-point-bookmark-input.json
#     /delphix-js-timeline-point-time-parameters.json
#     /delphix-js-timeline-point-latest-time-input.json
#     /delphix-js-timeline-point-time-input.json
#     /delphix-publickey-credential.json
#     /delphix-password-credential.json
#     /delphix-systemkey-credential.json
#     /delphix-keypair-credential.json
#     /delphix-control-node-initialization-parameters.json
#     /delphix-data-node-initialization-parameters.json
#     /delphix-system.json
#     /delphix-ase-attach-data.json
#     /delphix-mysql-attach-data.json
#     /delphix-mssql-attach-data.json
#     /delphix-oracle-attach-data.json
#     /delphix-pgsql-attach-data.json
#     /delphix-oracle-delete-parameters.json
#     /delphix-snapshot-log-fetch-parameters.json
#     /delphix-timeflow-log-fetch-parameters.json
#     /delphix-file-upload-result.json
#     /delphix-file-download-result.json
#     /delphix-mysql-snapshot-runtime.json
#     /delphix-ase-snapshot-runtime.json
#     /delphix-mssql-snapshot-runtime.json
#     /delphix-oracle-snapshot-runtime.json
#     /delphix-appdata-snapshot-runtime.json
#     /delphix-notification-drop.json
#     /delphix-singleton-update.json
#     /delphix-object-notification.json
#     /delphix-xpp-status.json
#     /delphix-analytics-integer-constraint.json
#     /delphix-analytics-boolean-constraint.json
#     /delphix-analytics-path-constraint.json
#     /delphix-analytics-enum-constraint.json
#     /delphix-analytics-string-constraint.json
#     /delphix-analytics-null-constraint.json
#     /delphix-analytics-string-equal-constraint.json
#     /delphix-analytics-enum-equal-constraint.json
#     /delphix-analytics-path-descendant-constraint.json
#     /delphix-analytics-boolean-equal-constraint.json
#     /delphix-analytics-integer-less-than-constraint.json
#     /delphix-analytics-integer-greater-than-constraint.json
#     /delphix-analytics-integer-equal-constraint.json
#     /delphix-mysql-gtid-coordinates.json
#     /delphix-mysql-binlog-coordinates.json
#     /delphix-ase-create-transformation-parameters.json
#     /delphix-mssql-create-transformation-parameters.json
#     /delphix-mysql-create-transformation-parameters.json
#     /delphix-oracle-create-transformation-parameters.json
#     /delphix-appdata-create-transformation-parameters.json
#     /delphix-pgsql-create-transformation-parameters.json
#     /delphix-vmware-create-transformation-parameters.json
#     /delphix-populate-compatibility-parameters.json
#     /delphix-xpp-compatibility-parameters.json
#     /delphix-migrate-compatibility-parameters.json
#     /delphix-staging-compatibility-parameters.json
#     /delphix-provision-compatibility-parameters.json
#     /delphix-upgrade-compatibility-parameters.json
#     /delphix-oracle-sourcing-policy.json
#     /delphix-appdata-filesystem-layout.json
#     /delphix-timeflow-filesystem-layout.json
#     /delphix-analytics-io-ops-datapoint.json
#     /delphix-analytics-cpu-util-datapoint.json
#     /delphix-analytics-network-interface-util-datapoint.json
#     /delphix-analytics-tcp-stats-datapoint.json
#     /delphix-mssql-source-runtime.json
#     /delphix-oracle-base-source-runtime.json
#     /delphix-appdata-source-runtime.json
#     /delphix-ase-source-runtime.json
#     /delphix-pgsql-source-runtime.json
#     /delphix-mysql-source-runtime.json
#     /delphix-oracle-source-runtime.json
#     /delphix-oracle-pdb-source-runtime.json
#     /delphix-oracle-live-source-runtime.json
#     /delphix-network-throughput-test-base-parameters.json
#     /delphix-network-latency-test-parameters.json
#     /delphix-network-throughput-test-parameters.json
#     /delphix-network-dsp-test-parameters.json
#     /delphix-windows-host-create-parameters.json
#     /delphix-unix-host-create-parameters.json
#     /delphix-ase-platform-parameters.json
#     /delphix-mysql-platform-parameters.json
#     /delphix-mssql-platform-parameters.json
#     /delphix-oracle-platform-parameters.json
#     /delphix-vmware-platform-parameters.json
#     /delphix-appdata-platform-parameters.json
#     /delphix-pgsql-platform-parameters.json
#     /delphix-connectivity-pgsql-db-cluster-config.json
#     /delphix-checklist-item-detail.json
#     /delphix-xpp-last-run-status.json
#     /delphix-xpp-validate-status.json
#     /delphix-xpp-staging-status.json
#     /delphix-xpp-target-status.json
#     /delphix-oracle-cluster-create-parameters.json
#     /delphix-host-environment-create-parameters.json
#     /delphix-windows-cluster-create-parameters.json
#     /delphix-pgsql-sync-parameters.json
#     /delphix-appdata-sync-parameters.json
#     /delphix-ase-sync-parameters.json
#     /delphix-mssql-sync-parameters.json
#     /delphix-oracle-sync-parameters.json
#     /delphix-mysql-sync-parameters.json
#     /delphix-mysql-existing-backup-sync-parameters.json
#     /delphix-mysql-new-mysqldump-sync-parameters.json
#     /delphix-mysql-existing-mysqldump-sync-parameters.json
#     /delphix-mysql-xtrabackup-sync-parameters.json
#     /delphix-ase-new-backup-sync-parameters.json
#     /delphix-ase-latest-backup-sync-parameters.json
#     /delphix-ase-specific-backup-sync-parameters.json
#     /delphix-timeflow-point-snapshot.json
#     /delphix-timeflow-point-bookmark-tag.json
#     /delphix-timeflow-point-timestamp.json
#     /delphix-timeflow-point-bookmark.json
#     /delphix-timeflow-point-location.json
#     /delphix-timeflow-point-semantic.json
#     /delphix-oracle-refresh-parameters.json
#     /delphix-oracle-datafile-tempfile-specification.json
#     /delphix-oracle-redo-log-file-specification.json
#     /delphix-oracle-tempfile-specification.json
#     /delphix-oracle-system-datafile-specification.json
#     /delphix-oracle-sysaux-datafile-specification.json
#     /delphix-oracle-undo-datafile-specification.json
#     /delphix-oracle-add-live-source-parameters.json
#     /delphix-js-operation-endpoint-branch-parameters.json
#     /delphix-js-operation-endpoint-data-layout-parameters.json
#     /delphix-mssql-failover-cluster-instance.json
#     /delphix-mssql-cluster-instance.json
#     /delphix-oracle-fetched-log.json
#     /delphix-oracle-missing-log.json
#     /delphix-timeflow-repair-ssh.json
#
# Do not edit this file manually!
#
from delphixpy.v1_8_1 import factory
from delphixpy.v1_8_1 import common

class __Undef(object):
    def __repr__(self):
        return "undef"

_UNDEFINED = __Undef()

class Json(object):
    """
    A dummy schema that is used to represent JSON.
    """
    def __init__(self, undef_enabled=True):
        self.__undef__ = _UNDEFINED if undef_enabled else None
        self._type = ("Json", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = cls()
        obj.__undef__ = _UNDEFINED if undef_enabled else None
        return obj

    def to_dict(self, dirty=False):
        dct = {}

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Json):
            return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class TypedObject(object):
    """
    Super schema for all other schemas.
    """
    def __init__(self, undef_enabled=True):
        self.__undef__ = _UNDEFINED if undef_enabled else None
        self._type = ("TypedObject", True)
        self._type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = cls()
        obj.__undef__ = _UNDEFINED if undef_enabled else None
        if "type" not in data:
            raise ValueError("Missing required property \"type\".")
        obj._type = (data.get("type", obj.__undef__), dirty)
        if obj._type[0] is not None and obj._type[0] is not obj.__undef__:
            assert isinstance(obj._type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._type[0]))
            common.validate_format(obj._type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = {}

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "type" == "type" or (self.type is not self.__undef__ and not (dirty and not self._type[1])):
            dct["type"] = dictify(self.type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._type = (self._type[0], True)

    def is_dirty(self):
        return any([self._type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TypedObject):
            return False
        return self.type == other.type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def type(self):
        """
        Object type.

        :rtype: ``basestring``
        """
        return self._type[0]

    @type.setter
    def type(self, value):
        self._type = (value, True)

class SchemaDraftV4(object):
    """
    A dummy schema that is used to represent JSON that is a valid Draft v4
    schema.
    """
    def __init__(self, undef_enabled=True):
        self.__undef__ = _UNDEFINED if undef_enabled else None
        self._type = ("SchemaDraftV4", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = cls()
        obj.__undef__ = _UNDEFINED if undef_enabled else None
        return obj

    def to_dict(self, dirty=False):
        dct = {}

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SchemaDraftV4):
            return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASEBackupLocation(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* SAP ASE backup
    location.
    """
    def __init__(self, undef_enabled=True):
        super(ASEBackupLocation, self).__init__()
        self._type = ("ASEBackupLocation", True)
        self._backup_host = (self.__undef__, True)
        self._backup_server_name = (self.__undef__, True)
        self._backup_host_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEBackupLocation, cls).from_dict(data, dirty, undef_enabled)
        obj._backup_host = (data.get("backupHost", obj.__undef__), dirty)
        if obj._backup_host[0] is not None and obj._backup_host[0] is not obj.__undef__:
            assert isinstance(obj._backup_host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_host[0]))
            common.validate_format(obj._backup_host[0], "objectReference", None, None)
        obj._backup_server_name = (data.get("backupServerName", obj.__undef__), dirty)
        if obj._backup_server_name[0] is not None and obj._backup_server_name[0] is not obj.__undef__:
            assert isinstance(obj._backup_server_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_server_name[0]))
            common.validate_format(obj._backup_server_name[0], "None", None, None)
        obj._backup_host_user = (data.get("backupHostUser", obj.__undef__), dirty)
        if obj._backup_host_user[0] is not None and obj._backup_host_user[0] is not obj.__undef__:
            assert isinstance(obj._backup_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_host_user[0]))
            common.validate_format(obj._backup_host_user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEBackupLocation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "backup_host" == "type" or (self.backup_host is not self.__undef__ and not (dirty and not self._backup_host[1])):
            dct["backupHost"] = dictify(self.backup_host)
        if "backup_server_name" == "type" or (self.backup_server_name is not self.__undef__ and not (dirty and not self._backup_server_name[1])):
            dct["backupServerName"] = dictify(self.backup_server_name)
        if "backup_host_user" == "type" or (self.backup_host_user is not self.__undef__ and not (dirty and not self._backup_host_user[1])):
            dct["backupHostUser"] = dictify(self.backup_host_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._backup_host = (self._backup_host[0], True)
        self._backup_server_name = (self._backup_server_name[0], True)
        self._backup_host_user = (self._backup_host_user[0], True)

    def is_dirty(self):
        return any([self._backup_host[1], self._backup_server_name[1], self._backup_host_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEBackupLocation):
            return False
        return super(ASEBackupLocation, self).__eq__(other) and \
               self.backup_host == other.backup_host and \
               self.backup_server_name == other.backup_server_name and \
               self.backup_host_user == other.backup_host_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def backup_host(self):
        """
        Host environment where the backup server is located.

        :rtype: ``basestring``
        """
        return self._backup_host[0]

    @backup_host.setter
    def backup_host(self, value):
        self._backup_host = (value, True)

    @property
    def backup_server_name(self):
        """
        Name of the backup server instance.

        :rtype: ``basestring``
        """
        return self._backup_server_name[0]

    @backup_server_name.setter
    def backup_server_name(self, value):
        self._backup_server_name = (value, True)

    @property
    def backup_host_user(self):
        """
        OS user for the host where the backup server is located.

        :rtype: ``basestring``
        """
        return self._backup_host_user[0]

    @backup_host_user.setter
    def backup_host_user(self, value):
        self._backup_host_user = (value, True)

class JSDataSourceCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    create the Jet Stream data sources.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataSourceCreateParameters, self).__init__()
        self._type = ("JSDataSourceCreateParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._properties = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataSourceCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "JSDataSource"), dirty)
            factory.validate_type(obj._source[0], "JSDataSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataSourceCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._properties = (self._properties[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._properties[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataSourceCreateParameters):
            return False
        return super(JSDataSourceCreateParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.properties == other.properties

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The Jet Stream data source object.

        :rtype: :py:class:`v1_8_1.web.vo.JSDataSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        A reference to the underlying container object.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this data source.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

class StorageInitializationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters used for
    initializing storage on a grid node.
    """
    def __init__(self, undef_enabled=True):
        super(StorageInitializationParameters, self).__init__()
        self._type = ("StorageInitializationParameters", True)
        self._devices = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageInitializationParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._devices = []
        for item in data.get("devices") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._devices.append(item)
        obj._devices = (obj._devices, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageInitializationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "devices" == "type" or (self.devices is not self.__undef__ and not (dirty and not self._devices[1])):
            dct["devices"] = dictify(self.devices)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._devices = (self._devices[0], True)

    def is_dirty(self):
        return any([self._devices[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageInitializationParameters):
            return False
        return super(StorageInitializationParameters, self).__eq__(other) and \
               self.devices == other.devices

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def devices(self):
        """
        List of storage devices to use for the domain.

        :rtype: ``list`` of ``basestring``
        """
        return self._devices[0]

    @devices.setter
    def devices(self, value):
        self._devices = (value, True)

class DetachSourceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters passed
    in for a database detach source operation.
    """
    def __init__(self, undef_enabled=True):
        super(DetachSourceParameters, self).__init__()
        self._type = ("DetachSourceParameters", True)
        self._source = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DetachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DetachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)

    def is_dirty(self):
        return any([self._source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DetachSourceParameters):
            return False
        return super(DetachSourceParameters, self).__eq__(other) and \
               self.source == other.source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Reference to the source to be removed. This must be a linked source
        attached to the target database.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

class JSDataContainerActiveBranchParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Input parameters for
    the API that given a point in time, returns the active branch of the data
    container.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainerActiveBranchParameters, self).__init__()
        self._type = ("JSDataContainerActiveBranchParameters", True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainerActiveBranchParameters, cls).from_dict(data, dirty, undef_enabled)
        if "time" not in data:
            raise ValueError("Missing required property \"time\".")
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainerActiveBranchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainerActiveBranchParameters):
            return False
        return super(JSDataContainerActiveBranchParameters, self).__eq__(other) and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def time(self):
        """
        The time that will be used to find which branch was active in the data
        layout.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class TimeflowRepairParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters to repair
    log files within a TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRepairParameters, self).__init__()
        self._type = ("TimeflowRepairParameters", True)
        self._end_location = (self.__undef__, True)
        self._start_location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRepairParameters, cls).from_dict(data, dirty, undef_enabled)
        if "endLocation" not in data:
            raise ValueError("Missing required property \"endLocation\".")
        obj._end_location = (data.get("endLocation", obj.__undef__), dirty)
        if obj._end_location[0] is not None and obj._end_location[0] is not obj.__undef__:
            assert isinstance(obj._end_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_location[0]))
            common.validate_format(obj._end_location[0], "None", None, None)
        if "startLocation" not in data:
            raise ValueError("Missing required property \"startLocation\".")
        obj._start_location = (data.get("startLocation", obj.__undef__), dirty)
        if obj._start_location[0] is not None and obj._start_location[0] is not obj.__undef__:
            assert isinstance(obj._start_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_location[0]))
            common.validate_format(obj._start_location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRepairParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_location" == "type" or (self.end_location is not self.__undef__ and not (dirty and not self._end_location[1])):
            dct["endLocation"] = dictify(self.end_location)
        if "start_location" == "type" or (self.start_location is not self.__undef__ and not (dirty and not self._start_location[1])):
            dct["startLocation"] = dictify(self.start_location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_location = (self._end_location[0], True)
        self._start_location = (self._start_location[0], True)

    def is_dirty(self):
        return any([self._end_location[1], self._start_location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRepairParameters):
            return False
        return super(TimeflowRepairParameters, self).__eq__(other) and \
               self.end_location == other.end_location and \
               self.start_location == other.start_location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_location(self):
        """
        The ending point of the range of log files to fetch.

        :rtype: ``basestring``
        """
        return self._end_location[0]

    @end_location.setter
    def end_location(self, value):
        self._end_location = (value, True)

    @property
    def start_location(self):
        """
        The starting point of the range of log files to fetch.

        :rtype: ``basestring``
        """
        return self._start_location[0]

    @start_location.setter
    def start_location(self, value):
        self._start_location = (value, True)

class GetLogParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to Log.get.
    """
    def __init__(self, undef_enabled=True):
        super(GetLogParameters, self).__init__()
        self._type = ("GetLogParameters", True)
        self._log_type = (self.__undef__, True)
        self._log_number = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(GetLogParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._log_type = (data.get("logType", obj.__undef__), dirty)
        if obj._log_type[0] is not None and obj._log_type[0] is not obj.__undef__:
            assert isinstance(obj._log_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._log_type[0]))
            assert obj._log_type[0] in [u'info', u'debug', u'error', u'trace'], "Expected enum [u'info', u'debug', u'error', u'trace'] but got %s" % obj._log_type[0]
            common.validate_format(obj._log_type[0], "None", None, None)
        obj._log_number = (data.get("logNumber", obj.__undef__), dirty)
        if obj._log_number[0] is not None and obj._log_number[0] is not obj.__undef__:
            assert isinstance(obj._log_number[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._log_number[0]))
            common.validate_format(obj._log_number[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(GetLogParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "log_type" == "type" or (self.log_type is not self.__undef__ and not (dirty and not self._log_type[1])):
            dct["logType"] = dictify(self.log_type)
        if "log_number" == "type" or (self.log_number is not self.__undef__ and not (dirty and not self._log_number[1])):
            dct["logNumber"] = dictify(self.log_number)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._log_type = (self._log_type[0], True)
        self._log_number = (self._log_number[0], True)

    def is_dirty(self):
        return any([self._log_type[1], self._log_number[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, GetLogParameters):
            return False
        return super(GetLogParameters, self).__eq__(other) and \
               self.log_type == other.log_type and \
               self.log_number == other.log_number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def log_type(self):
        """
        *(default value: debug)* Type of log to retrieve. *(permitted values:
        info, debug, error, trace)*

        :rtype: ``basestring``
        """
        return self._log_type[0]

    @log_type.setter
    def log_type(self, value):
        self._log_type = (value, True)

    @property
    def log_number(self):
        """
        Log number to return.

        :rtype: ``int``
        """
        return self._log_number[0]

    @log_number.setter
    def log_number(self, value):
        self._log_number = (value, True)

class Statistic(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Multidimensional
    analytics statistics which can be queried for data.
    """
    def __init__(self, undef_enabled=True):
        super(Statistic, self).__init__()
        self._type = ("Statistic", True)
        self._explanation = (self.__undef__, True)
        self._statistic_type = (self.__undef__, True)
        self._axes = (self.__undef__, True)
        self._min_collection_interval = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Statistic, cls).from_dict(data, dirty, undef_enabled)
        obj._explanation = (data.get("explanation", obj.__undef__), dirty)
        if obj._explanation[0] is not None and obj._explanation[0] is not obj.__undef__:
            assert isinstance(obj._explanation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._explanation[0]))
            common.validate_format(obj._explanation[0], "None", None, None)
        obj._statistic_type = (data.get("statisticType", obj.__undef__), dirty)
        if obj._statistic_type[0] is not None and obj._statistic_type[0] is not obj.__undef__:
            assert isinstance(obj._statistic_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._statistic_type[0]))
            common.validate_format(obj._statistic_type[0], "None", None, None)
        obj._axes = []
        for item in data.get("axes") or []:
            obj._axes.append(factory.create_object(item))
            factory.validate_type(obj._axes[-1], "StatisticAxis")
        obj._axes = (obj._axes, dirty)
        obj._min_collection_interval = (data.get("minCollectionInterval", obj.__undef__), dirty)
        if obj._min_collection_interval[0] is not None and obj._min_collection_interval[0] is not obj.__undef__:
            assert isinstance(obj._min_collection_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._min_collection_interval[0]))
            common.validate_format(obj._min_collection_interval[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Statistic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "explanation" == "type" or (self.explanation is not self.__undef__ and not (dirty and not self._explanation[1])):
            dct["explanation"] = dictify(self.explanation)
        if "statistic_type" == "type" or (self.statistic_type is not self.__undef__ and not (dirty and not self._statistic_type[1])):
            dct["statisticType"] = dictify(self.statistic_type)
        if "axes" == "type" or (self.axes is not self.__undef__ and not (dirty and not self._axes[1])):
            dct["axes"] = dictify(self.axes)
        if "min_collection_interval" == "type" or (self.min_collection_interval is not self.__undef__ and not (dirty and not self._min_collection_interval[1])):
            dct["minCollectionInterval"] = dictify(self.min_collection_interval)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._explanation = (self._explanation[0], True)
        self._statistic_type = (self._statistic_type[0], True)
        self._axes = (self._axes[0], True)
        self._min_collection_interval = (self._min_collection_interval[0], True)

    def is_dirty(self):
        return any([self._explanation[1], self._statistic_type[1], self._axes[1], self._min_collection_interval[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Statistic):
            return False
        return super(Statistic, self).__eq__(other) and \
               self.explanation == other.explanation and \
               self.statistic_type == other.statistic_type and \
               self.axes == other.axes and \
               self.min_collection_interval == other.min_collection_interval

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def explanation(self):
        """
        A deeper explanation of the data this can collect.

        :rtype: ``basestring``
        """
        return self._explanation[0]

    @explanation.setter
    def explanation(self, value):
        self._explanation = (value, True)

    @property
    def statistic_type(self):
        """
        The type name for the data this can collect.

        :rtype: ``basestring``
        """
        return self._statistic_type[0]

    @statistic_type.setter
    def statistic_type(self, value):
        self._statistic_type = (value, True)

    @property
    def axes(self):
        """
        The set of axes this statistic has.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.StatisticAxis`
        """
        return self._axes[0]

    @axes.setter
    def axes(self, value):
        self._axes = (value, True)

    @property
    def min_collection_interval(self):
        """
        The smallest unit of time this statistic can measure on.

        :rtype: ``int``
        """
        return self._min_collection_interval[0]

    @min_collection_interval.setter
    def min_collection_interval(self, value):
        self._min_collection_interval = (value, True)

class HostRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime, non-
    persistent properties for a host machine.
    """
    def __init__(self, undef_enabled=True):
        super(HostRuntime, self).__init__()
        self._type = ("HostRuntime", True)
        self._available = (self.__undef__, True)
        self._trace_route_info = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._available = (data.get("available", obj.__undef__), dirty)
        if obj._available[0] is not None and obj._available[0] is not obj.__undef__:
            assert isinstance(obj._available[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._available[0]))
            common.validate_format(obj._available[0], "None", None, None)
        if "traceRouteInfo" in data and data["traceRouteInfo"] is not None:
            obj._trace_route_info = (factory.create_object(data["traceRouteInfo"], "TracerouteInfo"), dirty)
            factory.validate_type(obj._trace_route_info[0], "TracerouteInfo")
        else:
            obj._trace_route_info = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "available" == "type" or (self.available is not self.__undef__ and not (dirty and not self._available[1])):
            dct["available"] = dictify(self.available)
        if "trace_route_info" == "type" or (self.trace_route_info is not self.__undef__ and not (dirty and not self._trace_route_info[1])):
            dct["traceRouteInfo"] = dictify(self.trace_route_info)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._available = (self._available[0], True)
        self._trace_route_info = (self._trace_route_info[0], True)

    def is_dirty(self):
        return any([self._available[1], self._trace_route_info[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostRuntime):
            return False
        return super(HostRuntime, self).__eq__(other) and \
               self.available == other.available and \
               self.trace_route_info == other.trace_route_info

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def available(self):
        """
        True if the host is up and a connection can be established.

        :rtype: ``bool``
        """
        return self._available[0]

    @available.setter
    def available(self, value):
        self._available = (value, True)

    @property
    def trace_route_info(self):
        """
        Traceroute network hops from host to Delphix Engine.

        :rtype: :py:class:`v1_8_1.web.vo.TracerouteInfo`
        """
        return self._trace_route_info[0]

    @trace_route_info.setter
    def trace_route_info(self, value):
        self._trace_route_info = (value, True)

class OracleCharacterSet(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents an Oracle
    character set.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCharacterSet, self).__init__()
        self._type = ("OracleCharacterSet", True)
        self._character_set = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCharacterSet, cls).from_dict(data, dirty, undef_enabled)
        obj._character_set = (data.get("characterSet", obj.__undef__), dirty)
        if obj._character_set[0] is not None and obj._character_set[0] is not obj.__undef__:
            assert isinstance(obj._character_set[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._character_set[0]))
            common.validate_format(obj._character_set[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCharacterSet, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "character_set" == "type" or (self.character_set is not self.__undef__ and not (dirty and not self._character_set[1])):
            dct["characterSet"] = dictify(self.character_set)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._character_set = (self._character_set[0], True)

    def is_dirty(self):
        return any([self._character_set[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCharacterSet):
            return False
        return super(OracleCharacterSet, self).__eq__(other) and \
               self.character_set == other.character_set

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def character_set(self):
        """
        Name of character set.

        :rtype: ``basestring``
        """
        return self._character_set[0]

    @character_set.setter
    def character_set(self, value):
        self._character_set = (value, True)

class StorageTestResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The test results of
    one storage test.
    """
    def __init__(self, undef_enabled=True):
        super(StorageTestResult, self).__init__()
        self._type = ("StorageTestResult", True)
        self._iops = (self.__undef__, True)
        self._load_scaling = (self.__undef__, True)
        self._jobs = (self.__undef__, True)
        self._max_latency = (self.__undef__, True)
        self._min_latency = (self.__undef__, True)
        self._block_size = (self.__undef__, True)
        self._latency_grade = (self.__undef__, True)
        self._test_name = (self.__undef__, True)
        self._latency95th_percentile = (self.__undef__, True)
        self._load_scaling_grade = (self.__undef__, True)
        self._average_latency = (self.__undef__, True)
        self._throughput = (self.__undef__, True)
        self._stddev_latency = (self.__undef__, True)
        self._test_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageTestResult, cls).from_dict(data, dirty, undef_enabled)
        obj._iops = (data.get("iops", obj.__undef__), dirty)
        if obj._iops[0] is not None and obj._iops[0] is not obj.__undef__:
            assert isinstance(obj._iops[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._iops[0]))
            common.validate_format(obj._iops[0], "None", None, None)
        obj._load_scaling = (data.get("loadScaling", obj.__undef__), dirty)
        if obj._load_scaling[0] is not None and obj._load_scaling[0] is not obj.__undef__:
            assert isinstance(obj._load_scaling[0], float), ("Expected one of [u'number'], but got %s" % type(obj._load_scaling[0]))
            common.validate_format(obj._load_scaling[0], "None", None, None)
        obj._jobs = (data.get("jobs", obj.__undef__), dirty)
        if obj._jobs[0] is not None and obj._jobs[0] is not obj.__undef__:
            assert isinstance(obj._jobs[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._jobs[0]))
            common.validate_format(obj._jobs[0], "None", None, None)
        obj._max_latency = (data.get("maxLatency", obj.__undef__), dirty)
        if obj._max_latency[0] is not None and obj._max_latency[0] is not obj.__undef__:
            assert isinstance(obj._max_latency[0], float), ("Expected one of [u'number'], but got %s" % type(obj._max_latency[0]))
            common.validate_format(obj._max_latency[0], "None", None, None)
        obj._min_latency = (data.get("minLatency", obj.__undef__), dirty)
        if obj._min_latency[0] is not None and obj._min_latency[0] is not obj.__undef__:
            assert isinstance(obj._min_latency[0], float), ("Expected one of [u'number'], but got %s" % type(obj._min_latency[0]))
            common.validate_format(obj._min_latency[0], "None", None, None)
        obj._block_size = (data.get("blockSize", obj.__undef__), dirty)
        if obj._block_size[0] is not None and obj._block_size[0] is not obj.__undef__:
            assert isinstance(obj._block_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._block_size[0]))
            common.validate_format(obj._block_size[0], "None", None, None)
        obj._latency_grade = (data.get("latencyGrade", obj.__undef__), dirty)
        if obj._latency_grade[0] is not None and obj._latency_grade[0] is not obj.__undef__:
            assert isinstance(obj._latency_grade[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._latency_grade[0]))
            common.validate_format(obj._latency_grade[0], "None", None, None)
        obj._test_name = (data.get("testName", obj.__undef__), dirty)
        if obj._test_name[0] is not None and obj._test_name[0] is not obj.__undef__:
            assert isinstance(obj._test_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._test_name[0]))
            common.validate_format(obj._test_name[0], "None", None, None)
        obj._latency95th_percentile = (data.get("latency95thPercentile", obj.__undef__), dirty)
        if obj._latency95th_percentile[0] is not None and obj._latency95th_percentile[0] is not obj.__undef__:
            assert isinstance(obj._latency95th_percentile[0], float), ("Expected one of [u'number'], but got %s" % type(obj._latency95th_percentile[0]))
            common.validate_format(obj._latency95th_percentile[0], "None", None, None)
        obj._load_scaling_grade = (data.get("loadScalingGrade", obj.__undef__), dirty)
        if obj._load_scaling_grade[0] is not None and obj._load_scaling_grade[0] is not obj.__undef__:
            assert isinstance(obj._load_scaling_grade[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._load_scaling_grade[0]))
            common.validate_format(obj._load_scaling_grade[0], "None", None, None)
        obj._average_latency = (data.get("averageLatency", obj.__undef__), dirty)
        if obj._average_latency[0] is not None and obj._average_latency[0] is not obj.__undef__:
            assert isinstance(obj._average_latency[0], float), ("Expected one of [u'number'], but got %s" % type(obj._average_latency[0]))
            common.validate_format(obj._average_latency[0], "None", None, None)
        obj._throughput = (data.get("throughput", obj.__undef__), dirty)
        if obj._throughput[0] is not None and obj._throughput[0] is not obj.__undef__:
            assert isinstance(obj._throughput[0], float), ("Expected one of [u'number'], but got %s" % type(obj._throughput[0]))
            common.validate_format(obj._throughput[0], "None", None, None)
        obj._stddev_latency = (data.get("stddevLatency", obj.__undef__), dirty)
        if obj._stddev_latency[0] is not None and obj._stddev_latency[0] is not obj.__undef__:
            assert isinstance(obj._stddev_latency[0], float), ("Expected one of [u'number'], but got %s" % type(obj._stddev_latency[0]))
            common.validate_format(obj._stddev_latency[0], "None", None, None)
        obj._test_type = (data.get("testType", obj.__undef__), dirty)
        if obj._test_type[0] is not None and obj._test_type[0] is not obj.__undef__:
            assert isinstance(obj._test_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._test_type[0]))
            assert obj._test_type[0] in [u'READ', u'WRITE', u'RANDREAD', u'RANDWRITE'], "Expected enum [u'READ', u'WRITE', u'RANDREAD', u'RANDWRITE'] but got %s" % obj._test_type[0]
            common.validate_format(obj._test_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageTestResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "iops" == "type" or (self.iops is not self.__undef__ and not (dirty and not self._iops[1])):
            dct["iops"] = dictify(self.iops)
        if "load_scaling" == "type" or (self.load_scaling is not self.__undef__ and not (dirty and not self._load_scaling[1])):
            dct["loadScaling"] = dictify(self.load_scaling)
        if "jobs" == "type" or (self.jobs is not self.__undef__ and not (dirty and not self._jobs[1])):
            dct["jobs"] = dictify(self.jobs)
        if "max_latency" == "type" or (self.max_latency is not self.__undef__ and not (dirty and not self._max_latency[1])):
            dct["maxLatency"] = dictify(self.max_latency)
        if "min_latency" == "type" or (self.min_latency is not self.__undef__ and not (dirty and not self._min_latency[1])):
            dct["minLatency"] = dictify(self.min_latency)
        if "block_size" == "type" or (self.block_size is not self.__undef__ and not (dirty and not self._block_size[1])):
            dct["blockSize"] = dictify(self.block_size)
        if "latency_grade" == "type" or (self.latency_grade is not self.__undef__ and not (dirty and not self._latency_grade[1])):
            dct["latencyGrade"] = dictify(self.latency_grade)
        if "test_name" == "type" or (self.test_name is not self.__undef__ and not (dirty and not self._test_name[1])):
            dct["testName"] = dictify(self.test_name)
        if "latency95th_percentile" == "type" or (self.latency95th_percentile is not self.__undef__ and not (dirty and not self._latency95th_percentile[1])):
            dct["latency95thPercentile"] = dictify(self.latency95th_percentile)
        if "load_scaling_grade" == "type" or (self.load_scaling_grade is not self.__undef__ and not (dirty and not self._load_scaling_grade[1])):
            dct["loadScalingGrade"] = dictify(self.load_scaling_grade)
        if "average_latency" == "type" or (self.average_latency is not self.__undef__ and not (dirty and not self._average_latency[1])):
            dct["averageLatency"] = dictify(self.average_latency)
        if "throughput" == "type" or (self.throughput is not self.__undef__ and not (dirty and not self._throughput[1])):
            dct["throughput"] = dictify(self.throughput)
        if "stddev_latency" == "type" or (self.stddev_latency is not self.__undef__ and not (dirty and not self._stddev_latency[1])):
            dct["stddevLatency"] = dictify(self.stddev_latency)
        if "test_type" == "type" or (self.test_type is not self.__undef__ and not (dirty and not self._test_type[1])):
            dct["testType"] = dictify(self.test_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._iops = (self._iops[0], True)
        self._load_scaling = (self._load_scaling[0], True)
        self._jobs = (self._jobs[0], True)
        self._max_latency = (self._max_latency[0], True)
        self._min_latency = (self._min_latency[0], True)
        self._block_size = (self._block_size[0], True)
        self._latency_grade = (self._latency_grade[0], True)
        self._test_name = (self._test_name[0], True)
        self._latency95th_percentile = (self._latency95th_percentile[0], True)
        self._load_scaling_grade = (self._load_scaling_grade[0], True)
        self._average_latency = (self._average_latency[0], True)
        self._throughput = (self._throughput[0], True)
        self._stddev_latency = (self._stddev_latency[0], True)
        self._test_type = (self._test_type[0], True)

    def is_dirty(self):
        return any([self._iops[1], self._load_scaling[1], self._jobs[1], self._max_latency[1], self._min_latency[1], self._block_size[1], self._latency_grade[1], self._test_name[1], self._latency95th_percentile[1], self._load_scaling_grade[1], self._average_latency[1], self._throughput[1], self._stddev_latency[1], self._test_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageTestResult):
            return False
        return super(StorageTestResult, self).__eq__(other) and \
               self.iops == other.iops and \
               self.load_scaling == other.load_scaling and \
               self.jobs == other.jobs and \
               self.max_latency == other.max_latency and \
               self.min_latency == other.min_latency and \
               self.block_size == other.block_size and \
               self.latency_grade == other.latency_grade and \
               self.test_name == other.test_name and \
               self.latency95th_percentile == other.latency95th_percentile and \
               self.load_scaling_grade == other.load_scaling_grade and \
               self.average_latency == other.average_latency and \
               self.throughput == other.throughput and \
               self.stddev_latency == other.stddev_latency and \
               self.test_type == other.test_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def iops(self):
        """
        IO operations per second.

        :rtype: ``int``
        """
        return self._iops[0]

    @iops.setter
    def iops(self, value):
        self._iops = (value, True)

    @property
    def load_scaling(self):
        """
        Load scaling.

        :rtype: ``float``
        """
        return self._load_scaling[0]

    @load_scaling.setter
    def load_scaling(self, value):
        self._load_scaling = (value, True)

    @property
    def jobs(self):
        """
        No of jobs/threads used.

        :rtype: ``int``
        """
        return self._jobs[0]

    @jobs.setter
    def jobs(self, value):
        self._jobs = (value, True)

    @property
    def max_latency(self):
        """
        Maximum latency in milliseconds.

        :rtype: ``float``
        """
        return self._max_latency[0]

    @max_latency.setter
    def max_latency(self, value):
        self._max_latency = (value, True)

    @property
    def min_latency(self):
        """
        Minimum latency in milliseconds.

        :rtype: ``float``
        """
        return self._min_latency[0]

    @min_latency.setter
    def min_latency(self, value):
        self._min_latency = (value, True)

    @property
    def block_size(self):
        """
        Block size used for the test.

        :rtype: ``int``
        """
        return self._block_size[0]

    @block_size.setter
    def block_size(self, value):
        self._block_size = (value, True)

    @property
    def latency_grade(self):
        """
        Grade assigned to the test for latency.

        :rtype: ``basestring``
        """
        return self._latency_grade[0]

    @latency_grade.setter
    def latency_grade(self, value):
        self._latency_grade = (value, True)

    @property
    def test_name(self):
        """
        Name of the test for which the grade is assigned.

        :rtype: ``basestring``
        """
        return self._test_name[0]

    @test_name.setter
    def test_name(self, value):
        self._test_name = (value, True)

    @property
    def latency95th_percentile(self):
        """
        95th percentile latency in milliseconds.

        :rtype: ``float``
        """
        return self._latency95th_percentile[0]

    @latency95th_percentile.setter
    def latency95th_percentile(self, value):
        self._latency95th_percentile = (value, True)

    @property
    def load_scaling_grade(self):
        """
        Grade assigned to the test for load scaling.

        :rtype: ``basestring``
        """
        return self._load_scaling_grade[0]

    @load_scaling_grade.setter
    def load_scaling_grade(self, value):
        self._load_scaling_grade = (value, True)

    @property
    def average_latency(self):
        """
        Average latency in milliseconds.

        :rtype: ``float``
        """
        return self._average_latency[0]

    @average_latency.setter
    def average_latency(self, value):
        self._average_latency = (value, True)

    @property
    def throughput(self):
        """
        Throughput.

        :rtype: ``float``
        """
        return self._throughput[0]

    @throughput.setter
    def throughput(self, value):
        self._throughput = (value, True)

    @property
    def stddev_latency(self):
        """
        Standard deviation of latency in milliseconds.

        :rtype: ``float``
        """
        return self._stddev_latency[0]

    @stddev_latency.setter
    def stddev_latency(self, value):
        self._stddev_latency = (value, True)

    @property
    def test_type(self):
        """
        The test type. *(permitted values: READ, WRITE, RANDREAD, RANDWRITE)*

        :rtype: ``basestring``
        """
        return self._test_type[0]

    @test_type.setter
    def test_type(self, value):
        self._test_type = (value, True)

class OracleTimeflowLog(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* An Oracle log on a
    TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(OracleTimeflowLog, self).__init__()
        self._type = ("OracleTimeflowLog", True)
        self._container = (self.__undef__, True)
        self._sequence = (self.__undef__, True)
        self._instance_num = (self.__undef__, True)
        self._start_timestamp = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._start_scn = (self.__undef__, True)
        self._end_scn = (self.__undef__, True)
        self._end_timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTimeflowLog, cls).from_dict(data, dirty, undef_enabled)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._sequence = (data.get("sequence", obj.__undef__), dirty)
        if obj._sequence[0] is not None and obj._sequence[0] is not obj.__undef__:
            assert isinstance(obj._sequence[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._sequence[0]))
            common.validate_format(obj._sequence[0], "None", None, None)
        obj._instance_num = (data.get("instanceNum", obj.__undef__), dirty)
        if obj._instance_num[0] is not None and obj._instance_num[0] is not obj.__undef__:
            assert isinstance(obj._instance_num[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._instance_num[0]))
            common.validate_format(obj._instance_num[0], "None", None, None)
        obj._start_timestamp = (data.get("startTimestamp", obj.__undef__), dirty)
        if obj._start_timestamp[0] is not None and obj._start_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._start_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_timestamp[0]))
            common.validate_format(obj._start_timestamp[0], "date", None, None)
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        obj._start_scn = (data.get("startScn", obj.__undef__), dirty)
        if obj._start_scn[0] is not None and obj._start_scn[0] is not obj.__undef__:
            assert isinstance(obj._start_scn[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._start_scn[0]))
            common.validate_format(obj._start_scn[0], "None", None, None)
        obj._end_scn = (data.get("endScn", obj.__undef__), dirty)
        if obj._end_scn[0] is not None and obj._end_scn[0] is not obj.__undef__:
            assert isinstance(obj._end_scn[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._end_scn[0]))
            common.validate_format(obj._end_scn[0], "None", None, None)
        obj._end_timestamp = (data.get("endTimestamp", obj.__undef__), dirty)
        if obj._end_timestamp[0] is not None and obj._end_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._end_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_timestamp[0]))
            common.validate_format(obj._end_timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTimeflowLog, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "sequence" == "type" or (self.sequence is not self.__undef__ and not (dirty and not self._sequence[1])):
            dct["sequence"] = dictify(self.sequence)
        if "instance_num" == "type" or (self.instance_num is not self.__undef__ and not (dirty and not self._instance_num[1])):
            dct["instanceNum"] = dictify(self.instance_num)
        if "start_timestamp" == "type" or (self.start_timestamp is not self.__undef__ and not (dirty and not self._start_timestamp[1])):
            dct["startTimestamp"] = dictify(self.start_timestamp)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "start_scn" == "type" or (self.start_scn is not self.__undef__ and not (dirty and not self._start_scn[1])):
            dct["startScn"] = dictify(self.start_scn)
        if "end_scn" == "type" or (self.end_scn is not self.__undef__ and not (dirty and not self._end_scn[1])):
            dct["endScn"] = dictify(self.end_scn)
        if "end_timestamp" == "type" or (self.end_timestamp is not self.__undef__ and not (dirty and not self._end_timestamp[1])):
            dct["endTimestamp"] = dictify(self.end_timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._sequence = (self._sequence[0], True)
        self._instance_num = (self._instance_num[0], True)
        self._start_timestamp = (self._start_timestamp[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._start_scn = (self._start_scn[0], True)
        self._end_scn = (self._end_scn[0], True)
        self._end_timestamp = (self._end_timestamp[0], True)

    def is_dirty(self):
        return any([self._container[1], self._sequence[1], self._instance_num[1], self._start_timestamp[1], self._timeflow[1], self._start_scn[1], self._end_scn[1], self._end_timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTimeflowLog):
            return False
        return super(OracleTimeflowLog, self).__eq__(other) and \
               self.container == other.container and \
               self.sequence == other.sequence and \
               self.instance_num == other.instance_num and \
               self.start_timestamp == other.start_timestamp and \
               self.timeflow == other.timeflow and \
               self.start_scn == other.start_scn and \
               self.end_scn == other.end_scn and \
               self.end_timestamp == other.end_timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        Reference to the database to which this log belongs.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def sequence(self):
        """
        Sequence number for the log file.

        :rtype: ``int``
        """
        return self._sequence[0]

    @sequence.setter
    def sequence(self, value):
        self._sequence = (value, True)

    @property
    def instance_num(self):
        """
        Instance number associated with the log file.

        :rtype: ``int``
        """
        return self._instance_num[0]

    @instance_num.setter
    def instance_num(self, value):
        self._instance_num = (value, True)

    @property
    def start_timestamp(self):
        """
        Start timestamp for the log file.

        :rtype: ``basestring``
        """
        return self._start_timestamp[0]

    @start_timestamp.setter
    def start_timestamp(self, value):
        self._start_timestamp = (value, True)

    @property
    def timeflow(self):
        """
        Reference to the TimeFlow of which this log is a part.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def start_scn(self):
        """
        Start SCN for the log file.

        :rtype: ``int``
        """
        return self._start_scn[0]

    @start_scn.setter
    def start_scn(self, value):
        self._start_scn = (value, True)

    @property
    def end_scn(self):
        """
        End SCN for the log file.

        :rtype: ``int``
        """
        return self._end_scn[0]

    @end_scn.setter
    def end_scn(self, value):
        self._end_scn = (value, True)

    @property
    def end_timestamp(self):
        """
        End timestamp for the log file.

        :rtype: ``basestring``
        """
        return self._end_timestamp[0]

    @end_timestamp.setter
    def end_timestamp(self, value):
        self._end_timestamp = (value, True)

class MSSqlBaseClusterInstance(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The representation of
    a SQL Server Instance on a clustered node.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlBaseClusterInstance, self).__init__()
        self._type = ("MSSqlBaseClusterInstance", True)
        self._node = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._server_name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._instance_owner = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlBaseClusterInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._node = (data.get("node", obj.__undef__), dirty)
        if obj._node[0] is not None and obj._node[0] is not obj.__undef__:
            assert isinstance(obj._node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._node[0]))
            common.validate_format(obj._node[0], "objectReference", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 16)
        obj._server_name = (data.get("serverName", obj.__undef__), dirty)
        if obj._server_name[0] is not None and obj._server_name[0] is not obj.__undef__:
            assert isinstance(obj._server_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server_name[0]))
            common.validate_format(obj._server_name[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._instance_owner = (data.get("instanceOwner", obj.__undef__), dirty)
        if obj._instance_owner[0] is not None and obj._instance_owner[0] is not obj.__undef__:
            assert isinstance(obj._instance_owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_owner[0]))
            common.validate_format(obj._instance_owner[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlBaseClusterInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "node" == "type" or (self.node is not self.__undef__ and not (dirty and not self._node[1])):
            dct["node"] = dictify(self.node)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "server_name" == "type" or (self.server_name is not self.__undef__ and not (dirty and not self._server_name[1])):
            dct["serverName"] = dictify(self.server_name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "instance_owner" == "type" or (self.instance_owner is not self.__undef__ and not (dirty and not self._instance_owner[1])):
            dct["instanceOwner"] = dictify(self.instance_owner)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._node = (self._node[0], True)
        self._name = (self._name[0], True)
        self._server_name = (self._server_name[0], True)
        self._version = (self._version[0], True)
        self._instance_owner = (self._instance_owner[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._node[1], self._name[1], self._server_name[1], self._version[1], self._instance_owner[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlBaseClusterInstance):
            return False
        return super(MSSqlBaseClusterInstance, self).__eq__(other) and \
               self.node == other.node and \
               self.name == other.name and \
               self.server_name == other.server_name and \
               self.version == other.version and \
               self.instance_owner == other.instance_owner and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def node(self):
        """
        A reference to the Windows Cluster Node for this instance.

        :rtype: ``basestring``
        """
        return self._node[0]

    @node.setter
    def node(self, value):
        self._node = (value, True)

    @property
    def name(self):
        """
        The name of the SQL Server Instance.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def server_name(self):
        """
        The Servername of the SQL Server Instance.

        :rtype: ``basestring``
        """
        return self._server_name[0]

    @server_name.setter
    def server_name(self, value):
        self._server_name = (value, True)

    @property
    def version(self):
        """
        The version of the SQL Server Instance.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def instance_owner(self):
        """
        The owner of the SQL Server Instance.

        :rtype: ``basestring``
        """
        return self._instance_owner[0]

    @instance_owner.setter
    def instance_owner(self, value):
        self._instance_owner = (value, True)

    @property
    def port(self):
        """
        The port to connect to the SQL Server Instance.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class HostMachine(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The representation of
    the host machine.
    """
    def __init__(self, undef_enabled=True):
        super(HostMachine, self).__init__()
        self._type = ("HostMachine", True)
        self._platform = (self.__undef__, True)
        self._memory_size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostMachine, cls).from_dict(data, dirty, undef_enabled)
        obj._platform = (data.get("platform", obj.__undef__), dirty)
        if obj._platform[0] is not None and obj._platform[0] is not obj.__undef__:
            assert isinstance(obj._platform[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._platform[0]))
            common.validate_format(obj._platform[0], "None", None, None)
        obj._memory_size = (data.get("memorySize", obj.__undef__), dirty)
        if obj._memory_size[0] is not None and obj._memory_size[0] is not obj.__undef__:
            assert isinstance(obj._memory_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._memory_size[0]))
            common.validate_format(obj._memory_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostMachine, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "platform" == "type" or (self.platform is not self.__undef__ and not (dirty and not self._platform[1])):
            dct["platform"] = dictify(self.platform)
        if "memory_size" == "type" or (self.memory_size is not self.__undef__ and not (dirty and not self._memory_size[1])):
            dct["memorySize"] = dictify(self.memory_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._platform = (self._platform[0], True)
        self._memory_size = (self._memory_size[0], True)

    def is_dirty(self):
        return any([self._platform[1], self._memory_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostMachine):
            return False
        return super(HostMachine, self).__eq__(other) and \
               self.platform == other.platform and \
               self.memory_size == other.memory_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def platform(self):
        """
        The platform for the host machine.

        :rtype: ``basestring``
        """
        return self._platform[0]

    @platform.setter
    def platform(self, value):
        self._platform = (value, True)

    @property
    def memory_size(self):
        """
        The amount of RAM on the host machine.

        :rtype: ``float``
        """
        return self._memory_size[0]

    @memory_size.setter
    def memory_size(self, value):
        self._memory_size = (value, True)

class JSOperationEndpointParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The input constraints
    for a call to fetch the first and last operation of a data layout or
    branch.
    """
    def __init__(self, undef_enabled=True):
        super(JSOperationEndpointParameters, self).__init__()
        self._type = ("JSOperationEndpointParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSOperationEndpointParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSOperationEndpointParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSOperationEndpointParameters):
            return False
        return super(JSOperationEndpointParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ProxyService(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Proxy service
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(ProxyService, self).__init__()
        self._type = ("ProxyService", True)
        self._https = (self.__undef__, True)
        self._socks = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProxyService, cls).from_dict(data, dirty, undef_enabled)
        if "https" in data and data["https"] is not None:
            obj._https = (factory.create_object(data["https"], "ProxyConfiguration"), dirty)
            factory.validate_type(obj._https[0], "ProxyConfiguration")
        else:
            obj._https = (obj.__undef__, dirty)
        if "socks" in data and data["socks"] is not None:
            obj._socks = (factory.create_object(data["socks"], "ProxyConfiguration"), dirty)
            factory.validate_type(obj._socks[0], "ProxyConfiguration")
        else:
            obj._socks = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProxyService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "https" == "type" or (self.https is not self.__undef__ and not (dirty and not self._https[1])):
            dct["https"] = dictify(self.https)
        if "socks" == "type" or (self.socks is not self.__undef__ and not (dirty and not self._socks[1])):
            dct["socks"] = dictify(self.socks)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._https = (self._https[0], True)
        self._socks = (self._socks[0], True)

    def is_dirty(self):
        return any([self._https[1], self._socks[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProxyService):
            return False
        return super(ProxyService, self).__eq__(other) and \
               self.https == other.https and \
               self.socks == other.socks

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def https(self):
        """
        HTTPS proxy configuration.

        :rtype: :py:class:`v1_8_1.web.vo.ProxyConfiguration`
        """
        return self._https[0]

    @https.setter
    def https(self, value):
        self._https = (value, True)

    @property
    def socks(self):
        """
        SOCKS proxy configuration.

        :rtype: :py:class:`v1_8_1.web.vo.ProxyConfiguration`
        """
        return self._socks[0]

    @socks.setter
    def socks(self, value):
        self._socks = (value, True)

class AddLiveSourceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to convert a dSource to a LiveSource.
    """
    def __init__(self, undef_enabled=True):
        super(AddLiveSourceParameters, self).__init__()
        self._type = ("AddLiveSourceParameters", True)
        self._source = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AddLiveSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "Source"), dirty)
            factory.validate_type(obj._source[0], "Source")
        else:
            obj._source = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AddLiveSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AddLiveSourceParameters):
            return False
        return super(AddLiveSourceParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes the LiveSource.

        :rtype: :py:class:`v1_8_1.web.vo.Source`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def source_config(self):
        """
        The source config of the LiveSource.

        :rtype: :py:class:`v1_8_1.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class APIError(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Description of an
    error encountered during an API call.
    """
    def __init__(self, undef_enabled=True):
        super(APIError, self).__init__()
        self._type = ("APIError", True)
        self._action = (self.__undef__, True)
        self._details = (self.__undef__, True)
        self._diagnoses = (self.__undef__, True)
        self._id = (self.__undef__, True)
        self._command_output = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APIError, cls).from_dict(data, dirty, undef_enabled)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._details = (data.get("details", obj.__undef__), dirty)
        if obj._details[0] is not None and obj._details[0] is not obj.__undef__:
            assert isinstance(obj._details[0], dict) or isinstance(obj._details[0], basestring), ("Expected one of [u'object', u'string'], but got %s" % type(obj._details[0]))
            common.validate_format(obj._details[0], "None", None, None)
        obj._diagnoses = []
        for item in data.get("diagnoses") or []:
            obj._diagnoses.append(factory.create_object(item))
            factory.validate_type(obj._diagnoses[-1], "DiagnosisResult")
        obj._diagnoses = (obj._diagnoses, dirty)
        obj._id = (data.get("id", obj.__undef__), dirty)
        if obj._id[0] is not None and obj._id[0] is not obj.__undef__:
            assert isinstance(obj._id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._id[0]))
            common.validate_format(obj._id[0], "None", None, None)
        obj._command_output = (data.get("commandOutput", obj.__undef__), dirty)
        if obj._command_output[0] is not None and obj._command_output[0] is not obj.__undef__:
            assert isinstance(obj._command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command_output[0]))
            common.validate_format(obj._command_output[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APIError, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "details" == "type" or (self.details is not self.__undef__ and not (dirty and not self._details[1])):
            dct["details"] = dictify(self.details)
        if "diagnoses" == "type" or (self.diagnoses is not self.__undef__ and not (dirty and not self._diagnoses[1])):
            dct["diagnoses"] = dictify(self.diagnoses)
        if "id" == "type" or (self.id is not self.__undef__ and not (dirty and not self._id[1])):
            dct["id"] = dictify(self.id)
        if "command_output" == "type" or (self.command_output is not self.__undef__ and not (dirty and not self._command_output[1])):
            dct["commandOutput"] = dictify(self.command_output)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action = (self._action[0], True)
        self._details = (self._details[0], True)
        self._diagnoses = (self._diagnoses[0], True)
        self._id = (self._id[0], True)
        self._command_output = (self._command_output[0], True)

    def is_dirty(self):
        return any([self._action[1], self._details[1], self._diagnoses[1], self._id[1], self._command_output[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APIError):
            return False
        return super(APIError, self).__eq__(other) and \
               self.action == other.action and \
               self.details == other.details and \
               self.diagnoses == other.diagnoses and \
               self.id == other.id and \
               self.command_output == other.command_output

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action(self):
        """
        Action to be taken by the user, if any, to fix the underlying problem.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def details(self):
        """
        For validation errors, a map of fields to APIError objects. For all
        other errors, a string with further details of the error.

        :rtype: ``dict`` *or* ``basestring``
        """
        return self._details[0]

    @details.setter
    def details(self, value):
        self._details = (value, True)

    @property
    def diagnoses(self):
        """
        Results of diagnostic checks run, if any, if the job failed.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.DiagnosisResult`
        """
        return self._diagnoses[0]

    @diagnoses.setter
    def diagnoses(self, value):
        self._diagnoses = (value, True)

    @property
    def id(self):
        """
        A stable identifier for the class of error encountered.

        :rtype: ``basestring``
        """
        return self._id[0]

    @id.setter
    def id(self, value):
        self._id = (value, True)

    @property
    def command_output(self):
        """
        Extra output, often from a script or other external process, that may
        give more insight into the cause of this error.

        :rtype: ``basestring``
        """
        return self._command_output[0]

    @command_output.setter
    def command_output(self, value):
        self._command_output = (value, True)

class OracleClusterNodeCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used
    for oracle cluster node operations.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterNodeCreateParameters, self).__init__()
        self._type = ("OracleClusterNodeCreateParameters", True)
        self._host_parameters = (self.__undef__, True)
        self._cluster = (self.__undef__, True)
        self._virtual_i_ps = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterNodeCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "hostParameters" in data and data["hostParameters"] is not None:
            obj._host_parameters = (factory.create_object(data["hostParameters"], "HostCreateParameters"), dirty)
            factory.validate_type(obj._host_parameters[0], "HostCreateParameters")
        else:
            obj._host_parameters = (obj.__undef__, dirty)
        obj._cluster = (data.get("cluster", obj.__undef__), dirty)
        if obj._cluster[0] is not None and obj._cluster[0] is not obj.__undef__:
            assert isinstance(obj._cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster[0]))
            common.validate_format(obj._cluster[0], "objectReference", None, None)
        obj._virtual_i_ps = []
        for item in data.get("virtualIPs") or []:
            obj._virtual_i_ps.append(factory.create_object(item))
            factory.validate_type(obj._virtual_i_ps[-1], "OracleVirtualIP")
        obj._virtual_i_ps = (obj._virtual_i_ps, dirty)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterNodeCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_parameters" == "type" or (self.host_parameters is not self.__undef__ and not (dirty and not self._host_parameters[1])):
            dct["hostParameters"] = dictify(self.host_parameters)
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "virtual_i_ps" == "type" or (self.virtual_i_ps is not self.__undef__ and not (dirty and not self._virtual_i_ps[1])):
            dct["virtualIPs"] = dictify(self.virtual_i_ps)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_parameters = (self._host_parameters[0], True)
        self._cluster = (self._cluster[0], True)
        self._virtual_i_ps = (self._virtual_i_ps[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._host_parameters[1], self._cluster[1], self._virtual_i_ps[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterNodeCreateParameters):
            return False
        return super(OracleClusterNodeCreateParameters, self).__eq__(other) and \
               self.host_parameters == other.host_parameters and \
               self.cluster == other.cluster and \
               self.virtual_i_ps == other.virtual_i_ps and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_parameters(self):
        """
        The host object associated with the cluster node.

        :rtype: :py:class:`v1_8_1.web.vo.HostCreateParameters`
        """
        return self._host_parameters[0]

    @host_parameters.setter
    def host_parameters(self, value):
        self._host_parameters = (value, True)

    @property
    def cluster(self):
        """
        The cluster to which the node belongs.

        :rtype: ``basestring``
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def virtual_i_ps(self):
        """
        The list of virtual IPs belonging to this node.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleVirtualIP`
        """
        return self._virtual_i_ps[0]

    @virtual_i_ps.setter
    def virtual_i_ps(self, value):
        self._virtual_i_ps = (value, True)

    @property
    def name(self):
        """
        The name of the cluster node.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class OracleFileSpecification(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes an Oracle
    data file, temporary file, or a redo log.
    """
    def __init__(self, undef_enabled=True):
        super(OracleFileSpecification, self).__init__()
        self._type = ("OracleFileSpecification", True)
        self._filename = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleFileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._filename = (data.get("filename", obj.__undef__), dirty)
        if obj._filename[0] is not None and obj._filename[0] is not obj.__undef__:
            assert isinstance(obj._filename[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._filename[0]))
            common.validate_format(obj._filename[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleFileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "filename" == "type" or (self.filename is not self.__undef__ and not (dirty and not self._filename[1])):
            dct["filename"] = dictify(self.filename)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._filename = (self._filename[0], True)

    def is_dirty(self):
        return any([self._filename[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleFileSpecification):
            return False
        return super(OracleFileSpecification, self).__eq__(other) and \
               self.filename == other.filename

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def filename(self):
        """
        The name of the data file, temporary file, or redo log.

        :rtype: ``basestring``
        """
        return self._filename[0]

    @filename.setter
    def filename(self, value):
        self._filename = (value, True)

class InterfaceAddress(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* IP address assigned to
    a network interface.
    """
    def __init__(self, undef_enabled=True):
        super(InterfaceAddress, self).__init__()
        self._type = ("InterfaceAddress", True)
        self._state = (self.__undef__, True)
        self._address_type = (self.__undef__, True)
        self._enable_ssh = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(InterfaceAddress, cls).from_dict(data, dirty, undef_enabled)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'OK', u'TENTATIVE', u'DUPLICATE', u'INACCESSIBLE'], "Expected enum [u'OK', u'TENTATIVE', u'DUPLICATE', u'INACCESSIBLE'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._address_type = (data.get("addressType", obj.__undef__), dirty)
        if obj._address_type[0] is not None and obj._address_type[0] is not obj.__undef__:
            assert isinstance(obj._address_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address_type[0]))
            assert obj._address_type[0] in [u'STATIC', u'DHCP'], "Expected enum [u'STATIC', u'DHCP'] but got %s" % obj._address_type[0]
            common.validate_format(obj._address_type[0], "None", None, None)
        obj._enable_ssh = (data.get("enableSSH", obj.__undef__), dirty)
        if obj._enable_ssh[0] is not None and obj._enable_ssh[0] is not obj.__undef__:
            assert isinstance(obj._enable_ssh[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enable_ssh[0]))
            common.validate_format(obj._enable_ssh[0], "None", None, None)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "cidrAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(InterfaceAddress, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "address_type" == "type" or (self.address_type is not self.__undef__ and not (dirty and not self._address_type[1])):
            dct["addressType"] = dictify(self.address_type)
        if "enable_ssh" == "type" or (self.enable_ssh is not self.__undef__ and not (dirty and not self._enable_ssh[1])):
            dct["enableSSH"] = dictify(self.enable_ssh)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._state = (self._state[0], True)
        self._address_type = (self._address_type[0], True)
        self._enable_ssh = (self._enable_ssh[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._state[1], self._address_type[1], self._enable_ssh[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, InterfaceAddress):
            return False
        return super(InterfaceAddress, self).__eq__(other) and \
               self.state == other.state and \
               self.address_type == other.address_type and \
               self.enable_ssh == other.enable_ssh and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def state(self):
        """
        The state of the address. *(permitted values: OK, TENTATIVE, DUPLICATE,
        INACCESSIBLE)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def address_type(self):
        """
        *(default value: STATIC)* The type of address (STATIC or DHCP).
        *(permitted values: STATIC, DHCP)*

        :rtype: ``basestring``
        """
        return self._address_type[0]

    @address_type.setter
    def address_type(self, value):
        self._address_type = (value, True)

    @property
    def enable_ssh(self):
        """
        *(default value: True)* True if this address should accept incoming SSH
        connections.

        :rtype: ``bool``
        """
        return self._enable_ssh[0]

    @enable_ssh.setter
    def enable_ssh(self, value):
        self._enable_ssh = (value, True)

    @property
    def address(self):
        """
        The address in Classless Inter-Domain Routing (CIDR) notation.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class AppDataAdditionalMountPoint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Specifies an
    additional location on which to mount a subdirectory of an AppData
    container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataAdditionalMountPoint, self).__init__()
        self._type = ("AppDataAdditionalMountPoint", True)
        self._environment = (self.__undef__, True)
        self._shared_path = (self.__undef__, True)
        self._mount_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataAdditionalMountPoint, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._shared_path = (data.get("sharedPath", obj.__undef__), dirty)
        if obj._shared_path[0] is not None and obj._shared_path[0] is not obj.__undef__:
            assert isinstance(obj._shared_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._shared_path[0]))
            common.validate_format(obj._shared_path[0], "unixpath", None, None)
        obj._mount_path = (data.get("mountPath", obj.__undef__), dirty)
        if obj._mount_path[0] is not None and obj._mount_path[0] is not obj.__undef__:
            assert isinstance(obj._mount_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_path[0]))
            common.validate_format(obj._mount_path[0], "unixpath", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataAdditionalMountPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "shared_path" == "type" or (self.shared_path is not self.__undef__ and not (dirty and not self._shared_path[1])):
            dct["sharedPath"] = dictify(self.shared_path)
        if "mount_path" == "type" or (self.mount_path is not self.__undef__ and not (dirty and not self._mount_path[1])):
            dct["mountPath"] = dictify(self.mount_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._shared_path = (self._shared_path[0], True)
        self._mount_path = (self._mount_path[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._shared_path[1], self._mount_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataAdditionalMountPoint):
            return False
        return super(AppDataAdditionalMountPoint, self).__eq__(other) and \
               self.environment == other.environment and \
               self.shared_path == other.shared_path and \
               self.mount_path == other.mount_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Reference to the environment on which the file system will be mounted.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def shared_path(self):
        """
        Relative path within the container of the directory that should be
        mounted.

        :rtype: ``basestring``
        """
        return self._shared_path[0]

    @shared_path.setter
    def shared_path(self, value):
        self._shared_path = (value, True)

    @property
    def mount_path(self):
        """
        Absolute path on the target environment were the filesystem should be
        mounted.

        :rtype: ``basestring``
        """
        return self._mount_path[0]

    @mount_path.setter
    def mount_path(self, value):
        self._mount_path = (value, True)

class RefreshParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to refresh requests for MSSQL, PostgreSQL, AppData, ASE or MySQL.
    """
    def __init__(self, undef_enabled=True):
        super(RefreshParameters, self).__init__()
        self._type = ("RefreshParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RefreshParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RefreshParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RefreshParameters):
            return False
        return super(RefreshParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to refresh the
        database to.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class Log(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Retrieve a log created
    by the logger.
    """
    def __init__(self, undef_enabled=True):
        super(Log, self).__init__()
        self._type = ("Log", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Log, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Log, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Log):
            return False
        return super(Log, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ApplyVersionParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to upgrade.
    """
    def __init__(self, undef_enabled=True):
        super(ApplyVersionParameters, self).__init__()
        self._type = ("ApplyVersionParameters", True)
        self._defer = (self.__undef__, True)
        self._enable_sources_on_failure = (self.__undef__, True)
        self._quiesce_sources = (self.__undef__, True)
        self._reboot = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ApplyVersionParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._defer = (data.get("defer", obj.__undef__), dirty)
        if obj._defer[0] is not None and obj._defer[0] is not obj.__undef__:
            assert isinstance(obj._defer[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._defer[0]))
            common.validate_format(obj._defer[0], "None", None, None)
        obj._enable_sources_on_failure = (data.get("enableSourcesOnFailure", obj.__undef__), dirty)
        if obj._enable_sources_on_failure[0] is not None and obj._enable_sources_on_failure[0] is not obj.__undef__:
            assert isinstance(obj._enable_sources_on_failure[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enable_sources_on_failure[0]))
            common.validate_format(obj._enable_sources_on_failure[0], "None", None, None)
        obj._quiesce_sources = (data.get("quiesceSources", obj.__undef__), dirty)
        if obj._quiesce_sources[0] is not None and obj._quiesce_sources[0] is not obj.__undef__:
            assert isinstance(obj._quiesce_sources[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._quiesce_sources[0]))
            common.validate_format(obj._quiesce_sources[0], "None", None, None)
        obj._reboot = (data.get("reboot", obj.__undef__), dirty)
        if obj._reboot[0] is not None and obj._reboot[0] is not obj.__undef__:
            assert isinstance(obj._reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._reboot[0]))
            common.validate_format(obj._reboot[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ApplyVersionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "defer" == "type" or (self.defer is not self.__undef__ and not (dirty and not self._defer[1])):
            dct["defer"] = dictify(self.defer)
        if "enable_sources_on_failure" == "type" or (self.enable_sources_on_failure is not self.__undef__ and not (dirty and not self._enable_sources_on_failure[1])):
            dct["enableSourcesOnFailure"] = dictify(self.enable_sources_on_failure)
        if "quiesce_sources" == "type" or (self.quiesce_sources is not self.__undef__ and not (dirty and not self._quiesce_sources[1])):
            dct["quiesceSources"] = dictify(self.quiesce_sources)
        if "reboot" == "type" or (self.reboot is not self.__undef__ and not (dirty and not self._reboot[1])):
            dct["reboot"] = dictify(self.reboot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._defer = (self._defer[0], True)
        self._enable_sources_on_failure = (self._enable_sources_on_failure[0], True)
        self._quiesce_sources = (self._quiesce_sources[0], True)
        self._reboot = (self._reboot[0], True)

    def is_dirty(self):
        return any([self._defer[1], self._enable_sources_on_failure[1], self._quiesce_sources[1], self._reboot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ApplyVersionParameters):
            return False
        return super(ApplyVersionParameters, self).__eq__(other) and \
               self.defer == other.defer and \
               self.enable_sources_on_failure == other.enable_sources_on_failure and \
               self.quiesce_sources == other.quiesce_sources and \
               self.reboot == other.reboot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def defer(self):
        """
        If true, the Delphix Engine is upgraded without updating the OS
        software. The operation will fail gracefully if the upgrade version
        requires a version of the OS that is newer than what is currently
        running. The OS software can subsequently be upgraded by applying any
        version and setting defer to false. It is possible to catch up to the
        current OS version on a previously deferred upgrade by re-applying the
        running version with a defer setting of false.

        :rtype: ``bool``
        """
        return self._defer[0]

    @defer.setter
    def defer(self, value):
        self._defer = (value, True)

    @property
    def enable_sources_on_failure(self):
        """
        *(default value: True)* This property governs whether or not data
        sources are re-enabled or left disabled in the event that upgrade fails
        before the Delphix Engine is restarted.

        :rtype: ``bool``
        """
        return self._enable_sources_on_failure[0]

    @enable_sources_on_failure.setter
    def enable_sources_on_failure(self, value):
        self._enable_sources_on_failure = (value, True)

    @property
    def quiesce_sources(self):
        """
        *(default value: True)* If true, all data sources (VDBs and dSources)
        are automatically disabled prior to upgrade, and re-enabled after
        upgrade. If any source cannot be disabled, then the upgrade fails and
        the recovery semantics are governed by the "enableSourcesOnFailure"
        property.

        :rtype: ``bool``
        """
        return self._quiesce_sources[0]

    @quiesce_sources.setter
    def quiesce_sources(self, value):
        self._quiesce_sources = (value, True)

    @property
    def reboot(self):
        """
        *(default value: True)* If true, the system reboots immediately after
        upgrade. If false, the system is shutdown.

        :rtype: ``bool``
        """
        return self._reboot[0]

    @reboot.setter
    def reboot(self, value):
        self._reboot = (value, True)

class TimeflowPointParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters indicating
    a TimeFlow point to use as input to database operations.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointParameters, self).__init__()
        self._type = ("TimeflowPointParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointParameters):
            return False
        return super(TimeflowPointParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NetworkRoute(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* IP routing table.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkRoute, self).__init__()
        self._type = ("NetworkRoute", True)
        self._out_interface = (self.__undef__, True)
        self._destination = (self.__undef__, True)
        self._data_node = (self.__undef__, True)
        self._gateway = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkRoute, cls).from_dict(data, dirty, undef_enabled)
        obj._out_interface = (data.get("outInterface", obj.__undef__), dirty)
        if obj._out_interface[0] is not None and obj._out_interface[0] is not obj.__undef__:
            assert isinstance(obj._out_interface[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._out_interface[0]))
            common.validate_format(obj._out_interface[0], "objectReference", None, None)
        obj._destination = (data.get("destination", obj.__undef__), dirty)
        if obj._destination[0] is not None and obj._destination[0] is not obj.__undef__:
            assert isinstance(obj._destination[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination[0]))
            common.validate_format(obj._destination[0], "routeDestination", None, None)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        obj._gateway = (data.get("gateway", obj.__undef__), dirty)
        if obj._gateway[0] is not None and obj._gateway[0] is not obj.__undef__:
            assert isinstance(obj._gateway[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._gateway[0]))
            common.validate_format(obj._gateway[0], "ipAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkRoute, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "out_interface" == "type" or (self.out_interface is not self.__undef__ and not (dirty and not self._out_interface[1])):
            dct["outInterface"] = dictify(self.out_interface)
        if "destination" == "type" or (self.destination is not self.__undef__ and not (dirty and not self._destination[1])):
            dct["destination"] = dictify(self.destination)
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        if "gateway" == "type" or (self.gateway is not self.__undef__ and not (dirty and not self._gateway[1])):
            dct["gateway"] = dictify(self.gateway)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._out_interface = (self._out_interface[0], True)
        self._destination = (self._destination[0], True)
        self._data_node = (self._data_node[0], True)
        self._gateway = (self._gateway[0], True)

    def is_dirty(self):
        return any([self._out_interface[1], self._destination[1], self._data_node[1], self._gateway[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkRoute):
            return False
        return super(NetworkRoute, self).__eq__(other) and \
               self.out_interface == other.out_interface and \
               self.destination == other.destination and \
               self.data_node == other.data_node and \
               self.gateway == other.gateway

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def out_interface(self):
        """
        Output interface to use for the route.

        :rtype: ``basestring``
        """
        return self._out_interface[0]

    @out_interface.setter
    def out_interface(self, value):
        self._out_interface = (value, True)

    @property
    def destination(self):
        """
        Destination for the route in Classless Inter-Domain Routing (CIDR)
        notation or the keyword 'default'.

        :rtype: ``basestring``
        """
        return self._destination[0]

    @destination.setter
    def destination(self, value):
        self._destination = (value, True)

    @property
    def data_node(self):
        """
        The node where this route exists.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

    @property
    def gateway(self):
        """
        Next hop for the route.

        :rtype: ``basestring``
        """
        return self._gateway[0]

    @gateway.setter
    def gateway(self, value):
        self._gateway = (value, True)

class SyncParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to sync requests.
    """
    def __init__(self, undef_enabled=True):
        super(SyncParameters, self).__init__()
        self._type = ("SyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyncParameters):
            return False
        return super(SyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SourceEnvironmentCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used
    for source environment create parameters.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnvironmentCreateParameters, self).__init__()
        self._type = ("SourceEnvironmentCreateParameters", True)
        self._primary_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnvironmentCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "primaryUser" in data and data["primaryUser"] is not None:
            obj._primary_user = (factory.create_object(data["primaryUser"], "EnvironmentUser"), dirty)
            factory.validate_type(obj._primary_user[0], "EnvironmentUser")
        else:
            obj._primary_user = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnvironmentCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "primary_user" == "type" or (self.primary_user is not self.__undef__ and not (dirty and not self._primary_user[1])):
            dct["primaryUser"] = dictify(self.primary_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._primary_user = (self._primary_user[0], True)

    def is_dirty(self):
        return any([self._primary_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnvironmentCreateParameters):
            return False
        return super(SourceEnvironmentCreateParameters, self).__eq__(other) and \
               self.primary_user == other.primary_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def primary_user(self):
        """
        The primary user associated with the environment.

        :rtype: :py:class:`v1_8_1.web.vo.EnvironmentUser`
        """
        return self._primary_user[0]

    @primary_user.setter
    def primary_user(self, value):
        self._primary_user = (value, True)

class ProxyConfiguration(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Proxy configuration
    for a specific protocol.
    """
    def __init__(self, undef_enabled=True):
        super(ProxyConfiguration, self).__init__()
        self._type = ("ProxyConfiguration", True)
        self._username = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProxyConfiguration, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProxyConfiguration, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._host = (self._host[0], True)
        self._password = (self._password[0], True)
        self._enabled = (self._enabled[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._host[1], self._password[1], self._enabled[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProxyConfiguration):
            return False
        return super(ProxyConfiguration, self).__eq__(other) and \
               self.username == other.username and \
               self.host == other.host and \
               self.password == other.password and \
               self.enabled == other.enabled and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        If authentication is required, the username to use when connecting to
        the proxy.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def host(self):
        """
        Host or IP address to use as proxy.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def password(self):
        """
        If authentication is required, the password to use when connecting to
        the proxy.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def enabled(self):
        """
        True if the proxy is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def port(self):
        """
        Port to use when connecting to the proxy host.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class ChecklistItem(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Generic checklist
    item.
    """
    def __init__(self, undef_enabled=True):
        super(ChecklistItem, self).__init__()
        self._type = ("ChecklistItem", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ChecklistItem, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ChecklistItem, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ChecklistItem):
            return False
        return super(ChecklistItem, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SnapshotSpaceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Input to the operation
    to determine how much space is used by a set of snapshots.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotSpaceParameters, self).__init__()
        self._type = ("SnapshotSpaceParameters", True)
        self._object_references = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotSpaceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "objectReferences" not in data:
            raise ValueError("Missing required property \"objectReferences\".")
        obj._object_references = []
        for item in data.get("objectReferences") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._object_references.append(item)
        obj._object_references = (obj._object_references, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotSpaceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_references" == "type" or (self.object_references is not self.__undef__ and not (dirty and not self._object_references[1])):
            dct["objectReferences"] = dictify(self.object_references)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_references = (self._object_references[0], True)

    def is_dirty(self):
        return any([self._object_references[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotSpaceParameters):
            return False
        return super(SnapshotSpaceParameters, self).__eq__(other) and \
               self.object_references == other.object_references

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_references(self):
        """
        FilesystemObjects to query, in canonical object reference form.

        :rtype: ``list`` of ``basestring``
        """
        return self._object_references[0]

    @object_references.setter
    def object_references(self, value):
        self._object_references = (value, True)

class SourceConfigConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Mechanism to test JDBC
    connectivity to source configs.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConfigConnectivity, self).__init__()
        self._type = ("SourceConfigConnectivity", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConfigConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConfigConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConfigConnectivity):
            return False
        return super(SourceConfigConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        Database username.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        Database password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

class JSUserUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a Jet Stream user.
    """
    def __init__(self, undef_enabled=True):
        super(JSUserUsageData, self).__init__()
        self._type = ("JSUserUsageData", True)
        self._num_containers = (self.__undef__, True)
        self._total = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSUserUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._num_containers = (data.get("numContainers", obj.__undef__), dirty)
        if obj._num_containers[0] is not None and obj._num_containers[0] is not obj.__undef__:
            assert isinstance(obj._num_containers[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_containers[0]))
            common.validate_format(obj._num_containers[0], "None", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSUserUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "num_containers" == "type" or (self.num_containers is not self.__undef__ and not (dirty and not self._num_containers[1])):
            dct["numContainers"] = dictify(self.num_containers)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._num_containers = (self._num_containers[0], True)
        self._total = (self._total[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._num_containers[1], self._total[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSUserUsageData):
            return False
        return super(JSUserUsageData, self).__eq__(other) and \
               self.num_containers == other.num_containers and \
               self.total == other.total and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def num_containers(self):
        """
        The number of containers owned by this user.

        :rtype: ``int``
        """
        return self._num_containers[0]

    @num_containers.setter
    def num_containers(self, value):
        self._num_containers = (value, True)

    @property
    def total(self):
        """
        The amount of space referenced by the data containers owned by this
        user.

        :rtype: ``float``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

    @property
    def user(self):
        """
        The user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleDatabaseStatsSection(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Oracle database
    performance statistics for a specific section.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseStatsSection, self).__init__()
        self._type = ("OracleDatabaseStatsSection", True)
        self._row_values = (self.__undef__, True)
        self._column_headers = (self.__undef__, True)
        self._section_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseStatsSection, cls).from_dict(data, dirty, undef_enabled)
        obj._row_values = []
        for item in data.get("rowValues") or []:
            obj._row_values.append(factory.create_object(item))
            factory.validate_type(obj._row_values[-1], "OracleDatabaseStatistic")
        obj._row_values = (obj._row_values, dirty)
        obj._column_headers = []
        for item in data.get("columnHeaders") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._column_headers.append(item)
        obj._column_headers = (obj._column_headers, dirty)
        obj._section_name = (data.get("sectionName", obj.__undef__), dirty)
        if obj._section_name[0] is not None and obj._section_name[0] is not obj.__undef__:
            assert isinstance(obj._section_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._section_name[0]))
            common.validate_format(obj._section_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseStatsSection, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "row_values" == "type" or (self.row_values is not self.__undef__ and not (dirty and not self._row_values[1])):
            dct["rowValues"] = dictify(self.row_values)
        if "column_headers" == "type" or (self.column_headers is not self.__undef__ and not (dirty and not self._column_headers[1])):
            dct["columnHeaders"] = dictify(self.column_headers)
        if "section_name" == "type" or (self.section_name is not self.__undef__ and not (dirty and not self._section_name[1])):
            dct["sectionName"] = dictify(self.section_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._row_values = (self._row_values[0], True)
        self._column_headers = (self._column_headers[0], True)
        self._section_name = (self._section_name[0], True)

    def is_dirty(self):
        return any([self._row_values[1], self._column_headers[1], self._section_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseStatsSection):
            return False
        return super(OracleDatabaseStatsSection, self).__eq__(other) and \
               self.row_values == other.row_values and \
               self.column_headers == other.column_headers and \
               self.section_name == other.section_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def row_values(self):
        """
        List of statistic rows corresponding to column headers.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleDatabaseStatistic`
        """
        return self._row_values[0]

    @row_values.setter
    def row_values(self, value):
        self._row_values = (value, True)

    @property
    def column_headers(self):
        """
        List of statistic column headers.

        :rtype: ``list`` of ``basestring``
        """
        return self._column_headers[0]

    @column_headers.setter
    def column_headers(self, value):
        self._column_headers = (value, True)

    @property
    def section_name(self):
        """
        Database statistic section name.

        :rtype: ``basestring``
        """
        return self._section_name[0]

    @section_name.setter
    def section_name(self, value):
        self._section_name = (value, True)

class BasePlatformParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Base schema for
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(BasePlatformParameters, self).__init__()
        self._type = ("BasePlatformParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BasePlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BasePlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BasePlatformParameters):
            return False
        return super(BasePlatformParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class HostCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used
    for the add host operation.
    """
    def __init__(self, undef_enabled=True):
        super(HostCreateParameters, self).__init__()
        self._type = ("HostCreateParameters", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "host" in data and data["host"] is not None:
            obj._host = (factory.create_object(data["host"], "Host"), dirty)
            factory.validate_type(obj._host[0], "Host")
        else:
            obj._host = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostCreateParameters):
            return False
        return super(HostCreateParameters, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The host object.

        :rtype: :py:class:`v1_8_1.web.vo.Host`
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class NetworkTestParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The base type for
    parameters passed to a network test execution.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkTestParameters, self).__init__()
        self._type = ("NetworkTestParameters", True)
        self._remote_host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkTestParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_host = (data.get("remoteHost", obj.__undef__), dirty)
        if obj._remote_host[0] is not None and obj._remote_host[0] is not obj.__undef__:
            assert isinstance(obj._remote_host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_host[0]))
            common.validate_format(obj._remote_host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkTestParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_host" == "type" or (self.remote_host is not self.__undef__ and not (dirty and not self._remote_host[1])):
            dct["remoteHost"] = dictify(self.remote_host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_host = (self._remote_host[0], True)

    def is_dirty(self):
        return any([self._remote_host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkTestParameters):
            return False
        return super(NetworkTestParameters, self).__eq__(other) and \
               self.remote_host == other.remote_host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_host(self):
        """
        The remote host for the test. The host must be part of an existing
        environment.

        :rtype: ``basestring``
        """
        return self._remote_host[0]

    @remote_host.setter
    def remote_host(self, value):
        self._remote_host = (value, True)

class FractionPlugParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input when transporting a transportable tablespace.
    """
    def __init__(self, undef_enabled=True):
        super(FractionPlugParameters, self).__init__()
        self._type = ("FractionPlugParameters", True)
        self._schemas_prefix = (self.__undef__, True)
        self._tablespaces_prefix = (self.__undef__, True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FractionPlugParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._schemas_prefix = (data.get("schemasPrefix", obj.__undef__), dirty)
        if obj._schemas_prefix[0] is not None and obj._schemas_prefix[0] is not obj.__undef__:
            assert isinstance(obj._schemas_prefix[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._schemas_prefix[0]))
            common.validate_format(obj._schemas_prefix[0], "None", None, 28)
        obj._tablespaces_prefix = (data.get("tablespacesPrefix", obj.__undef__), dirty)
        if obj._tablespaces_prefix[0] is not None and obj._tablespaces_prefix[0] is not obj.__undef__:
            assert isinstance(obj._tablespaces_prefix[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tablespaces_prefix[0]))
            common.validate_format(obj._tablespaces_prefix[0], "None", None, 28)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FractionPlugParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "schemas_prefix" == "type" or (self.schemas_prefix is not self.__undef__ and not (dirty and not self._schemas_prefix[1])):
            dct["schemasPrefix"] = dictify(self.schemas_prefix)
        if "tablespaces_prefix" == "type" or (self.tablespaces_prefix is not self.__undef__ and not (dirty and not self._tablespaces_prefix[1])):
            dct["tablespacesPrefix"] = dictify(self.tablespaces_prefix)
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._schemas_prefix = (self._schemas_prefix[0], True)
        self._tablespaces_prefix = (self._tablespaces_prefix[0], True)
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._schemas_prefix[1], self._tablespaces_prefix[1], self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FractionPlugParameters):
            return False
        return super(FractionPlugParameters, self).__eq__(other) and \
               self.schemas_prefix == other.schemas_prefix and \
               self.tablespaces_prefix == other.tablespaces_prefix and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def schemas_prefix(self):
        """
        Optional prefix to add to schemas being moved into warehouse.

        :rtype: ``basestring``
        """
        return self._schemas_prefix[0]

    @schemas_prefix.setter
    def schemas_prefix(self, value):
        self._schemas_prefix = (value, True)

    @property
    def tablespaces_prefix(self):
        """
        Optional prefix to add to tablespaces being moved into warehouse.

        :rtype: ``basestring``
        """
        return self._tablespaces_prefix[0]

    @tablespaces_prefix.setter
    def tablespaces_prefix(self, value):
        self._tablespaces_prefix = (value, True)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to base provisioning
        on.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class SourceRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime properties of
    a linked or virtual source database.
    """
    def __init__(self, undef_enabled=True):
        super(SourceRuntime, self).__init__()
        self._type = ("SourceRuntime", True)
        self._accessible = (self.__undef__, True)
        self._database_size = (self.__undef__, True)
        self._status = (self.__undef__, True)
        self._not_accessible_reason = (self.__undef__, True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._accessible = (data.get("accessible", obj.__undef__), dirty)
        if obj._accessible[0] is not None and obj._accessible[0] is not obj.__undef__:
            assert isinstance(obj._accessible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._accessible[0]))
            common.validate_format(obj._accessible[0], "None", None, None)
        obj._database_size = (data.get("databaseSize", obj.__undef__), dirty)
        if obj._database_size[0] is not None and obj._database_size[0] is not obj.__undef__:
            assert isinstance(obj._database_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._database_size[0]))
            common.validate_format(obj._database_size[0], "None", None, None)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'RUNNING', u'INACTIVE', u'PENDING', u'CANCELED', u'FAILED', u'CHECKING', u'UNKNOWN'], "Expected enum [u'RUNNING', u'INACTIVE', u'PENDING', u'CANCELED', u'FAILED', u'CHECKING', u'UNKNOWN'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._not_accessible_reason = (data.get("notAccessibleReason", obj.__undef__), dirty)
        if obj._not_accessible_reason[0] is not None and obj._not_accessible_reason[0] is not obj.__undef__:
            assert isinstance(obj._not_accessible_reason[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._not_accessible_reason[0]))
            common.validate_format(obj._not_accessible_reason[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._enabled[0]))
            assert obj._enabled[0] in [u'ENABLED', u'PARTIAL', u'DISABLED'], "Expected enum [u'ENABLED', u'PARTIAL', u'DISABLED'] but got %s" % obj._enabled[0]
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "accessible" == "type" or (self.accessible is not self.__undef__ and not (dirty and not self._accessible[1])):
            dct["accessible"] = dictify(self.accessible)
        if "database_size" == "type" or (self.database_size is not self.__undef__ and not (dirty and not self._database_size[1])):
            dct["databaseSize"] = dictify(self.database_size)
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "not_accessible_reason" == "type" or (self.not_accessible_reason is not self.__undef__ and not (dirty and not self._not_accessible_reason[1])):
            dct["notAccessibleReason"] = dictify(self.not_accessible_reason)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._accessible = (self._accessible[0], True)
        self._database_size = (self._database_size[0], True)
        self._status = (self._status[0], True)
        self._not_accessible_reason = (self._not_accessible_reason[0], True)
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._accessible[1], self._database_size[1], self._status[1], self._not_accessible_reason[1], self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceRuntime):
            return False
        return super(SourceRuntime, self).__eq__(other) and \
               self.accessible == other.accessible and \
               self.database_size == other.database_size and \
               self.status == other.status and \
               self.not_accessible_reason == other.not_accessible_reason and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def accessible(self):
        """
        True if the source is JDBC accessible. If false then no properties can
        be retrieved.

        :rtype: ``bool``
        """
        return self._accessible[0]

    @accessible.setter
    def accessible(self, value):
        self._accessible = (value, True)

    @property
    def database_size(self):
        """
        Size of the database in bytes.

        :rtype: ``float``
        """
        return self._database_size[0]

    @database_size.setter
    def database_size(self, value):
        self._database_size = (value, True)

    @property
    def status(self):
        """
        Status of the source. 'Unknown' if all attempts to connect to the
        source failed. *(permitted values: RUNNING, INACTIVE, PENDING,
        CANCELED, FAILED, CHECKING, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def not_accessible_reason(self):
        """
        The reason why the source is not JDBC accessible.

        :rtype: ``basestring``
        """
        return self._not_accessible_reason[0]

    @not_accessible_reason.setter
    def not_accessible_reason(self, value):
        self._not_accessible_reason = (value, True)

    @property
    def enabled(self):
        """
        Status indicating whether the source is enabled. A source has a
        'PARTIAL' status if its sub-sources are not all enabled. *(permitted
        values: ENABLED, PARTIAL, DISABLED)*

        :rtype: ``basestring``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class RegistrationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Credentials used to
    register the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(RegistrationParameters, self).__init__()
        self._type = ("RegistrationParameters", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RegistrationParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RegistrationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RegistrationParameters):
            return False
        return super(RegistrationParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        Username to send to registration portal.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        Password to send to registration portal.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

class JSBranchCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    create a Jet Stream branch.
    """
    def __init__(self, undef_enabled=True):
        super(JSBranchCreateParameters, self).__init__()
        self._type = ("JSBranchCreateParameters", True)
        self._data_container = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._timeline_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBranchCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "dataContainer" not in data:
            raise ValueError("Missing required property \"dataContainer\".")
        obj._data_container = (data.get("dataContainer", obj.__undef__), dirty)
        if obj._data_container[0] is not None and obj._data_container[0] is not obj.__undef__:
            assert isinstance(obj._data_container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_container[0]))
            common.validate_format(obj._data_container[0], "objectReference", None, None)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        if "timelinePointParameters" not in data:
            raise ValueError("Missing required property \"timelinePointParameters\".")
        if "timelinePointParameters" in data and data["timelinePointParameters"] is not None:
            obj._timeline_point_parameters = (factory.create_object(data["timelinePointParameters"], "JSTimelinePointParameters"), dirty)
            factory.validate_type(obj._timeline_point_parameters[0], "JSTimelinePointParameters")
        else:
            obj._timeline_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBranchCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_container" == "type" or (self.data_container is not self.__undef__ and not (dirty and not self._data_container[1])):
            dct["dataContainer"] = dictify(self.data_container)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "timeline_point_parameters" == "type" or (self.timeline_point_parameters is not self.__undef__ and not (dirty and not self._timeline_point_parameters[1])):
            dct["timelinePointParameters"] = dictify(self.timeline_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_container = (self._data_container[0], True)
        self._name = (self._name[0], True)
        self._timeline_point_parameters = (self._timeline_point_parameters[0], True)

    def is_dirty(self):
        return any([self._data_container[1], self._name[1], self._timeline_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBranchCreateParameters):
            return False
        return super(JSBranchCreateParameters, self).__eq__(other) and \
               self.data_container == other.data_container and \
               self.name == other.name and \
               self.timeline_point_parameters == other.timeline_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_container(self):
        """
        A reference to the data container to create this branch on.

        :rtype: ``basestring``
        """
        return self._data_container[0]

    @data_container.setter
    def data_container(self, value):
        self._data_container = (value, True)

    @property
    def name(self):
        """
        The name of the branch.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def timeline_point_parameters(self):
        """
        The Jet Stream data timeline point from which the branch will be
        created.

        :rtype: :py:class:`v1_8_1.web.vo.JSTimelinePointParameters`
        """
        return self._timeline_point_parameters[0]

    @timeline_point_parameters.setter
    def timeline_point_parameters(self, value):
        self._timeline_point_parameters = (value, True)

class TimeflowRangeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to fetch TimeFlow ranges.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRangeParameters, self).__init__()
        self._type = ("TimeflowRangeParameters", True)
        self._end_point = (self.__undef__, True)
        self._start_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRangeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "endPoint" in data and data["endPoint"] is not None:
            obj._end_point = (factory.create_object(data["endPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._end_point[0], "TimeflowPoint")
        else:
            obj._end_point = (obj.__undef__, dirty)
        if "startPoint" in data and data["startPoint"] is not None:
            obj._start_point = (factory.create_object(data["startPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._start_point[0], "TimeflowPoint")
        else:
            obj._start_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRangeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_point" == "type" or (self.end_point is not self.__undef__ and not (dirty and not self._end_point[1])):
            dct["endPoint"] = dictify(self.end_point)
        if "start_point" == "type" or (self.start_point is not self.__undef__ and not (dirty and not self._start_point[1])):
            dct["startPoint"] = dictify(self.start_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_point = (self._end_point[0], True)
        self._start_point = (self._start_point[0], True)

    def is_dirty(self):
        return any([self._end_point[1], self._start_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRangeParameters):
            return False
        return super(TimeflowRangeParameters, self).__eq__(other) and \
               self.end_point == other.end_point and \
               self.start_point == other.start_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_point(self):
        """
        The ending TimeFlow point of the time period to search for TimeFlow
        ranges.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._end_point[0]

    @end_point.setter
    def end_point(self, value):
        self._end_point = (value, True)

    @property
    def start_point(self):
        """
        The starting TimeFlow point of the time period to search for TimeFlow
        ranges.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._start_point[0]

    @start_point.setter
    def start_point(self, value):
        self._start_point = (value, True)

class PreProvisioningRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime properties for
    pre-provisioning of a MSSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(PreProvisioningRuntime, self).__init__()
        self._type = ("PreProvisioningRuntime", True)
        self._status = (self.__undef__, True)
        self._last_update_timestamp = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._pending_action = (self.__undef__, True)
        self._pre_provisioning_state = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PreProvisioningRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._last_update_timestamp = (data.get("lastUpdateTimestamp", obj.__undef__), dirty)
        if obj._last_update_timestamp[0] is not None and obj._last_update_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._last_update_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_update_timestamp[0]))
            common.validate_format(obj._last_update_timestamp[0], "None", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._pending_action = (data.get("pendingAction", obj.__undef__), dirty)
        if obj._pending_action[0] is not None and obj._pending_action[0] is not obj.__undef__:
            assert isinstance(obj._pending_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pending_action[0]))
            common.validate_format(obj._pending_action[0], "None", None, None)
        obj._pre_provisioning_state = (data.get("preProvisioningState", obj.__undef__), dirty)
        if obj._pre_provisioning_state[0] is not None and obj._pre_provisioning_state[0] is not obj.__undef__:
            assert isinstance(obj._pre_provisioning_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_provisioning_state[0]))
            assert obj._pre_provisioning_state[0] in [u'ACTIVE', u'INACTIVE', u'FAULTED', u'UNKNOWN'], "Expected enum [u'ACTIVE', u'INACTIVE', u'FAULTED', u'UNKNOWN'] but got %s" % obj._pre_provisioning_state[0]
            common.validate_format(obj._pre_provisioning_state[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PreProvisioningRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "last_update_timestamp" == "type" or (self.last_update_timestamp is not self.__undef__ and not (dirty and not self._last_update_timestamp[1])):
            dct["lastUpdateTimestamp"] = dictify(self.last_update_timestamp)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "pending_action" == "type" or (self.pending_action is not self.__undef__ and not (dirty and not self._pending_action[1])):
            dct["pendingAction"] = dictify(self.pending_action)
        if "pre_provisioning_state" == "type" or (self.pre_provisioning_state is not self.__undef__ and not (dirty and not self._pre_provisioning_state[1])):
            dct["preProvisioningState"] = dictify(self.pre_provisioning_state)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._last_update_timestamp = (self._last_update_timestamp[0], True)
        self._response = (self._response[0], True)
        self._pending_action = (self._pending_action[0], True)
        self._pre_provisioning_state = (self._pre_provisioning_state[0], True)

    def is_dirty(self):
        return any([self._status[1], self._last_update_timestamp[1], self._response[1], self._pending_action[1], self._pre_provisioning_state[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PreProvisioningRuntime):
            return False
        return super(PreProvisioningRuntime, self).__eq__(other) and \
               self.status == other.status and \
               self.last_update_timestamp == other.last_update_timestamp and \
               self.response == other.response and \
               self.pending_action == other.pending_action and \
               self.pre_provisioning_state == other.pre_provisioning_state

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the pre-provisioning run.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def last_update_timestamp(self):
        """
        Timestamp of the last update to the status.

        :rtype: ``basestring``
        """
        return self._last_update_timestamp[0]

    @last_update_timestamp.setter
    def last_update_timestamp(self, value):
        self._last_update_timestamp = (value, True)

    @property
    def response(self):
        """
        Response taken based on the status of the pre-provisioning run.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def pending_action(self):
        """
        User action required to resolve any error that the pre-provisioning run
        encountered.

        :rtype: ``basestring``
        """
        return self._pending_action[0]

    @pending_action.setter
    def pending_action(self, value):
        self._pending_action = (value, True)

    @property
    def pre_provisioning_state(self):
        """
        Indicates the current state of pre-provisioning for the database.
        *(permitted values: ACTIVE, INACTIVE, FAULTED, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._pre_provisioning_state[0]

    @pre_provisioning_state.setter
    def pre_provisioning_state(self, value):
        self._pre_provisioning_state = (value, True)

class CreateMaskingJobTransformationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    parameters to create a transformation for a provided Masking Job.
    """
    def __init__(self, undef_enabled=True):
        super(CreateMaskingJobTransformationParameters, self).__init__()
        self._type = ("CreateMaskingJobTransformationParameters", True)
        self._container = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CreateMaskingJobTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "Container"), dirty)
            factory.validate_type(obj._container[0], "Container")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CreateMaskingJobTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._repository = (self._repository[0], True)

    def is_dirty(self):
        return any([self._container[1], self._environment_user[1], self._repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CreateMaskingJobTransformationParameters):
            return False
        return super(CreateMaskingJobTransformationParameters, self).__eq__(other) and \
               self.container == other.container and \
               self.environment_user == other.environment_user and \
               self.repository == other.repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the masked data associated with the
        newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.Container`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def environment_user(self):
        """
        Reference to the user used during application of the transformation.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def repository(self):
        """
        Reference to the repository used during application of the
        transformation.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

class ASEHostEnvironmentParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* SAP ASE host
    environment parameters.
    """
    def __init__(self, undef_enabled=True):
        super(ASEHostEnvironmentParameters, self).__init__()
        self._type = ("ASEHostEnvironmentParameters", True)
        self._credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEHostEnvironmentParameters, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEHostEnvironmentParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._db_user = (self._db_user[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._db_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEHostEnvironmentParameters):
            return False
        return super(ASEHostEnvironmentParameters, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.db_user == other.db_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def db_user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

class TimeRangeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input for methods requiring a time range.
    """
    def __init__(self, undef_enabled=True):
        super(TimeRangeParameters, self).__init__()
        self._type = ("TimeRangeParameters", True)
        self._end_time = (self.__undef__, True)
        self._start_time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeRangeParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeRangeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_time = (self._end_time[0], True)
        self._start_time = (self._start_time[0], True)

    def is_dirty(self):
        return any([self._end_time[1], self._start_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeRangeParameters):
            return False
        return super(TimeRangeParameters, self).__eq__(other) and \
               self.end_time == other.end_time and \
               self.start_time == other.start_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_time(self):
        """
        The date at the end of the period.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def start_time(self):
        """
        The date at the beginning of the period.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

class JSDataContainerDeleteParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    delete a data container.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainerDeleteParameters, self).__init__()
        self._type = ("JSDataContainerDeleteParameters", True)
        self._delete_data_sources = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainerDeleteParameters, cls).from_dict(data, dirty, undef_enabled)
        if "deleteDataSources" not in data:
            raise ValueError("Missing required property \"deleteDataSources\".")
        obj._delete_data_sources = (data.get("deleteDataSources", obj.__undef__), dirty)
        if obj._delete_data_sources[0] is not None and obj._delete_data_sources[0] is not obj.__undef__:
            assert isinstance(obj._delete_data_sources[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._delete_data_sources[0]))
            common.validate_format(obj._delete_data_sources[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainerDeleteParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "delete_data_sources" == "type" or (self.delete_data_sources is not self.__undef__ and not (dirty and not self._delete_data_sources[1])):
            dct["deleteDataSources"] = dictify(self.delete_data_sources)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._delete_data_sources = (self._delete_data_sources[0], True)

    def is_dirty(self):
        return any([self._delete_data_sources[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainerDeleteParameters):
            return False
        return super(JSDataContainerDeleteParameters, self).__eq__(other) and \
               self.delete_data_sources == other.delete_data_sources

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def delete_data_sources(self):
        """
        *(default value: True)* If this value is true, then delete the
        underlying data from all data sources.

        :rtype: ``bool``
        """
        return self._delete_data_sources[0]

    @delete_data_sources.setter
    def delete_data_sources(self, value):
        self._delete_data_sources = (value, True)

class HostOS(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The operating system
    information for the host.
    """
    def __init__(self, undef_enabled=True):
        super(HostOS, self).__init__()
        self._type = ("HostOS", True)
        self._kernel = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._release = (self.__undef__, True)
        self._timezone = (self.__undef__, True)
        self._distribution = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostOS, cls).from_dict(data, dirty, undef_enabled)
        obj._kernel = (data.get("kernel", obj.__undef__), dirty)
        if obj._kernel[0] is not None and obj._kernel[0] is not obj.__undef__:
            assert isinstance(obj._kernel[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._kernel[0]))
            common.validate_format(obj._kernel[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._release = (data.get("release", obj.__undef__), dirty)
        if obj._release[0] is not None and obj._release[0] is not obj.__undef__:
            assert isinstance(obj._release[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._release[0]))
            common.validate_format(obj._release[0], "None", None, None)
        obj._timezone = (data.get("timezone", obj.__undef__), dirty)
        if obj._timezone[0] is not None and obj._timezone[0] is not obj.__undef__:
            assert isinstance(obj._timezone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timezone[0]))
            common.validate_format(obj._timezone[0], "None", None, None)
        obj._distribution = (data.get("distribution", obj.__undef__), dirty)
        if obj._distribution[0] is not None and obj._distribution[0] is not obj.__undef__:
            assert isinstance(obj._distribution[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._distribution[0]))
            common.validate_format(obj._distribution[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostOS, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "kernel" == "type" or (self.kernel is not self.__undef__ and not (dirty and not self._kernel[1])):
            dct["kernel"] = dictify(self.kernel)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "release" == "type" or (self.release is not self.__undef__ and not (dirty and not self._release[1])):
            dct["release"] = dictify(self.release)
        if "timezone" == "type" or (self.timezone is not self.__undef__ and not (dirty and not self._timezone[1])):
            dct["timezone"] = dictify(self.timezone)
        if "distribution" == "type" or (self.distribution is not self.__undef__ and not (dirty and not self._distribution[1])):
            dct["distribution"] = dictify(self.distribution)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._kernel = (self._kernel[0], True)
        self._name = (self._name[0], True)
        self._version = (self._version[0], True)
        self._release = (self._release[0], True)
        self._timezone = (self._timezone[0], True)
        self._distribution = (self._distribution[0], True)

    def is_dirty(self):
        return any([self._kernel[1], self._name[1], self._version[1], self._release[1], self._timezone[1], self._distribution[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostOS):
            return False
        return super(HostOS, self).__eq__(other) and \
               self.kernel == other.kernel and \
               self.name == other.name and \
               self.version == other.version and \
               self.release == other.release and \
               self.timezone == other.timezone and \
               self.distribution == other.distribution

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def kernel(self):
        """
        The OS kernel.

        :rtype: ``basestring``
        """
        return self._kernel[0]

    @kernel.setter
    def kernel(self, value):
        self._kernel = (value, True)

    @property
    def name(self):
        """
        The OS name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def version(self):
        """
        The OS version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def release(self):
        """
        The OS release.

        :rtype: ``basestring``
        """
        return self._release[0]

    @release.setter
    def release(self, value):
        self._release = (value, True)

    @property
    def timezone(self):
        """
        The OS timezone.

        :rtype: ``basestring``
        """
        return self._timezone[0]

    @timezone.setter
    def timezone(self, value):
        self._timezone = (value, True)

    @property
    def distribution(self):
        """
        The OS distribution.

        :rtype: ``basestring``
        """
        return self._distribution[0]

    @distribution.setter
    def distribution(self, value):
        self._distribution = (value, True)

class StorageDeviceRemovalVerifyResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The .
    """
    def __init__(self, undef_enabled=True):
        super(StorageDeviceRemovalVerifyResult, self).__init__()
        self._type = ("StorageDeviceRemovalVerifyResult", True)
        self._new_free_bytes = (self.__undef__, True)
        self._old_mapping_memory = (self.__undef__, True)
        self._old_free_bytes = (self.__undef__, True)
        self._new_mapping_memory = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageDeviceRemovalVerifyResult, cls).from_dict(data, dirty, undef_enabled)
        obj._new_free_bytes = (data.get("newFreeBytes", obj.__undef__), dirty)
        if obj._new_free_bytes[0] is not None and obj._new_free_bytes[0] is not obj.__undef__:
            assert isinstance(obj._new_free_bytes[0], float), ("Expected one of [u'number'], but got %s" % type(obj._new_free_bytes[0]))
            common.validate_format(obj._new_free_bytes[0], "None", None, None)
        obj._old_mapping_memory = (data.get("oldMappingMemory", obj.__undef__), dirty)
        if obj._old_mapping_memory[0] is not None and obj._old_mapping_memory[0] is not obj.__undef__:
            assert isinstance(obj._old_mapping_memory[0], float), ("Expected one of [u'number'], but got %s" % type(obj._old_mapping_memory[0]))
            common.validate_format(obj._old_mapping_memory[0], "None", None, None)
        obj._old_free_bytes = (data.get("oldFreeBytes", obj.__undef__), dirty)
        if obj._old_free_bytes[0] is not None and obj._old_free_bytes[0] is not obj.__undef__:
            assert isinstance(obj._old_free_bytes[0], float), ("Expected one of [u'number'], but got %s" % type(obj._old_free_bytes[0]))
            common.validate_format(obj._old_free_bytes[0], "None", None, None)
        obj._new_mapping_memory = (data.get("newMappingMemory", obj.__undef__), dirty)
        if obj._new_mapping_memory[0] is not None and obj._new_mapping_memory[0] is not obj.__undef__:
            assert isinstance(obj._new_mapping_memory[0], float), ("Expected one of [u'number'], but got %s" % type(obj._new_mapping_memory[0]))
            common.validate_format(obj._new_mapping_memory[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageDeviceRemovalVerifyResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "new_free_bytes" == "type" or (self.new_free_bytes is not self.__undef__ and not (dirty and not self._new_free_bytes[1])):
            dct["newFreeBytes"] = dictify(self.new_free_bytes)
        if "old_mapping_memory" == "type" or (self.old_mapping_memory is not self.__undef__ and not (dirty and not self._old_mapping_memory[1])):
            dct["oldMappingMemory"] = dictify(self.old_mapping_memory)
        if "old_free_bytes" == "type" or (self.old_free_bytes is not self.__undef__ and not (dirty and not self._old_free_bytes[1])):
            dct["oldFreeBytes"] = dictify(self.old_free_bytes)
        if "new_mapping_memory" == "type" or (self.new_mapping_memory is not self.__undef__ and not (dirty and not self._new_mapping_memory[1])):
            dct["newMappingMemory"] = dictify(self.new_mapping_memory)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._new_free_bytes = (self._new_free_bytes[0], True)
        self._old_mapping_memory = (self._old_mapping_memory[0], True)
        self._old_free_bytes = (self._old_free_bytes[0], True)
        self._new_mapping_memory = (self._new_mapping_memory[0], True)

    def is_dirty(self):
        return any([self._new_free_bytes[1], self._old_mapping_memory[1], self._old_free_bytes[1], self._new_mapping_memory[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageDeviceRemovalVerifyResult):
            return False
        return super(StorageDeviceRemovalVerifyResult, self).__eq__(other) and \
               self.new_free_bytes == other.new_free_bytes and \
               self.old_mapping_memory == other.old_mapping_memory and \
               self.old_free_bytes == other.old_free_bytes and \
               self.new_mapping_memory == other.new_mapping_memory

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def new_free_bytes(self):
        """
        Free space of the pool if this device is removed, in bytes.

        :rtype: ``float``
        """
        return self._new_free_bytes[0]

    @new_free_bytes.setter
    def new_free_bytes(self, value):
        self._new_free_bytes = (value, True)

    @property
    def old_mapping_memory(self):
        """
        Amount of memory used by removal mappings before this device is
        removed, in bytes.

        :rtype: ``float``
        """
        return self._old_mapping_memory[0]

    @old_mapping_memory.setter
    def old_mapping_memory(self, value):
        self._old_mapping_memory = (value, True)

    @property
    def old_free_bytes(self):
        """
        Free space of the pool before this device is removed, in bytes.

        :rtype: ``float``
        """
        return self._old_free_bytes[0]

    @old_free_bytes.setter
    def old_free_bytes(self, value):
        self._old_free_bytes = (value, True)

    @property
    def new_mapping_memory(self):
        """
        Amount of memory to be used by mappings if this device is removed, in
        bytes.

        :rtype: ``float``
        """
        return self._new_mapping_memory[0]

    @new_mapping_memory.setter
    def new_mapping_memory(self, value):
        self._new_mapping_memory = (value, True)

class Datapoint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A datapoint recorded
    by the analytics system.
    """
    def __init__(self, undef_enabled=True):
        super(Datapoint, self).__init__()
        self._type = ("Datapoint", True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Datapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Datapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Datapoint):
            return False
        return super(Datapoint, self).__eq__(other) and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The time this datapoint was collected.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class SNMPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* SNMP configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SNMPConfig, self).__init__()
        self._type = ("SNMPConfig", True)
        self._location = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._severity = (self.__undef__, True)
        self._community = (self.__undef__, True)
        self._authorized_network = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SNMPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING', u'INFORMATIONAL'], "Expected enum [u'CRITICAL', u'WARNING', u'INFORMATIONAL'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        obj._community = (data.get("community", obj.__undef__), dirty)
        if obj._community[0] is not None and obj._community[0] is not obj.__undef__:
            assert isinstance(obj._community[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._community[0]))
            common.validate_format(obj._community[0], "None", None, None)
        obj._authorized_network = (data.get("authorizedNetwork", obj.__undef__), dirty)
        if obj._authorized_network[0] is not None and obj._authorized_network[0] is not obj.__undef__:
            assert isinstance(obj._authorized_network[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._authorized_network[0]))
            common.validate_format(obj._authorized_network[0], "cidrAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SNMPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if "community" == "type" or (self.community is not self.__undef__ and not (dirty and not self._community[1])):
            dct["community"] = dictify(self.community)
        if "authorized_network" == "type" or (self.authorized_network is not self.__undef__ and not (dirty and not self._authorized_network[1])):
            dct["authorizedNetwork"] = dictify(self.authorized_network)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._location = (self._location[0], True)
        self._enabled = (self._enabled[0], True)
        self._severity = (self._severity[0], True)
        self._community = (self._community[0], True)
        self._authorized_network = (self._authorized_network[0], True)

    def is_dirty(self):
        return any([self._location[1], self._enabled[1], self._severity[1], self._community[1], self._authorized_network[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SNMPConfig):
            return False
        return super(SNMPConfig, self).__eq__(other) and \
               self.location == other.location and \
               self.enabled == other.enabled and \
               self.severity == other.severity and \
               self.community == other.community and \
               self.authorized_network == other.authorized_network

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def location(self):
        """
        The physical location of this Delphix Engine (OID 1.3.6.1.2.1.1.6 -
        sysLocation).

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the SNMP service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def severity(self):
        """
        *(default value: WARNING)* SNMP trap severity. SNMP managers are only
        notified of events at or above this level. *(permitted values:
        CRITICAL, WARNING, INFORMATIONAL)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

    @property
    def community(self):
        """
        *(default value: public)* The community string that clients must
        provide when querying this server.

        :rtype: ``basestring``
        """
        return self._community[0]

    @community.setter
    def community(self, value):
        self._community = (value, True)

    @property
    def authorized_network(self):
        """
        *(default value: 0.0.0.0/0)* The network which is authorized to query
        this SNMP server, in CIDR notation. Toallow any client, then leave
        unset or set to 0.0.0.0/0. To block all clients, set to 127.0.0.1/8.

        :rtype: ``basestring``
        """
        return self._authorized_network[0]

    @authorized_network.setter
    def authorized_network(self, value):
        self._authorized_network = (value, True)

class FilesystemLayout(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The filesystem
    configuration of a database.
    """
    def __init__(self, undef_enabled=True):
        super(FilesystemLayout, self).__init__()
        self._type = ("FilesystemLayout", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FilesystemLayout):
            return False
        return super(FilesystemLayout, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SMTPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* SMTP configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SMTPConfig, self).__init__()
        self._type = ("SMTPConfig", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._send_timeout = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._tls_enabled = (self.__undef__, True)
        self._server = (self.__undef__, True)
        self._authentication_enabled = (self.__undef__, True)
        self._from_address = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SMTPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", None, None)
        obj._send_timeout = (data.get("sendTimeout", obj.__undef__), dirty)
        if obj._send_timeout[0] is not None and obj._send_timeout[0] is not obj.__undef__:
            assert isinstance(obj._send_timeout[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._send_timeout[0]))
            common.validate_format(obj._send_timeout[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._tls_enabled = (data.get("tlsEnabled", obj.__undef__), dirty)
        if obj._tls_enabled[0] is not None and obj._tls_enabled[0] is not obj.__undef__:
            assert isinstance(obj._tls_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._tls_enabled[0]))
            common.validate_format(obj._tls_enabled[0], "None", None, None)
        obj._server = (data.get("server", obj.__undef__), dirty)
        if obj._server[0] is not None and obj._server[0] is not obj.__undef__:
            assert isinstance(obj._server[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server[0]))
            common.validate_format(obj._server[0], "host", None, None)
        obj._authentication_enabled = (data.get("authenticationEnabled", obj.__undef__), dirty)
        if obj._authentication_enabled[0] is not None and obj._authentication_enabled[0] is not obj.__undef__:
            assert isinstance(obj._authentication_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._authentication_enabled[0]))
            common.validate_format(obj._authentication_enabled[0], "None", None, None)
        obj._from_address = (data.get("fromAddress", obj.__undef__), dirty)
        if obj._from_address[0] is not None and obj._from_address[0] is not obj.__undef__:
            assert isinstance(obj._from_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._from_address[0]))
            common.validate_format(obj._from_address[0], "email", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SMTPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "send_timeout" == "type" or (self.send_timeout is not self.__undef__ and not (dirty and not self._send_timeout[1])):
            dct["sendTimeout"] = dictify(self.send_timeout)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "tls_enabled" == "type" or (self.tls_enabled is not self.__undef__ and not (dirty and not self._tls_enabled[1])):
            dct["tlsEnabled"] = dictify(self.tls_enabled)
        if "server" == "type" or (self.server is not self.__undef__ and not (dirty and not self._server[1])):
            dct["server"] = dictify(self.server)
        if "authentication_enabled" == "type" or (self.authentication_enabled is not self.__undef__ and not (dirty and not self._authentication_enabled[1])):
            dct["authenticationEnabled"] = dictify(self.authentication_enabled)
        if "from_address" == "type" or (self.from_address is not self.__undef__ and not (dirty and not self._from_address[1])):
            dct["fromAddress"] = dictify(self.from_address)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)
        self._send_timeout = (self._send_timeout[0], True)
        self._enabled = (self._enabled[0], True)
        self._tls_enabled = (self._tls_enabled[0], True)
        self._server = (self._server[0], True)
        self._authentication_enabled = (self._authentication_enabled[0], True)
        self._from_address = (self._from_address[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1], self._send_timeout[1], self._enabled[1], self._tls_enabled[1], self._server[1], self._authentication_enabled[1], self._from_address[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SMTPConfig):
            return False
        return super(SMTPConfig, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password and \
               self.send_timeout == other.send_timeout and \
               self.enabled == other.enabled and \
               self.tls_enabled == other.tls_enabled and \
               self.server == other.server and \
               self.authentication_enabled == other.authentication_enabled and \
               self.from_address == other.from_address and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        If authentication is enabled, username to use when authenticating to
        the server.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        If authentication is enabled, password to use when authenticating to
        the server.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def send_timeout(self):
        """
        Maximum timeout to wait, in seconds, when sending mail.

        :rtype: ``int``
        """
        return self._send_timeout[0]

    @send_timeout.setter
    def send_timeout(self, value):
        self._send_timeout = (value, True)

    @property
    def enabled(self):
        """
        True if outbound email is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def tls_enabled(self):
        """
        True if TLS (transport layer security) should be used.

        :rtype: ``bool``
        """
        return self._tls_enabled[0]

    @tls_enabled.setter
    def tls_enabled(self, value):
        self._tls_enabled = (value, True)

    @property
    def server(self):
        """
        IP address or hostname of SMTP relay server.

        :rtype: ``basestring``
        """
        return self._server[0]

    @server.setter
    def server(self, value):
        self._server = (value, True)

    @property
    def authentication_enabled(self):
        """
        True if username/password authentication should be used.

        :rtype: ``bool``
        """
        return self._authentication_enabled[0]

    @authentication_enabled.setter
    def authentication_enabled(self, value):
        self._authentication_enabled = (value, True)

    @property
    def from_address(self):
        """
        From address to use when sending mail. If unspecified,
        'noreply@delphix.com' is used.

        :rtype: ``basestring``
        """
        return self._from_address[0]

    @from_address.setter
    def from_address(self, value):
        self._from_address = (value, True)

    @property
    def port(self):
        """
        *(default value: -1)* Port number to use. A value of -1 indicates the
        default (25 or 587 for TLS).

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class JSBranchUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a Jet Stream branch.
    """
    def __init__(self, undef_enabled=True):
        super(JSBranchUsageData, self).__init__()
        self._type = ("JSBranchUsageData", True)
        self._data_container = (self.__undef__, True)
        self._shared_others = (self.__undef__, True)
        self._unique = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._shared_self = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBranchUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._data_container = (data.get("dataContainer", obj.__undef__), dirty)
        if obj._data_container[0] is not None and obj._data_container[0] is not obj.__undef__:
            assert isinstance(obj._data_container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_container[0]))
            common.validate_format(obj._data_container[0], "None", None, None)
        obj._shared_others = (data.get("sharedOthers", obj.__undef__), dirty)
        if obj._shared_others[0] is not None and obj._shared_others[0] is not obj.__undef__:
            assert isinstance(obj._shared_others[0], float), ("Expected one of [u'number'], but got %s" % type(obj._shared_others[0]))
            common.validate_format(obj._shared_others[0], "None", None, None)
        obj._unique = (data.get("unique", obj.__undef__), dirty)
        if obj._unique[0] is not None and obj._unique[0] is not obj.__undef__:
            assert isinstance(obj._unique[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unique[0]))
            common.validate_format(obj._unique[0], "None", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._shared_self = (data.get("sharedSelf", obj.__undef__), dirty)
        if obj._shared_self[0] is not None and obj._shared_self[0] is not obj.__undef__:
            assert isinstance(obj._shared_self[0], float), ("Expected one of [u'number'], but got %s" % type(obj._shared_self[0]))
            common.validate_format(obj._shared_self[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBranchUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_container" == "type" or (self.data_container is not self.__undef__ and not (dirty and not self._data_container[1])):
            dct["dataContainer"] = dictify(self.data_container)
        if "shared_others" == "type" or (self.shared_others is not self.__undef__ and not (dirty and not self._shared_others[1])):
            dct["sharedOthers"] = dictify(self.shared_others)
        if "unique" == "type" or (self.unique is not self.__undef__ and not (dirty and not self._unique[1])):
            dct["unique"] = dictify(self.unique)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "shared_self" == "type" or (self.shared_self is not self.__undef__ and not (dirty and not self._shared_self[1])):
            dct["sharedSelf"] = dictify(self.shared_self)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_container = (self._data_container[0], True)
        self._shared_others = (self._shared_others[0], True)
        self._unique = (self._unique[0], True)
        self._branch = (self._branch[0], True)
        self._shared_self = (self._shared_self[0], True)

    def is_dirty(self):
        return any([self._data_container[1], self._shared_others[1], self._unique[1], self._branch[1], self._shared_self[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBranchUsageData):
            return False
        return super(JSBranchUsageData, self).__eq__(other) and \
               self.data_container == other.data_container and \
               self.shared_others == other.shared_others and \
               self.unique == other.unique and \
               self.branch == other.branch and \
               self.shared_self == other.shared_self

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_container(self):
        """
        The name of the data container that this branch resides on.

        :rtype: ``basestring``
        """
        return self._data_container[0]

    @data_container.setter
    def data_container(self, value):
        self._data_container = (value, True)

    @property
    def shared_others(self):
        """
        The amount of space that cannot be freed on the parent data template
        (or sibling data containers) because it is also being referenced by
        this branch due to restore or create branch operations.

        :rtype: ``float``
        """
        return self._shared_others[0]

    @shared_others.setter
    def shared_others(self, value):
        self._shared_others = (value, True)

    @property
    def unique(self):
        """
        The amount of space that will be freed if this branch is deleted.

        :rtype: ``float``
        """
        return self._unique[0]

    @unique.setter
    def unique(self, value):
        self._unique = (value, True)

    @property
    def branch(self):
        """
        The Jet Stream branch that this usage information is for.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def shared_self(self):
        """
        The amount of space that cannot be freed up on this branch because it
        is also being referenced by sibling data containers due to restore or
        create branch operations.

        :rtype: ``float``
        """
        return self._shared_self[0]

    @shared_self.setter
    def shared_self(self, value):
        self._shared_self = (value, True)

class SourcingPolicy(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Database policies for
    managing SnapSync and LogSync across sources for a MSSQL container.
    """
    def __init__(self, undef_enabled=True):
        super(SourcingPolicy, self).__init__()
        self._type = ("SourcingPolicy", True)
        self._load_from_backup = (self.__undef__, True)
        self._logsync_enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourcingPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._load_from_backup = (data.get("loadFromBackup", obj.__undef__), dirty)
        if obj._load_from_backup[0] is not None and obj._load_from_backup[0] is not obj.__undef__:
            assert isinstance(obj._load_from_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._load_from_backup[0]))
            common.validate_format(obj._load_from_backup[0], "None", None, None)
        obj._logsync_enabled = (data.get("logsyncEnabled", obj.__undef__), dirty)
        if obj._logsync_enabled[0] is not None and obj._logsync_enabled[0] is not obj.__undef__:
            assert isinstance(obj._logsync_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._logsync_enabled[0]))
            common.validate_format(obj._logsync_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourcingPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "load_from_backup" == "type" or (self.load_from_backup is not self.__undef__ and not (dirty and not self._load_from_backup[1])):
            dct["loadFromBackup"] = dictify(self.load_from_backup)
        if "logsync_enabled" == "type" or (self.logsync_enabled is not self.__undef__ and not (dirty and not self._logsync_enabled[1])):
            dct["logsyncEnabled"] = dictify(self.logsync_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._load_from_backup = (self._load_from_backup[0], True)
        self._logsync_enabled = (self._logsync_enabled[0], True)

    def is_dirty(self):
        return any([self._load_from_backup[1], self._logsync_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourcingPolicy):
            return False
        return super(SourcingPolicy, self).__eq__(other) and \
               self.load_from_backup == other.load_from_backup and \
               self.logsync_enabled == other.logsync_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def load_from_backup(self):
        """
        True if the initial load and subsequent syncs for this container
        restore from already existing database backups. In such cases Delphix
        does not take any full database backups of the source database. When
        false, Delphix will take a full backup of the source.

        :rtype: ``bool``
        """
        return self._load_from_backup[0]

    @load_from_backup.setter
    def load_from_backup(self, value):
        self._load_from_backup = (value, True)

    @property
    def logsync_enabled(self):
        """
        True if LogSync should run for this database.

        :rtype: ``bool``
        """
        return self._logsync_enabled[0]

    @logsync_enabled.setter
    def logsync_enabled(self, value):
        self._logsync_enabled = (value, True)

class DatabaseTemplateConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Static template
    configuration information for a given source type.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseTemplateConfig, self).__init__()
        self._type = ("DatabaseTemplateConfig", True)
        self._reserved = (self.__undef__, True)
        self._source_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseTemplateConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._reserved = []
        for item in data.get("reserved") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._reserved.append(item)
        obj._reserved = (obj._reserved, dirty)
        obj._source_type = (data.get("sourceType", obj.__undef__), dirty)
        if obj._source_type[0] is not None and obj._source_type[0] is not obj.__undef__:
            assert isinstance(obj._source_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_type[0]))
            common.validate_format(obj._source_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseTemplateConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "reserved" == "type" or (self.reserved is not self.__undef__ and not (dirty and not self._reserved[1])):
            dct["reserved"] = dictify(self.reserved)
        if "source_type" == "type" or (self.source_type is not self.__undef__ and not (dirty and not self._source_type[1])):
            dct["sourceType"] = dictify(self.source_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._reserved = (self._reserved[0], True)
        self._source_type = (self._source_type[0], True)

    def is_dirty(self):
        return any([self._reserved[1], self._source_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseTemplateConfig):
            return False
        return super(DatabaseTemplateConfig, self).__eq__(other) and \
               self.reserved == other.reserved and \
               self.source_type == other.source_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def reserved(self):
        """
        A list of reserved parameters names that cannot be used in the
        template.

        :rtype: ``list`` of ``basestring``
        """
        return self._reserved[0]

    @reserved.setter
    def reserved(self, value):
        self._reserved = (value, True)

    @property
    def source_type(self):
        """
        The object type for sources to which this template is applicable.

        :rtype: ``basestring``
        """
        return self._source_type[0]

    @source_type.setter
    def source_type(self, value):
        self._source_type = (value, True)

class SupportAccessState(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The state of the
    access to the support shell.
    """
    def __init__(self, undef_enabled=True):
        super(SupportAccessState, self).__init__()
        self._type = ("SupportAccessState", True)
        self._token = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._access_type = (self.__undef__, True)
        self._start_time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SupportAccessState, cls).from_dict(data, dirty, undef_enabled)
        obj._token = (data.get("token", obj.__undef__), dirty)
        if obj._token[0] is not None and obj._token[0] is not obj.__undef__:
            assert isinstance(obj._token[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._token[0]))
            common.validate_format(obj._token[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._access_type = (data.get("accessType", obj.__undef__), dirty)
        if obj._access_type[0] is not None and obj._access_type[0] is not obj.__undef__:
            assert isinstance(obj._access_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._access_type[0]))
            assert obj._access_type[0] in [u'DISABLED', u'ENABLED_NO_TOKEN', u'ENABLED_WITH_TOKEN'], "Expected enum [u'DISABLED', u'ENABLED_NO_TOKEN', u'ENABLED_WITH_TOKEN'] but got %s" % obj._access_type[0]
            common.validate_format(obj._access_type[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SupportAccessState, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "token" == "type" or (self.token is not self.__undef__ and not (dirty and not self._token[1])):
            dct["token"] = dictify(self.token)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "access_type" == "type" or (self.access_type is not self.__undef__ and not (dirty and not self._access_type[1])):
            dct["accessType"] = dictify(self.access_type)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._token = (self._token[0], True)
        self._end_time = (self._end_time[0], True)
        self._access_type = (self._access_type[0], True)
        self._start_time = (self._start_time[0], True)

    def is_dirty(self):
        return any([self._token[1], self._end_time[1], self._access_type[1], self._start_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SupportAccessState):
            return False
        return super(SupportAccessState, self).__eq__(other) and \
               self.token == other.token and \
               self.end_time == other.end_time and \
               self.access_type == other.access_type and \
               self.start_time == other.start_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def token(self):
        """
        If ENABLED_WITH_TOKEN, the token that must be supplied to login.

        :rtype: ``basestring``
        """
        return self._token[0]

    @token.setter
    def token(self, value):
        self._token = (value, True)

    @property
    def end_time(self):
        """
        If ENABLED_WITH_TOKEN, time that the token will no longer be valid.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def access_type(self):
        """
        How the support shell can be accessed. *(permitted values: DISABLED,
        ENABLED_NO_TOKEN, ENABLED_WITH_TOKEN)*

        :rtype: ``basestring``
        """
        return self._access_type[0]

    @access_type.setter
    def access_type(self, value):
        self._access_type = (value, True)

    @property
    def start_time(self):
        """
        If ENABLED_WITH_TOKEN, the time that the token will be valid.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

class CompatibleRepositoriesParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The compatibility
    parameters to use for filtering the list of available repositories.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibleRepositoriesParameters, self).__init__()
        self._type = ("CompatibleRepositoriesParameters", True)
        self._environment = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibleRepositoriesParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibleRepositoriesParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)

    def is_dirty(self):
        return any([self._environment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibleRepositoriesParameters):
            return False
        return super(CompatibleRepositoriesParameters, self).__eq__(other) and \
               self.environment == other.environment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Restrict returned repositories to this environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

class PurgeLogsParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    parameters of a purgeLogs request.
    """
    def __init__(self, undef_enabled=True):
        super(PurgeLogsParameters, self).__init__()
        self._type = ("PurgeLogsParameters", True)
        self._dry_run = (self.__undef__, True)
        self._delete_snapshot_logs = (self.__undef__, True)
        self._storage_space_to_reclaim = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PurgeLogsParameters, cls).from_dict(data, dirty, undef_enabled)
        if "dryRun" not in data:
            raise ValueError("Missing required property \"dryRun\".")
        obj._dry_run = (data.get("dryRun", obj.__undef__), dirty)
        if obj._dry_run[0] is not None and obj._dry_run[0] is not obj.__undef__:
            assert isinstance(obj._dry_run[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._dry_run[0]))
            common.validate_format(obj._dry_run[0], "None", None, None)
        if "deleteSnapshotLogs" not in data:
            raise ValueError("Missing required property \"deleteSnapshotLogs\".")
        obj._delete_snapshot_logs = (data.get("deleteSnapshotLogs", obj.__undef__), dirty)
        if obj._delete_snapshot_logs[0] is not None and obj._delete_snapshot_logs[0] is not obj.__undef__:
            assert isinstance(obj._delete_snapshot_logs[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._delete_snapshot_logs[0]))
            common.validate_format(obj._delete_snapshot_logs[0], "None", None, None)
        if "storageSpaceToReclaim" not in data:
            raise ValueError("Missing required property \"storageSpaceToReclaim\".")
        obj._storage_space_to_reclaim = (data.get("storageSpaceToReclaim", obj.__undef__), dirty)
        if obj._storage_space_to_reclaim[0] is not None and obj._storage_space_to_reclaim[0] is not obj.__undef__:
            assert isinstance(obj._storage_space_to_reclaim[0], float), ("Expected one of [u'number'], but got %s" % type(obj._storage_space_to_reclaim[0]))
            common.validate_format(obj._storage_space_to_reclaim[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PurgeLogsParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "dry_run" == "type" or (self.dry_run is not self.__undef__ and not (dirty and not self._dry_run[1])):
            dct["dryRun"] = dictify(self.dry_run)
        if "delete_snapshot_logs" == "type" or (self.delete_snapshot_logs is not self.__undef__ and not (dirty and not self._delete_snapshot_logs[1])):
            dct["deleteSnapshotLogs"] = dictify(self.delete_snapshot_logs)
        if "storage_space_to_reclaim" == "type" or (self.storage_space_to_reclaim is not self.__undef__ and not (dirty and not self._storage_space_to_reclaim[1])):
            dct["storageSpaceToReclaim"] = dictify(self.storage_space_to_reclaim)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._dry_run = (self._dry_run[0], True)
        self._delete_snapshot_logs = (self._delete_snapshot_logs[0], True)
        self._storage_space_to_reclaim = (self._storage_space_to_reclaim[0], True)

    def is_dirty(self):
        return any([self._dry_run[1], self._delete_snapshot_logs[1], self._storage_space_to_reclaim[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PurgeLogsParameters):
            return False
        return super(PurgeLogsParameters, self).__eq__(other) and \
               self.dry_run == other.dry_run and \
               self.delete_snapshot_logs == other.delete_snapshot_logs and \
               self.storage_space_to_reclaim == other.storage_space_to_reclaim

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def dry_run(self):
        """
        *(default value: True)* If this is set to true, this operation does not
        actually delete logs. It returns the affected snapshots and truncated
        timeline as if the logs were deleted.

        :rtype: ``bool``
        """
        return self._dry_run[0]

    @dry_run.setter
    def dry_run(self, value):
        self._dry_run = (value, True)

    @property
    def delete_snapshot_logs(self):
        """
        Delete expired logs which have been retained to make snapshots
        consistent.

        :rtype: ``bool``
        """
        return self._delete_snapshot_logs[0]

    @delete_snapshot_logs.setter
    def delete_snapshot_logs(self, value):
        self._delete_snapshot_logs = (value, True)

    @property
    def storage_space_to_reclaim(self):
        """
        Amount of space in bytes to reclaim as part of purgeLogs process.

        :rtype: ``float``
        """
        return self._storage_space_to_reclaim[0]

    @storage_space_to_reclaim.setter
    def storage_space_to_reclaim(self, value):
        self._storage_space_to_reclaim = (value, True)

class SnapshotSpaceResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of the
    operation to determine how much space is used by a set of snapshots.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotSpaceResult, self).__init__()
        self._type = ("SnapshotSpaceResult", True)
        self._total_size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotSpaceResult, cls).from_dict(data, dirty, undef_enabled)
        obj._total_size = (data.get("totalSize", obj.__undef__), dirty)
        if obj._total_size[0] is not None and obj._total_size[0] is not obj.__undef__:
            assert isinstance(obj._total_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total_size[0]))
            common.validate_format(obj._total_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotSpaceResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "total_size" == "type" or (self.total_size is not self.__undef__ and not (dirty and not self._total_size[1])):
            dct["totalSize"] = dictify(self.total_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._total_size = (self._total_size[0], True)

    def is_dirty(self):
        return any([self._total_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotSpaceResult):
            return False
        return super(SnapshotSpaceResult, self).__eq__(other) and \
               self.total_size == other.total_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def total_size(self):
        """
        Total amount of space, in bytes, that would be freed by deleting the
        input snapshots.

        :rtype: ``float``
        """
        return self._total_size[0]

    @total_size.setter
    def total_size(self, value):
        self._total_size = (value, True)

class CreateTransformationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    parameters of a createTransformation request.
    """
    def __init__(self, undef_enabled=True):
        super(CreateTransformationParameters, self).__init__()
        self._type = ("CreateTransformationParameters", True)
        self._operations = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._operations = []
        for item in data.get("operations") or []:
            obj._operations.append(factory.create_object(item))
            factory.validate_type(obj._operations[-1], "SourceOperation")
        obj._operations = (obj._operations, dirty)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "Container"), dirty)
            factory.validate_type(obj._container[0], "Container")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._container = (self._container[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._repository = (self._repository[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._container[1], self._environment_user[1], self._repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CreateTransformationParameters):
            return False
        return super(CreateTransformationParameters, self).__eq__(other) and \
               self.operations == other.operations and \
               self.container == other.container and \
               self.environment_user == other.environment_user and \
               self.repository == other.repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        Operations to perform when this transformation is applied.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.Container`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def environment_user(self):
        """
        Reference to the user used during application of the transformation.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def repository(self):
        """
        Reference to the repository used during application of the
        transformation.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

class MySQLReplicationCoordinates(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The current position
    on the master to start replication from.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLReplicationCoordinates, self).__init__()
        self._type = ("MySQLReplicationCoordinates", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLReplicationCoordinates, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLReplicationCoordinates, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLReplicationCoordinates):
            return False
        return super(MySQLReplicationCoordinates, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleActiveInstance(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Active instance
    information for an Oracle database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleActiveInstance, self).__init__()
        self._type = ("OracleActiveInstance", True)
        self._instance_number = (self.__undef__, True)
        self._host_name = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleActiveInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_number = (data.get("instanceNumber", obj.__undef__), dirty)
        if obj._instance_number[0] is not None and obj._instance_number[0] is not obj.__undef__:
            assert isinstance(obj._instance_number[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._instance_number[0]))
            common.validate_format(obj._instance_number[0], "None", None, None)
        obj._host_name = (data.get("hostName", obj.__undef__), dirty)
        if obj._host_name[0] is not None and obj._host_name[0] is not obj.__undef__:
            assert isinstance(obj._host_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host_name[0]))
            common.validate_format(obj._host_name[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleActiveInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_number" == "type" or (self.instance_number is not self.__undef__ and not (dirty and not self._instance_number[1])):
            dct["instanceNumber"] = dictify(self.instance_number)
        if "host_name" == "type" or (self.host_name is not self.__undef__ and not (dirty and not self._host_name[1])):
            dct["hostName"] = dictify(self.host_name)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_number = (self._instance_number[0], True)
        self._host_name = (self._host_name[0], True)
        self._instance_name = (self._instance_name[0], True)

    def is_dirty(self):
        return any([self._instance_number[1], self._host_name[1], self._instance_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleActiveInstance):
            return False
        return super(OracleActiveInstance, self).__eq__(other) and \
               self.instance_number == other.instance_number and \
               self.host_name == other.host_name and \
               self.instance_name == other.instance_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_number(self):
        """
        The number of the Oracle instance.

        :rtype: ``int``
        """
        return self._instance_number[0]

    @instance_number.setter
    def instance_number(self, value):
        self._instance_number = (value, True)

    @property
    def host_name(self):
        """
        The name of the host the instance runs on.

        :rtype: ``basestring``
        """
        return self._host_name[0]

    @host_name.setter
    def host_name(self, value):
        self._host_name = (value, True)

    @property
    def instance_name(self):
        """
        The name of the Oracle instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

class AuthFilterParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to filter a list of objects or object type by a permission.
    """
    def __init__(self, undef_enabled=True):
        super(AuthFilterParameters, self).__init__()
        self._type = ("AuthFilterParameters", True)
        self._object_type = (self.__undef__, True)
        self._objects = (self.__undef__, True)
        self._permission = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AuthFilterParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._object_type = (data.get("objectType", obj.__undef__), dirty)
        if obj._object_type[0] is not None and obj._object_type[0] is not obj.__undef__:
            assert isinstance(obj._object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object_type[0]))
            common.validate_format(obj._object_type[0], "type", None, None)
        obj._objects = []
        for item in data.get("objects") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._objects.append(item)
        obj._objects = (obj._objects, dirty)
        obj._permission = (data.get("permission", obj.__undef__), dirty)
        if obj._permission[0] is not None and obj._permission[0] is not obj.__undef__:
            assert isinstance(obj._permission[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._permission[0]))
            common.validate_format(obj._permission[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AuthFilterParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_type" == "type" or (self.object_type is not self.__undef__ and not (dirty and not self._object_type[1])):
            dct["objectType"] = dictify(self.object_type)
        if "objects" == "type" or (self.objects is not self.__undef__ and not (dirty and not self._objects[1])):
            dct["objects"] = dictify(self.objects)
        if "permission" == "type" or (self.permission is not self.__undef__ and not (dirty and not self._permission[1])):
            dct["permission"] = dictify(self.permission)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_type = (self._object_type[0], True)
        self._objects = (self._objects[0], True)
        self._permission = (self._permission[0], True)

    def is_dirty(self):
        return any([self._object_type[1], self._objects[1], self._permission[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AuthFilterParameters):
            return False
        return super(AuthFilterParameters, self).__eq__(other) and \
               self.object_type == other.object_type and \
               self.objects == other.objects and \
               self.permission == other.permission

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_type(self):
        """
        The object type on which to perform filtering. This option is mutually
        exclusive with the "objects" field.

        :rtype: ``basestring``
        """
        return self._object_type[0]

    @object_type.setter
    def object_type(self, value):
        self._object_type = (value, True)

    @property
    def objects(self):
        """
        The list of objects to filter. This option is mutually exclusive with
        the "objectType" field.

        :rtype: ``list`` of ``basestring``
        """
        return self._objects[0]

    @objects.setter
    def objects(self, value):
        self._objects = (value, True)

    @property
    def permission(self):
        """
        The permission to filter by.

        :rtype: ``basestring``
        """
        return self._permission[0]

    @permission.setter
    def permission(self, value):
        self._permission = (value, True)

class SyslogConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Syslog configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SyslogConfig, self).__init__()
        self._type = ("SyslogConfig", True)
        self._pattern = (self.__undef__, True)
        self._format = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._severity = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyslogConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._pattern = (data.get("pattern", obj.__undef__), dirty)
        if obj._pattern[0] is not None and obj._pattern[0] is not obj.__undef__:
            assert isinstance(obj._pattern[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pattern[0]))
            common.validate_format(obj._pattern[0], "None", None, None)
        obj._format = (data.get("format", obj.__undef__), dirty)
        if obj._format[0] is not None and obj._format[0] is not obj.__undef__:
            assert isinstance(obj._format[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._format[0]))
            assert obj._format[0] in [u'TEXT', u'JSON'], "Expected enum [u'TEXT', u'JSON'] but got %s" % obj._format[0]
            common.validate_format(obj._format[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'EMERGENCY', u'ALERT', u'CRITICAL', u'ERROR', u'WARNING', u'NOTICE', u'INFORMATIONAL', u'DEBUG'], "Expected enum [u'EMERGENCY', u'ALERT', u'CRITICAL', u'ERROR', u'WARNING', u'NOTICE', u'INFORMATIONAL', u'DEBUG'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        obj._servers = []
        for item in data.get("servers") or []:
            obj._servers.append(factory.create_object(item))
            factory.validate_type(obj._servers[-1], "SyslogServer")
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyslogConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "pattern" == "type" or (self.pattern is not self.__undef__ and not (dirty and not self._pattern[1])):
            dct["pattern"] = dictify(self.pattern)
        if "format" == "type" or (self.format is not self.__undef__ and not (dirty and not self._format[1])):
            dct["format"] = dictify(self.format)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._pattern = (self._pattern[0], True)
        self._format = (self._format[0], True)
        self._enabled = (self._enabled[0], True)
        self._severity = (self._severity[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._pattern[1], self._format[1], self._enabled[1], self._severity[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyslogConfig):
            return False
        return super(SyslogConfig, self).__eq__(other) and \
               self.pattern == other.pattern and \
               self.format == other.format and \
               self.enabled == other.enabled and \
               self.severity == other.severity and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def pattern(self):
        """
        *(default value: %-5p delphix : %m%n)* Syslog logging pattern. Events
        will be logged in the pattern as specified.

        :rtype: ``basestring``
        """
        return self._pattern[0]

    @pattern.setter
    def pattern(self, value):
        self._pattern = (value, True)

    @property
    def format(self):
        """
        *(default value: TEXT)* Syslog message format. *(permitted values:
        TEXT, JSON)*

        :rtype: ``basestring``
        """
        return self._format[0]

    @format.setter
    def format(self, value):
        self._format = (value, True)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the syslog service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def severity(self):
        """
        *(default value: WARNING)* Syslog logging severity. Only events at or
        above this severity will be logged. *(permitted values: EMERGENCY,
        ALERT, CRITICAL, ERROR, WARNING, NOTICE, INFORMATIONAL, DEBUG)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

    @property
    def servers(self):
        """
        List of syslog servers. At least one syslog server must be specified.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SyslogServer`
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class AxisConstraint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Constraints placed on
    the axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(AxisConstraint, self).__init__()
        self._type = ("AxisConstraint", True)
        self._axis_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AxisConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._axis_name = (data.get("axisName", obj.__undef__), dirty)
        if obj._axis_name[0] is not None and obj._axis_name[0] is not obj.__undef__:
            assert isinstance(obj._axis_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._axis_name[0]))
            common.validate_format(obj._axis_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AxisConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "axis_name" == "type" or (self.axis_name is not self.__undef__ and not (dirty and not self._axis_name[1])):
            dct["axisName"] = dictify(self.axis_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._axis_name = (self._axis_name[0], True)

    def is_dirty(self):
        return any([self._axis_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AxisConstraint):
            return False
        return super(AxisConstraint, self).__eq__(other) and \
               self.axis_name == other.axis_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def axis_name(self):
        """
        The name of the axis being constrained.

        :rtype: ``basestring``
        """
        return self._axis_name[0]

    @axis_name.setter
    def axis_name(self, value):
        self._axis_name = (value, True)

class Schedule(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represent a schedule
    in the Delphix system.
    """
    def __init__(self, undef_enabled=True):
        super(Schedule, self).__init__()
        self._type = ("Schedule", True)
        self._cron_string = (self.__undef__, True)
        self._cutoff_time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Schedule, cls).from_dict(data, dirty, undef_enabled)
        obj._cron_string = (data.get("cronString", obj.__undef__), dirty)
        if obj._cron_string[0] is not None and obj._cron_string[0] is not obj.__undef__:
            assert isinstance(obj._cron_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cron_string[0]))
            common.validate_format(obj._cron_string[0], "None", None, 120)
        obj._cutoff_time = (data.get("cutoffTime", obj.__undef__), dirty)
        if obj._cutoff_time[0] is not None and obj._cutoff_time[0] is not obj.__undef__:
            assert isinstance(obj._cutoff_time[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cutoff_time[0]))
            common.validate_format(obj._cutoff_time[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Schedule, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cron_string" == "type" or (self.cron_string is not self.__undef__ and not (dirty and not self._cron_string[1])):
            dct["cronString"] = dictify(self.cron_string)
        if "cutoff_time" == "type" or (self.cutoff_time is not self.__undef__ and not (dirty and not self._cutoff_time[1])):
            dct["cutoffTime"] = dictify(self.cutoff_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cron_string = (self._cron_string[0], True)
        self._cutoff_time = (self._cutoff_time[0], True)

    def is_dirty(self):
        return any([self._cron_string[1], self._cutoff_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Schedule):
            return False
        return super(Schedule, self).__eq__(other) and \
               self.cron_string == other.cron_string and \
               self.cutoff_time == other.cutoff_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cron_string(self):
        """
        Schedule cron string. See CronTrigger documentation at http://quartz-
        scheduler.org/ for details.

        :rtype: ``basestring``
        """
        return self._cron_string[0]

    @cron_string.setter
    def cron_string(self, value):
        self._cron_string = (value, True)

    @property
    def cutoff_time(self):
        """
        Cutoff time in seconds. The policy job will suspend if not completed
        within the given time limit.

        :rtype: ``int``
        """
        return self._cutoff_time[0]

    @cutoff_time.setter
    def cutoff_time(self, value):
        self._cutoff_time = (value, True)

class SamlInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Global SAML
    information.
    """
    def __init__(self, undef_enabled=True):
        super(SamlInfo, self).__init__()
        self._type = ("SamlInfo", True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SamlInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SamlInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SamlInfo):
            return False
        return super(SamlInfo, self).__eq__(other) and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        Whether or not SAML authentication is configured and enabled for this
        Delphix Engine.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class Checklist(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Generic checklist
    object.
    """
    def __init__(self, undef_enabled=True):
        super(Checklist, self).__init__()
        self._type = ("Checklist", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Checklist, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Checklist, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Checklist):
            return False
        return super(Checklist, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NetworkRouteLookupParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters used for a
    routing table lookup.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkRouteLookupParameters, self).__init__()
        self._type = ("NetworkRouteLookupParameters", True)
        self._destination = (self.__undef__, True)
        self._data_node = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkRouteLookupParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._destination = (data.get("destination", obj.__undef__), dirty)
        if obj._destination[0] is not None and obj._destination[0] is not obj.__undef__:
            assert isinstance(obj._destination[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination[0]))
            common.validate_format(obj._destination[0], "host", None, None)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkRouteLookupParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "destination" == "type" or (self.destination is not self.__undef__ and not (dirty and not self._destination[1])):
            dct["destination"] = dictify(self.destination)
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._destination = (self._destination[0], True)
        self._data_node = (self._data_node[0], True)

    def is_dirty(self):
        return any([self._destination[1], self._data_node[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkRouteLookupParameters):
            return False
        return super(NetworkRouteLookupParameters, self).__eq__(other) and \
               self.destination == other.destination and \
               self.data_node == other.data_node

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def destination(self):
        """
        Destination address or hostname.

        :rtype: ``basestring``
        """
        return self._destination[0]

    @destination.setter
    def destination(self, value):
        self._destination = (value, True)

    @property
    def data_node(self):
        """
        The node where to perform the lookup.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

class CompatibleRepositoriesResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of a compatible
    repositories request.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibleRepositoriesResult, self).__init__()
        self._type = ("CompatibleRepositoriesResult", True)
        self._repositories = (self.__undef__, True)
        self._criteria = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibleRepositoriesResult, cls).from_dict(data, dirty, undef_enabled)
        if "repositories" not in data:
            raise ValueError("Missing required property \"repositories\".")
        obj._repositories = []
        for item in data.get("repositories") or []:
            obj._repositories.append(factory.create_object(item))
            factory.validate_type(obj._repositories[-1], "SourceRepository")
        obj._repositories = (obj._repositories, dirty)
        if "criteria" not in data:
            raise ValueError("Missing required property \"criteria\".")
        if "criteria" in data and data["criteria"] is not None:
            obj._criteria = (factory.create_object(data["criteria"], "CompatibilityCriteria"), dirty)
            factory.validate_type(obj._criteria[0], "CompatibilityCriteria")
        else:
            obj._criteria = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibleRepositoriesResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "repositories" == "type" or (self.repositories is not self.__undef__ and not (dirty and not self._repositories[1])):
            dct["repositories"] = dictify(self.repositories)
        if "criteria" == "type" or (self.criteria is not self.__undef__ and not (dirty and not self._criteria[1])):
            dct["criteria"] = dictify(self.criteria)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._repositories = (self._repositories[0], True)
        self._criteria = (self._criteria[0], True)

    def is_dirty(self):
        return any([self._repositories[1], self._criteria[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibleRepositoriesResult):
            return False
        return super(CompatibleRepositoriesResult, self).__eq__(other) and \
               self.repositories == other.repositories and \
               self.criteria == other.criteria

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def repositories(self):
        """
        The list of compatible repositories.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceRepository`
        """
        return self._repositories[0]

    @repositories.setter
    def repositories(self, value):
        self._repositories = (value, True)

    @property
    def criteria(self):
        """
        The criteria matched to select compatible repositories.

        :rtype: :py:class:`v1_8_1.web.vo.CompatibilityCriteria`
        """
        return self._criteria[0]

    @criteria.setter
    def criteria(self, value):
        self._criteria = (value, True)

class FileMappingParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Input parameters to
    test file mapping rules.
    """
    def __init__(self, undef_enabled=True):
        super(FileMappingParameters, self).__init__()
        self._type = ("FileMappingParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)
        self._mapping_rules = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileMappingParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        if "mappingRules" not in data:
            raise ValueError("Missing required property \"mappingRules\".")
        obj._mapping_rules = (data.get("mappingRules", obj.__undef__), dirty)
        if obj._mapping_rules[0] is not None and obj._mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mapping_rules[0]))
            common.validate_format(obj._mapping_rules[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileMappingParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        if "mapping_rules" == "type" or (self.mapping_rules is not self.__undef__ and not (dirty and not self._mapping_rules[1])):
            dct["mappingRules"] = dictify(self.mapping_rules)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)
        self._mapping_rules = (self._mapping_rules[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1], self._mapping_rules[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileMappingParameters):
            return False
        return super(FileMappingParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters and \
               self.mapping_rules == other.mapping_rules

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to use for list of
        files.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

    @property
    def mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._mapping_rules[0]

    @mapping_rules.setter
    def mapping_rules(self, value):
        self._mapping_rules = (value, True)

class MSSqlFailoverClusterDriveLetter(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* This represents a
    logical volume with a drive letter that resides on a Physical Disk cluster
    resource that is part of a SQL Server Failover Cluster Instance.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlFailoverClusterDriveLetter, self).__init__()
        self._type = ("MSSqlFailoverClusterDriveLetter", True)
        self._drive_letter = (self.__undef__, True)
        self._label = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlFailoverClusterDriveLetter, cls).from_dict(data, dirty, undef_enabled)
        obj._drive_letter = (data.get("driveLetter", obj.__undef__), dirty)
        if obj._drive_letter[0] is not None and obj._drive_letter[0] is not obj.__undef__:
            assert isinstance(obj._drive_letter[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._drive_letter[0]))
            common.validate_format(obj._drive_letter[0], "None", 1, 1)
        obj._label = (data.get("label", obj.__undef__), dirty)
        if obj._label[0] is not None and obj._label[0] is not obj.__undef__:
            assert isinstance(obj._label[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._label[0]))
            common.validate_format(obj._label[0], "None", None, 32)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlFailoverClusterDriveLetter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "drive_letter" == "type" or (self.drive_letter is not self.__undef__ and not (dirty and not self._drive_letter[1])):
            dct["driveLetter"] = dictify(self.drive_letter)
        if "label" == "type" or (self.label is not self.__undef__ and not (dirty and not self._label[1])):
            dct["label"] = dictify(self.label)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._drive_letter = (self._drive_letter[0], True)
        self._label = (self._label[0], True)

    def is_dirty(self):
        return any([self._drive_letter[1], self._label[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlFailoverClusterDriveLetter):
            return False
        return super(MSSqlFailoverClusterDriveLetter, self).__eq__(other) and \
               self.drive_letter == other.drive_letter and \
               self.label == other.label

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def drive_letter(self):
        """
        The drive letter.

        :rtype: ``basestring``
        """
        return self._drive_letter[0]

    @drive_letter.setter
    def drive_letter(self, value):
        self._drive_letter = (value, True)

    @property
    def label(self):
        """
        The drive letter label.

        :rtype: ``basestring``
        """
        return self._label[0]

    @label.setter
    def label(self, value):
        self._label = (value, True)

class Notification(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Base type for all
    notification types.
    """
    def __init__(self, undef_enabled=True):
        super(Notification, self).__init__()
        self._type = ("Notification", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Notification, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Notification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Notification):
            return False
        return super(Notification, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SnapshotRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime properties of
    a TimeFlow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotRuntime, self).__init__()
        self._type = ("SnapshotRuntime", True)
        self._provisionable = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._provisionable = (data.get("provisionable", obj.__undef__), dirty)
        if obj._provisionable[0] is not None and obj._provisionable[0] is not obj.__undef__:
            assert isinstance(obj._provisionable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisionable[0]))
            common.validate_format(obj._provisionable[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provisionable" == "type" or (self.provisionable is not self.__undef__ and not (dirty and not self._provisionable[1])):
            dct["provisionable"] = dictify(self.provisionable)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provisionable = (self._provisionable[0], True)

    def is_dirty(self):
        return any([self._provisionable[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotRuntime):
            return False
        return super(SnapshotRuntime, self).__eq__(other) and \
               self.provisionable == other.provisionable

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provisionable(self):
        """
        True if this snapshot can be used as the basis for provisioning a new
        TimeFlow.

        :rtype: ``bool``
        """
        return self._provisionable[0]

    @provisionable.setter
    def provisionable(self, value):
        self._provisionable = (value, True)

class JSBookmarkUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a Jet Stream bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmarkUsageData, self).__init__()
        self._type = ("JSBookmarkUsageData", True)
        self._bookmark = (self.__undef__, True)
        self._data_layout = (self.__undef__, True)
        self._unique = (self.__undef__, True)
        self._externally_referenced = (self.__undef__, True)
        self._shared = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmarkUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._data_layout = (data.get("dataLayout", obj.__undef__), dirty)
        if obj._data_layout[0] is not None and obj._data_layout[0] is not obj.__undef__:
            assert isinstance(obj._data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_layout[0]))
            common.validate_format(obj._data_layout[0], "None", None, None)
        obj._unique = (data.get("unique", obj.__undef__), dirty)
        if obj._unique[0] is not None and obj._unique[0] is not obj.__undef__:
            assert isinstance(obj._unique[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unique[0]))
            common.validate_format(obj._unique[0], "None", None, None)
        obj._externally_referenced = (data.get("externallyReferenced", obj.__undef__), dirty)
        if obj._externally_referenced[0] is not None and obj._externally_referenced[0] is not obj.__undef__:
            assert isinstance(obj._externally_referenced[0], float), ("Expected one of [u'number'], but got %s" % type(obj._externally_referenced[0]))
            common.validate_format(obj._externally_referenced[0], "None", None, None)
        obj._shared = (data.get("shared", obj.__undef__), dirty)
        if obj._shared[0] is not None and obj._shared[0] is not obj.__undef__:
            assert isinstance(obj._shared[0], float), ("Expected one of [u'number'], but got %s" % type(obj._shared[0]))
            common.validate_format(obj._shared[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmarkUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "data_layout" == "type" or (self.data_layout is not self.__undef__ and not (dirty and not self._data_layout[1])):
            dct["dataLayout"] = dictify(self.data_layout)
        if "unique" == "type" or (self.unique is not self.__undef__ and not (dirty and not self._unique[1])):
            dct["unique"] = dictify(self.unique)
        if "externally_referenced" == "type" or (self.externally_referenced is not self.__undef__ and not (dirty and not self._externally_referenced[1])):
            dct["externallyReferenced"] = dictify(self.externally_referenced)
        if "shared" == "type" or (self.shared is not self.__undef__ and not (dirty and not self._shared[1])):
            dct["shared"] = dictify(self.shared)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._data_layout = (self._data_layout[0], True)
        self._unique = (self._unique[0], True)
        self._externally_referenced = (self._externally_referenced[0], True)
        self._shared = (self._shared[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._data_layout[1], self._unique[1], self._externally_referenced[1], self._shared[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmarkUsageData):
            return False
        return super(JSBookmarkUsageData, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.data_layout == other.data_layout and \
               self.unique == other.unique and \
               self.externally_referenced == other.externally_referenced and \
               self.shared == other.shared

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The Jet Stream bookmark that this usage information is for.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def data_layout(self):
        """
        The data layout that this bookmark belongs to.

        :rtype: ``basestring``
        """
        return self._data_layout[0]

    @data_layout.setter
    def data_layout(self, value):
        self._data_layout = (value, True)

    @property
    def unique(self):
        """
        The amount of space that will be freed if this bookmark is deleted.

        :rtype: ``float``
        """
        return self._unique[0]

    @unique.setter
    def unique(self, value):
        self._unique = (value, True)

    @property
    def externally_referenced(self):
        """
        The amount of space referenced by this bookmark that cannot be freed up
        by deleting this bookmark because it is also being referenced outside
        of Jet Stream (e.g. by retention policy).

        :rtype: ``float``
        """
        return self._externally_referenced[0]

    @externally_referenced.setter
    def externally_referenced(self, value):
        self._externally_referenced = (value, True)

    @property
    def shared(self):
        """
        The amount of space referenced by this bookmark that cannot be freed up
        by deleting this bookmark because it is also referenced by neighboring
        bookmarks or branches that have been created or restored from this
        bookmark.

        :rtype: ``float``
        """
        return self._shared[0]

    @shared.setter
    def shared(self, value):
        self._shared = (value, True)

class FileProcessingResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of a file
    processing request (upload or download).
    """
    def __init__(self, undef_enabled=True):
        super(FileProcessingResult, self).__init__()
        self._type = ("FileProcessingResult", True)
        self._url = (self.__undef__, True)
        self._token = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileProcessingResult, cls).from_dict(data, dirty, undef_enabled)
        obj._url = (data.get("url", obj.__undef__), dirty)
        if obj._url[0] is not None and obj._url[0] is not obj.__undef__:
            assert isinstance(obj._url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._url[0]))
            common.validate_format(obj._url[0], "None", None, None)
        obj._token = (data.get("token", obj.__undef__), dirty)
        if obj._token[0] is not None and obj._token[0] is not obj.__undef__:
            assert isinstance(obj._token[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._token[0]))
            common.validate_format(obj._token[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileProcessingResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "url" == "type" or (self.url is not self.__undef__ and not (dirty and not self._url[1])):
            dct["url"] = dictify(self.url)
        if "token" == "type" or (self.token is not self.__undef__ and not (dirty and not self._token[1])):
            dct["token"] = dictify(self.token)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._url = (self._url[0], True)
        self._token = (self._token[0], True)

    def is_dirty(self):
        return any([self._url[1], self._token[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileProcessingResult):
            return False
        return super(FileProcessingResult, self).__eq__(other) and \
               self.url == other.url and \
               self.token == other.token

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def url(self):
        """
        URL to download from or upload to.

        :rtype: ``basestring``
        """
        return self._url[0]

    @url.setter
    def url(self, value):
        self._url = (value, True)

    @property
    def token(self):
        """
        Token to pass as parameter to identify the file.

        :rtype: ``basestring``
        """
        return self._token[0]

    @token.setter
    def token(self, value):
        self._token = (value, True)

class APIVersion(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes an API
    version.
    """
    def __init__(self, undef_enabled=True):
        super(APIVersion, self).__init__()
        self._type = ("APIVersion", True)
        self._micro = (self.__undef__, True)
        self._major = (self.__undef__, True)
        self._minor = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APIVersion, cls).from_dict(data, dirty, undef_enabled)
        if "micro" not in data:
            raise ValueError("Missing required property \"micro\".")
        obj._micro = (data.get("micro", obj.__undef__), dirty)
        if obj._micro[0] is not None and obj._micro[0] is not obj.__undef__:
            assert isinstance(obj._micro[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._micro[0]))
            common.validate_format(obj._micro[0], "None", None, None)
        if "major" not in data:
            raise ValueError("Missing required property \"major\".")
        obj._major = (data.get("major", obj.__undef__), dirty)
        if obj._major[0] is not None and obj._major[0] is not obj.__undef__:
            assert isinstance(obj._major[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._major[0]))
            common.validate_format(obj._major[0], "None", None, None)
        if "minor" not in data:
            raise ValueError("Missing required property \"minor\".")
        obj._minor = (data.get("minor", obj.__undef__), dirty)
        if obj._minor[0] is not None and obj._minor[0] is not obj.__undef__:
            assert isinstance(obj._minor[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._minor[0]))
            common.validate_format(obj._minor[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APIVersion, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "micro" == "type" or (self.micro is not self.__undef__ and not (dirty and not self._micro[1])):
            dct["micro"] = dictify(self.micro)
        if "major" == "type" or (self.major is not self.__undef__ and not (dirty and not self._major[1])):
            dct["major"] = dictify(self.major)
        if "minor" == "type" or (self.minor is not self.__undef__ and not (dirty and not self._minor[1])):
            dct["minor"] = dictify(self.minor)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._micro = (self._micro[0], True)
        self._major = (self._major[0], True)
        self._minor = (self._minor[0], True)

    def is_dirty(self):
        return any([self._micro[1], self._major[1], self._minor[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APIVersion):
            return False
        return super(APIVersion, self).__eq__(other) and \
               self.micro == other.micro and \
               self.major == other.major and \
               self.minor == other.minor

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def micro(self):
        """
        Micro API version number.

        :rtype: ``int``
        """
        return self._micro[0]

    @micro.setter
    def micro(self, value):
        self._micro = (value, True)

    @property
    def major(self):
        """
        Major API version number.

        :rtype: ``int``
        """
        return self._major[0]

    @major.setter
    def major(self, value):
        self._major = (value, True)

    @property
    def minor(self):
        """
        Minor API version number.

        :rtype: ``int``
        """
        return self._minor[0]

    @minor.setter
    def minor(self, value):
        self._minor = (value, True)

class LogFetchSSH(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters to fetch
    log files that apply to a TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(LogFetchSSH, self).__init__()
        self._type = ("LogFetchSSH", True)
        self._directory = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._username = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LogFetchSSH, cls).from_dict(data, dirty, undef_enabled)
        if "directory" not in data:
            raise ValueError("Missing required property \"directory\".")
        obj._directory = (data.get("directory", obj.__undef__), dirty)
        if obj._directory[0] is not None and obj._directory[0] is not obj.__undef__:
            assert isinstance(obj._directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._directory[0]))
            common.validate_format(obj._directory[0], "None", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LogFetchSSH, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "directory" == "type" or (self.directory is not self.__undef__ and not (dirty and not self._directory[1])):
            dct["directory"] = dictify(self.directory)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._directory = (self._directory[0], True)
        self._credentials = (self._credentials[0], True)
        self._host = (self._host[0], True)
        self._username = (self._username[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._directory[1], self._credentials[1], self._host[1], self._username[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LogFetchSSH):
            return False
        return super(LogFetchSSH, self).__eq__(other) and \
               self.directory == other.directory and \
               self.credentials == other.credentials and \
               self.host == other.host and \
               self.username == other.username and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def directory(self):
        """
        Directory on the remote server where the missing log files reside.

        :rtype: ``basestring``
        """
        return self._directory[0]

    @directory.setter
    def directory(self, value):
        self._directory = (value, True)

    @property
    def credentials(self):
        """
        User credentials. If not provided will use environment credentials for
        'username' on 'host'.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def host(self):
        """
        Remote host to connect to.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def username(self):
        """
        User name to authenticate as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def port(self):
        """
        *(default value: 22)* SSH port to connect to.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class DeleteParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to delete requests for MSSQL, PostgreSQL, AppData, ASE or MySQL.
    """
    def __init__(self, undef_enabled=True):
        super(DeleteParameters, self).__init__()
        self._type = ("DeleteParameters", True)
        self._force = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DeleteParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._force = (data.get("force", obj.__undef__), dirty)
        if obj._force[0] is not None and obj._force[0] is not obj.__undef__:
            assert isinstance(obj._force[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._force[0]))
            common.validate_format(obj._force[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DeleteParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "force" == "type" or (self.force is not self.__undef__ and not (dirty and not self._force[1])):
            dct["force"] = dictify(self.force)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._force = (self._force[0], True)

    def is_dirty(self):
        return any([self._force[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DeleteParameters):
            return False
        return super(DeleteParameters, self).__eq__(other) and \
               self.force == other.force

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def force(self):
        """
        Flag indicating whether to continue the operation upon failures.

        :rtype: ``bool``
        """
        return self._force[0]

    @force.setter
    def force(self, value):
        self._force = (value, True)

class AttachData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    database-specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(AttachData, self).__init__()
        self._type = ("AttachData", True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AttachData, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AttachData):
            return False
        return super(AttachData, self).__eq__(other) and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class PublicSystemInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Retrieve static
    system-wide properties.
    """
    def __init__(self, undef_enabled=True):
        super(PublicSystemInfo, self).__init__()
        self._type = ("PublicSystemInfo", True)
        self._current_locale = (self.__undef__, True)
        self._enabled_features = (self.__undef__, True)
        self._build_version = (self.__undef__, True)
        self._configured = (self.__undef__, True)
        self._api_version = (self.__undef__, True)
        self._product_name = (self.__undef__, True)
        self._build_timestamp = (self.__undef__, True)
        self._product_type = (self.__undef__, True)
        self._build_title = (self.__undef__, True)
        self._banner = (self.__undef__, True)
        self._locales = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PublicSystemInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._current_locale = (data.get("currentLocale", obj.__undef__), dirty)
        if obj._current_locale[0] is not None and obj._current_locale[0] is not obj.__undef__:
            assert isinstance(obj._current_locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_locale[0]))
            common.validate_format(obj._current_locale[0], "locale", None, None)
        obj._enabled_features = []
        for item in data.get("enabledFeatures") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._enabled_features.append(item)
        obj._enabled_features = (obj._enabled_features, dirty)
        if "buildVersion" in data and data["buildVersion"] is not None:
            obj._build_version = (factory.create_object(data["buildVersion"], "VersionInfo"), dirty)
            factory.validate_type(obj._build_version[0], "VersionInfo")
        else:
            obj._build_version = (obj.__undef__, dirty)
        obj._configured = (data.get("configured", obj.__undef__), dirty)
        if obj._configured[0] is not None and obj._configured[0] is not obj.__undef__:
            assert isinstance(obj._configured[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._configured[0]))
            common.validate_format(obj._configured[0], "None", None, None)
        if "apiVersion" in data and data["apiVersion"] is not None:
            obj._api_version = (factory.create_object(data["apiVersion"], "APIVersion"), dirty)
            factory.validate_type(obj._api_version[0], "APIVersion")
        else:
            obj._api_version = (obj.__undef__, dirty)
        obj._product_name = (data.get("productName", obj.__undef__), dirty)
        if obj._product_name[0] is not None and obj._product_name[0] is not obj.__undef__:
            assert isinstance(obj._product_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._product_name[0]))
            common.validate_format(obj._product_name[0], "None", None, None)
        obj._build_timestamp = (data.get("buildTimestamp", obj.__undef__), dirty)
        if obj._build_timestamp[0] is not None and obj._build_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._build_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_timestamp[0]))
            common.validate_format(obj._build_timestamp[0], "date", None, None)
        obj._product_type = (data.get("productType", obj.__undef__), dirty)
        if obj._product_type[0] is not None and obj._product_type[0] is not obj.__undef__:
            assert isinstance(obj._product_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._product_type[0]))
            common.validate_format(obj._product_type[0], "None", None, None)
        obj._build_title = (data.get("buildTitle", obj.__undef__), dirty)
        if obj._build_title[0] is not None and obj._build_title[0] is not obj.__undef__:
            assert isinstance(obj._build_title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_title[0]))
            common.validate_format(obj._build_title[0], "None", None, None)
        obj._banner = (data.get("banner", obj.__undef__), dirty)
        if obj._banner[0] is not None and obj._banner[0] is not obj.__undef__:
            assert isinstance(obj._banner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._banner[0]))
            common.validate_format(obj._banner[0], "None", None, None)
        obj._locales = []
        for item in data.get("locales") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "locale", None, None)
            obj._locales.append(item)
        obj._locales = (obj._locales, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PublicSystemInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "current_locale" == "type" or (self.current_locale is not self.__undef__ and not (dirty and not self._current_locale[1])):
            dct["currentLocale"] = dictify(self.current_locale)
        if "enabled_features" == "type" or (self.enabled_features is not self.__undef__ and not (dirty and not self._enabled_features[1])):
            dct["enabledFeatures"] = dictify(self.enabled_features)
        if "build_version" == "type" or (self.build_version is not self.__undef__ and not (dirty and not self._build_version[1])):
            dct["buildVersion"] = dictify(self.build_version)
        if "configured" == "type" or (self.configured is not self.__undef__ and not (dirty and not self._configured[1])):
            dct["configured"] = dictify(self.configured)
        if "api_version" == "type" or (self.api_version is not self.__undef__ and not (dirty and not self._api_version[1])):
            dct["apiVersion"] = dictify(self.api_version)
        if "product_name" == "type" or (self.product_name is not self.__undef__ and not (dirty and not self._product_name[1])):
            dct["productName"] = dictify(self.product_name)
        if "build_timestamp" == "type" or (self.build_timestamp is not self.__undef__ and not (dirty and not self._build_timestamp[1])):
            dct["buildTimestamp"] = dictify(self.build_timestamp)
        if "product_type" == "type" or (self.product_type is not self.__undef__ and not (dirty and not self._product_type[1])):
            dct["productType"] = dictify(self.product_type)
        if "build_title" == "type" or (self.build_title is not self.__undef__ and not (dirty and not self._build_title[1])):
            dct["buildTitle"] = dictify(self.build_title)
        if "banner" == "type" or (self.banner is not self.__undef__ and not (dirty and not self._banner[1])):
            dct["banner"] = dictify(self.banner)
        if "locales" == "type" or (self.locales is not self.__undef__ and not (dirty and not self._locales[1])):
            dct["locales"] = dictify(self.locales)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._current_locale = (self._current_locale[0], True)
        self._enabled_features = (self._enabled_features[0], True)
        self._build_version = (self._build_version[0], True)
        self._configured = (self._configured[0], True)
        self._api_version = (self._api_version[0], True)
        self._product_name = (self._product_name[0], True)
        self._build_timestamp = (self._build_timestamp[0], True)
        self._product_type = (self._product_type[0], True)
        self._build_title = (self._build_title[0], True)
        self._banner = (self._banner[0], True)
        self._locales = (self._locales[0], True)

    def is_dirty(self):
        return any([self._current_locale[1], self._enabled_features[1], self._build_version[1], self._configured[1], self._api_version[1], self._product_name[1], self._build_timestamp[1], self._product_type[1], self._build_title[1], self._banner[1], self._locales[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PublicSystemInfo):
            return False
        return super(PublicSystemInfo, self).__eq__(other) and \
               self.current_locale == other.current_locale and \
               self.enabled_features == other.enabled_features and \
               self.build_version == other.build_version and \
               self.configured == other.configured and \
               self.api_version == other.api_version and \
               self.product_name == other.product_name and \
               self.build_timestamp == other.build_timestamp and \
               self.product_type == other.product_type and \
               self.build_title == other.build_title and \
               self.banner == other.banner and \
               self.locales == other.locales

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def current_locale(self):
        """
        The current system locale.

        :rtype: ``basestring``
        """
        return self._current_locale[0]

    @current_locale.setter
    def current_locale(self, value):
        self._current_locale = (value, True)

    @property
    def enabled_features(self):
        """
        The list of enabled features on this Delphix Engine.

        :rtype: ``list`` of ``basestring``
        """
        return self._enabled_features[0]

    @enabled_features.setter
    def enabled_features(self, value):
        self._enabled_features = (value, True)

    @property
    def build_version(self):
        """
        Delphix version of the current system software.

        :rtype: :py:class:`v1_8_1.web.vo.VersionInfo`
        """
        return self._build_version[0]

    @build_version.setter
    def build_version(self, value):
        self._build_version = (value, True)

    @property
    def configured(self):
        """
        Indicates whether the server has gone through initial setup or not.

        :rtype: ``bool``
        """
        return self._configured[0]

    @configured.setter
    def configured(self, value):
        self._configured = (value, True)

    @property
    def api_version(self):
        """
        Maximum supported API version of the current system software.

        :rtype: :py:class:`v1_8_1.web.vo.APIVersion`
        """
        return self._api_version[0]

    @api_version.setter
    def api_version(self, value):
        self._api_version = (value, True)

    @property
    def product_name(self):
        """
        Name of the product that the system is running.

        :rtype: ``basestring``
        """
        return self._product_name[0]

    @product_name.setter
    def product_name(self, value):
        self._product_name = (value, True)

    @property
    def build_timestamp(self):
        """
        Time at which the current system software was built.

        :rtype: ``basestring``
        """
        return self._build_timestamp[0]

    @build_timestamp.setter
    def build_timestamp(self, value):
        self._build_timestamp = (value, True)

    @property
    def product_type(self):
        """
        Product type.

        :rtype: ``basestring``
        """
        return self._product_type[0]

    @product_type.setter
    def product_type(self, value):
        self._product_type = (value, True)

    @property
    def build_title(self):
        """
        Description of the current system software.

        :rtype: ``basestring``
        """
        return self._build_title[0]

    @build_title.setter
    def build_title(self, value):
        self._build_title = (value, True)

    @property
    def banner(self):
        """
        Security banner to display prior to login.

        :rtype: ``basestring``
        """
        return self._banner[0]

    @banner.setter
    def banner(self, value):
        self._banner = (value, True)

    @property
    def locales(self):
        """
        List of available locales.

        :rtype: ``list`` of ``basestring``
        """
        return self._locales[0]

    @locales.setter
    def locales(self, value):
        self._locales = (value, True)

class GlobalLinkingSettings(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* System-wide linking
    settings.
    """
    def __init__(self, undef_enabled=True):
        super(GlobalLinkingSettings, self).__init__()
        self._type = ("GlobalLinkingSettings", True)
        self._encrypted_linking_enabled_by_default = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(GlobalLinkingSettings, cls).from_dict(data, dirty, undef_enabled)
        obj._encrypted_linking_enabled_by_default = (data.get("encryptedLinkingEnabledByDefault", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled_by_default[0] is not None and obj._encrypted_linking_enabled_by_default[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled_by_default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled_by_default[0]))
            common.validate_format(obj._encrypted_linking_enabled_by_default[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(GlobalLinkingSettings, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "encrypted_linking_enabled_by_default" == "type" or (self.encrypted_linking_enabled_by_default is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled_by_default[1])):
            dct["encryptedLinkingEnabledByDefault"] = dictify(self.encrypted_linking_enabled_by_default)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._encrypted_linking_enabled_by_default = (self._encrypted_linking_enabled_by_default[0], True)

    def is_dirty(self):
        return any([self._encrypted_linking_enabled_by_default[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, GlobalLinkingSettings):
            return False
        return super(GlobalLinkingSettings, self).__eq__(other) and \
               self.encrypted_linking_enabled_by_default == other.encrypted_linking_enabled_by_default

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def encrypted_linking_enabled_by_default(self):
        """
        True if encrypted linking should be enabled by default on new dSources.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled_by_default[0]

    @encrypted_linking_enabled_by_default.setter
    def encrypted_linking_enabled_by_default(self, value):
        self._encrypted_linking_enabled_by_default = (value, True)

class DSPOptions(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Options commonly used
    by apps that use DSP.
    """
    def __init__(self, undef_enabled=True):
        super(DSPOptions, self).__init__()
        self._type = ("DSPOptions", True)
        self._encryption = (self.__undef__, True)
        self._compression = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)
        self._num_connections = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DSPOptions, cls).from_dict(data, dirty, undef_enabled)
        obj._encryption = (data.get("encryption", obj.__undef__), dirty)
        if obj._encryption[0] is not None and obj._encryption[0] is not obj.__undef__:
            assert isinstance(obj._encryption[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encryption[0]))
            common.validate_format(obj._encryption[0], "None", None, None)
        obj._compression = (data.get("compression", obj.__undef__), dirty)
        if obj._compression[0] is not None and obj._compression[0] is not obj.__undef__:
            assert isinstance(obj._compression[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compression[0]))
            common.validate_format(obj._compression[0], "None", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        obj._num_connections = (data.get("numConnections", obj.__undef__), dirty)
        if obj._num_connections[0] is not None and obj._num_connections[0] is not obj.__undef__:
            assert isinstance(obj._num_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_connections[0]))
            common.validate_format(obj._num_connections[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DSPOptions, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "encryption" == "type" or (self.encryption is not self.__undef__ and not (dirty and not self._encryption[1])):
            dct["encryption"] = dictify(self.encryption)
        if "compression" == "type" or (self.compression is not self.__undef__ and not (dirty and not self._compression[1])):
            dct["compression"] = dictify(self.compression)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        if "num_connections" == "type" or (self.num_connections is not self.__undef__ and not (dirty and not self._num_connections[1])):
            dct["numConnections"] = dictify(self.num_connections)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._encryption = (self._encryption[0], True)
        self._compression = (self._compression[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)
        self._num_connections = (self._num_connections[0], True)

    def is_dirty(self):
        return any([self._encryption[1], self._compression[1], self._bandwidth_limit[1], self._num_connections[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DSPOptions):
            return False
        return super(DSPOptions, self).__eq__(other) and \
               self.encryption == other.encryption and \
               self.compression == other.compression and \
               self.bandwidth_limit == other.bandwidth_limit and \
               self.num_connections == other.num_connections

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def encryption(self):
        """
        Encrypt the data stream over the network.

        :rtype: ``bool``
        """
        return self._encryption[0]

    @encryption.setter
    def encryption(self, value):
        self._encryption = (value, True)

    @property
    def compression(self):
        """
        Compress the data stream over the network.

        :rtype: ``bool``
        """
        return self._compression[0]

    @compression.setter
    def compression(self, value):
        self._compression = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for network traffic. A value of 0 means no
        limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

    @property
    def num_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use.

        :rtype: ``int``
        """
        return self._num_connections[0]

    @num_connections.setter
    def num_connections(self, value):
        self._num_connections = (value, True)

class HostConfiguration(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The representation of
    the host configuration properties.
    """
    def __init__(self, undef_enabled=True):
        super(HostConfiguration, self).__init__()
        self._type = ("HostConfiguration", True)
        self._discovered = (self.__undef__, True)
        self._machine = (self.__undef__, True)
        self._last_refreshed = (self.__undef__, True)
        self._operating_system = (self.__undef__, True)
        self._last_updated = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostConfiguration, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        if "machine" in data and data["machine"] is not None:
            obj._machine = (factory.create_object(data["machine"], "HostMachine"), dirty)
            factory.validate_type(obj._machine[0], "HostMachine")
        else:
            obj._machine = (obj.__undef__, dirty)
        obj._last_refreshed = (data.get("lastRefreshed", obj.__undef__), dirty)
        if obj._last_refreshed[0] is not None and obj._last_refreshed[0] is not obj.__undef__:
            assert isinstance(obj._last_refreshed[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_refreshed[0]))
            common.validate_format(obj._last_refreshed[0], "None", None, None)
        if "operatingSystem" in data and data["operatingSystem"] is not None:
            obj._operating_system = (factory.create_object(data["operatingSystem"], "HostOS"), dirty)
            factory.validate_type(obj._operating_system[0], "HostOS")
        else:
            obj._operating_system = (obj.__undef__, dirty)
        obj._last_updated = (data.get("lastUpdated", obj.__undef__), dirty)
        if obj._last_updated[0] is not None and obj._last_updated[0] is not obj.__undef__:
            assert isinstance(obj._last_updated[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_updated[0]))
            common.validate_format(obj._last_updated[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostConfiguration, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "machine" == "type" or (self.machine is not self.__undef__ and not (dirty and not self._machine[1])):
            dct["machine"] = dictify(self.machine)
        if "last_refreshed" == "type" or (self.last_refreshed is not self.__undef__ and not (dirty and not self._last_refreshed[1])):
            dct["lastRefreshed"] = dictify(self.last_refreshed)
        if "operating_system" == "type" or (self.operating_system is not self.__undef__ and not (dirty and not self._operating_system[1])):
            dct["operatingSystem"] = dictify(self.operating_system)
        if "last_updated" == "type" or (self.last_updated is not self.__undef__ and not (dirty and not self._last_updated[1])):
            dct["lastUpdated"] = dictify(self.last_updated)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._machine = (self._machine[0], True)
        self._last_refreshed = (self._last_refreshed[0], True)
        self._operating_system = (self._operating_system[0], True)
        self._last_updated = (self._last_updated[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._machine[1], self._last_refreshed[1], self._operating_system[1], self._last_updated[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostConfiguration):
            return False
        return super(HostConfiguration, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.machine == other.machine and \
               self.last_refreshed == other.last_refreshed and \
               self.operating_system == other.operating_system and \
               self.last_updated == other.last_updated

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Indicates whether the host configuration properties were discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def machine(self):
        """
        The host machine information.

        :rtype: :py:class:`v1_8_1.web.vo.HostMachine`
        """
        return self._machine[0]

    @machine.setter
    def machine(self, value):
        self._machine = (value, True)

    @property
    def last_refreshed(self):
        """
        The timestamp when the host was last refreshed.

        :rtype: ``basestring``
        """
        return self._last_refreshed[0]

    @last_refreshed.setter
    def last_refreshed(self, value):
        self._last_refreshed = (value, True)

    @property
    def operating_system(self):
        """
        The host operating system information.

        :rtype: :py:class:`v1_8_1.web.vo.HostOS`
        """
        return self._operating_system[0]

    @operating_system.setter
    def operating_system(self, value):
        self._operating_system = (value, True)

    @property
    def last_updated(self):
        """
        The timestamp when the host was last updated.

        :rtype: ``basestring``
        """
        return self._last_updated[0]

    @last_updated.setter
    def last_updated(self, value):
        self._last_updated = (value, True)

class CertificateFetchParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters for
    fetching a certificate.
    """
    def __init__(self, undef_enabled=True):
        super(CertificateFetchParameters, self).__init__()
        self._type = ("CertificateFetchParameters", True)
        self._host = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CertificateFetchParameters, cls).from_dict(data, dirty, undef_enabled)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CertificateFetchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._host[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CertificateFetchParameters):
            return False
        return super(CertificateFetchParameters, self).__eq__(other) and \
               self.host == other.host and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        Hostname or IP address.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def port(self):
        """
        Port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class JSBookmarkTagUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a Jet Stream bookmark tag.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmarkTagUsageData, self).__init__()
        self._type = ("JSBookmarkTagUsageData", True)
        self._unique = (self.__undef__, True)
        self._referenced = (self.__undef__, True)
        self._bookmark_tag = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmarkTagUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._unique = (data.get("unique", obj.__undef__), dirty)
        if obj._unique[0] is not None and obj._unique[0] is not obj.__undef__:
            assert isinstance(obj._unique[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unique[0]))
            common.validate_format(obj._unique[0], "None", None, None)
        obj._referenced = (data.get("referenced", obj.__undef__), dirty)
        if obj._referenced[0] is not None and obj._referenced[0] is not obj.__undef__:
            assert isinstance(obj._referenced[0], float), ("Expected one of [u'number'], but got %s" % type(obj._referenced[0]))
            common.validate_format(obj._referenced[0], "None", None, None)
        obj._bookmark_tag = (data.get("bookmarkTag", obj.__undef__), dirty)
        if obj._bookmark_tag[0] is not None and obj._bookmark_tag[0] is not obj.__undef__:
            assert isinstance(obj._bookmark_tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark_tag[0]))
            common.validate_format(obj._bookmark_tag[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmarkTagUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "unique" == "type" or (self.unique is not self.__undef__ and not (dirty and not self._unique[1])):
            dct["unique"] = dictify(self.unique)
        if "referenced" == "type" or (self.referenced is not self.__undef__ and not (dirty and not self._referenced[1])):
            dct["referenced"] = dictify(self.referenced)
        if "bookmark_tag" == "type" or (self.bookmark_tag is not self.__undef__ and not (dirty and not self._bookmark_tag[1])):
            dct["bookmarkTag"] = dictify(self.bookmark_tag)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._unique = (self._unique[0], True)
        self._referenced = (self._referenced[0], True)
        self._bookmark_tag = (self._bookmark_tag[0], True)

    def is_dirty(self):
        return any([self._unique[1], self._referenced[1], self._bookmark_tag[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmarkTagUsageData):
            return False
        return super(JSBookmarkTagUsageData, self).__eq__(other) and \
               self.unique == other.unique and \
               self.referenced == other.referenced and \
               self.bookmark_tag == other.bookmark_tag

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def unique(self):
        """
        The space that is being consumed by the set of bookmarks with the given
        tag. This represents the minimum amount of space that will be freed if
        all of the bookmarks are deleted.

        :rtype: ``float``
        """
        return self._unique[0]

    @unique.setter
    def unique(self, value):
        self._unique = (value, True)

    @property
    def referenced(self):
        """
        The total amount of space referenced by bookmarks with this tag. This
        is the sum of the bookmarks' unique, shared, and externallyReferenced
        space.

        :rtype: ``float``
        """
        return self._referenced[0]

    @referenced.setter
    def referenced(self, value):
        self._referenced = (value, True)

    @property
    def bookmark_tag(self):
        """
        The amount of space that will be freed if bookmarks with this tag are
        deleted.

        :rtype: ``basestring``
        """
        return self._bookmark_tag[0]

    @bookmark_tag.setter
    def bookmark_tag(self, value):
        self._bookmark_tag = (value, True)

class SystemInitializationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters used for
    intializing an engine.
    """
    def __init__(self, undef_enabled=True):
        super(SystemInitializationParameters, self).__init__()
        self._type = ("SystemInitializationParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemInitializationParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemInitializationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemInitializationParameters):
            return False
        return super(SystemInitializationParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleDatabaseStatistic(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A row in the database
    performance statistic table.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseStatistic, self).__init__()
        self._type = ("OracleDatabaseStatistic", True)
        self._statistic_values = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseStatistic, cls).from_dict(data, dirty, undef_enabled)
        obj._statistic_values = []
        for item in data.get("statisticValues") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._statistic_values.append(item)
        obj._statistic_values = (obj._statistic_values, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseStatistic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "statistic_values" == "type" or (self.statistic_values is not self.__undef__ and not (dirty and not self._statistic_values[1])):
            dct["statisticValues"] = dictify(self.statistic_values)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._statistic_values = (self._statistic_values[0], True)

    def is_dirty(self):
        return any([self._statistic_values[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseStatistic):
            return False
        return super(OracleDatabaseStatistic, self).__eq__(other) and \
               self.statistic_values == other.statistic_values

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def statistic_values(self):
        """
        A single performance statistic row.

        :rtype: ``list`` of ``basestring``
        """
        return self._statistic_values[0]

    @statistic_values.setter
    def statistic_values(self, value):
        self._statistic_values = (value, True)

class Credential(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The security
    credential.
    """
    def __init__(self, undef_enabled=True):
        super(Credential, self).__init__()
        self._type = ("Credential", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Credential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Credential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Credential):
            return False
        return super(Credential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSSourceDataTimestampParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Input parameters for
    the API that given a point in time, returns the timestamps of the latest
    provisionable points, before the specified time and from the given branch,
    for each data source in the branch's data layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSSourceDataTimestampParameters, self).__init__()
        self._type = ("JSSourceDataTimestampParameters", True)
        self._branch = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSSourceDataTimestampParameters, cls).from_dict(data, dirty, undef_enabled)
        if "branch" not in data:
            raise ValueError("Missing required property \"branch\".")
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        if "time" not in data:
            raise ValueError("Missing required property \"time\".")
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSSourceDataTimestampParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._branch = (self._branch[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._branch[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSSourceDataTimestampParameters):
            return False
        return super(JSSourceDataTimestampParameters, self).__eq__(other) and \
               self.branch == other.branch and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def branch(self):
        """
        A reference to the Jet Stream branch.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def time(self):
        """
        The time that will be used to find provisionable timestamps for the
        sources in the branch's data layout.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class JSTimelinePointParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Specifies the Jet
    Stream timeline point to use for Jet Stream timeline operations such as
    restore and create bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimelinePointParameters, self).__init__()
        self._type = ("JSTimelinePointParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimelinePointParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimelinePointParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimelinePointParameters):
            return False
        return super(JSTimelinePointParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class UserAuthInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Summary authorization
    information about the current user.
    """
    def __init__(self, undef_enabled=True):
        super(UserAuthInfo, self).__init__()
        self._type = ("UserAuthInfo", True)
        self._owner_role = (self.__undef__, True)
        self._provisioner_role = (self.__undef__, True)
        self._authorizations = (self.__undef__, True)
        self._jet_stream_user_role = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UserAuthInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._owner_role = (data.get("ownerRole", obj.__undef__), dirty)
        if obj._owner_role[0] is not None and obj._owner_role[0] is not obj.__undef__:
            assert isinstance(obj._owner_role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._owner_role[0]))
            common.validate_format(obj._owner_role[0], "objectReference", None, None)
        obj._provisioner_role = (data.get("provisionerRole", obj.__undef__), dirty)
        if obj._provisioner_role[0] is not None and obj._provisioner_role[0] is not obj.__undef__:
            assert isinstance(obj._provisioner_role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._provisioner_role[0]))
            common.validate_format(obj._provisioner_role[0], "objectReference", None, None)
        obj._authorizations = []
        for item in data.get("authorizations") or []:
            obj._authorizations.append(factory.create_object(item))
            factory.validate_type(obj._authorizations[-1], "Authorization")
        obj._authorizations = (obj._authorizations, dirty)
        obj._jet_stream_user_role = (data.get("jetStreamUserRole", obj.__undef__), dirty)
        if obj._jet_stream_user_role[0] is not None and obj._jet_stream_user_role[0] is not obj.__undef__:
            assert isinstance(obj._jet_stream_user_role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jet_stream_user_role[0]))
            common.validate_format(obj._jet_stream_user_role[0], "objectReference", None, None)
        if "user" in data and data["user"] is not None:
            obj._user = (factory.create_object(data["user"], "User"), dirty)
            factory.validate_type(obj._user[0], "User")
        else:
            obj._user = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UserAuthInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owner_role" == "type" or (self.owner_role is not self.__undef__ and not (dirty and not self._owner_role[1])):
            dct["ownerRole"] = dictify(self.owner_role)
        if "provisioner_role" == "type" or (self.provisioner_role is not self.__undef__ and not (dirty and not self._provisioner_role[1])):
            dct["provisionerRole"] = dictify(self.provisioner_role)
        if "authorizations" == "type" or (self.authorizations is not self.__undef__ and not (dirty and not self._authorizations[1])):
            dct["authorizations"] = dictify(self.authorizations)
        if "jet_stream_user_role" == "type" or (self.jet_stream_user_role is not self.__undef__ and not (dirty and not self._jet_stream_user_role[1])):
            dct["jetStreamUserRole"] = dictify(self.jet_stream_user_role)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owner_role = (self._owner_role[0], True)
        self._provisioner_role = (self._provisioner_role[0], True)
        self._authorizations = (self._authorizations[0], True)
        self._jet_stream_user_role = (self._jet_stream_user_role[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._owner_role[1], self._provisioner_role[1], self._authorizations[1], self._jet_stream_user_role[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UserAuthInfo):
            return False
        return super(UserAuthInfo, self).__eq__(other) and \
               self.owner_role == other.owner_role and \
               self.provisioner_role == other.provisioner_role and \
               self.authorizations == other.authorizations and \
               self.jet_stream_user_role == other.jet_stream_user_role and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owner_role(self):
        """
        A reference to the system-defined owner role.

        :rtype: ``basestring``
        """
        return self._owner_role[0]

    @owner_role.setter
    def owner_role(self, value):
        self._owner_role = (value, True)

    @property
    def provisioner_role(self):
        """
        A reference to the system-defined provisioner role.

        :rtype: ``basestring``
        """
        return self._provisioner_role[0]

    @provisioner_role.setter
    def provisioner_role(self, value):
        self._provisioner_role = (value, True)

    @property
    def authorizations(self):
        """
        The list of authorizations granted to the current user.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.Authorization`
        """
        return self._authorizations[0]

    @authorizations.setter
    def authorizations(self, value):
        self._authorizations = (value, True)

    @property
    def jet_stream_user_role(self):
        """
        A reference to the system-defined Jet Stream user role.

        :rtype: ``basestring``
        """
        return self._jet_stream_user_role[0]

    @jet_stream_user_role.setter
    def jet_stream_user_role(self, value):
        self._jet_stream_user_role = (value, True)

    @property
    def user(self):
        """
        The currently logged in user.

        :rtype: :py:class:`v1_8_1.web.vo.User`
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class ToolkitLocale(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Contains a mapping
    from message IDs to messages for a locale.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitLocale, self).__init__()
        self._type = ("ToolkitLocale", True)
        self._locale_name = (self.__undef__, True)
        self._messages = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitLocale, cls).from_dict(data, dirty, undef_enabled)
        if "localeName" not in data:
            raise ValueError("Missing required property \"localeName\".")
        obj._locale_name = (data.get("localeName", obj.__undef__), dirty)
        if obj._locale_name[0] is not None and obj._locale_name[0] is not obj.__undef__:
            assert isinstance(obj._locale_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale_name[0]))
            common.validate_format(obj._locale_name[0], "locale", None, None)
        if "messages" not in data:
            raise ValueError("Missing required property \"messages\".")
        obj._messages = (data.get("messages", obj.__undef__), dirty)
        if obj._messages[0] is not None and obj._messages[0] is not obj.__undef__:
            assert isinstance(obj._messages[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._messages[0]))
            common.validate_format(obj._messages[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitLocale, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "locale_name" == "type" or (self.locale_name is not self.__undef__ and not (dirty and not self._locale_name[1])):
            dct["localeName"] = dictify(self.locale_name)
        if "messages" == "type" or (self.messages is not self.__undef__ and not (dirty and not self._messages[1])):
            dct["messages"] = dictify(self.messages)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._locale_name = (self._locale_name[0], True)
        self._messages = (self._messages[0], True)

    def is_dirty(self):
        return any([self._locale_name[1], self._messages[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitLocale):
            return False
        return super(ToolkitLocale, self).__eq__(other) and \
               self.locale_name == other.locale_name and \
               self.messages == other.messages

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def locale_name(self):
        """
        The name of this locale.

        :rtype: ``basestring``
        """
        return self._locale_name[0]

    @locale_name.setter
    def locale_name(self, value):
        self._locale_name = (value, True)

    @property
    def messages(self):
        """
        A mapping of message IDs to messages for this locale.

        :rtype: ``dict``
        """
        return self._messages[0]

    @messages.setter
    def messages(self, value):
        self._messages = (value, True)

class SSHConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Mechanism to test SSH
    connectivity of arbitrary hosts.
    """
    def __init__(self, undef_enabled=True):
        super(SSHConnectivity, self).__init__()
        self._type = ("SSHConnectivity", True)
        self._username = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SSHConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credentials" not in data:
            raise ValueError("Missing required property \"credentials\".")
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SSHConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credentials = (self._credentials[0], True)
        self._port = (self._port[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credentials[1], self._port[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SSHConnectivity):
            return False
        return super(SSHConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.credentials == other.credentials and \
               self.port == other.port and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        User name.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credentials(self):
        """
        User credentials.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def port(self):
        """
        *(default value: 22)* SSH port on remote server.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def address(self):
        """
        Target host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class JobEvent(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents a job event
    object. This can either be a state change or a progress update.
    """
    def __init__(self, undef_enabled=True):
        super(JobEvent, self).__init__()
        self._type = ("JobEvent", True)
        self._diagnoses = (self.__undef__, True)
        self._message_command_output = (self.__undef__, True)
        self._event_type = (self.__undef__, True)
        self._message_details = (self.__undef__, True)
        self._message_action = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._percent_complete = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._message_code = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JobEvent, cls).from_dict(data, dirty, undef_enabled)
        obj._diagnoses = []
        for item in data.get("diagnoses") or []:
            obj._diagnoses.append(factory.create_object(item))
            factory.validate_type(obj._diagnoses[-1], "DiagnosisResult")
        obj._diagnoses = (obj._diagnoses, dirty)
        obj._message_command_output = (data.get("messageCommandOutput", obj.__undef__), dirty)
        if obj._message_command_output[0] is not None and obj._message_command_output[0] is not obj.__undef__:
            assert isinstance(obj._message_command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_command_output[0]))
            common.validate_format(obj._message_command_output[0], "None", None, None)
        obj._event_type = (data.get("eventType", obj.__undef__), dirty)
        if obj._event_type[0] is not None and obj._event_type[0] is not obj.__undef__:
            assert isinstance(obj._event_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_type[0]))
            assert obj._event_type[0] in [u'INFO', u'WARNING', u'ERROR'], "Expected enum [u'INFO', u'WARNING', u'ERROR'] but got %s" % obj._event_type[0]
            common.validate_format(obj._event_type[0], "None", None, None)
        obj._message_details = (data.get("messageDetails", obj.__undef__), dirty)
        if obj._message_details[0] is not None and obj._message_details[0] is not obj.__undef__:
            assert isinstance(obj._message_details[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_details[0]))
            common.validate_format(obj._message_details[0], "None", None, None)
        obj._message_action = (data.get("messageAction", obj.__undef__), dirty)
        if obj._message_action[0] is not None and obj._message_action[0] is not obj.__undef__:
            assert isinstance(obj._message_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_action[0]))
            common.validate_format(obj._message_action[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED', u'RETRYABLE'], "Expected enum [u'INITIAL', u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED', u'RETRYABLE'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._percent_complete = (data.get("percentComplete", obj.__undef__), dirty)
        if obj._percent_complete[0] is not None and obj._percent_complete[0] is not obj.__undef__:
            assert isinstance(obj._percent_complete[0], float), ("Expected one of [u'number'], but got %s" % type(obj._percent_complete[0]))
            common.validate_format(obj._percent_complete[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._message_code = (data.get("messageCode", obj.__undef__), dirty)
        if obj._message_code[0] is not None and obj._message_code[0] is not obj.__undef__:
            assert isinstance(obj._message_code[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_code[0]))
            common.validate_format(obj._message_code[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JobEvent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "diagnoses" == "type" or (self.diagnoses is not self.__undef__ and not (dirty and not self._diagnoses[1])):
            dct["diagnoses"] = dictify(self.diagnoses)
        if "message_command_output" == "type" or (self.message_command_output is not self.__undef__ and not (dirty and not self._message_command_output[1])):
            dct["messageCommandOutput"] = dictify(self.message_command_output)
        if "event_type" == "type" or (self.event_type is not self.__undef__ and not (dirty and not self._event_type[1])):
            dct["eventType"] = dictify(self.event_type)
        if "message_details" == "type" or (self.message_details is not self.__undef__ and not (dirty and not self._message_details[1])):
            dct["messageDetails"] = dictify(self.message_details)
        if "message_action" == "type" or (self.message_action is not self.__undef__ and not (dirty and not self._message_action[1])):
            dct["messageAction"] = dictify(self.message_action)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "percent_complete" == "type" or (self.percent_complete is not self.__undef__ and not (dirty and not self._percent_complete[1])):
            dct["percentComplete"] = dictify(self.percent_complete)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "message_code" == "type" or (self.message_code is not self.__undef__ and not (dirty and not self._message_code[1])):
            dct["messageCode"] = dictify(self.message_code)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._diagnoses = (self._diagnoses[0], True)
        self._message_command_output = (self._message_command_output[0], True)
        self._event_type = (self._event_type[0], True)
        self._message_details = (self._message_details[0], True)
        self._message_action = (self._message_action[0], True)
        self._state = (self._state[0], True)
        self._percent_complete = (self._percent_complete[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._message_code = (self._message_code[0], True)

    def is_dirty(self):
        return any([self._diagnoses[1], self._message_command_output[1], self._event_type[1], self._message_details[1], self._message_action[1], self._state[1], self._percent_complete[1], self._timestamp[1], self._message_code[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JobEvent):
            return False
        return super(JobEvent, self).__eq__(other) and \
               self.diagnoses == other.diagnoses and \
               self.message_command_output == other.message_command_output and \
               self.event_type == other.event_type and \
               self.message_details == other.message_details and \
               self.message_action == other.message_action and \
               self.state == other.state and \
               self.percent_complete == other.percent_complete and \
               self.timestamp == other.timestamp and \
               self.message_code == other.message_code

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def diagnoses(self):
        """
        Results of diagnostic checks run, if any, if the job failed.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.DiagnosisResult`
        """
        return self._diagnoses[0]

    @diagnoses.setter
    def diagnoses(self, value):
        self._diagnoses = (value, True)

    @property
    def message_command_output(self):
        """
        Command output associated with the event, if applicable.

        :rtype: ``basestring``
        """
        return self._message_command_output[0]

    @message_command_output.setter
    def message_command_output(self, value):
        self._message_command_output = (value, True)

    @property
    def event_type(self):
        """
        Type of event. *(permitted values: INFO, WARNING, ERROR)*

        :rtype: ``basestring``
        """
        return self._event_type[0]

    @event_type.setter
    def event_type(self, value):
        self._event_type = (value, True)

    @property
    def message_details(self):
        """
        Localized message details.

        :rtype: ``basestring``
        """
        return self._message_details[0]

    @message_details.setter
    def message_details(self, value):
        self._message_details = (value, True)

    @property
    def message_action(self):
        """
        Localized message action.

        :rtype: ``basestring``
        """
        return self._message_action[0]

    @message_action.setter
    def message_action(self, value):
        self._message_action = (value, True)

    @property
    def state(self):
        """
        New state of the job. *(permitted values: INITIAL, RUNNING, SUSPENDED,
        CANCELED, COMPLETED, FAILED, RETRYABLE)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def percent_complete(self):
        """
        Completion percentage.

        :rtype: ``float``
        """
        return self._percent_complete[0]

    @percent_complete.setter
    def percent_complete(self, value):
        self._percent_complete = (value, True)

    @property
    def timestamp(self):
        """
        Time the event occurred.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def message_code(self):
        """
        Message ID associated with the event.

        :rtype: ``basestring``
        """
        return self._message_code[0]

    @message_code.setter
    def message_code(self, value):
        self._message_code = (value, True)

class LinkedSourceOperations(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes operations
    which are performed on linked sources at various times.
    """
    def __init__(self, undef_enabled=True):
        super(LinkedSourceOperations, self).__init__()
        self._type = ("LinkedSourceOperations", True)
        self._post_sync = (self.__undef__, True)
        self._pre_sync = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LinkedSourceOperations, cls).from_dict(data, dirty, undef_enabled)
        obj._post_sync = []
        for item in data.get("postSync") or []:
            obj._post_sync.append(factory.create_object(item))
            factory.validate_type(obj._post_sync[-1], "SourceOperation")
        obj._post_sync = (obj._post_sync, dirty)
        obj._pre_sync = []
        for item in data.get("preSync") or []:
            obj._pre_sync.append(factory.create_object(item))
            factory.validate_type(obj._pre_sync[-1], "SourceOperation")
        obj._pre_sync = (obj._pre_sync, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LinkedSourceOperations, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "post_sync" == "type" or (self.post_sync is not self.__undef__ and not (dirty and not self._post_sync[1])):
            dct["postSync"] = dictify(self.post_sync)
        if "pre_sync" == "type" or (self.pre_sync is not self.__undef__ and not (dirty and not self._pre_sync[1])):
            dct["preSync"] = dictify(self.pre_sync)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._post_sync = (self._post_sync[0], True)
        self._pre_sync = (self._pre_sync[0], True)

    def is_dirty(self):
        return any([self._post_sync[1], self._pre_sync[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LinkedSourceOperations):
            return False
        return super(LinkedSourceOperations, self).__eq__(other) and \
               self.post_sync == other.post_sync and \
               self.pre_sync == other.pre_sync

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def post_sync(self):
        """
        Operations to perform after syncing a linked source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_sync[0]

    @post_sync.setter
    def post_sync(self, value):
        self._post_sync = (value, True)

    @property
    def pre_sync(self):
        """
        Operations to perform before syncing from a linked source. These
        operations can quiesce any data prior to syncing.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_sync[0]

    @pre_sync.setter
    def pre_sync(self, value):
        self._pre_sync = (value, True)

class JSDataContainerModifyOwnerParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Input parameters for
    addOwner or removeOwner for a data container.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainerModifyOwnerParameters, self).__init__()
        self._type = ("JSDataContainerModifyOwnerParameters", True)
        self._owner = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainerModifyOwnerParameters, cls).from_dict(data, dirty, undef_enabled)
        if "owner" not in data:
            raise ValueError("Missing required property \"owner\".")
        obj._owner = (data.get("owner", obj.__undef__), dirty)
        if obj._owner[0] is not None and obj._owner[0] is not obj.__undef__:
            assert isinstance(obj._owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._owner[0]))
            common.validate_format(obj._owner[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainerModifyOwnerParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owner" == "type" or (self.owner is not self.__undef__ and not (dirty and not self._owner[1])):
            dct["owner"] = dictify(self.owner)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owner = (self._owner[0], True)

    def is_dirty(self):
        return any([self._owner[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainerModifyOwnerParameters):
            return False
        return super(JSDataContainerModifyOwnerParameters, self).__eq__(other) and \
               self.owner == other.owner

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owner(self):
        """
        A reference to the user object for whom to add or remove
        authorizations.

        :rtype: ``basestring``
        """
        return self._owner[0]

    @owner.setter
    def owner(self, value):
        self._owner = (value, True)

class CallResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of an API call.
    """
    def __init__(self, undef_enabled=True):
        super(CallResult, self).__init__()
        self._type = ("CallResult", True)
        self._status = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CallResult, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'OK', u'ERROR'], "Expected enum [u'OK', u'ERROR'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CallResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)

    def is_dirty(self):
        return any([self._status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CallResult):
            return False
        return super(CallResult, self).__eq__(other) and \
               self.status == other.status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Indicates whether an error occurred during the call. *(permitted
        values: OK, ERROR)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

class OracleExport(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The mutable state of
    an Oracle database export.
    """
    def __init__(self, undef_enabled=True):
        super(OracleExport, self).__init__()
        self._type = ("OracleExport", True)
        self._dsp_options = (self.__undef__, True)
        self._file_parallelism = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleExport, cls).from_dict(data, dirty, undef_enabled)
        if "dspOptions" in data and data["dspOptions"] is not None:
            obj._dsp_options = (factory.create_object(data["dspOptions"], "DSPOptions"), dirty)
            factory.validate_type(obj._dsp_options[0], "DSPOptions")
        else:
            obj._dsp_options = (obj.__undef__, dirty)
        obj._file_parallelism = (data.get("fileParallelism", obj.__undef__), dirty)
        if obj._file_parallelism[0] is not None and obj._file_parallelism[0] is not obj.__undef__:
            assert isinstance(obj._file_parallelism[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._file_parallelism[0]))
            common.validate_format(obj._file_parallelism[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleExport, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "dsp_options" == "type" or (self.dsp_options is not self.__undef__ and not (dirty and not self._dsp_options[1])):
            dct["dspOptions"] = dictify(self.dsp_options)
        if "file_parallelism" == "type" or (self.file_parallelism is not self.__undef__ and not (dirty and not self._file_parallelism[1])):
            dct["fileParallelism"] = dictify(self.file_parallelism)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._dsp_options = (self._dsp_options[0], True)
        self._file_parallelism = (self._file_parallelism[0], True)

    def is_dirty(self):
        return any([self._dsp_options[1], self._file_parallelism[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleExport):
            return False
        return super(OracleExport, self).__eq__(other) and \
               self.dsp_options == other.dsp_options and \
               self.file_parallelism == other.file_parallelism

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def dsp_options(self):
        """
        DSP options for export.

        :rtype: :py:class:`v1_8_1.web.vo.DSPOptions`
        """
        return self._dsp_options[0]

    @dsp_options.setter
    def dsp_options(self, value):
        self._dsp_options = (value, True)

    @property
    def file_parallelism(self):
        """
        *(default value: 3)* Number of files to stream in parallel across the
        network.

        :rtype: ``int``
        """
        return self._file_parallelism[0]

    @file_parallelism.setter
    def file_parallelism(self, value):
        self._file_parallelism = (value, True)

class WindowsClusterNodeDiscoveryParameter(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The Name and Address
    for a Windows Cluster Node.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsClusterNodeDiscoveryParameter, self).__init__()
        self._type = ("WindowsClusterNodeDiscoveryParameter", True)
        self._name = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsClusterNodeDiscoveryParameter, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsClusterNodeDiscoveryParameter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._name[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsClusterNodeDiscoveryParameter):
            return False
        return super(WindowsClusterNodeDiscoveryParameter, self).__eq__(other) and \
               self.name == other.name and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        The hostname of the node.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def address(self):
        """
        The address of the node.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class FaultResolveParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input when marking a fault as resolved.
    """
    def __init__(self, undef_enabled=True):
        super(FaultResolveParameters, self).__init__()
        self._type = ("FaultResolveParameters", True)
        self._ignore = (self.__undef__, True)
        self._comments = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FaultResolveParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._ignore = (data.get("ignore", obj.__undef__), dirty)
        if obj._ignore[0] is not None and obj._ignore[0] is not obj.__undef__:
            assert isinstance(obj._ignore[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._ignore[0]))
            common.validate_format(obj._ignore[0], "None", None, None)
        obj._comments = (data.get("comments", obj.__undef__), dirty)
        if obj._comments[0] is not None and obj._comments[0] is not obj.__undef__:
            assert isinstance(obj._comments[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._comments[0]))
            common.validate_format(obj._comments[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FaultResolveParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ignore" == "type" or (self.ignore is not self.__undef__ and not (dirty and not self._ignore[1])):
            dct["ignore"] = dictify(self.ignore)
        if "comments" == "type" or (self.comments is not self.__undef__ and not (dirty and not self._comments[1])):
            dct["comments"] = dictify(self.comments)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ignore = (self._ignore[0], True)
        self._comments = (self._comments[0], True)

    def is_dirty(self):
        return any([self._ignore[1], self._comments[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FaultResolveParameters):
            return False
        return super(FaultResolveParameters, self).__eq__(other) and \
               self.ignore == other.ignore and \
               self.comments == other.comments

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ignore(self):
        """
        Flag indicating whether to ignore this fault if it is detected on the
        same object in the future.

        :rtype: ``bool``
        """
        return self._ignore[0]

    @ignore.setter
    def ignore(self, value):
        self._ignore = (value, True)

    @property
    def comments(self):
        """
        The comments describing the steps taken to resolve a fault.

        :rtype: ``basestring``
        """
        return self._comments[0]

    @comments.setter
    def comments(self, value):
        self._comments = (value, True)

class AggregateCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Capacity data for an
    aggregation of containers.
    """
    def __init__(self, undef_enabled=True):
        super(AggregateCapacityData, self).__init__()
        self._type = ("AggregateCapacityData", True)
        self._source = (self.__undef__, True)
        self._virtual = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AggregateCapacityData, cls).from_dict(data, dirty, undef_enabled)
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._source[0], "CapacityBreakdown")
        else:
            obj._source = (obj.__undef__, dirty)
        if "virtual" in data and data["virtual"] is not None:
            obj._virtual = (factory.create_object(data["virtual"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._virtual[0], "CapacityBreakdown")
        else:
            obj._virtual = (obj.__undef__, dirty)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AggregateCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "virtual" == "type" or (self.virtual is not self.__undef__ and not (dirty and not self._virtual[1])):
            dct["virtual"] = dictify(self.virtual)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._virtual = (self._virtual[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._source[1], self._virtual[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AggregateCapacityData):
            return False
        return super(AggregateCapacityData, self).__eq__(other) and \
               self.source == other.source and \
               self.virtual == other.virtual and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        Statistics for dSources in this aggregation.

        :rtype: :py:class:`v1_8_1.web.vo.CapacityBreakdown`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def virtual(self):
        """
        Statistics for VDBs in this aggregation.

        :rtype: :py:class:`v1_8_1.web.vo.CapacityBreakdown`
        """
        return self._virtual[0]

    @virtual.setter
    def virtual(self, value):
        self._virtual = (value, True)

    @property
    def timestamp(self):
        """
        Time at which this information was sampled.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class LuaEventBundle(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* An opaque type
    containing all information necessary to produce localized content from a
    toolkit.
    """
    def __init__(self, undef_enabled=True):
        super(LuaEventBundle, self).__init__()
        self._type = ("LuaEventBundle", True)
        self._params = (self.__undef__, True)
        self._toolkit_name = (self.__undef__, True)
        self._message_id = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LuaEventBundle, cls).from_dict(data, dirty, undef_enabled)
        if "params" not in data:
            raise ValueError("Missing required property \"params\".")
        obj._params = []
        for item in data.get("params") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._params.append(item)
        obj._params = (obj._params, dirty)
        if "toolkitName" not in data:
            raise ValueError("Missing required property \"toolkitName\".")
        obj._toolkit_name = (data.get("toolkitName", obj.__undef__), dirty)
        if obj._toolkit_name[0] is not None and obj._toolkit_name[0] is not obj.__undef__:
            assert isinstance(obj._toolkit_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit_name[0]))
            common.validate_format(obj._toolkit_name[0], "None", None, None)
        if "messageId" not in data:
            raise ValueError("Missing required property \"messageId\".")
        obj._message_id = (data.get("messageId", obj.__undef__), dirty)
        if obj._message_id[0] is not None and obj._message_id[0] is not obj.__undef__:
            assert isinstance(obj._message_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_id[0]))
            common.validate_format(obj._message_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LuaEventBundle, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "params" == "type" or (self.params is not self.__undef__ and not (dirty and not self._params[1])):
            dct["params"] = dictify(self.params)
        if "toolkit_name" == "type" or (self.toolkit_name is not self.__undef__ and not (dirty and not self._toolkit_name[1])):
            dct["toolkitName"] = dictify(self.toolkit_name)
        if "message_id" == "type" or (self.message_id is not self.__undef__ and not (dirty and not self._message_id[1])):
            dct["messageId"] = dictify(self.message_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._params = (self._params[0], True)
        self._toolkit_name = (self._toolkit_name[0], True)
        self._message_id = (self._message_id[0], True)

    def is_dirty(self):
        return any([self._params[1], self._toolkit_name[1], self._message_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LuaEventBundle):
            return False
        return super(LuaEventBundle, self).__eq__(other) and \
               self.params == other.params and \
               self.toolkit_name == other.toolkit_name and \
               self.message_id == other.message_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def params(self):
        """
        The parameter values to consume when this event bundle is localized.

        :rtype: ``list`` of ``basestring``
        """
        return self._params[0]

    @params.setter
    def params(self, value):
        self._params = (value, True)

    @property
    def toolkit_name(self):
        """
        The name of the toolkit that generated this event bundle.

        :rtype: ``basestring``
        """
        return self._toolkit_name[0]

    @toolkit_name.setter
    def toolkit_name(self, value):
        self._toolkit_name = (value, True)

    @property
    def message_id(self):
        """
        The unique identifier of the message in this event bundle.

        :rtype: ``basestring``
        """
        return self._message_id[0]

    @message_id.setter
    def message_id(self, value):
        self._message_id = (value, True)

class ASEInstanceConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* SAP ASE instance
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(ASEInstanceConfig, self).__init__()
        self._type = ("ASEInstanceConfig", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEInstanceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEInstanceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEInstanceConfig):
            return False
        return super(ASEInstanceConfig, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The reference to the associated host.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class PersistentObject(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Super schema for all
    typed schemas with a reference property.
    """
    def __init__(self, undef_enabled=True):
        super(PersistentObject, self).__init__()
        self._type = ("PersistentObject", True)
        self._namespace = (self.__undef__, True)
        self._reference = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PersistentObject, cls).from_dict(data, dirty, undef_enabled)
        obj._namespace = (data.get("namespace", obj.__undef__), dirty)
        if obj._namespace[0] is not None and obj._namespace[0] is not obj.__undef__:
            assert isinstance(obj._namespace[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._namespace[0]))
            common.validate_format(obj._namespace[0], "objectReference", None, None)
        obj._reference = (data.get("reference", obj.__undef__), dirty)
        if obj._reference[0] is not None and obj._reference[0] is not obj.__undef__:
            assert isinstance(obj._reference[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._reference[0]))
            common.validate_format(obj._reference[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PersistentObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "namespace" == "type" or (self.namespace is not self.__undef__ and not (dirty and not self._namespace[1])):
            dct["namespace"] = dictify(self.namespace)
        if "reference" == "type" or (self.reference is not self.__undef__ and not (dirty and not self._reference[1])):
            dct["reference"] = dictify(self.reference)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._namespace = (self._namespace[0], True)
        self._reference = (self._reference[0], True)

    def is_dirty(self):
        return any([self._namespace[1], self._reference[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PersistentObject):
            return False
        return super(PersistentObject, self).__eq__(other) and \
               self.namespace == other.namespace and \
               self.reference == other.reference

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def namespace(self):
        """
        Alternate namespace for this object, for replicated and restored
        objects.

        :rtype: ``basestring``
        """
        return self._namespace[0]

    @namespace.setter
    def namespace(self, value):
        self._namespace = (value, True)

    @property
    def reference(self):
        """
        The object reference.

        :rtype: ``basestring``
        """
        return self._reference[0]

    @reference.setter
    def reference(self, value):
        self._reference = (value, True)

class OracleInstance(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Representation of an
    Oracle instance configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleInstance, self).__init__()
        self._type = ("OracleInstance", True)
        self._instance_number = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_number = (data.get("instanceNumber", obj.__undef__), dirty)
        if obj._instance_number[0] is not None and obj._instance_number[0] is not obj.__undef__:
            assert isinstance(obj._instance_number[0], float), ("Expected one of [u'number'], but got %s" % type(obj._instance_number[0]))
            common.validate_format(obj._instance_number[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, 15)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_number" == "type" or (self.instance_number is not self.__undef__ and not (dirty and not self._instance_number[1])):
            dct["instanceNumber"] = dictify(self.instance_number)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_number = (self._instance_number[0], True)
        self._instance_name = (self._instance_name[0], True)

    def is_dirty(self):
        return any([self._instance_number[1], self._instance_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleInstance):
            return False
        return super(OracleInstance, self).__eq__(other) and \
               self.instance_number == other.instance_number and \
               self.instance_name == other.instance_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_number(self):
        """
        The number of the instance.

        :rtype: ``float``
        """
        return self._instance_number[0]

    @instance_number.setter
    def instance_number(self, value):
        self._instance_number = (value, True)

    @property
    def instance_name(self):
        """
        The name of the instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

class PgSQLHBAEntry(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* An entry in the
    PostgreSQL host-based authentication file (pg_hba.conf).
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLHBAEntry, self).__init__()
        self._type = ("PgSQLHBAEntry", True)
        self._auth_method = (self.__undef__, True)
        self._database = (self.__undef__, True)
        self._auth_options = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._entry_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLHBAEntry, cls).from_dict(data, dirty, undef_enabled)
        obj._auth_method = (data.get("authMethod", obj.__undef__), dirty)
        if obj._auth_method[0] is not None and obj._auth_method[0] is not obj.__undef__:
            assert isinstance(obj._auth_method[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_method[0]))
            assert obj._auth_method[0] in [u'trust', u'reject', u'md5', u'password', u'gss', u'sspi', u'krb5', u'ident', u'peer', u'ldap', u'radius', u'cert', u'pam'], "Expected enum [u'trust', u'reject', u'md5', u'password', u'gss', u'sspi', u'krb5', u'ident', u'peer', u'ldap', u'radius', u'cert', u'pam'] but got %s" % obj._auth_method[0]
            common.validate_format(obj._auth_method[0], "None", None, None)
        obj._database = (data.get("database", obj.__undef__), dirty)
        if obj._database[0] is not None and obj._database[0] is not obj.__undef__:
            assert isinstance(obj._database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database[0]))
            common.validate_format(obj._database[0], "None", None, 63)
        obj._auth_options = (data.get("authOptions", obj.__undef__), dirty)
        if obj._auth_options[0] is not None and obj._auth_options[0] is not obj.__undef__:
            assert isinstance(obj._auth_options[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_options[0]))
            common.validate_format(obj._auth_options[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 63)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        obj._entry_type = (data.get("entryType", obj.__undef__), dirty)
        if obj._entry_type[0] is not None and obj._entry_type[0] is not obj.__undef__:
            assert isinstance(obj._entry_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._entry_type[0]))
            assert obj._entry_type[0] in [u'local', u'host', u'hostssl', u'hostnossl'], "Expected enum [u'local', u'host', u'hostssl', u'hostnossl'] but got %s" % obj._entry_type[0]
            common.validate_format(obj._entry_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLHBAEntry, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "auth_method" == "type" or (self.auth_method is not self.__undef__ and not (dirty and not self._auth_method[1])):
            dct["authMethod"] = dictify(self.auth_method)
        if "database" == "type" or (self.database is not self.__undef__ and not (dirty and not self._database[1])):
            dct["database"] = dictify(self.database)
        if "auth_options" == "type" or (self.auth_options is not self.__undef__ and not (dirty and not self._auth_options[1])):
            dct["authOptions"] = dictify(self.auth_options)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "entry_type" == "type" or (self.entry_type is not self.__undef__ and not (dirty and not self._entry_type[1])):
            dct["entryType"] = dictify(self.entry_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._auth_method = (self._auth_method[0], True)
        self._database = (self._database[0], True)
        self._auth_options = (self._auth_options[0], True)
        self._user = (self._user[0], True)
        self._address = (self._address[0], True)
        self._entry_type = (self._entry_type[0], True)

    def is_dirty(self):
        return any([self._auth_method[1], self._database[1], self._auth_options[1], self._user[1], self._address[1], self._entry_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLHBAEntry):
            return False
        return super(PgSQLHBAEntry, self).__eq__(other) and \
               self.auth_method == other.auth_method and \
               self.database == other.database and \
               self.auth_options == other.auth_options and \
               self.user == other.user and \
               self.address == other.address and \
               self.entry_type == other.entry_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def auth_method(self):
        """
        The authentication method to use when connecting via this entry.
        *(permitted values: trust, reject, md5, password, gss, sspi, krb5,
        ident, peer, ldap, radius, cert, pam)*

        :rtype: ``basestring``
        """
        return self._auth_method[0]

    @auth_method.setter
    def auth_method(self, value):
        self._auth_method = (value, True)

    @property
    def database(self):
        """
        *(default value: all)* The database name this entry matches.

        :rtype: ``basestring``
        """
        return self._database[0]

    @database.setter
    def database(self, value):
        self._database = (value, True)

    @property
    def auth_options(self):
        """
        Options for the authentication method.

        :rtype: ``basestring``
        """
        return self._auth_options[0]

    @auth_options.setter
    def auth_options(self, value):
        self._auth_options = (value, True)

    @property
    def user(self):
        """
        *(default value: all)* The database username this entry matches.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def address(self):
        """
        The client machine address that this entry matches.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def entry_type(self):
        """
        The connection type of this entry. *(permitted values: local, host,
        hostssl, hostnossl)*

        :rtype: ``basestring``
        """
        return self._entry_type[0]

    @entry_type.setter
    def entry_type(self, value):
        self._entry_type = (value, True)

class LdapInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Global LDAP
    information.
    """
    def __init__(self, undef_enabled=True):
        super(LdapInfo, self).__init__()
        self._type = ("LdapInfo", True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LdapInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LdapInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LdapInfo):
            return False
        return super(LdapInfo, self).__eq__(other) and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        Whether LDAP authentication is configured and enabled or not for this
        Delphix Engine.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class CompatibilityCriteria(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The compatibility
    criteria to use for selecting compatible repositories. Parameters with a
    value of null are not considered when selecting compatible repositories.
    """
    def __init__(self, undef_enabled=True):
        super(CompatibilityCriteria, self).__init__()
        self._type = ("CompatibilityCriteria", True)
        self._environment = (self.__undef__, True)
        self._staging_enabled = (self.__undef__, True)
        self._os = (self.__undef__, True)
        self._architecture = (self.__undef__, True)
        self._processor = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._staging_enabled = (data.get("stagingEnabled", obj.__undef__), dirty)
        if obj._staging_enabled[0] is not None and obj._staging_enabled[0] is not obj.__undef__:
            assert isinstance(obj._staging_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging_enabled[0]))
            common.validate_format(obj._staging_enabled[0], "None", None, None)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            assert obj._os[0] in [u'Linux', u'AIX', u'HPUX', u'SunOS', u'Windows'], "Expected enum [u'Linux', u'AIX', u'HPUX', u'SunOS', u'Windows'] but got %s" % obj._os[0]
            common.validate_format(obj._os[0], "None", None, None)
        obj._architecture = (data.get("architecture", obj.__undef__), dirty)
        if obj._architecture[0] is not None and obj._architecture[0] is not obj.__undef__:
            assert isinstance(obj._architecture[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._architecture[0]))
            common.validate_format(obj._architecture[0], "None", None, None)
        obj._processor = (data.get("processor", obj.__undef__), dirty)
        if obj._processor[0] is not None and obj._processor[0] is not obj.__undef__:
            assert isinstance(obj._processor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._processor[0]))
            assert obj._processor[0] in [u'x86', u'ia64', u'powerpc', u'sparc'], "Expected enum [u'x86', u'ia64', u'powerpc', u'sparc'] but got %s" % obj._processor[0]
            common.validate_format(obj._processor[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "staging_enabled" == "type" or (self.staging_enabled is not self.__undef__ and not (dirty and not self._staging_enabled[1])):
            dct["stagingEnabled"] = dictify(self.staging_enabled)
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        if "architecture" == "type" or (self.architecture is not self.__undef__ and not (dirty and not self._architecture[1])):
            dct["architecture"] = dictify(self.architecture)
        if "processor" == "type" or (self.processor is not self.__undef__ and not (dirty and not self._processor[1])):
            dct["processor"] = dictify(self.processor)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._staging_enabled = (self._staging_enabled[0], True)
        self._os = (self._os[0], True)
        self._architecture = (self._architecture[0], True)
        self._processor = (self._processor[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._staging_enabled[1], self._os[1], self._architecture[1], self._processor[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CompatibilityCriteria):
            return False
        return super(CompatibilityCriteria, self).__eq__(other) and \
               self.environment == other.environment and \
               self.staging_enabled == other.staging_enabled and \
               self.os == other.os and \
               self.architecture == other.architecture and \
               self.processor == other.processor

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Selected repositories are installed on this environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def staging_enabled(self):
        """
        If true, selected repositories have staging enabled.

        :rtype: ``bool``
        """
        return self._staging_enabled[0]

    @staging_enabled.setter
    def staging_enabled(self, value):
        self._staging_enabled = (value, True)

    @property
    def os(self):
        """
        Selected repositories are installed on a host with this OS. *(permitted
        values: Linux, AIX, HPUX, SunOS, Windows)*

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

    @property
    def architecture(self):
        """
        Selected repositories are installed on a host with this architecture
        (32-bit or 64-bit).

        :rtype: ``int``
        """
        return self._architecture[0]

    @architecture.setter
    def architecture(self, value):
        self._architecture = (value, True)

    @property
    def processor(self):
        """
        Selected repositories are installed on a host with this type of
        processor. *(permitted values: x86, ia64, powerpc, sparc)*

        :rtype: ``basestring``
        """
        return self._processor[0]

    @processor.setter
    def processor(self, value):
        self._processor = (value, True)

class AppDataCachedMountPoint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Specified information
    about an active mount of an AppData container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataCachedMountPoint, self).__init__()
        self._type = ("AppDataCachedMountPoint", True)
        self._environment = (self.__undef__, True)
        self._ordinal = (self.__undef__, True)
        self._mount_path = (self.__undef__, True)
        self._shared_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataCachedMountPoint, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._ordinal = (data.get("ordinal", obj.__undef__), dirty)
        if obj._ordinal[0] is not None and obj._ordinal[0] is not obj.__undef__:
            assert isinstance(obj._ordinal[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._ordinal[0]))
            common.validate_format(obj._ordinal[0], "None", None, None)
        obj._mount_path = (data.get("mountPath", obj.__undef__), dirty)
        if obj._mount_path[0] is not None and obj._mount_path[0] is not obj.__undef__:
            assert isinstance(obj._mount_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_path[0]))
            common.validate_format(obj._mount_path[0], "unixpath", None, None)
        obj._shared_path = (data.get("sharedPath", obj.__undef__), dirty)
        if obj._shared_path[0] is not None and obj._shared_path[0] is not obj.__undef__:
            assert isinstance(obj._shared_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._shared_path[0]))
            common.validate_format(obj._shared_path[0], "unixpath", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataCachedMountPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "ordinal" == "type" or (self.ordinal is not self.__undef__ and not (dirty and not self._ordinal[1])):
            dct["ordinal"] = dictify(self.ordinal)
        if "mount_path" == "type" or (self.mount_path is not self.__undef__ and not (dirty and not self._mount_path[1])):
            dct["mountPath"] = dictify(self.mount_path)
        if "shared_path" == "type" or (self.shared_path is not self.__undef__ and not (dirty and not self._shared_path[1])):
            dct["sharedPath"] = dictify(self.shared_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._ordinal = (self._ordinal[0], True)
        self._mount_path = (self._mount_path[0], True)
        self._shared_path = (self._shared_path[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._ordinal[1], self._mount_path[1], self._shared_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataCachedMountPoint):
            return False
        return super(AppDataCachedMountPoint, self).__eq__(other) and \
               self.environment == other.environment and \
               self.ordinal == other.ordinal and \
               self.mount_path == other.mount_path and \
               self.shared_path == other.shared_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Reference to the environment on which the file system is mounted.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def ordinal(self):
        """
        Order in mount sequence.

        :rtype: ``int``
        """
        return self._ordinal[0]

    @ordinal.setter
    def ordinal(self, value):
        self._ordinal = (value, True)

    @property
    def mount_path(self):
        """
        Absolute path on the target environment were the filesystem is mounted.

        :rtype: ``basestring``
        """
        return self._mount_path[0]

    @mount_path.setter
    def mount_path(self, value):
        self._mount_path = (value, True)

    @property
    def shared_path(self):
        """
        Relative path within the container of the directory that is mounted.

        :rtype: ``basestring``
        """
        return self._shared_path[0]

    @shared_path.setter
    def shared_path(self, value):
        self._shared_path = (value, True)

class SnapshotCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Capacity metrics for a
    single snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotCapacityData, self).__init__()
        self._type = ("SnapshotCapacityData", True)
        self._descendant_vd_bs = (self.__undef__, True)
        self._manual_retention = (self.__undef__, True)
        self._snapshot = (self.__undef__, True)
        self._snapshot_timestamp = (self.__undef__, True)
        self._policy_retention = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._descendant_vd_bs = []
        for item in data.get("descendantVDBs") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._descendant_vd_bs.append(item)
        obj._descendant_vd_bs = (obj._descendant_vd_bs, dirty)
        obj._manual_retention = (data.get("manualRetention", obj.__undef__), dirty)
        if obj._manual_retention[0] is not None and obj._manual_retention[0] is not obj.__undef__:
            assert isinstance(obj._manual_retention[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._manual_retention[0]))
            common.validate_format(obj._manual_retention[0], "None", None, None)
        obj._snapshot = (data.get("snapshot", obj.__undef__), dirty)
        if obj._snapshot[0] is not None and obj._snapshot[0] is not obj.__undef__:
            assert isinstance(obj._snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot[0]))
            common.validate_format(obj._snapshot[0], "objectReference", None, None)
        obj._snapshot_timestamp = (data.get("snapshotTimestamp", obj.__undef__), dirty)
        if obj._snapshot_timestamp[0] is not None and obj._snapshot_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._snapshot_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot_timestamp[0]))
            common.validate_format(obj._snapshot_timestamp[0], "date", None, None)
        obj._policy_retention = (data.get("policyRetention", obj.__undef__), dirty)
        if obj._policy_retention[0] is not None and obj._policy_retention[0] is not obj.__undef__:
            assert isinstance(obj._policy_retention[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._policy_retention[0]))
            common.validate_format(obj._policy_retention[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "descendant_vd_bs" == "type" or (self.descendant_vd_bs is not self.__undef__ and not (dirty and not self._descendant_vd_bs[1])):
            dct["descendantVDBs"] = dictify(self.descendant_vd_bs)
        if "manual_retention" == "type" or (self.manual_retention is not self.__undef__ and not (dirty and not self._manual_retention[1])):
            dct["manualRetention"] = dictify(self.manual_retention)
        if "snapshot" == "type" or (self.snapshot is not self.__undef__ and not (dirty and not self._snapshot[1])):
            dct["snapshot"] = dictify(self.snapshot)
        if "snapshot_timestamp" == "type" or (self.snapshot_timestamp is not self.__undef__ and not (dirty and not self._snapshot_timestamp[1])):
            dct["snapshotTimestamp"] = dictify(self.snapshot_timestamp)
        if "policy_retention" == "type" or (self.policy_retention is not self.__undef__ and not (dirty and not self._policy_retention[1])):
            dct["policyRetention"] = dictify(self.policy_retention)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._descendant_vd_bs = (self._descendant_vd_bs[0], True)
        self._manual_retention = (self._manual_retention[0], True)
        self._snapshot = (self._snapshot[0], True)
        self._snapshot_timestamp = (self._snapshot_timestamp[0], True)
        self._policy_retention = (self._policy_retention[0], True)

    def is_dirty(self):
        return any([self._descendant_vd_bs[1], self._manual_retention[1], self._snapshot[1], self._snapshot_timestamp[1], self._policy_retention[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotCapacityData):
            return False
        return super(SnapshotCapacityData, self).__eq__(other) and \
               self.descendant_vd_bs == other.descendant_vd_bs and \
               self.manual_retention == other.manual_retention and \
               self.snapshot == other.snapshot and \
               self.snapshot_timestamp == other.snapshot_timestamp and \
               self.policy_retention == other.policy_retention

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def descendant_vd_bs(self):
        """
        List of VDBs that have been provisioned from this snapshot.

        :rtype: ``list`` of ``basestring``
        """
        return self._descendant_vd_bs[0]

    @descendant_vd_bs.setter
    def descendant_vd_bs(self, value):
        self._descendant_vd_bs = (value, True)

    @property
    def manual_retention(self):
        """
        The manual retention setting on this snapshot, in days.

        :rtype: ``int``
        """
        return self._manual_retention[0]

    @manual_retention.setter
    def manual_retention(self, value):
        self._manual_retention = (value, True)

    @property
    def snapshot(self):
        """
        Reference to the snapshot.

        :rtype: ``basestring``
        """
        return self._snapshot[0]

    @snapshot.setter
    def snapshot(self, value):
        self._snapshot = (value, True)

    @property
    def snapshot_timestamp(self):
        """
        Time at which this snapshot was taken.

        :rtype: ``basestring``
        """
        return self._snapshot_timestamp[0]

    @snapshot_timestamp.setter
    def snapshot_timestamp(self, value):
        self._snapshot_timestamp = (value, True)

    @property
    def policy_retention(self):
        """
        Whether this snapshot is currently being retained due to policy
        settings.

        :rtype: ``bool``
        """
        return self._policy_retention[0]

    @policy_retention.setter
    def policy_retention(self, value):
        self._policy_retention = (value, True)

class JSDataLayoutCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    create a data layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataLayoutCreateParameters, self).__init__()
        self._type = ("JSDataLayoutCreateParameters", True)
        self._notes = (self.__undef__, True)
        self._properties = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._data_sources = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataLayoutCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._notes = (data.get("notes", obj.__undef__), dirty)
        if obj._notes[0] is not None and obj._notes[0] is not obj.__undef__:
            assert isinstance(obj._notes[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._notes[0]))
            common.validate_format(obj._notes[0], "None", None, 4096)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        if "dataSources" not in data:
            raise ValueError("Missing required property \"dataSources\".")
        obj._data_sources = []
        for item in data.get("dataSources") or []:
            obj._data_sources.append(factory.create_object(item))
            factory.validate_type(obj._data_sources[-1], "JSDataSourceCreateParameters")
        obj._data_sources = (obj._data_sources, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataLayoutCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "notes" == "type" or (self.notes is not self.__undef__ and not (dirty and not self._notes[1])):
            dct["notes"] = dictify(self.notes)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "data_sources" == "type" or (self.data_sources is not self.__undef__ and not (dirty and not self._data_sources[1])):
            dct["dataSources"] = dictify(self.data_sources)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._notes = (self._notes[0], True)
        self._properties = (self._properties[0], True)
        self._name = (self._name[0], True)
        self._data_sources = (self._data_sources[0], True)

    def is_dirty(self):
        return any([self._notes[1], self._properties[1], self._name[1], self._data_sources[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataLayoutCreateParameters):
            return False
        return super(JSDataLayoutCreateParameters, self).__eq__(other) and \
               self.notes == other.notes and \
               self.properties == other.properties and \
               self.name == other.name and \
               self.data_sources == other.data_sources

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def notes(self):
        """
        A description of this data layout to define what it is used for.

        :rtype: ``basestring``
        """
        return self._notes[0]

    @notes.setter
    def notes(self, value):
        self._notes = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this data layout.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

    @property
    def name(self):
        """
        The name of the data layout.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def data_sources(self):
        """
        The set of data sources that belong to this data layout.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.JSDataSourceCreateParameters`
        """
        return self._data_sources[0]

    @data_sources.setter
    def data_sources(self, value):
        self._data_sources = (value, True)

class StatisticAxis(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The attributes of a
    statistic axis.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticAxis, self).__init__()
        self._type = ("StatisticAxis", True)
        self._explanation = (self.__undef__, True)
        self._constraint_type = (self.__undef__, True)
        self._value_type = (self.__undef__, True)
        self._axis_name = (self.__undef__, True)
        self._stream_attribute = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticAxis, cls).from_dict(data, dirty, undef_enabled)
        obj._explanation = (data.get("explanation", obj.__undef__), dirty)
        if obj._explanation[0] is not None and obj._explanation[0] is not obj.__undef__:
            assert isinstance(obj._explanation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._explanation[0]))
            common.validate_format(obj._explanation[0], "None", None, None)
        obj._constraint_type = (data.get("constraintType", obj.__undef__), dirty)
        if obj._constraint_type[0] is not None and obj._constraint_type[0] is not obj.__undef__:
            assert isinstance(obj._constraint_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._constraint_type[0]))
            common.validate_format(obj._constraint_type[0], "None", None, None)
        obj._value_type = (data.get("valueType", obj.__undef__), dirty)
        if obj._value_type[0] is not None and obj._value_type[0] is not obj.__undef__:
            assert isinstance(obj._value_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._value_type[0]))
            assert obj._value_type[0] in [u'INTEGER', u'BOOLEAN', u'STRING', u'HISTOGRAM'], "Expected enum [u'INTEGER', u'BOOLEAN', u'STRING', u'HISTOGRAM'] but got %s" % obj._value_type[0]
            common.validate_format(obj._value_type[0], "None", None, None)
        obj._axis_name = (data.get("axisName", obj.__undef__), dirty)
        if obj._axis_name[0] is not None and obj._axis_name[0] is not obj.__undef__:
            assert isinstance(obj._axis_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._axis_name[0]))
            common.validate_format(obj._axis_name[0], "None", None, None)
        obj._stream_attribute = (data.get("streamAttribute", obj.__undef__), dirty)
        if obj._stream_attribute[0] is not None and obj._stream_attribute[0] is not obj.__undef__:
            assert isinstance(obj._stream_attribute[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._stream_attribute[0]))
            common.validate_format(obj._stream_attribute[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticAxis, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "explanation" == "type" or (self.explanation is not self.__undef__ and not (dirty and not self._explanation[1])):
            dct["explanation"] = dictify(self.explanation)
        if "constraint_type" == "type" or (self.constraint_type is not self.__undef__ and not (dirty and not self._constraint_type[1])):
            dct["constraintType"] = dictify(self.constraint_type)
        if "value_type" == "type" or (self.value_type is not self.__undef__ and not (dirty and not self._value_type[1])):
            dct["valueType"] = dictify(self.value_type)
        if "axis_name" == "type" or (self.axis_name is not self.__undef__ and not (dirty and not self._axis_name[1])):
            dct["axisName"] = dictify(self.axis_name)
        if "stream_attribute" == "type" or (self.stream_attribute is not self.__undef__ and not (dirty and not self._stream_attribute[1])):
            dct["streamAttribute"] = dictify(self.stream_attribute)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._explanation = (self._explanation[0], True)
        self._constraint_type = (self._constraint_type[0], True)
        self._value_type = (self._value_type[0], True)
        self._axis_name = (self._axis_name[0], True)
        self._stream_attribute = (self._stream_attribute[0], True)

    def is_dirty(self):
        return any([self._explanation[1], self._constraint_type[1], self._value_type[1], self._axis_name[1], self._stream_attribute[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticAxis):
            return False
        return super(StatisticAxis, self).__eq__(other) and \
               self.explanation == other.explanation and \
               self.constraint_type == other.constraint_type and \
               self.value_type == other.value_type and \
               self.axis_name == other.axis_name and \
               self.stream_attribute == other.stream_attribute

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def explanation(self):
        """
        A deeper explanation of the data this corresponds to.

        :rtype: ``basestring``
        """
        return self._explanation[0]

    @explanation.setter
    def explanation(self, value):
        self._explanation = (value, True)

    @property
    def constraint_type(self):
        """
        The type of constraint that can be applied to this axis.

        :rtype: ``basestring``
        """
        return self._constraint_type[0]

    @constraint_type.setter
    def constraint_type(self, value):
        self._constraint_type = (value, True)

    @property
    def value_type(self):
        """
        The type of value this axis will have for collected data. *(permitted
        values: INTEGER, BOOLEAN, STRING, HISTOGRAM)*

        :rtype: ``basestring``
        """
        return self._value_type[0]

    @value_type.setter
    def value_type(self, value):
        self._value_type = (value, True)

    @property
    def axis_name(self):
        """
        The name for this axis.

        :rtype: ``basestring``
        """
        return self._axis_name[0]

    @axis_name.setter
    def axis_name(self, value):
        self._axis_name = (value, True)

    @property
    def stream_attribute(self):
        """
        Whether this axis appears as an attribute of a datapoint stream or of
        datapoints themselves.

        :rtype: ``bool``
        """
        return self._stream_attribute[0]

    @stream_attribute.setter
    def stream_attribute(self, value):
        self._stream_attribute = (value, True)

class JSBookmarkCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    create a Jet Stream bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmarkCreateParameters, self).__init__()
        self._type = ("JSBookmarkCreateParameters", True)
        self._bookmark = (self.__undef__, True)
        self._timeline_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmarkCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" not in data:
            raise ValueError("Missing required property \"bookmark\".")
        if "bookmark" in data and data["bookmark"] is not None:
            obj._bookmark = (factory.create_object(data["bookmark"], "JSBookmark"), dirty)
            factory.validate_type(obj._bookmark[0], "JSBookmark")
        else:
            obj._bookmark = (obj.__undef__, dirty)
        if "timelinePointParameters" not in data:
            raise ValueError("Missing required property \"timelinePointParameters\".")
        if "timelinePointParameters" in data and data["timelinePointParameters"] is not None:
            obj._timeline_point_parameters = (factory.create_object(data["timelinePointParameters"], "JSTimelinePointTimeParameters"), dirty)
            factory.validate_type(obj._timeline_point_parameters[0], "JSTimelinePointTimeParameters")
        else:
            obj._timeline_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmarkCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "timeline_point_parameters" == "type" or (self.timeline_point_parameters is not self.__undef__ and not (dirty and not self._timeline_point_parameters[1])):
            dct["timelinePointParameters"] = dictify(self.timeline_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._timeline_point_parameters = (self._timeline_point_parameters[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._timeline_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmarkCreateParameters):
            return False
        return super(JSBookmarkCreateParameters, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.timeline_point_parameters == other.timeline_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The Jet Stream bookmark object.

        :rtype: :py:class:`v1_8_1.web.vo.JSBookmark`
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def timeline_point_parameters(self):
        """
        The Jet Stream data timeline point at which the bookmark will be
        created.

        :rtype: :py:class:`v1_8_1.web.vo.JSTimelinePointTimeParameters`
        """
        return self._timeline_point_parameters[0]

    @timeline_point_parameters.setter
    def timeline_point_parameters(self, value):
        self._timeline_point_parameters = (value, True)

class StorageTestParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters used to
    execute a storage test.
    """
    def __init__(self, undef_enabled=True):
        super(StorageTestParameters, self).__init__()
        self._type = ("StorageTestParameters", True)
        self._test_region = (self.__undef__, True)
        self._tests = (self.__undef__, True)
        self._devices = (self.__undef__, True)
        self._initialize_entire_device = (self.__undef__, True)
        self._duration = (self.__undef__, True)
        self._initialize_devices = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageTestParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._test_region = (data.get("testRegion", obj.__undef__), dirty)
        if obj._test_region[0] is not None and obj._test_region[0] is not obj.__undef__:
            assert isinstance(obj._test_region[0], float), ("Expected one of [u'number'], but got %s" % type(obj._test_region[0]))
            common.validate_format(obj._test_region[0], "None", None, None)
        obj._tests = (data.get("tests", obj.__undef__), dirty)
        if obj._tests[0] is not None and obj._tests[0] is not obj.__undef__:
            assert isinstance(obj._tests[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tests[0]))
            assert obj._tests[0] in [u'ALL', u'MINIMAL', u'READ', u'WRITE', u'RANDREAD'], "Expected enum [u'ALL', u'MINIMAL', u'READ', u'WRITE', u'RANDREAD'] but got %s" % obj._tests[0]
            common.validate_format(obj._tests[0], "None", None, None)
        obj._devices = []
        for item in data.get("devices") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._devices.append(item)
        obj._devices = (obj._devices, dirty)
        obj._initialize_entire_device = (data.get("initializeEntireDevice", obj.__undef__), dirty)
        if obj._initialize_entire_device[0] is not None and obj._initialize_entire_device[0] is not obj.__undef__:
            assert isinstance(obj._initialize_entire_device[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._initialize_entire_device[0]))
            common.validate_format(obj._initialize_entire_device[0], "None", None, None)
        obj._duration = (data.get("duration", obj.__undef__), dirty)
        if obj._duration[0] is not None and obj._duration[0] is not obj.__undef__:
            assert isinstance(obj._duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._duration[0]))
            common.validate_format(obj._duration[0], "None", None, None)
        obj._initialize_devices = (data.get("initializeDevices", obj.__undef__), dirty)
        if obj._initialize_devices[0] is not None and obj._initialize_devices[0] is not obj.__undef__:
            assert isinstance(obj._initialize_devices[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._initialize_devices[0]))
            common.validate_format(obj._initialize_devices[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageTestParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "test_region" == "type" or (self.test_region is not self.__undef__ and not (dirty and not self._test_region[1])):
            dct["testRegion"] = dictify(self.test_region)
        if "tests" == "type" or (self.tests is not self.__undef__ and not (dirty and not self._tests[1])):
            dct["tests"] = dictify(self.tests)
        if "devices" == "type" or (self.devices is not self.__undef__ and not (dirty and not self._devices[1])):
            dct["devices"] = dictify(self.devices)
        if "initialize_entire_device" == "type" or (self.initialize_entire_device is not self.__undef__ and not (dirty and not self._initialize_entire_device[1])):
            dct["initializeEntireDevice"] = dictify(self.initialize_entire_device)
        if "duration" == "type" or (self.duration is not self.__undef__ and not (dirty and not self._duration[1])):
            dct["duration"] = dictify(self.duration)
        if "initialize_devices" == "type" or (self.initialize_devices is not self.__undef__ and not (dirty and not self._initialize_devices[1])):
            dct["initializeDevices"] = dictify(self.initialize_devices)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._test_region = (self._test_region[0], True)
        self._tests = (self._tests[0], True)
        self._devices = (self._devices[0], True)
        self._initialize_entire_device = (self._initialize_entire_device[0], True)
        self._duration = (self._duration[0], True)
        self._initialize_devices = (self._initialize_devices[0], True)

    def is_dirty(self):
        return any([self._test_region[1], self._tests[1], self._devices[1], self._initialize_entire_device[1], self._duration[1], self._initialize_devices[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageTestParameters):
            return False
        return super(StorageTestParameters, self).__eq__(other) and \
               self.test_region == other.test_region and \
               self.tests == other.tests and \
               self.devices == other.devices and \
               self.initialize_entire_device == other.initialize_entire_device and \
               self.duration == other.duration and \
               self.initialize_devices == other.initialize_devices

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def test_region(self):
        """
        *(default value: 549755813888)* Total disk space, spread over all
        devices, used by the test (in bytes).

        :rtype: ``float``
        """
        return self._test_region[0]

    @test_region.setter
    def test_region(self, value):
        self._test_region = (value, True)

    @property
    def tests(self):
        """
        *(default value: ALL)* The tests that are to be run. *(permitted
        values: ALL, MINIMAL, READ, WRITE, RANDREAD)*

        :rtype: ``basestring``
        """
        return self._tests[0]

    @tests.setter
    def tests(self, value):
        self._tests = (value, True)

    @property
    def devices(self):
        """
        The list of devices to be used for the test.

        :rtype: ``list`` of ``basestring``
        """
        return self._devices[0]

    @devices.setter
    def devices(self, value):
        self._devices = (value, True)

    @property
    def initialize_entire_device(self):
        """
        True if the entire disk should be initialized prior to running the
        benchmark.

        :rtype: ``bool``
        """
        return self._initialize_entire_device[0]

    @initialize_entire_device.setter
    def initialize_entire_device(self, value):
        self._initialize_entire_device = (value, True)

    @property
    def duration(self):
        """
        *(default value: 120)* Run time of each test, in seconds.

        :rtype: ``int``
        """
        return self._duration[0]

    @duration.setter
    def duration(self, value):
        self._duration = (value, True)

    @property
    def initialize_devices(self):
        """
        *(default value: True)* True if the disks should be initialized prior
        to running the benchmark.

        :rtype: ``bool``
        """
        return self._initialize_devices[0]

    @initialize_devices.setter
    def initialize_devices(self, value):
        self._initialize_devices = (value, True)

class VirtualSourceOperations(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes operations
    which are performed on virtual sources at various times.
    """
    def __init__(self, undef_enabled=True):
        super(VirtualSourceOperations, self).__init__()
        self._type = ("VirtualSourceOperations", True)
        self._post_refresh = (self.__undef__, True)
        self._pre_start = (self.__undef__, True)
        self._pre_refresh = (self.__undef__, True)
        self._configure_clone = (self.__undef__, True)
        self._pre_rollback = (self.__undef__, True)
        self._pre_stop = (self.__undef__, True)
        self._post_stop = (self.__undef__, True)
        self._pre_snapshot = (self.__undef__, True)
        self._post_rollback = (self.__undef__, True)
        self._post_snapshot = (self.__undef__, True)
        self._post_start = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VirtualSourceOperations, cls).from_dict(data, dirty, undef_enabled)
        obj._post_refresh = []
        for item in data.get("postRefresh") or []:
            obj._post_refresh.append(factory.create_object(item))
            factory.validate_type(obj._post_refresh[-1], "SourceOperation")
        obj._post_refresh = (obj._post_refresh, dirty)
        obj._pre_start = []
        for item in data.get("preStart") or []:
            obj._pre_start.append(factory.create_object(item))
            factory.validate_type(obj._pre_start[-1], "SourceOperation")
        obj._pre_start = (obj._pre_start, dirty)
        obj._pre_refresh = []
        for item in data.get("preRefresh") or []:
            obj._pre_refresh.append(factory.create_object(item))
            factory.validate_type(obj._pre_refresh[-1], "SourceOperation")
        obj._pre_refresh = (obj._pre_refresh, dirty)
        obj._configure_clone = []
        for item in data.get("configureClone") or []:
            obj._configure_clone.append(factory.create_object(item))
            factory.validate_type(obj._configure_clone[-1], "SourceOperation")
        obj._configure_clone = (obj._configure_clone, dirty)
        obj._pre_rollback = []
        for item in data.get("preRollback") or []:
            obj._pre_rollback.append(factory.create_object(item))
            factory.validate_type(obj._pre_rollback[-1], "SourceOperation")
        obj._pre_rollback = (obj._pre_rollback, dirty)
        obj._pre_stop = []
        for item in data.get("preStop") or []:
            obj._pre_stop.append(factory.create_object(item))
            factory.validate_type(obj._pre_stop[-1], "SourceOperation")
        obj._pre_stop = (obj._pre_stop, dirty)
        obj._post_stop = []
        for item in data.get("postStop") or []:
            obj._post_stop.append(factory.create_object(item))
            factory.validate_type(obj._post_stop[-1], "SourceOperation")
        obj._post_stop = (obj._post_stop, dirty)
        obj._pre_snapshot = []
        for item in data.get("preSnapshot") or []:
            obj._pre_snapshot.append(factory.create_object(item))
            factory.validate_type(obj._pre_snapshot[-1], "SourceOperation")
        obj._pre_snapshot = (obj._pre_snapshot, dirty)
        obj._post_rollback = []
        for item in data.get("postRollback") or []:
            obj._post_rollback.append(factory.create_object(item))
            factory.validate_type(obj._post_rollback[-1], "SourceOperation")
        obj._post_rollback = (obj._post_rollback, dirty)
        obj._post_snapshot = []
        for item in data.get("postSnapshot") or []:
            obj._post_snapshot.append(factory.create_object(item))
            factory.validate_type(obj._post_snapshot[-1], "SourceOperation")
        obj._post_snapshot = (obj._post_snapshot, dirty)
        obj._post_start = []
        for item in data.get("postStart") or []:
            obj._post_start.append(factory.create_object(item))
            factory.validate_type(obj._post_start[-1], "SourceOperation")
        obj._post_start = (obj._post_start, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VirtualSourceOperations, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "post_refresh" == "type" or (self.post_refresh is not self.__undef__ and not (dirty and not self._post_refresh[1])):
            dct["postRefresh"] = dictify(self.post_refresh)
        if "pre_start" == "type" or (self.pre_start is not self.__undef__ and not (dirty and not self._pre_start[1])):
            dct["preStart"] = dictify(self.pre_start)
        if "pre_refresh" == "type" or (self.pre_refresh is not self.__undef__ and not (dirty and not self._pre_refresh[1])):
            dct["preRefresh"] = dictify(self.pre_refresh)
        if "configure_clone" == "type" or (self.configure_clone is not self.__undef__ and not (dirty and not self._configure_clone[1])):
            dct["configureClone"] = dictify(self.configure_clone)
        if "pre_rollback" == "type" or (self.pre_rollback is not self.__undef__ and not (dirty and not self._pre_rollback[1])):
            dct["preRollback"] = dictify(self.pre_rollback)
        if "pre_stop" == "type" or (self.pre_stop is not self.__undef__ and not (dirty and not self._pre_stop[1])):
            dct["preStop"] = dictify(self.pre_stop)
        if "post_stop" == "type" or (self.post_stop is not self.__undef__ and not (dirty and not self._post_stop[1])):
            dct["postStop"] = dictify(self.post_stop)
        if "pre_snapshot" == "type" or (self.pre_snapshot is not self.__undef__ and not (dirty and not self._pre_snapshot[1])):
            dct["preSnapshot"] = dictify(self.pre_snapshot)
        if "post_rollback" == "type" or (self.post_rollback is not self.__undef__ and not (dirty and not self._post_rollback[1])):
            dct["postRollback"] = dictify(self.post_rollback)
        if "post_snapshot" == "type" or (self.post_snapshot is not self.__undef__ and not (dirty and not self._post_snapshot[1])):
            dct["postSnapshot"] = dictify(self.post_snapshot)
        if "post_start" == "type" or (self.post_start is not self.__undef__ and not (dirty and not self._post_start[1])):
            dct["postStart"] = dictify(self.post_start)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._post_refresh = (self._post_refresh[0], True)
        self._pre_start = (self._pre_start[0], True)
        self._pre_refresh = (self._pre_refresh[0], True)
        self._configure_clone = (self._configure_clone[0], True)
        self._pre_rollback = (self._pre_rollback[0], True)
        self._pre_stop = (self._pre_stop[0], True)
        self._post_stop = (self._post_stop[0], True)
        self._pre_snapshot = (self._pre_snapshot[0], True)
        self._post_rollback = (self._post_rollback[0], True)
        self._post_snapshot = (self._post_snapshot[0], True)
        self._post_start = (self._post_start[0], True)

    def is_dirty(self):
        return any([self._post_refresh[1], self._pre_start[1], self._pre_refresh[1], self._configure_clone[1], self._pre_rollback[1], self._pre_stop[1], self._post_stop[1], self._pre_snapshot[1], self._post_rollback[1], self._post_snapshot[1], self._post_start[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VirtualSourceOperations):
            return False
        return super(VirtualSourceOperations, self).__eq__(other) and \
               self.post_refresh == other.post_refresh and \
               self.pre_start == other.pre_start and \
               self.pre_refresh == other.pre_refresh and \
               self.configure_clone == other.configure_clone and \
               self.pre_rollback == other.pre_rollback and \
               self.pre_stop == other.pre_stop and \
               self.post_stop == other.post_stop and \
               self.pre_snapshot == other.pre_snapshot and \
               self.post_rollback == other.post_rollback and \
               self.post_snapshot == other.post_snapshot and \
               self.post_start == other.post_start

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def post_refresh(self):
        """
        Operations to perform after refreshing a virtual source. These
        operations can be used to restore any data or configuration backed up
        in the preRefresh operations.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_refresh[0]

    @post_refresh.setter
    def post_refresh(self, value):
        self._post_refresh = (value, True)

    @property
    def pre_start(self):
        """
        Operations to perform before starting a virtual source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_start[0]

    @pre_start.setter
    def pre_start(self, value):
        self._pre_start = (value, True)

    @property
    def pre_refresh(self):
        """
        Operations to perform before refreshing a virtual source. These
        operations can backup any data or configuration from the running source
        before doing the refresh.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_refresh[0]

    @pre_refresh.setter
    def pre_refresh(self, value):
        self._pre_refresh = (value, True)

    @property
    def configure_clone(self):
        """
        Operations to perform when initially creating the virtual source and
        every time it is refreshed.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._configure_clone[0]

    @configure_clone.setter
    def configure_clone(self, value):
        self._configure_clone = (value, True)

    @property
    def pre_rollback(self):
        """
        Operations to perform before rewinding a virtual source. These
        operations can backup any data or configuration from the running source
        prior to rewinding.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_rollback[0]

    @pre_rollback.setter
    def pre_rollback(self, value):
        self._pre_rollback = (value, True)

    @property
    def pre_stop(self):
        """
        Operations to perform before stopping a virtual source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_stop[0]

    @pre_stop.setter
    def pre_stop(self, value):
        self._pre_stop = (value, True)

    @property
    def post_stop(self):
        """
        Operations to perform after stopping a virtual source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_stop[0]

    @post_stop.setter
    def post_stop(self, value):
        self._post_stop = (value, True)

    @property
    def pre_snapshot(self):
        """
        Operations to perform before snapshotting a virtual source. These
        operations can quiesce any data prior to snapshotting.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._pre_snapshot[0]

    @pre_snapshot.setter
    def pre_snapshot(self, value):
        self._pre_snapshot = (value, True)

    @property
    def post_rollback(self):
        """
        Operations to perform after rewinding a virtual source. These
        operations can be used to automate processes once the rewind is
        complete.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_rollback[0]

    @post_rollback.setter
    def post_rollback(self, value):
        self._post_rollback = (value, True)

    @property
    def post_snapshot(self):
        """
        Operations to perform after snapshotting a virtual source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_snapshot[0]

    @post_snapshot.setter
    def post_snapshot(self, value):
        self._post_snapshot = (value, True)

    @property
    def post_start(self):
        """
        Operations to perform after starting a virtual source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._post_start[0]

    @post_start.setter
    def post_start(self, value):
        self._post_start = (value, True)

class ScrubStatus(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The status of a scrub
    of the storage in the system.
    """
    def __init__(self, undef_enabled=True):
        super(ScrubStatus, self).__init__()
        self._type = ("ScrubStatus", True)
        self._errors = (self.__undef__, True)
        self._completed = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._total = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ScrubStatus, cls).from_dict(data, dirty, undef_enabled)
        obj._errors = (data.get("errors", obj.__undef__), dirty)
        if obj._errors[0] is not None and obj._errors[0] is not obj.__undef__:
            assert isinstance(obj._errors[0], float), ("Expected one of [u'number'], but got %s" % type(obj._errors[0]))
            common.validate_format(obj._errors[0], "None", None, None)
        obj._completed = (data.get("completed", obj.__undef__), dirty)
        if obj._completed[0] is not None and obj._completed[0] is not obj.__undef__:
            assert isinstance(obj._completed[0], float), ("Expected one of [u'number'], but got %s" % type(obj._completed[0]))
            common.validate_format(obj._completed[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'], "Expected enum [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ScrubStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "errors" == "type" or (self.errors is not self.__undef__ and not (dirty and not self._errors[1])):
            dct["errors"] = dictify(self.errors)
        if "completed" == "type" or (self.completed is not self.__undef__ and not (dirty and not self._completed[1])):
            dct["completed"] = dictify(self.completed)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._errors = (self._errors[0], True)
        self._completed = (self._completed[0], True)
        self._state = (self._state[0], True)
        self._end_time = (self._end_time[0], True)
        self._start_time = (self._start_time[0], True)
        self._total = (self._total[0], True)

    def is_dirty(self):
        return any([self._errors[1], self._completed[1], self._state[1], self._end_time[1], self._start_time[1], self._total[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ScrubStatus):
            return False
        return super(ScrubStatus, self).__eq__(other) and \
               self.errors == other.errors and \
               self.completed == other.completed and \
               self.state == other.state and \
               self.end_time == other.end_time and \
               self.start_time == other.start_time and \
               self.total == other.total

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def errors(self):
        """
        Number of errors encountered during scrub.

        :rtype: ``float``
        """
        return self._errors[0]

    @errors.setter
    def errors(self, value):
        self._errors = (value, True)

    @property
    def completed(self):
        """
        Amount of data scrubbed, in bytes.

        :rtype: ``float``
        """
        return self._completed[0]

    @completed.setter
    def completed(self, value):
        self._completed = (value, True)

    @property
    def state(self):
        """
        Scrub state. *(permitted values: NONE, ACTIVE, COMPLETED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def end_time(self):
        """
        Time scrub ended.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def start_time(self):
        """
        Time scrub was started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def total(self):
        """
        Total amount of data to scrub (including completed), in bytes.

        :rtype: ``float``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

class CapacityBreakdown(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Storage stats
    breakdown.
    """
    def __init__(self, undef_enabled=True):
        super(CapacityBreakdown, self).__init__()
        self._type = ("CapacityBreakdown", True)
        self._manual_space = (self.__undef__, True)
        self._unvirtualized_space = (self.__undef__, True)
        self._active_space = (self.__undef__, True)
        self._policy_space = (self.__undef__, True)
        self._log_space = (self.__undef__, True)
        self._timeflow_unvirtualized_space = (self.__undef__, True)
        self._sync_space = (self.__undef__, True)
        self._descendant_space = (self.__undef__, True)
        self._actual_space = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CapacityBreakdown, cls).from_dict(data, dirty, undef_enabled)
        obj._manual_space = (data.get("manualSpace", obj.__undef__), dirty)
        if obj._manual_space[0] is not None and obj._manual_space[0] is not obj.__undef__:
            assert isinstance(obj._manual_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._manual_space[0]))
            common.validate_format(obj._manual_space[0], "None", None, None)
        obj._unvirtualized_space = (data.get("unvirtualizedSpace", obj.__undef__), dirty)
        if obj._unvirtualized_space[0] is not None and obj._unvirtualized_space[0] is not obj.__undef__:
            assert isinstance(obj._unvirtualized_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unvirtualized_space[0]))
            common.validate_format(obj._unvirtualized_space[0], "None", None, None)
        obj._active_space = (data.get("activeSpace", obj.__undef__), dirty)
        if obj._active_space[0] is not None and obj._active_space[0] is not obj.__undef__:
            assert isinstance(obj._active_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._active_space[0]))
            common.validate_format(obj._active_space[0], "None", None, None)
        obj._policy_space = (data.get("policySpace", obj.__undef__), dirty)
        if obj._policy_space[0] is not None and obj._policy_space[0] is not obj.__undef__:
            assert isinstance(obj._policy_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._policy_space[0]))
            common.validate_format(obj._policy_space[0], "None", None, None)
        obj._log_space = (data.get("logSpace", obj.__undef__), dirty)
        if obj._log_space[0] is not None and obj._log_space[0] is not obj.__undef__:
            assert isinstance(obj._log_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._log_space[0]))
            common.validate_format(obj._log_space[0], "None", None, None)
        obj._timeflow_unvirtualized_space = (data.get("timeflowUnvirtualizedSpace", obj.__undef__), dirty)
        if obj._timeflow_unvirtualized_space[0] is not None and obj._timeflow_unvirtualized_space[0] is not obj.__undef__:
            assert isinstance(obj._timeflow_unvirtualized_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._timeflow_unvirtualized_space[0]))
            common.validate_format(obj._timeflow_unvirtualized_space[0], "None", None, None)
        obj._sync_space = (data.get("syncSpace", obj.__undef__), dirty)
        if obj._sync_space[0] is not None and obj._sync_space[0] is not obj.__undef__:
            assert isinstance(obj._sync_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._sync_space[0]))
            common.validate_format(obj._sync_space[0], "None", None, None)
        obj._descendant_space = (data.get("descendantSpace", obj.__undef__), dirty)
        if obj._descendant_space[0] is not None and obj._descendant_space[0] is not obj.__undef__:
            assert isinstance(obj._descendant_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._descendant_space[0]))
            common.validate_format(obj._descendant_space[0], "None", None, None)
        obj._actual_space = (data.get("actualSpace", obj.__undef__), dirty)
        if obj._actual_space[0] is not None and obj._actual_space[0] is not obj.__undef__:
            assert isinstance(obj._actual_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._actual_space[0]))
            common.validate_format(obj._actual_space[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CapacityBreakdown, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "manual_space" == "type" or (self.manual_space is not self.__undef__ and not (dirty and not self._manual_space[1])):
            dct["manualSpace"] = dictify(self.manual_space)
        if "unvirtualized_space" == "type" or (self.unvirtualized_space is not self.__undef__ and not (dirty and not self._unvirtualized_space[1])):
            dct["unvirtualizedSpace"] = dictify(self.unvirtualized_space)
        if "active_space" == "type" or (self.active_space is not self.__undef__ and not (dirty and not self._active_space[1])):
            dct["activeSpace"] = dictify(self.active_space)
        if "policy_space" == "type" or (self.policy_space is not self.__undef__ and not (dirty and not self._policy_space[1])):
            dct["policySpace"] = dictify(self.policy_space)
        if "log_space" == "type" or (self.log_space is not self.__undef__ and not (dirty and not self._log_space[1])):
            dct["logSpace"] = dictify(self.log_space)
        if "timeflow_unvirtualized_space" == "type" or (self.timeflow_unvirtualized_space is not self.__undef__ and not (dirty and not self._timeflow_unvirtualized_space[1])):
            dct["timeflowUnvirtualizedSpace"] = dictify(self.timeflow_unvirtualized_space)
        if "sync_space" == "type" or (self.sync_space is not self.__undef__ and not (dirty and not self._sync_space[1])):
            dct["syncSpace"] = dictify(self.sync_space)
        if "descendant_space" == "type" or (self.descendant_space is not self.__undef__ and not (dirty and not self._descendant_space[1])):
            dct["descendantSpace"] = dictify(self.descendant_space)
        if "actual_space" == "type" or (self.actual_space is not self.__undef__ and not (dirty and not self._actual_space[1])):
            dct["actualSpace"] = dictify(self.actual_space)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._manual_space = (self._manual_space[0], True)
        self._unvirtualized_space = (self._unvirtualized_space[0], True)
        self._active_space = (self._active_space[0], True)
        self._policy_space = (self._policy_space[0], True)
        self._log_space = (self._log_space[0], True)
        self._timeflow_unvirtualized_space = (self._timeflow_unvirtualized_space[0], True)
        self._sync_space = (self._sync_space[0], True)
        self._descendant_space = (self._descendant_space[0], True)
        self._actual_space = (self._actual_space[0], True)

    def is_dirty(self):
        return any([self._manual_space[1], self._unvirtualized_space[1], self._active_space[1], self._policy_space[1], self._log_space[1], self._timeflow_unvirtualized_space[1], self._sync_space[1], self._descendant_space[1], self._actual_space[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CapacityBreakdown):
            return False
        return super(CapacityBreakdown, self).__eq__(other) and \
               self.manual_space == other.manual_space and \
               self.unvirtualized_space == other.unvirtualized_space and \
               self.active_space == other.active_space and \
               self.policy_space == other.policy_space and \
               self.log_space == other.log_space and \
               self.timeflow_unvirtualized_space == other.timeflow_unvirtualized_space and \
               self.sync_space == other.sync_space and \
               self.descendant_space == other.descendant_space and \
               self.actual_space == other.actual_space

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def manual_space(self):
        """
        Amount of space used for snapshots held by manual retention settings.

        :rtype: ``float``
        """
        return self._manual_space[0]

    @manual_space.setter
    def manual_space(self, value):
        self._manual_space = (value, True)

    @property
    def unvirtualized_space(self):
        """
        Unvirtualized space used by the container.

        :rtype: ``float``
        """
        return self._unvirtualized_space[0]

    @unvirtualized_space.setter
    def unvirtualized_space(self, value):
        self._unvirtualized_space = (value, True)

    @property
    def active_space(self):
        """
        Amount of space used for the active copy of the container.

        :rtype: ``float``
        """
        return self._active_space[0]

    @active_space.setter
    def active_space(self, value):
        self._active_space = (value, True)

    @property
    def policy_space(self):
        """
        Amount of space used for snapshots held by policy settings.

        :rtype: ``float``
        """
        return self._policy_space[0]

    @policy_space.setter
    def policy_space(self, value):
        self._policy_space = (value, True)

    @property
    def log_space(self):
        """
        Amount of space used by logs.

        :rtype: ``float``
        """
        return self._log_space[0]

    @log_space.setter
    def log_space(self, value):
        self._log_space = (value, True)

    @property
    def timeflow_unvirtualized_space(self):
        """
        Unvirtualized space used by the TimeFlow.

        :rtype: ``float``
        """
        return self._timeflow_unvirtualized_space[0]

    @timeflow_unvirtualized_space.setter
    def timeflow_unvirtualized_space(self, value):
        self._timeflow_unvirtualized_space = (value, True)

    @property
    def sync_space(self):
        """
        Amount of space used by snapshots.

        :rtype: ``float``
        """
        return self._sync_space[0]

    @sync_space.setter
    def sync_space(self, value):
        self._sync_space = (value, True)

    @property
    def descendant_space(self):
        """
        Amount of space used for snapshots from which VDBs have been
        provisioned.

        :rtype: ``float``
        """
        return self._descendant_space[0]

    @descendant_space.setter
    def descendant_space(self, value):
        self._descendant_space = (value, True)

    @property
    def actual_space(self):
        """
        Actual space used by the container.

        :rtype: ``float``
        """
        return self._actual_space[0]

    @actual_space.setter
    def actual_space(self, value):
        self._actual_space = (value, True)

class SourceDisableParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to disable a MSSQL, PostgreSQL, AppData, ASE or MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceDisableParameters, self).__init__()
        self._type = ("SourceDisableParameters", True)
        self._attempt_cleanup = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceDisableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._attempt_cleanup = (data.get("attemptCleanup", obj.__undef__), dirty)
        if obj._attempt_cleanup[0] is not None and obj._attempt_cleanup[0] is not obj.__undef__:
            assert isinstance(obj._attempt_cleanup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._attempt_cleanup[0]))
            common.validate_format(obj._attempt_cleanup[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceDisableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "attempt_cleanup" == "type" or (self.attempt_cleanup is not self.__undef__ and not (dirty and not self._attempt_cleanup[1])):
            dct["attemptCleanup"] = dictify(self.attempt_cleanup)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._attempt_cleanup = (self._attempt_cleanup[0], True)

    def is_dirty(self):
        return any([self._attempt_cleanup[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceDisableParameters):
            return False
        return super(SourceDisableParameters, self).__eq__(other) and \
               self.attempt_cleanup == other.attempt_cleanup

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def attempt_cleanup(self):
        """
        *(default value: True)* Whether to attempt a cleanup of the database
        from the environment before the disable.

        :rtype: ``bool``
        """
        return self._attempt_cleanup[0]

    @attempt_cleanup.setter
    def attempt_cleanup(self, value):
        self._attempt_cleanup = (value, True)

class TimeflowRange(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Time range within a
    TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRange, self).__init__()
        self._type = ("TimeflowRange", True)
        self._provisionable = (self.__undef__, True)
        self._end_point = (self.__undef__, True)
        self._start_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRange, cls).from_dict(data, dirty, undef_enabled)
        obj._provisionable = (data.get("provisionable", obj.__undef__), dirty)
        if obj._provisionable[0] is not None and obj._provisionable[0] is not obj.__undef__:
            assert isinstance(obj._provisionable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisionable[0]))
            common.validate_format(obj._provisionable[0], "None", None, None)
        if "endPoint" in data and data["endPoint"] is not None:
            obj._end_point = (factory.create_object(data["endPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._end_point[0], "TimeflowPoint")
        else:
            obj._end_point = (obj.__undef__, dirty)
        if "startPoint" in data and data["startPoint"] is not None:
            obj._start_point = (factory.create_object(data["startPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._start_point[0], "TimeflowPoint")
        else:
            obj._start_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRange, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provisionable" == "type" or (self.provisionable is not self.__undef__ and not (dirty and not self._provisionable[1])):
            dct["provisionable"] = dictify(self.provisionable)
        if "end_point" == "type" or (self.end_point is not self.__undef__ and not (dirty and not self._end_point[1])):
            dct["endPoint"] = dictify(self.end_point)
        if "start_point" == "type" or (self.start_point is not self.__undef__ and not (dirty and not self._start_point[1])):
            dct["startPoint"] = dictify(self.start_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provisionable = (self._provisionable[0], True)
        self._end_point = (self._end_point[0], True)
        self._start_point = (self._start_point[0], True)

    def is_dirty(self):
        return any([self._provisionable[1], self._end_point[1], self._start_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRange):
            return False
        return super(TimeflowRange, self).__eq__(other) and \
               self.provisionable == other.provisionable and \
               self.end_point == other.end_point and \
               self.start_point == other.start_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provisionable(self):
        """
        Whether or not this TimeFlow range is provisionable.

        :rtype: ``bool``
        """
        return self._provisionable[0]

    @provisionable.setter
    def provisionable(self, value):
        self._provisionable = (value, True)

    @property
    def end_point(self):
        """
        The ending TimeFlow point of this range.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._end_point[0]

    @end_point.setter
    def end_point(self, value):
        self._end_point = (value, True)

    @property
    def start_point(self):
        """
        The starting TimeFlow point of this range.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._start_point[0]

    @start_point.setter
    def start_point(self, value):
        self._start_point = (value, True)

class Operation(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A user-specifiable
    operation that can be performed on sources.
    """
    def __init__(self, undef_enabled=True):
        super(Operation, self).__init__()
        self._type = ("Operation", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Operation, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Operation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Operation):
            return False
        return super(Operation, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSContainerUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a data container.
    """
    def __init__(self, undef_enabled=True):
        super(JSContainerUsageData, self).__init__()
        self._type = ("JSContainerUsageData", True)
        self._data_container = (self.__undef__, True)
        self._unvirtualized = (self.__undef__, True)
        self._shared_others = (self.__undef__, True)
        self._unique = (self.__undef__, True)
        self._shared_self = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSContainerUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._data_container = (data.get("dataContainer", obj.__undef__), dirty)
        if obj._data_container[0] is not None and obj._data_container[0] is not obj.__undef__:
            assert isinstance(obj._data_container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_container[0]))
            common.validate_format(obj._data_container[0], "objectReference", None, None)
        obj._unvirtualized = (data.get("unvirtualized", obj.__undef__), dirty)
        if obj._unvirtualized[0] is not None and obj._unvirtualized[0] is not obj.__undef__:
            assert isinstance(obj._unvirtualized[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unvirtualized[0]))
            common.validate_format(obj._unvirtualized[0], "None", None, None)
        obj._shared_others = (data.get("sharedOthers", obj.__undef__), dirty)
        if obj._shared_others[0] is not None and obj._shared_others[0] is not obj.__undef__:
            assert isinstance(obj._shared_others[0], float), ("Expected one of [u'number'], but got %s" % type(obj._shared_others[0]))
            common.validate_format(obj._shared_others[0], "None", None, None)
        obj._unique = (data.get("unique", obj.__undef__), dirty)
        if obj._unique[0] is not None and obj._unique[0] is not obj.__undef__:
            assert isinstance(obj._unique[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unique[0]))
            common.validate_format(obj._unique[0], "None", None, None)
        obj._shared_self = (data.get("sharedSelf", obj.__undef__), dirty)
        if obj._shared_self[0] is not None and obj._shared_self[0] is not obj.__undef__:
            assert isinstance(obj._shared_self[0], float), ("Expected one of [u'number'], but got %s" % type(obj._shared_self[0]))
            common.validate_format(obj._shared_self[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSContainerUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_container" == "type" or (self.data_container is not self.__undef__ and not (dirty and not self._data_container[1])):
            dct["dataContainer"] = dictify(self.data_container)
        if "unvirtualized" == "type" or (self.unvirtualized is not self.__undef__ and not (dirty and not self._unvirtualized[1])):
            dct["unvirtualized"] = dictify(self.unvirtualized)
        if "shared_others" == "type" or (self.shared_others is not self.__undef__ and not (dirty and not self._shared_others[1])):
            dct["sharedOthers"] = dictify(self.shared_others)
        if "unique" == "type" or (self.unique is not self.__undef__ and not (dirty and not self._unique[1])):
            dct["unique"] = dictify(self.unique)
        if "shared_self" == "type" or (self.shared_self is not self.__undef__ and not (dirty and not self._shared_self[1])):
            dct["sharedSelf"] = dictify(self.shared_self)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_container = (self._data_container[0], True)
        self._unvirtualized = (self._unvirtualized[0], True)
        self._shared_others = (self._shared_others[0], True)
        self._unique = (self._unique[0], True)
        self._shared_self = (self._shared_self[0], True)

    def is_dirty(self):
        return any([self._data_container[1], self._unvirtualized[1], self._shared_others[1], self._unique[1], self._shared_self[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSContainerUsageData):
            return False
        return super(JSContainerUsageData, self).__eq__(other) and \
               self.data_container == other.data_container and \
               self.unvirtualized == other.unvirtualized and \
               self.shared_others == other.shared_others and \
               self.unique == other.unique and \
               self.shared_self == other.shared_self

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_container(self):
        """
        The data container that this usage information is for.

        :rtype: ``basestring``
        """
        return self._data_container[0]

    @data_container.setter
    def data_container(self, value):
        self._data_container = (value, True)

    @property
    def unvirtualized(self):
        """
        The amount of space that would be consumed by the data in this
        container without Delphix.

        :rtype: ``float``
        """
        return self._unvirtualized[0]

    @unvirtualized.setter
    def unvirtualized(self, value):
        self._unvirtualized = (value, True)

    @property
    def shared_others(self):
        """
        The amount of space that cannot be freed on the parent data template
        (or sibling data containers) because it is also being referenced by
        this data container due to restore or create branch operations.

        :rtype: ``float``
        """
        return self._shared_others[0]

    @shared_others.setter
    def shared_others(self, value):
        self._shared_others = (value, True)

    @property
    def unique(self):
        """
        The amount of space that will be freed if this data container is
        deleted or purged. This assumes that the data container is deleted
        along with underlying data sources.

        :rtype: ``float``
        """
        return self._unique[0]

    @unique.setter
    def unique(self, value):
        self._unique = (value, True)

    @property
    def shared_self(self):
        """
        The amount of space that cannot be freed on this data container because
        it is also being referenced by sibling data containers due to restore
        or create branch operations.

        :rtype: ``float``
        """
        return self._shared_self[0]

    @shared_self.setter
    def shared_self(self, value):
        self._shared_self = (value, True)

class PolicyCreateAndApplyParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used
    for creating and applying policies.
    """
    def __init__(self, undef_enabled=True):
        super(PolicyCreateAndApplyParameters, self).__init__()
        self._type = ("PolicyCreateAndApplyParameters", True)
        self._policy = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PolicyCreateAndApplyParameters, cls).from_dict(data, dirty, undef_enabled)
        if "policy" not in data:
            raise ValueError("Missing required property \"policy\".")
        if "policy" in data and data["policy"] is not None:
            obj._policy = (factory.create_object(data["policy"], "Policy"), dirty)
            factory.validate_type(obj._policy[0], "Policy")
        else:
            obj._policy = (obj.__undef__, dirty)
        if "target" not in data:
            raise ValueError("Missing required property \"target\".")
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PolicyCreateAndApplyParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "policy" == "type" or (self.policy is not self.__undef__ and not (dirty and not self._policy[1])):
            dct["policy"] = dictify(self.policy)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._policy = (self._policy[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._policy[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PolicyCreateAndApplyParameters):
            return False
        return super(PolicyCreateAndApplyParameters, self).__eq__(other) and \
               self.policy == other.policy and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def policy(self):
        """
        Policy to create.

        :rtype: :py:class:`v1_8_1.web.vo.Policy`
        """
        return self._policy[0]

    @policy.setter
    def policy(self, value):
        self._policy = (value, True)

    @property
    def target(self):
        """
        Object reference of the target.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class SourceConnectionInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Contains information
    that can be used to connect to the source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConnectionInfo, self).__init__()
        self._type = ("SourceConnectionInfo", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConnectionInfo):
            return False
        return super(SourceConnectionInfo, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        The database version string.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class SourceStartParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to start a MSSQL, PostgreSQL, AppData, ASE or MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceStartParameters, self).__init__()
        self._type = ("SourceStartParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceStartParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceStartParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceStartParameters):
            return False
        return super(SourceStartParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class RegistrationInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The information
    required to register the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(RegistrationInfo, self).__init__()
        self._type = ("RegistrationInfo", True)
        self._code = (self.__undef__, True)
        self._registration_portal_hostname = (self.__undef__, True)
        self._uuid = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RegistrationInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._code = (data.get("code", obj.__undef__), dirty)
        if obj._code[0] is not None and obj._code[0] is not obj.__undef__:
            assert isinstance(obj._code[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._code[0]))
            common.validate_format(obj._code[0], "None", None, None)
        obj._registration_portal_hostname = (data.get("registrationPortalHostname", obj.__undef__), dirty)
        if obj._registration_portal_hostname[0] is not None and obj._registration_portal_hostname[0] is not obj.__undef__:
            assert isinstance(obj._registration_portal_hostname[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._registration_portal_hostname[0]))
            common.validate_format(obj._registration_portal_hostname[0], "None", None, None)
        obj._uuid = (data.get("uuid", obj.__undef__), dirty)
        if obj._uuid[0] is not None and obj._uuid[0] is not obj.__undef__:
            assert isinstance(obj._uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._uuid[0]))
            common.validate_format(obj._uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RegistrationInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "code" == "type" or (self.code is not self.__undef__ and not (dirty and not self._code[1])):
            dct["code"] = dictify(self.code)
        if "registration_portal_hostname" == "type" or (self.registration_portal_hostname is not self.__undef__ and not (dirty and not self._registration_portal_hostname[1])):
            dct["registrationPortalHostname"] = dictify(self.registration_portal_hostname)
        if "uuid" == "type" or (self.uuid is not self.__undef__ and not (dirty and not self._uuid[1])):
            dct["uuid"] = dictify(self.uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._code = (self._code[0], True)
        self._registration_portal_hostname = (self._registration_portal_hostname[0], True)
        self._uuid = (self._uuid[0], True)

    def is_dirty(self):
        return any([self._code[1], self._registration_portal_hostname[1], self._uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RegistrationInfo):
            return False
        return super(RegistrationInfo, self).__eq__(other) and \
               self.code == other.code and \
               self.registration_portal_hostname == other.registration_portal_hostname and \
               self.uuid == other.uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def code(self):
        """
        The registration code for this Delphix Engine.

        :rtype: ``basestring``
        """
        return self._code[0]

    @code.setter
    def code(self, value):
        self._code = (value, True)

    @property
    def registration_portal_hostname(self):
        """
        The registration portal hostname.

        :rtype: ``basestring``
        """
        return self._registration_portal_hostname[0]

    @registration_portal_hostname.setter
    def registration_portal_hostname(self, value):
        self._registration_portal_hostname = (value, True)

    @property
    def uuid(self):
        """
        The UUID for this Delphix Engine.

        :rtype: ``basestring``
        """
        return self._uuid[0]

    @uuid.setter
    def uuid(self, value):
        self._uuid = (value, True)

class LinkData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Base type for specific
    parameters for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(LinkData, self).__init__()
        self._type = ("LinkData", True)
        self._config = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LinkData, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "SourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "SourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)

    def is_dirty(self):
        return any([self._config[1], self._sourcing_policy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LinkData):
            return False
        return super(LinkData, self).__eq__(other) and \
               self.config == other.config and \
               self.sourcing_policy == other.sourcing_policy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing LogSync and SnapSync across sources.

        :rtype: :py:class:`v1_8_1.web.vo.SourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

class PgSQLIdentEntry(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* An entry in the
    PostgreSQL username map file (pg_ident.conf).
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLIdentEntry, self).__init__()
        self._type = ("PgSQLIdentEntry", True)
        self._map_name = (self.__undef__, True)
        self._system_username = (self.__undef__, True)
        self._database_username = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLIdentEntry, cls).from_dict(data, dirty, undef_enabled)
        obj._map_name = (data.get("mapName", obj.__undef__), dirty)
        if obj._map_name[0] is not None and obj._map_name[0] is not obj.__undef__:
            assert isinstance(obj._map_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._map_name[0]))
            common.validate_format(obj._map_name[0], "None", None, None)
        obj._system_username = (data.get("systemUsername", obj.__undef__), dirty)
        if obj._system_username[0] is not None and obj._system_username[0] is not obj.__undef__:
            assert isinstance(obj._system_username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._system_username[0]))
            common.validate_format(obj._system_username[0], "None", None, None)
        obj._database_username = (data.get("databaseUsername", obj.__undef__), dirty)
        if obj._database_username[0] is not None and obj._database_username[0] is not obj.__undef__:
            assert isinstance(obj._database_username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_username[0]))
            common.validate_format(obj._database_username[0], "None", None, 63)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLIdentEntry, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "map_name" == "type" or (self.map_name is not self.__undef__ and not (dirty and not self._map_name[1])):
            dct["mapName"] = dictify(self.map_name)
        if "system_username" == "type" or (self.system_username is not self.__undef__ and not (dirty and not self._system_username[1])):
            dct["systemUsername"] = dictify(self.system_username)
        if "database_username" == "type" or (self.database_username is not self.__undef__ and not (dirty and not self._database_username[1])):
            dct["databaseUsername"] = dictify(self.database_username)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._map_name = (self._map_name[0], True)
        self._system_username = (self._system_username[0], True)
        self._database_username = (self._database_username[0], True)

    def is_dirty(self):
        return any([self._map_name[1], self._system_username[1], self._database_username[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLIdentEntry):
            return False
        return super(PgSQLIdentEntry, self).__eq__(other) and \
               self.map_name == other.map_name and \
               self.system_username == other.system_username and \
               self.database_username == other.database_username

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def map_name(self):
        """
        The name of the map to which this entry belongs (used to refer to the
        map in pg_hba.conf).

        :rtype: ``basestring``
        """
        return self._map_name[0]

    @map_name.setter
    def map_name(self, value):
        self._map_name = (value, True)

    @property
    def system_username(self):
        """
        The operating system username this entry matches.

        :rtype: ``basestring``
        """
        return self._system_username[0]

    @system_username.setter
    def system_username(self, value):
        self._system_username = (value, True)

    @property
    def database_username(self):
        """
        The database username this entry matches.

        :rtype: ``basestring``
        """
        return self._database_username[0]

    @database_username.setter
    def database_username(self, value):
        self._database_username = (value, True)

class SyslogServer(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Syslog server
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SyslogServer, self).__init__()
        self._type = ("SyslogServer", True)
        self._protocol = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyslogServer, cls).from_dict(data, dirty, undef_enabled)
        if "protocol" not in data:
            raise ValueError("Missing required property \"protocol\".")
        obj._protocol = (data.get("protocol", obj.__undef__), dirty)
        if obj._protocol[0] is not None and obj._protocol[0] is not obj.__undef__:
            assert isinstance(obj._protocol[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._protocol[0]))
            assert obj._protocol[0] in [u'udp', u'tcp'], "Expected enum [u'udp', u'tcp'] but got %s" % obj._protocol[0]
            common.validate_format(obj._protocol[0], "None", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyslogServer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "protocol" == "type" or (self.protocol is not self.__undef__ and not (dirty and not self._protocol[1])):
            dct["protocol"] = dictify(self.protocol)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._protocol = (self._protocol[0], True)
        self._port = (self._port[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._protocol[1], self._port[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyslogServer):
            return False
        return super(SyslogServer, self).__eq__(other) and \
               self.protocol == other.protocol and \
               self.port == other.port and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def protocol(self):
        """
        *(default value: udp)* Syslog transport protocol. *(permitted values:
        udp, tcp)*

        :rtype: ``basestring``
        """
        return self._protocol[0]

    @protocol.setter
    def protocol(self, value):
        self._protocol = (value, True)

    @property
    def port(self):
        """
        *(default value: 514)* Syslog port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def address(self):
        """
        Syslog host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class TimeflowBookmarkCreateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to create TimeFlow bookmarks.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowBookmarkCreateParameters, self).__init__()
        self._type = ("TimeflowBookmarkCreateParameters", True)
        self._retention_proof = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._timeflow_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowBookmarkCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._retention_proof = (data.get("retentionProof", obj.__undef__), dirty)
        if obj._retention_proof[0] is not None and obj._retention_proof[0] is not obj.__undef__:
            assert isinstance(obj._retention_proof[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._retention_proof[0]))
            common.validate_format(obj._retention_proof[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, 64)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        if "timeflowPoint" not in data:
            raise ValueError("Missing required property \"timeflowPoint\".")
        if "timeflowPoint" in data and data["timeflowPoint"] is not None:
            obj._timeflow_point = (factory.create_object(data["timeflowPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._timeflow_point[0], "TimeflowPoint")
        else:
            obj._timeflow_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowBookmarkCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "retention_proof" == "type" or (self.retention_proof is not self.__undef__ and not (dirty and not self._retention_proof[1])):
            dct["retentionProof"] = dictify(self.retention_proof)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "timeflow_point" == "type" or (self.timeflow_point is not self.__undef__ and not (dirty and not self._timeflow_point[1])):
            dct["timeflowPoint"] = dictify(self.timeflow_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._retention_proof = (self._retention_proof[0], True)
        self._tag = (self._tag[0], True)
        self._name = (self._name[0], True)
        self._timeflow_point = (self._timeflow_point[0], True)

    def is_dirty(self):
        return any([self._retention_proof[1], self._tag[1], self._name[1], self._timeflow_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowBookmarkCreateParameters):
            return False
        return super(TimeflowBookmarkCreateParameters, self).__eq__(other) and \
               self.retention_proof == other.retention_proof and \
               self.tag == other.tag and \
               self.name == other.name and \
               self.timeflow_point == other.timeflow_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def retention_proof(self):
        """
        Indicates whether retention should be allowed to clean up the TimeFlow
        bookmark and associated data.

        :rtype: ``bool``
        """
        return self._retention_proof[0]

    @retention_proof.setter
    def retention_proof(self, value):
        self._retention_proof = (value, True)

    @property
    def tag(self):
        """
        A tag for the bookmark that can be used to group bookmarks together or
        qualify the type of the bookmark.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def name(self):
        """
        The bookmark name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def timeflow_point(self):
        """
        The TimeFlow point which is referenced by this bookmark.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._timeflow_point[0]

    @timeflow_point.setter
    def timeflow_point(self, value):
        self._timeflow_point = (value, True)

class LoginRequest(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents a Delphix
    user authentication request.
    """
    def __init__(self, undef_enabled=True):
        super(LoginRequest, self).__init__()
        self._type = ("LoginRequest", True)
        self._username = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LoginRequest, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            assert obj._target[0] in [u'DOMAIN', u'SYSTEM'], "Expected enum [u'DOMAIN', u'SYSTEM'] but got %s" % obj._target[0]
            common.validate_format(obj._target[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LoginRequest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._password = (self._password[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._username[1], self._password[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LoginRequest):
            return False
        return super(LoginRequest, self).__eq__(other) and \
               self.username == other.username and \
               self.password == other.password and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The username of the user to authenticate.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def password(self):
        """
        The password of the user to authenticate.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def target(self):
        """
        The authentication domain. *(permitted values: DOMAIN, SYSTEM)*

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class NTPConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* NTP (Network Time
    Protocol) configuration.
    """
    def __init__(self, undef_enabled=True):
        super(NTPConfig, self).__init__()
        self._type = ("NTPConfig", True)
        self._multicast_address = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._use_multicast = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NTPConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._multicast_address = (data.get("multicastAddress", obj.__undef__), dirty)
        if obj._multicast_address[0] is not None and obj._multicast_address[0] is not obj.__undef__:
            assert isinstance(obj._multicast_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._multicast_address[0]))
            common.validate_format(obj._multicast_address[0], "ipv4Address", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._use_multicast = (data.get("useMulticast", obj.__undef__), dirty)
        if obj._use_multicast[0] is not None and obj._use_multicast[0] is not obj.__undef__:
            assert isinstance(obj._use_multicast[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_multicast[0]))
            common.validate_format(obj._use_multicast[0], "None", None, None)
        obj._servers = []
        for item in data.get("servers") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "host", None, None)
            obj._servers.append(item)
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NTPConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "multicast_address" == "type" or (self.multicast_address is not self.__undef__ and not (dirty and not self._multicast_address[1])):
            dct["multicastAddress"] = dictify(self.multicast_address)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "use_multicast" == "type" or (self.use_multicast is not self.__undef__ and not (dirty and not self._use_multicast[1])):
            dct["useMulticast"] = dictify(self.use_multicast)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._multicast_address = (self._multicast_address[0], True)
        self._enabled = (self._enabled[0], True)
        self._use_multicast = (self._use_multicast[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._multicast_address[1], self._enabled[1], self._use_multicast[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NTPConfig):
            return False
        return super(NTPConfig, self).__eq__(other) and \
               self.multicast_address == other.multicast_address and \
               self.enabled == other.enabled and \
               self.use_multicast == other.use_multicast and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def multicast_address(self):
        """
        *(default value: 224.0.1.1)* Address to use for multicast NTP
        discovery. This is only valid when 'useMulticast' is set.

        :rtype: ``basestring``
        """
        return self._multicast_address[0]

    @multicast_address.setter
    def multicast_address(self, value):
        self._multicast_address = (value, True)

    @property
    def enabled(self):
        """
        If true, then time is synchronized with the configured NTP servers. The
        management service is automatically restarted if this value is changed.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def use_multicast(self):
        """
        If true, discover NTP servers using multicast.

        :rtype: ``bool``
        """
        return self._use_multicast[0]

    @use_multicast.setter
    def use_multicast(self, value):
        self._use_multicast = (value, True)

    @property
    def servers(self):
        """
        A list of NTP servers to use for synchronization. At least one server
        must be specified if multicast is not being used.

        :rtype: ``list`` of ``basestring``
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class ReplicationSpecRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime properties for
    a replication spec.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationSpecRuntime, self).__init__()
        self._type = ("ReplicationSpecRuntime", True)
        self._next_scheduled_execution = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationSpecRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._next_scheduled_execution = (data.get("nextScheduledExecution", obj.__undef__), dirty)
        if obj._next_scheduled_execution[0] is not None and obj._next_scheduled_execution[0] is not obj.__undef__:
            assert isinstance(obj._next_scheduled_execution[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._next_scheduled_execution[0]))
            common.validate_format(obj._next_scheduled_execution[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationSpecRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "next_scheduled_execution" == "type" or (self.next_scheduled_execution is not self.__undef__ and not (dirty and not self._next_scheduled_execution[1])):
            dct["nextScheduledExecution"] = dictify(self.next_scheduled_execution)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._next_scheduled_execution = (self._next_scheduled_execution[0], True)

    def is_dirty(self):
        return any([self._next_scheduled_execution[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationSpecRuntime):
            return False
        return super(ReplicationSpecRuntime, self).__eq__(other) and \
               self.next_scheduled_execution == other.next_scheduled_execution

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def next_scheduled_execution(self):
        """
        Date of the next execution of this replication spec according to the
        schedule.

        :rtype: ``basestring``
        """
        return self._next_scheduled_execution[0]

    @next_scheduled_execution.setter
    def next_scheduled_execution(self, value):
        self._next_scheduled_execution = (value, True)

class OracleService(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The representation of
    an oracle service object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleService, self).__init__()
        self._type = ("OracleService", True)
        self._discovered = (self.__undef__, True)
        self._jdbc_connection_string = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleService, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._jdbc_connection_string = (data.get("jdbcConnectionString", obj.__undef__), dirty)
        if obj._jdbc_connection_string[0] is not None and obj._jdbc_connection_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_connection_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_connection_string[0]))
            common.validate_format(obj._jdbc_connection_string[0], "oracleJDBCConnectionString", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "jdbc_connection_string" == "type" or (self.jdbc_connection_string is not self.__undef__ and not (dirty and not self._jdbc_connection_string[1])):
            dct["jdbcConnectionString"] = dictify(self.jdbc_connection_string)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._jdbc_connection_string = (self._jdbc_connection_string[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._jdbc_connection_string[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleService):
            return False
        return super(OracleService, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.jdbc_connection_string == other.jdbc_connection_string

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this service was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def jdbc_connection_string(self):
        """
        The connection string used to connect to JDBC.

        :rtype: ``basestring``
        """
        return self._jdbc_connection_string[0]

    @jdbc_connection_string.setter
    def jdbc_connection_string(self, value):
        self._jdbc_connection_string = (value, True)

class HostPrivilegeElevationSettings(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Settings for elevating
    user privileges on a host.
    """
    def __init__(self, undef_enabled=True):
        super(HostPrivilegeElevationSettings, self).__init__()
        self._type = ("HostPrivilegeElevationSettings", True)
        self._default_profile = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostPrivilegeElevationSettings, cls).from_dict(data, dirty, undef_enabled)
        obj._default_profile = (data.get("defaultProfile", obj.__undef__), dirty)
        if obj._default_profile[0] is not None and obj._default_profile[0] is not obj.__undef__:
            assert isinstance(obj._default_profile[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_profile[0]))
            common.validate_format(obj._default_profile[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostPrivilegeElevationSettings, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "default_profile" == "type" or (self.default_profile is not self.__undef__ and not (dirty and not self._default_profile[1])):
            dct["defaultProfile"] = dictify(self.default_profile)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._default_profile = (self._default_profile[0], True)

    def is_dirty(self):
        return any([self._default_profile[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostPrivilegeElevationSettings):
            return False
        return super(HostPrivilegeElevationSettings, self).__eq__(other) and \
               self.default_profile == other.default_profile

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def default_profile(self):
        """
        The default privilege elevation profile for new environments.

        :rtype: ``basestring``
        """
        return self._default_profile[0]

    @default_profile.setter
    def default_profile(self, value):
        self._default_profile = (value, True)

class OracleVirtualIP(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used
    for virtual IP operations.
    """
    def __init__(self, undef_enabled=True):
        super(OracleVirtualIP, self).__init__()
        self._type = ("OracleVirtualIP", True)
        self._discovered = (self.__undef__, True)
        self._ip = (self.__undef__, True)
        self._domain_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleVirtualIP, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        if "ip" not in data:
            raise ValueError("Missing required property \"ip\".")
        obj._ip = (data.get("ip", obj.__undef__), dirty)
        if obj._ip[0] is not None and obj._ip[0] is not obj.__undef__:
            assert isinstance(obj._ip[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ip[0]))
            common.validate_format(obj._ip[0], "ipv4Address", None, None)
        if "domainName" not in data:
            raise ValueError("Missing required property \"domainName\".")
        obj._domain_name = (data.get("domainName", obj.__undef__), dirty)
        if obj._domain_name[0] is not None and obj._domain_name[0] is not obj.__undef__:
            assert isinstance(obj._domain_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._domain_name[0]))
            common.validate_format(obj._domain_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleVirtualIP, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "ip" == "type" or (self.ip is not self.__undef__ and not (dirty and not self._ip[1])):
            dct["ip"] = dictify(self.ip)
        if "domain_name" == "type" or (self.domain_name is not self.__undef__ and not (dirty and not self._domain_name[1])):
            dct["domainName"] = dictify(self.domain_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._ip = (self._ip[0], True)
        self._domain_name = (self._domain_name[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._ip[1], self._domain_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleVirtualIP):
            return False
        return super(OracleVirtualIP, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.ip == other.ip and \
               self.domain_name == other.domain_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        A boolean indicating whether this VIP was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def ip(self):
        """
        The virtual IP address.

        :rtype: ``basestring``
        """
        return self._ip[0]

    @ip.setter
    def ip(self, value):
        self._ip = (value, True)

    @property
    def domain_name(self):
        """
        The name of the domain where the cluster is residing.

        :rtype: ``basestring``
        """
        return self._domain_name[0]

    @domain_name.setter
    def domain_name(self, value):
        self._domain_name = (value, True)

class RegistrationStatus(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Information on the
    status of the Delphix Engine's registration.
    """
    def __init__(self, undef_enabled=True):
        super(RegistrationStatus, self).__init__()
        self._type = ("RegistrationStatus", True)
        self._status = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RegistrationStatus, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RegistrationStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._status[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RegistrationStatus):
            return False
        return super(RegistrationStatus, self).__eq__(other) and \
               self.status == other.status and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the Delphix Engine's registration. It may be unknown,
        unregistered, in-progress, or registered.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def timestamp(self):
        """
        The time at which the registration status was last updated.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class VersionInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Representation of a
    Delphix software revision.
    """
    def __init__(self, undef_enabled=True):
        super(VersionInfo, self).__init__()
        self._type = ("VersionInfo", True)
        self._micro = (self.__undef__, True)
        self._major = (self.__undef__, True)
        self._minor = (self.__undef__, True)
        self._patch = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VersionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._micro = (data.get("micro", obj.__undef__), dirty)
        if obj._micro[0] is not None and obj._micro[0] is not obj.__undef__:
            assert isinstance(obj._micro[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._micro[0]))
            common.validate_format(obj._micro[0], "None", None, None)
        obj._major = (data.get("major", obj.__undef__), dirty)
        if obj._major[0] is not None and obj._major[0] is not obj.__undef__:
            assert isinstance(obj._major[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._major[0]))
            common.validate_format(obj._major[0], "None", None, None)
        obj._minor = (data.get("minor", obj.__undef__), dirty)
        if obj._minor[0] is not None and obj._minor[0] is not obj.__undef__:
            assert isinstance(obj._minor[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._minor[0]))
            common.validate_format(obj._minor[0], "None", None, None)
        obj._patch = (data.get("patch", obj.__undef__), dirty)
        if obj._patch[0] is not None and obj._patch[0] is not obj.__undef__:
            assert isinstance(obj._patch[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._patch[0]))
            common.validate_format(obj._patch[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VersionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "micro" == "type" or (self.micro is not self.__undef__ and not (dirty and not self._micro[1])):
            dct["micro"] = dictify(self.micro)
        if "major" == "type" or (self.major is not self.__undef__ and not (dirty and not self._major[1])):
            dct["major"] = dictify(self.major)
        if "minor" == "type" or (self.minor is not self.__undef__ and not (dirty and not self._minor[1])):
            dct["minor"] = dictify(self.minor)
        if "patch" == "type" or (self.patch is not self.__undef__ and not (dirty and not self._patch[1])):
            dct["patch"] = dictify(self.patch)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._micro = (self._micro[0], True)
        self._major = (self._major[0], True)
        self._minor = (self._minor[0], True)
        self._patch = (self._patch[0], True)

    def is_dirty(self):
        return any([self._micro[1], self._major[1], self._minor[1], self._patch[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VersionInfo):
            return False
        return super(VersionInfo, self).__eq__(other) and \
               self.micro == other.micro and \
               self.major == other.major and \
               self.minor == other.minor and \
               self.patch == other.patch

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def micro(self):
        """
        Micro version number.

        :rtype: ``int``
        """
        return self._micro[0]

    @micro.setter
    def micro(self, value):
        self._micro = (value, True)

    @property
    def major(self):
        """
        Major version number.

        :rtype: ``int``
        """
        return self._major[0]

    @major.setter
    def major(self, value):
        self._major = (value, True)

    @property
    def minor(self):
        """
        Minor version number.

        :rtype: ``int``
        """
        return self._minor[0]

    @minor.setter
    def minor(self, value):
        self._minor = (value, True)

    @property
    def patch(self):
        """
        Patch version number.

        :rtype: ``int``
        """
        return self._patch[0]

    @patch.setter
    def patch(self, value):
        self._patch = (value, True)

class AttachSourceParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(AttachSourceParameters, self).__init__()
        self._type = ("AttachSourceParameters", True)
        self._attach_data = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AttachSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        if "attachData" not in data:
            raise ValueError("Missing required property \"attachData\".")
        if "attachData" in data and data["attachData"] is not None:
            obj._attach_data = (factory.create_object(data["attachData"], "AttachData"), dirty)
            factory.validate_type(obj._attach_data[0], "AttachData")
        else:
            obj._attach_data = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AttachSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "attach_data" == "type" or (self.attach_data is not self.__undef__ and not (dirty and not self._attach_data[1])):
            dct["attachData"] = dictify(self.attach_data)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._attach_data = (self._attach_data[0], True)

    def is_dirty(self):
        return any([self._attach_data[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AttachSourceParameters):
            return False
        return super(AttachSourceParameters, self).__eq__(other) and \
               self.attach_data == other.attach_data

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def attach_data(self):
        """
        The database-specific parameters of an attach request.

        :rtype: :py:class:`v1_8_1.web.vo.AttachData`
        """
        return self._attach_data[0]

    @attach_data.setter
    def attach_data(self, value):
        self._attach_data = (value, True)

class SecurityConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* System wide security
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SecurityConfig, self).__init__()
        self._type = ("SecurityConfig", True)
        self._allowed_cors_origins = (self.__undef__, True)
        self._is_cors_enabled = (self.__undef__, True)
        self._banner = (self.__undef__, True)
        self._boot_password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SecurityConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._allowed_cors_origins = (data.get("allowedCORSOrigins", obj.__undef__), dirty)
        if obj._allowed_cors_origins[0] is not None and obj._allowed_cors_origins[0] is not obj.__undef__:
            assert isinstance(obj._allowed_cors_origins[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._allowed_cors_origins[0]))
            common.validate_format(obj._allowed_cors_origins[0], "None", None, None)
        obj._is_cors_enabled = (data.get("isCORSEnabled", obj.__undef__), dirty)
        if obj._is_cors_enabled[0] is not None and obj._is_cors_enabled[0] is not obj.__undef__:
            assert isinstance(obj._is_cors_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._is_cors_enabled[0]))
            common.validate_format(obj._is_cors_enabled[0], "None", None, None)
        obj._banner = (data.get("banner", obj.__undef__), dirty)
        if obj._banner[0] is not None and obj._banner[0] is not obj.__undef__:
            assert isinstance(obj._banner[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._banner[0]))
            common.validate_format(obj._banner[0], "None", None, None)
        obj._boot_password = (data.get("bootPassword", obj.__undef__), dirty)
        if obj._boot_password[0] is not None and obj._boot_password[0] is not obj.__undef__:
            assert isinstance(obj._boot_password[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._boot_password[0]))
            common.validate_format(obj._boot_password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SecurityConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "allowed_cors_origins" == "type" or (self.allowed_cors_origins is not self.__undef__ and not (dirty and not self._allowed_cors_origins[1])):
            dct["allowedCORSOrigins"] = dictify(self.allowed_cors_origins)
        if "is_cors_enabled" == "type" or (self.is_cors_enabled is not self.__undef__ and not (dirty and not self._is_cors_enabled[1])):
            dct["isCORSEnabled"] = dictify(self.is_cors_enabled)
        if "banner" == "type" or (self.banner is not self.__undef__ and not (dirty and not self._banner[1])):
            dct["banner"] = dictify(self.banner)
        if "boot_password" == "type" or (self.boot_password is not self.__undef__ and not (dirty and not self._boot_password[1])):
            dct["bootPassword"] = dictify(self.boot_password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._allowed_cors_origins = (self._allowed_cors_origins[0], True)
        self._is_cors_enabled = (self._is_cors_enabled[0], True)
        self._banner = (self._banner[0], True)
        self._boot_password = (self._boot_password[0], True)

    def is_dirty(self):
        return any([self._allowed_cors_origins[1], self._is_cors_enabled[1], self._banner[1], self._boot_password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SecurityConfig):
            return False
        return super(SecurityConfig, self).__eq__(other) and \
               self.allowed_cors_origins == other.allowed_cors_origins and \
               self.is_cors_enabled == other.is_cors_enabled and \
               self.banner == other.banner and \
               self.boot_password == other.boot_password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def allowed_cors_origins(self):
        """
        Allowed origin domains for CORS. Should be a comma separated list. Use
        * for all domains. Defaults to none. Changing this value requires a
        stack restart for it to take effect.

        :rtype: ``basestring``
        """
        return self._allowed_cors_origins[0]

    @allowed_cors_origins.setter
    def allowed_cors_origins(self, value):
        self._allowed_cors_origins = (value, True)

    @property
    def is_cors_enabled(self):
        """
        Whether or not CORS is enabled. Changing this value requires a stack
        restart for it to take effect.

        :rtype: ``bool``
        """
        return self._is_cors_enabled[0]

    @is_cors_enabled.setter
    def is_cors_enabled(self, value):
        self._is_cors_enabled = (value, True)

    @property
    def banner(self):
        """
        Banner displayed prior to login.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._banner[0]

    @banner.setter
    def banner(self, value):
        self._banner = (value, True)

    @property
    def boot_password(self):
        """
        Password controlling access to bootloader configuration changes during
        startup.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._boot_password[0]

    @boot_password.setter
    def boot_password(self, value):
        self._boot_password = (value, True)

class OracleLog(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Oracle log file.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLog, self).__init__()
        self._type = ("OracleLog", True)
        self._instance_num = (self.__undef__, True)
        self._sequence = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLog, cls).from_dict(data, dirty, undef_enabled)
        obj._instance_num = (data.get("instanceNum", obj.__undef__), dirty)
        if obj._instance_num[0] is not None and obj._instance_num[0] is not obj.__undef__:
            assert isinstance(obj._instance_num[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._instance_num[0]))
            common.validate_format(obj._instance_num[0], "None", None, None)
        obj._sequence = (data.get("sequence", obj.__undef__), dirty)
        if obj._sequence[0] is not None and obj._sequence[0] is not obj.__undef__:
            assert isinstance(obj._sequence[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._sequence[0]))
            common.validate_format(obj._sequence[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLog, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance_num" == "type" or (self.instance_num is not self.__undef__ and not (dirty and not self._instance_num[1])):
            dct["instanceNum"] = dictify(self.instance_num)
        if "sequence" == "type" or (self.sequence is not self.__undef__ and not (dirty and not self._sequence[1])):
            dct["sequence"] = dictify(self.sequence)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance_num = (self._instance_num[0], True)
        self._sequence = (self._sequence[0], True)

    def is_dirty(self):
        return any([self._instance_num[1], self._sequence[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLog):
            return False
        return super(OracleLog, self).__eq__(other) and \
               self.instance_num == other.instance_num and \
               self.sequence == other.sequence

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance_num(self):
        """
        Instance number associated with the log file.

        :rtype: ``int``
        """
        return self._instance_num[0]

    @instance_num.setter
    def instance_num(self, value):
        self._instance_num = (value, True)

    @property
    def sequence(self):
        """
        Sequence number for the log file.

        :rtype: ``int``
        """
        return self._sequence[0]

    @sequence.setter
    def sequence(self, value):
        self._sequence = (value, True)

class CPUInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes a processor
    available to the system.
    """
    def __init__(self, undef_enabled=True):
        super(CPUInfo, self).__init__()
        self._type = ("CPUInfo", True)
        self._cores = (self.__undef__, True)
        self._speed = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CPUInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._cores = (data.get("cores", obj.__undef__), dirty)
        if obj._cores[0] is not None and obj._cores[0] is not obj.__undef__:
            assert isinstance(obj._cores[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cores[0]))
            common.validate_format(obj._cores[0], "None", None, None)
        obj._speed = (data.get("speed", obj.__undef__), dirty)
        if obj._speed[0] is not None and obj._speed[0] is not obj.__undef__:
            assert isinstance(obj._speed[0], float), ("Expected one of [u'number'], but got %s" % type(obj._speed[0]))
            common.validate_format(obj._speed[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CPUInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cores" == "type" or (self.cores is not self.__undef__ and not (dirty and not self._cores[1])):
            dct["cores"] = dictify(self.cores)
        if "speed" == "type" or (self.speed is not self.__undef__ and not (dirty and not self._speed[1])):
            dct["speed"] = dictify(self.speed)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cores = (self._cores[0], True)
        self._speed = (self._speed[0], True)

    def is_dirty(self):
        return any([self._cores[1], self._speed[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CPUInfo):
            return False
        return super(CPUInfo, self).__eq__(other) and \
               self.cores == other.cores and \
               self.speed == other.speed

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cores(self):
        """
        Number of cores in the processor.

        :rtype: ``int``
        """
        return self._cores[0]

    @cores.setter
    def cores(self, value):
        self._cores = (value, True)

    @property
    def speed(self):
        """
        Speed of the processor, in hertz.

        :rtype: ``float``
        """
        return self._speed[0]

    @speed.setter
    def speed(self, value):
        self._speed = (value, True)

class PhoneHomeService(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Phone home service
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(PhoneHomeService, self).__init__()
        self._type = ("PhoneHomeService", True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PhoneHomeService, cls).from_dict(data, dirty, undef_enabled)
        if "enabled" not in data:
            raise ValueError("Missing required property \"enabled\".")
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PhoneHomeService, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PhoneHomeService):
            return False
        return super(PhoneHomeService, self).__eq__(other) and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enabled(self):
        """
        True if the phone home service is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class ExportParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to export requests.
    """
    def __init__(self, undef_enabled=True):
        super(ExportParameters, self).__init__()
        self._type = ("ExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._timeflow_point_parameters = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._timeflow_point_parameters[1], self._file_mapping_rules[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ExportParameters):
            return False
        return super(ExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.timeflow_point_parameters == other.timeflow_point_parameters and \
               self.file_mapping_rules == other.file_mapping_rules

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_8_1.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to base export on.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

class BaseConsumerCapacityData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Data about a
    particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(BaseConsumerCapacityData, self).__init__()
        self._type = ("BaseConsumerCapacityData", True)
        self._breakdown = (self.__undef__, True)
        self._group = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._parent = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._group_name = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        if "breakdown" in data and data["breakdown"] is not None:
            obj._breakdown = (factory.create_object(data["breakdown"], "CapacityBreakdown"), dirty)
            factory.validate_type(obj._breakdown[0], "CapacityBreakdown")
        else:
            obj._breakdown = (obj.__undef__, dirty)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._parent = (data.get("parent", obj.__undef__), dirty)
        if obj._parent[0] is not None and obj._parent[0] is not obj.__undef__:
            assert isinstance(obj._parent[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent[0]))
            common.validate_format(obj._parent[0], "objectReference", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._group_name = (data.get("groupName", obj.__undef__), dirty)
        if obj._group_name[0] is not None and obj._group_name[0] is not obj.__undef__:
            assert isinstance(obj._group_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group_name[0]))
            common.validate_format(obj._group_name[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "breakdown" == "type" or (self.breakdown is not self.__undef__ and not (dirty and not self._breakdown[1])):
            dct["breakdown"] = dictify(self.breakdown)
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "parent" == "type" or (self.parent is not self.__undef__ and not (dirty and not self._parent[1])):
            dct["parent"] = dictify(self.parent)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "group_name" == "type" or (self.group_name is not self.__undef__ and not (dirty and not self._group_name[1])):
            dct["groupName"] = dictify(self.group_name)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._breakdown = (self._breakdown[0], True)
        self._group = (self._group[0], True)
        self._name = (self._name[0], True)
        self._parent = (self._parent[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._group_name = (self._group_name[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._breakdown[1], self._group[1], self._name[1], self._parent[1], self._timestamp[1], self._group_name[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseConsumerCapacityData):
            return False
        return super(BaseConsumerCapacityData, self).__eq__(other) and \
               self.breakdown == other.breakdown and \
               self.group == other.group and \
               self.name == other.name and \
               self.parent == other.parent and \
               self.timestamp == other.timestamp and \
               self.group_name == other.group_name and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def breakdown(self):
        """
        Statistics for this consumer.

        :rtype: :py:class:`v1_8_1.web.vo.CapacityBreakdown`
        """
        return self._breakdown[0]

    @breakdown.setter
    def breakdown(self, value):
        self._breakdown = (value, True)

    @property
    def group(self):
        """
        Reference to this container's group.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

    @property
    def name(self):
        """
        Name of the container.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def parent(self):
        """
        Container from which this TimeFlow was provisioned.

        :rtype: ``basestring``
        """
        return self._parent[0]

    @parent.setter
    def parent(self, value):
        self._parent = (value, True)

    @property
    def timestamp(self):
        """
        Time at which this information was sampled.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def group_name(self):
        """
        Name of this container's group.

        :rtype: ``basestring``
        """
        return self._group_name[0]

    @group_name.setter
    def group_name(self, value):
        self._group_name = (value, True)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class TracerouteInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Trace route info from
    target host to Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(TracerouteInfo, self).__init__()
        self._type = ("TracerouteInfo", True)
        self._network_hops = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TracerouteInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._network_hops = (data.get("networkHops", obj.__undef__), dirty)
        if obj._network_hops[0] is not None and obj._network_hops[0] is not obj.__undef__:
            assert isinstance(obj._network_hops[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._network_hops[0]))
            common.validate_format(obj._network_hops[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TracerouteInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "network_hops" == "type" or (self.network_hops is not self.__undef__ and not (dirty and not self._network_hops[1])):
            dct["networkHops"] = dictify(self.network_hops)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._network_hops = (self._network_hops[0], True)

    def is_dirty(self):
        return any([self._network_hops[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TracerouteInfo):
            return False
        return super(TracerouteInfo, self).__eq__(other) and \
               self.network_hops == other.network_hops

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def network_hops(self):
        """
        Latency of network hops from host to Delphix Engine.

        :rtype: ``basestring``
        """
        return self._network_hops[0]

    @network_hops.setter
    def network_hops(self, value):
        self._network_hops = (value, True)

class WorkflowFunctionDefinition(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The definition of a
    Workflow Function.
    """
    def __init__(self, undef_enabled=True):
        super(WorkflowFunctionDefinition, self).__init__()
        self._type = ("WorkflowFunctionDefinition", True)
        self._input_schema = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._output_schema = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WorkflowFunctionDefinition, cls).from_dict(data, dirty, undef_enabled)
        if "inputSchema" in data and data["inputSchema"] is not None:
            obj._input_schema = (data["inputSchema"], dirty)
        else:
            obj._input_schema = (obj.__undef__, dirty)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        if "outputSchema" in data and data["outputSchema"] is not None:
            obj._output_schema = (data["outputSchema"], dirty)
        else:
            obj._output_schema = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WorkflowFunctionDefinition, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "input_schema" == "type" or (self.input_schema is not self.__undef__ and not (dirty and not self._input_schema[1])):
            dct["inputSchema"] = dictify(self.input_schema)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "output_schema" == "type" or (self.output_schema is not self.__undef__ and not (dirty and not self._output_schema[1])):
            dct["outputSchema"] = dictify(self.output_schema)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._input_schema = (self._input_schema[0], True)
        self._name = (self._name[0], True)
        self._output_schema = (self._output_schema[0], True)

    def is_dirty(self):
        return any([self._input_schema[1], self._name[1], self._output_schema[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WorkflowFunctionDefinition):
            return False
        return super(WorkflowFunctionDefinition, self).__eq__(other) and \
               self.input_schema == other.input_schema and \
               self.name == other.name and \
               self.output_schema == other.output_schema

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def input_schema(self):
        """
        The input schema for this function according to DRAFTV4.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._input_schema[0]

    @input_schema.setter
    def input_schema(self, value):
        self._input_schema = (value, True)

    @property
    def name(self):
        """
        The name of this function.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def output_schema(self):
        """
        The output schema for this function according to DRAFTV4.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._output_schema[0]

    @output_schema.setter
    def output_schema(self, value):
        self._output_schema = (value, True)

class JSSourceDataTimestamp(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The association
    between a Jet Stream data source and a point in time that's provisionable.
    """
    def __init__(self, undef_enabled=True):
        super(JSSourceDataTimestamp, self).__init__()
        self._type = ("JSSourceDataTimestamp", True)
        self._priority = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSSourceDataTimestamp, cls).from_dict(data, dirty, undef_enabled)
        obj._priority = (data.get("priority", obj.__undef__), dirty)
        if obj._priority[0] is not None and obj._priority[0] is not obj.__undef__:
            assert isinstance(obj._priority[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._priority[0]))
            common.validate_format(obj._priority[0], "None", None, None)
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "objectReference", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSSourceDataTimestamp, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "priority" == "type" or (self.priority is not self.__undef__ and not (dirty and not self._priority[1])):
            dct["priority"] = dictify(self.priority)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._priority = (self._priority[0], True)
        self._source = (self._source[0], True)
        self._name = (self._name[0], True)
        self._branch = (self._branch[0], True)
        self._timestamp = (self._timestamp[0], True)

    def is_dirty(self):
        return any([self._priority[1], self._source[1], self._name[1], self._branch[1], self._timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSSourceDataTimestamp):
            return False
        return super(JSSourceDataTimestamp, self).__eq__(other) and \
               self.priority == other.priority and \
               self.source == other.source and \
               self.name == other.name and \
               self.branch == other.branch and \
               self.timestamp == other.timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def priority(self):
        """
        The priority of the Jet Stream data source.

        :rtype: ``int``
        """
        return self._priority[0]

    @priority.setter
    def priority(self, value):
        self._priority = (value, True)

    @property
    def source(self):
        """
        A reference to the Jet Stream data source.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def name(self):
        """
        The name of the Jet Stream data source.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def branch(self):
        """
        A reference to the Jet Stream branch.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def timestamp(self):
        """
        The point in the source's dataset time which is provisionable.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

class SupportBundleUploadParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters to be used
    when uploading a support bundle.
    """
    def __init__(self, undef_enabled=True):
        super(SupportBundleUploadParameters, self).__init__()
        self._type = ("SupportBundleUploadParameters", True)
        self._case_number = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SupportBundleUploadParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._case_number = (data.get("caseNumber", obj.__undef__), dirty)
        if obj._case_number[0] is not None and obj._case_number[0] is not obj.__undef__:
            assert isinstance(obj._case_number[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._case_number[0]))
            common.validate_format(obj._case_number[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SupportBundleUploadParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "case_number" == "type" or (self.case_number is not self.__undef__ and not (dirty and not self._case_number[1])):
            dct["caseNumber"] = dictify(self.case_number)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._case_number = (self._case_number[0], True)

    def is_dirty(self):
        return any([self._case_number[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SupportBundleUploadParameters):
            return False
        return super(SupportBundleUploadParameters, self).__eq__(other) and \
               self.case_number == other.case_number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def case_number(self):
        """
        The Delphix support case number.

        :rtype: ``int``
        """
        return self._case_number[0]

    @case_number.setter
    def case_number(self, value):
        self._case_number = (value, True)

class Schema(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Schema object.
    """
    def __init__(self, undef_enabled=True):
        super(Schema, self).__init__()
        self._type = ("Schema", True)
        self._schema = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Schema, cls).from_dict(data, dirty, undef_enabled)
        obj._schema = (data.get("schema", obj.__undef__), dirty)
        if obj._schema[0] is not None and obj._schema[0] is not obj.__undef__:
            assert isinstance(obj._schema[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._schema[0]))
            common.validate_format(obj._schema[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Schema, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "schema" == "type" or (self.schema is not self.__undef__ and not (dirty and not self._schema[1])):
            dct["schema"] = dictify(self.schema)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._schema = (self._schema[0], True)

    def is_dirty(self):
        return any([self._schema[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Schema):
            return False
        return super(Schema, self).__eq__(other) and \
               self.schema == other.schema

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def schema(self):
        """
        JSON representation of the schema based on the locale and API Session
        version.

        :rtype: ``basestring``
        """
        return self._schema[0]

    @schema.setter
    def schema(self, value):
        self._schema = (value, True)

class OracleCustomEnvVar(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Dictates one or more
    environment variables to be set when the Delphix Engine administers an
    Oracle virtual database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVar, self).__init__()
        self._type = ("OracleCustomEnvVar", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVar, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVar, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVar):
            return False
        return super(OracleCustomEnvVar, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSTemplateUsageData(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The space usage
    information for a data template.
    """
    def __init__(self, undef_enabled=True):
        super(JSTemplateUsageData, self).__init__()
        self._type = ("JSTemplateUsageData", True)
        self._unvirtualized = (self.__undef__, True)
        self._bookmarks = (self.__undef__, True)
        self._total = (self.__undef__, True)
        self._containers = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTemplateUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._unvirtualized = (data.get("unvirtualized", obj.__undef__), dirty)
        if obj._unvirtualized[0] is not None and obj._unvirtualized[0] is not obj.__undef__:
            assert isinstance(obj._unvirtualized[0], float), ("Expected one of [u'number'], but got %s" % type(obj._unvirtualized[0]))
            common.validate_format(obj._unvirtualized[0], "None", None, None)
        obj._bookmarks = (data.get("bookmarks", obj.__undef__), dirty)
        if obj._bookmarks[0] is not None and obj._bookmarks[0] is not obj.__undef__:
            assert isinstance(obj._bookmarks[0], float), ("Expected one of [u'number'], but got %s" % type(obj._bookmarks[0]))
            common.validate_format(obj._bookmarks[0], "None", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        obj._containers = (data.get("containers", obj.__undef__), dirty)
        if obj._containers[0] is not None and obj._containers[0] is not obj.__undef__:
            assert isinstance(obj._containers[0], float), ("Expected one of [u'number'], but got %s" % type(obj._containers[0]))
            common.validate_format(obj._containers[0], "None", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTemplateUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "unvirtualized" == "type" or (self.unvirtualized is not self.__undef__ and not (dirty and not self._unvirtualized[1])):
            dct["unvirtualized"] = dictify(self.unvirtualized)
        if "bookmarks" == "type" or (self.bookmarks is not self.__undef__ and not (dirty and not self._bookmarks[1])):
            dct["bookmarks"] = dictify(self.bookmarks)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        if "containers" == "type" or (self.containers is not self.__undef__ and not (dirty and not self._containers[1])):
            dct["containers"] = dictify(self.containers)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._unvirtualized = (self._unvirtualized[0], True)
        self._bookmarks = (self._bookmarks[0], True)
        self._total = (self._total[0], True)
        self._containers = (self._containers[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._unvirtualized[1], self._bookmarks[1], self._total[1], self._containers[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTemplateUsageData):
            return False
        return super(JSTemplateUsageData, self).__eq__(other) and \
               self.unvirtualized == other.unvirtualized and \
               self.bookmarks == other.bookmarks and \
               self.total == other.total and \
               self.containers == other.containers and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def unvirtualized(self):
        """
        The amount of space that would be consumed by the data in this template
        (and child containers) without Delphix.

        :rtype: ``float``
        """
        return self._unvirtualized[0]

    @unvirtualized.setter
    def unvirtualized(self, value):
        self._unvirtualized = (value, True)

    @property
    def bookmarks(self):
        """
        The amount of space consumed by the bookmarks on this data template.
        This is the space that will be freed up if all bookmarks on the
        template were deleted. This presumes that all of child data containers
        are purged first.

        :rtype: ``float``
        """
        return self._bookmarks[0]

    @bookmarks.setter
    def bookmarks(self, value):
        self._bookmarks = (value, True)

    @property
    def total(self):
        """
        The space that will be freed up if this template (and all of its child
        data containers are deleted).

        :rtype: ``float``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

    @property
    def containers(self):
        """
        The amount of space consumed by data containers that were provisioned
        from this data template. This is the space that will be freed up if all
        of those data containers are deleted or purged. This assumes that the
        data containers are deleted along with underlying data sources.

        :rtype: ``float``
        """
        return self._containers[0]

    @containers.setter
    def containers(self, value):
        self._containers = (value, True)

    @property
    def template(self):
        """
        The data template that this usage information is for.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class DBContainerRuntime(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Runtime properties of
    a database container.
    """
    def __init__(self, undef_enabled=True):
        super(DBContainerRuntime, self).__init__()
        self._type = ("DBContainerRuntime", True)
        self._log_sync_active = (self.__undef__, True)
        self._pre_provisioning_status = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._log_sync_active = (data.get("logSyncActive", obj.__undef__), dirty)
        if obj._log_sync_active[0] is not None and obj._log_sync_active[0] is not obj.__undef__:
            assert isinstance(obj._log_sync_active[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._log_sync_active[0]))
            common.validate_format(obj._log_sync_active[0], "None", None, None)
        if "preProvisioningStatus" in data and data["preProvisioningStatus"] is not None:
            obj._pre_provisioning_status = (factory.create_object(data["preProvisioningStatus"], "PreProvisioningRuntime"), dirty)
            factory.validate_type(obj._pre_provisioning_status[0], "PreProvisioningRuntime")
        else:
            obj._pre_provisioning_status = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "log_sync_active" == "type" or (self.log_sync_active is not self.__undef__ and not (dirty and not self._log_sync_active[1])):
            dct["logSyncActive"] = dictify(self.log_sync_active)
        if "pre_provisioning_status" == "type" or (self.pre_provisioning_status is not self.__undef__ and not (dirty and not self._pre_provisioning_status[1])):
            dct["preProvisioningStatus"] = dictify(self.pre_provisioning_status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._log_sync_active = (self._log_sync_active[0], True)
        self._pre_provisioning_status = (self._pre_provisioning_status[0], True)

    def is_dirty(self):
        return any([self._log_sync_active[1], self._pre_provisioning_status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DBContainerRuntime):
            return False
        return super(DBContainerRuntime, self).__eq__(other) and \
               self.log_sync_active == other.log_sync_active and \
               self.pre_provisioning_status == other.pre_provisioning_status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def log_sync_active(self):
        """
        True if the LogSync is enabled and running for this container.

        :rtype: ``bool``
        """
        return self._log_sync_active[0]

    @log_sync_active.setter
    def log_sync_active(self, value):
        self._log_sync_active = (value, True)

    @property
    def pre_provisioning_status(self):
        """
        The pre-provisioning runtime for the container.

        :rtype: :py:class:`v1_8_1.web.vo.PreProvisioningRuntime`
        """
        return self._pre_provisioning_status[0]

    @pre_provisioning_status.setter
    def pre_provisioning_status(self, value):
        self._pre_provisioning_status = (value, True)

class DatapointSet(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A set of datapoints
    from a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DatapointSet, self).__init__()
        self._type = ("DatapointSet", True)
        self._overflow = (self.__undef__, True)
        self._resolution = (self.__undef__, True)
        self._datapoint_streams = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatapointSet, cls).from_dict(data, dirty, undef_enabled)
        obj._overflow = (data.get("overflow", obj.__undef__), dirty)
        if obj._overflow[0] is not None and obj._overflow[0] is not obj.__undef__:
            assert isinstance(obj._overflow[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._overflow[0]))
            common.validate_format(obj._overflow[0], "None", None, None)
        obj._resolution = (data.get("resolution", obj.__undef__), dirty)
        if obj._resolution[0] is not None and obj._resolution[0] is not obj.__undef__:
            assert isinstance(obj._resolution[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._resolution[0]))
            common.validate_format(obj._resolution[0], "None", None, None)
        obj._datapoint_streams = []
        for item in data.get("datapointStreams") or []:
            obj._datapoint_streams.append(factory.create_object(item))
            factory.validate_type(obj._datapoint_streams[-1], "DatapointStream")
        obj._datapoint_streams = (obj._datapoint_streams, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatapointSet, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "overflow" == "type" or (self.overflow is not self.__undef__ and not (dirty and not self._overflow[1])):
            dct["overflow"] = dictify(self.overflow)
        if "resolution" == "type" or (self.resolution is not self.__undef__ and not (dirty and not self._resolution[1])):
            dct["resolution"] = dictify(self.resolution)
        if "datapoint_streams" == "type" or (self.datapoint_streams is not self.__undef__ and not (dirty and not self._datapoint_streams[1])):
            dct["datapointStreams"] = dictify(self.datapoint_streams)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._overflow = (self._overflow[0], True)
        self._resolution = (self._resolution[0], True)
        self._datapoint_streams = (self._datapoint_streams[0], True)

    def is_dirty(self):
        return any([self._overflow[1], self._resolution[1], self._datapoint_streams[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatapointSet):
            return False
        return super(DatapointSet, self).__eq__(other) and \
               self.overflow == other.overflow and \
               self.resolution == other.resolution and \
               self.datapoint_streams == other.datapoint_streams

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def overflow(self):
        """
        True if the number of datapoints to be included exceeded the maximum
        allowable for a single datapoint set. As a result, not all datapoints
        could be included in the datapointStreams array.

        :rtype: ``bool``
        """
        return self._overflow[0]

    @overflow.setter
    def overflow(self, value):
        self._overflow = (value, True)

    @property
    def resolution(self):
        """
        The amount of time each datapoint spans.

        :rtype: ``int``
        """
        return self._resolution[0]

    @resolution.setter
    def resolution(self, value):
        self._resolution = (value, True)

    @property
    def datapoint_streams(self):
        """
        The set of datapoint streams in the result.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.DatapointStream`
        """
        return self._datapoint_streams[0]

    @datapoint_streams.setter
    def datapoint_streams(self, value):
        self._datapoint_streams = (value, True)

class MSSqlBaseClusterListener(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The representation of
    a SQL Server Cluster Listener.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlBaseClusterListener, self).__init__()
        self._type = ("MSSqlBaseClusterListener", True)
        self._address = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlBaseClusterListener, cls).from_dict(data, dirty, undef_enabled)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], float), ("Expected one of [u'number'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlBaseClusterListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._address = (self._address[0], True)
        self._port = (self._port[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._address[1], self._port[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlBaseClusterListener):
            return False
        return super(MSSqlBaseClusterListener, self).__eq__(other) and \
               self.address == other.address and \
               self.port == other.port and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def address(self):
        """
        The address of the listener.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def port(self):
        """
        The port for the listener.

        :rtype: ``float``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def name(self):
        """
        The name of the listener.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class AuthFilterResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of an auth
    filter request.
    """
    def __init__(self, undef_enabled=True):
        super(AuthFilterResult, self).__init__()
        self._type = ("AuthFilterResult", True)
        self._objects = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AuthFilterResult, cls).from_dict(data, dirty, undef_enabled)
        obj._objects = []
        for item in data.get("objects") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._objects.append(item)
        obj._objects = (obj._objects, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AuthFilterResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "objects" == "type" or (self.objects is not self.__undef__ and not (dirty and not self._objects[1])):
            dct["objects"] = dictify(self.objects)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._objects = (self._objects[0], True)

    def is_dirty(self):
        return any([self._objects[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AuthFilterResult):
            return False
        return super(AuthFilterResult, self).__eq__(other) and \
               self.objects == other.objects

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def objects(self):
        """
        The list of objects that have been filtered.

        :rtype: ``list`` of ``basestring``
        """
        return self._objects[0]

    @objects.setter
    def objects(self, value):
        self._objects = (value, True)

class VirtualDatasetCreationParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input when creating a new virtual dataset.
    """
    def __init__(self, undef_enabled=True):
        super(VirtualDatasetCreationParameters, self).__init__()
        self._type = ("VirtualDatasetCreationParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VirtualDatasetCreationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "Source"), dirty)
            factory.validate_type(obj._source[0], "Source")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "Container"), dirty)
            factory.validate_type(obj._container[0], "Container")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VirtualDatasetCreationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VirtualDatasetCreationParameters):
            return False
        return super(VirtualDatasetCreationParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external dataset instance.

        :rtype: :py:class:`v1_8_1.web.vo.Source`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the created dataset.

        :rtype: :py:class:`v1_8_1.web.vo.Container`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class RemoteDelphixEngineInfo(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters for logging
    into another Delphix Engine when running a network throughput test.
    """
    def __init__(self, undef_enabled=True):
        super(RemoteDelphixEngineInfo, self).__init__()
        self._type = ("RemoteDelphixEngineInfo", True)
        self._credential = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._principal = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RemoteDelphixEngineInfo, cls).from_dict(data, dirty, undef_enabled)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credential[0], "PasswordCredential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._principal = (data.get("principal", obj.__undef__), dirty)
        if obj._principal[0] is not None and obj._principal[0] is not obj.__undef__:
            assert isinstance(obj._principal[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._principal[0]))
            common.validate_format(obj._principal[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RemoteDelphixEngineInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "principal" == "type" or (self.principal is not self.__undef__ and not (dirty and not self._principal[1])):
            dct["principal"] = dictify(self.principal)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credential = (self._credential[0], True)
        self._address = (self._address[0], True)
        self._principal = (self._principal[0], True)

    def is_dirty(self):
        return any([self._credential[1], self._address[1], self._principal[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RemoteDelphixEngineInfo):
            return False
        return super(RemoteDelphixEngineInfo, self).__eq__(other) and \
               self.credential == other.credential and \
               self.address == other.address and \
               self.principal == other.principal

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credential(self):
        """
        Password for the other Delphix Engine.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def address(self):
        """
        Address of other Delphix Engine.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def principal(self):
        """
        Username for the other Delphix Engine.

        :rtype: ``basestring``
        """
        return self._principal[0]

    @principal.setter
    def principal(self, value):
        self._principal = (value, True)

class DiagnosisResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Details from a
    diagnosis check that was run due to a failed operation.
    """
    def __init__(self, undef_enabled=True):
        super(DiagnosisResult, self).__init__()
        self._type = ("DiagnosisResult", True)
        self._failure = (self.__undef__, True)
        self._message = (self.__undef__, True)
        self._message_code = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DiagnosisResult, cls).from_dict(data, dirty, undef_enabled)
        obj._failure = (data.get("failure", obj.__undef__), dirty)
        if obj._failure[0] is not None and obj._failure[0] is not obj.__undef__:
            assert isinstance(obj._failure[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._failure[0]))
            common.validate_format(obj._failure[0], "None", None, None)
        obj._message = (data.get("message", obj.__undef__), dirty)
        if obj._message[0] is not None and obj._message[0] is not obj.__undef__:
            assert isinstance(obj._message[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message[0]))
            common.validate_format(obj._message[0], "None", None, None)
        obj._message_code = (data.get("messageCode", obj.__undef__), dirty)
        if obj._message_code[0] is not None and obj._message_code[0] is not obj.__undef__:
            assert isinstance(obj._message_code[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message_code[0]))
            common.validate_format(obj._message_code[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DiagnosisResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "failure" == "type" or (self.failure is not self.__undef__ and not (dirty and not self._failure[1])):
            dct["failure"] = dictify(self.failure)
        if "message" == "type" or (self.message is not self.__undef__ and not (dirty and not self._message[1])):
            dct["message"] = dictify(self.message)
        if "message_code" == "type" or (self.message_code is not self.__undef__ and not (dirty and not self._message_code[1])):
            dct["messageCode"] = dictify(self.message_code)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._failure = (self._failure[0], True)
        self._message = (self._message[0], True)
        self._message_code = (self._message_code[0], True)

    def is_dirty(self):
        return any([self._failure[1], self._message[1], self._message_code[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DiagnosisResult):
            return False
        return super(DiagnosisResult, self).__eq__(other) and \
               self.failure == other.failure and \
               self.message == other.message and \
               self.message_code == other.message_code

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def failure(self):
        """
        True if this was a check that did not pass.

        :rtype: ``bool``
        """
        return self._failure[0]

    @failure.setter
    def failure(self, value):
        self._failure = (value, True)

    @property
    def message(self):
        """
        Localized message.

        :rtype: ``basestring``
        """
        return self._message[0]

    @message.setter
    def message(self, value):
        self._message = (value, True)

    @property
    def message_code(self):
        """
        Message code associated with the event.

        :rtype: ``basestring``
        """
        return self._message_code[0]

    @message_code.setter
    def message_code(self, value):
        self._message_code = (value, True)

class DatapointStream(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A stream of datapoints
    from a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DatapointStream, self).__init__()
        self._type = ("DatapointStream", True)
        self._datapoints = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._datapoints = []
        for item in data.get("datapoints") or []:
            obj._datapoints.append(factory.create_object(item))
            factory.validate_type(obj._datapoints[-1], "Datapoint")
        obj._datapoints = (obj._datapoints, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "datapoints" == "type" or (self.datapoints is not self.__undef__ and not (dirty and not self._datapoints[1])):
            dct["datapoints"] = dictify(self.datapoints)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._datapoints = (self._datapoints[0], True)

    def is_dirty(self):
        return any([self._datapoints[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatapointStream):
            return False
        return super(DatapointStream, self).__eq__(other) and \
               self.datapoints == other.datapoints

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def datapoints(self):
        """
        The set of datapoints in the stream.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.Datapoint`
        """
        return self._datapoints[0]

    @datapoints.setter
    def datapoints(self, value):
        self._datapoints = (value, True)

class APISession(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Describes a Delphix
    web service session and is the result of an initial handshake.
    """
    def __init__(self, undef_enabled=True):
        super(APISession, self).__init__()
        self._type = ("APISession", True)
        self._locale = (self.__undef__, True)
        self._client = (self.__undef__, True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(APISession, cls).from_dict(data, dirty, undef_enabled)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            common.validate_format(obj._locale[0], "locale", None, None)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "None", None, 64)
        if "version" not in data:
            raise ValueError("Missing required property \"version\".")
        if "version" in data and data["version"] is not None:
            obj._version = (factory.create_object(data["version"], "APIVersion"), dirty)
            factory.validate_type(obj._version[0], "APIVersion")
        else:
            obj._version = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(APISession, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._locale = (self._locale[0], True)
        self._client = (self._client[0], True)
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._locale[1], self._client[1], self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, APISession):
            return False
        return super(APISession, self).__eq__(other) and \
               self.locale == other.locale and \
               self.client == other.client and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def locale(self):
        """
        Locale as an IETF BCP 47 language tag, defaults to 'en-US'.

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

    @property
    def client(self):
        """
        Client software identification token.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def version(self):
        """
        Version of the API to use.

        :rtype: :py:class:`v1_8_1.web.vo.APIVersion`
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class ConnectorConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Mechanism to test
    Connector connectivity of arbitrary hosts.
    """
    def __init__(self, undef_enabled=True):
        super(ConnectorConnectivity, self).__init__()
        self._type = ("ConnectorConnectivity", True)
        self._username = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._proxy = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ConnectorConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credentials" not in data:
            raise ValueError("Missing required property \"credentials\".")
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        if "address" not in data:
            raise ValueError("Missing required property \"address\".")
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._proxy = (data.get("proxy", obj.__undef__), dirty)
        if obj._proxy[0] is not None and obj._proxy[0] is not obj.__undef__:
            assert isinstance(obj._proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._proxy[0]))
            common.validate_format(obj._proxy[0], "objectReference", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ConnectorConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "proxy" == "type" or (self.proxy is not self.__undef__ and not (dirty and not self._proxy[1])):
            dct["proxy"] = dictify(self.proxy)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credentials = (self._credentials[0], True)
        self._address = (self._address[0], True)
        self._proxy = (self._proxy[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credentials[1], self._address[1], self._proxy[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ConnectorConnectivity):
            return False
        return super(ConnectorConnectivity, self).__eq__(other) and \
               self.username == other.username and \
               self.credentials == other.credentials and \
               self.address == other.address and \
               self.proxy == other.proxy and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        User name.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credentials(self):
        """
        User credentials.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def address(self):
        """
        Target host name or IP address.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def proxy(self):
        """
        Host to use as a proxy for credential validation.

        :rtype: ``basestring``
        """
        return self._proxy[0]

    @proxy.setter
    def proxy(self, value):
        self._proxy = (value, True)

    @property
    def port(self):
        """
        *(default value: 9100)* Connector port on remote server.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class SourceStopParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to stop a MSSQL, PostgreSQL, AppData, ASE or MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceStopParameters, self).__init__()
        self._type = ("SourceStopParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceStopParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceStopParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceStopParameters):
            return False
        return super(SourceStopParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLDBConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Configuration
    information for a PostgreSQL database in a cluster.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBConfig, self).__init__()
        self._type = ("PgSQLDBConfig", True)
        self._database_cluster = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._database_cluster = (data.get("databaseCluster", obj.__undef__), dirty)
        if obj._database_cluster[0] is not None and obj._database_cluster[0] is not obj.__undef__:
            assert isinstance(obj._database_cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_cluster[0]))
            common.validate_format(obj._database_cluster[0], "objectReference", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 63)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_cluster" == "type" or (self.database_cluster is not self.__undef__ and not (dirty and not self._database_cluster[1])):
            dct["databaseCluster"] = dictify(self.database_cluster)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_cluster = (self._database_cluster[0], True)
        self._credentials = (self._credentials[0], True)
        self._user = (self._user[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._database_cluster[1], self._credentials[1], self._user[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBConfig):
            return False
        return super(PgSQLDBConfig, self).__eq__(other) and \
               self.database_cluster == other.database_cluster and \
               self.credentials == other.credentials and \
               self.user == other.user and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_cluster(self):
        """
        The PostgreSQL cluster this database is part of.

        :rtype: ``basestring``
        """
        return self._database_cluster[0]

    @database_cluster.setter
    def database_cluster(self, value):
        self._database_cluster = (value, True)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class ValidateSMTPParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Validate SMTP
    configuration without committing it by sending mail to the specified
    address(es).
    """
    def __init__(self, undef_enabled=True):
        super(ValidateSMTPParameters, self).__init__()
        self._type = ("ValidateSMTPParameters", True)
        self._config = (self.__undef__, True)
        self._addresses = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ValidateSMTPParameters, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        if "config" in data and data["config"] is not None:
            obj._config = (factory.create_object(data["config"], "SMTPConfig"), dirty)
            factory.validate_type(obj._config[0], "SMTPConfig")
        else:
            obj._config = (obj.__undef__, dirty)
        if "addresses" not in data:
            raise ValueError("Missing required property \"addresses\".")
        obj._addresses = []
        for item in data.get("addresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._addresses.append(item)
        obj._addresses = (obj._addresses, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ValidateSMTPParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)
        self._addresses = (self._addresses[0], True)

    def is_dirty(self):
        return any([self._config[1], self._addresses[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ValidateSMTPParameters):
            return False
        return super(ValidateSMTPParameters, self).__eq__(other) and \
               self.config == other.config and \
               self.addresses == other.addresses

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        SMTP configuration to use for validation.

        :rtype: :py:class:`v1_8_1.web.vo.SMTPConfig`
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def addresses(self):
        """
        List of email addresses to send test email to.

        :rtype: ``list`` of ``basestring``
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

class PurgeLogsResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the result
    of a purgeLogs operation.
    """
    def __init__(self, undef_enabled=True):
        super(PurgeLogsResult, self).__init__()
        self._type = ("PurgeLogsResult", True)
        self._truncate_point = (self.__undef__, True)
        self._affected_snapshots = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PurgeLogsResult, cls).from_dict(data, dirty, undef_enabled)
        if "truncatePoint" in data and data["truncatePoint"] is not None:
            obj._truncate_point = (factory.create_object(data["truncatePoint"], "OracleTimeflowPoint"), dirty)
            factory.validate_type(obj._truncate_point[0], "OracleTimeflowPoint")
        else:
            obj._truncate_point = (obj.__undef__, dirty)
        obj._affected_snapshots = []
        for item in data.get("affectedSnapshots") or []:
            obj._affected_snapshots.append(factory.create_object(item))
            factory.validate_type(obj._affected_snapshots[-1], "TimeflowSnapshot")
        obj._affected_snapshots = (obj._affected_snapshots, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PurgeLogsResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "truncate_point" == "type" or (self.truncate_point is not self.__undef__ and not (dirty and not self._truncate_point[1])):
            dct["truncatePoint"] = dictify(self.truncate_point)
        if "affected_snapshots" == "type" or (self.affected_snapshots is not self.__undef__ and not (dirty and not self._affected_snapshots[1])):
            dct["affectedSnapshots"] = dictify(self.affected_snapshots)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._truncate_point = (self._truncate_point[0], True)
        self._affected_snapshots = (self._affected_snapshots[0], True)

    def is_dirty(self):
        return any([self._truncate_point[1], self._affected_snapshots[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PurgeLogsResult):
            return False
        return super(PurgeLogsResult, self).__eq__(other) and \
               self.truncate_point == other.truncate_point and \
               self.affected_snapshots == other.affected_snapshots

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def truncate_point(self):
        """
        TimeFlow point after the last snapshot beyond which TimeFlow will be
        lost as a result of purging logs.

        :rtype: :py:class:`v1_8_1.web.vo.OracleTimeflowPoint`
        """
        return self._truncate_point[0]

    @truncate_point.setter
    def truncate_point(self, value):
        self._truncate_point = (value, True)

    @property
    def affected_snapshots(self):
        """
        List of snapshots which have been rendered unprovisionable because logs
        needed to make them consistent have been deleted.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.TimeflowSnapshot`
        """
        return self._affected_snapshots[0]

    @affected_snapshots.setter
    def affected_snapshots(self, value):
        self._affected_snapshots = (value, True)

class TimeConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Get and set the
    current time configuration.
    """
    def __init__(self, undef_enabled=True):
        super(TimeConfig, self).__init__()
        self._type = ("TimeConfig", True)
        self._ntp_config = (self.__undef__, True)
        self._system_time_zone = (self.__undef__, True)
        self._current_time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeConfig, cls).from_dict(data, dirty, undef_enabled)
        if "ntpConfig" in data and data["ntpConfig"] is not None:
            obj._ntp_config = (factory.create_object(data["ntpConfig"], "NTPConfig"), dirty)
            factory.validate_type(obj._ntp_config[0], "NTPConfig")
        else:
            obj._ntp_config = (obj.__undef__, dirty)
        obj._system_time_zone = (data.get("systemTimeZone", obj.__undef__), dirty)
        if obj._system_time_zone[0] is not None and obj._system_time_zone[0] is not obj.__undef__:
            assert isinstance(obj._system_time_zone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._system_time_zone[0]))
            common.validate_format(obj._system_time_zone[0], "None", None, None)
        obj._current_time = (data.get("currentTime", obj.__undef__), dirty)
        if obj._current_time[0] is not None and obj._current_time[0] is not obj.__undef__:
            assert isinstance(obj._current_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_time[0]))
            common.validate_format(obj._current_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ntp_config" == "type" or (self.ntp_config is not self.__undef__ and not (dirty and not self._ntp_config[1])):
            dct["ntpConfig"] = dictify(self.ntp_config)
        if "system_time_zone" == "type" or (self.system_time_zone is not self.__undef__ and not (dirty and not self._system_time_zone[1])):
            dct["systemTimeZone"] = dictify(self.system_time_zone)
        if "current_time" == "type" or (self.current_time is not self.__undef__ and not (dirty and not self._current_time[1])):
            dct["currentTime"] = dictify(self.current_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ntp_config = (self._ntp_config[0], True)
        self._system_time_zone = (self._system_time_zone[0], True)
        self._current_time = (self._current_time[0], True)

    def is_dirty(self):
        return any([self._ntp_config[1], self._system_time_zone[1], self._current_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeConfig):
            return False
        return super(TimeConfig, self).__eq__(other) and \
               self.ntp_config == other.ntp_config and \
               self.system_time_zone == other.system_time_zone and \
               self.current_time == other.current_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ntp_config(self):
        """
        NTP configuration.

        :rtype: :py:class:`v1_8_1.web.vo.NTPConfig`
        """
        return self._ntp_config[0]

    @ntp_config.setter
    def ntp_config(self, value):
        self._ntp_config = (value, True)

    @property
    def system_time_zone(self):
        """
        *(default value: Etc/UTC)* Default time zone for system wide policies
        and schedules. The management service is automatically restarted if the
        timezone is changed.

        :rtype: ``basestring``
        """
        return self._system_time_zone[0]

    @system_time_zone.setter
    def system_time_zone(self, value):
        self._system_time_zone = (value, True)

    @property
    def current_time(self):
        """
        Current system time. This value can only be set if NTP is disabled. The
        management service is automatically restarted if the time is changed.

        :rtype: ``basestring``
        """
        return self._current_time[0]

    @current_time.setter
    def current_time(self, value):
        self._current_time = (value, True)

class SamlAuthParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameter to use
    as input to determine whether to encode a SAML authentication request.
    """
    def __init__(self, undef_enabled=True):
        super(SamlAuthParameters, self).__init__()
        self._type = ("SamlAuthParameters", True)
        self._encode_request = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SamlAuthParameters, cls).from_dict(data, dirty, undef_enabled)
        if "encodeRequest" not in data:
            raise ValueError("Missing required property \"encodeRequest\".")
        obj._encode_request = (data.get("encodeRequest", obj.__undef__), dirty)
        if obj._encode_request[0] is not None and obj._encode_request[0] is not obj.__undef__:
            assert isinstance(obj._encode_request[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encode_request[0]))
            common.validate_format(obj._encode_request[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SamlAuthParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "encode_request" == "type" or (self.encode_request is not self.__undef__ and not (dirty and not self._encode_request[1])):
            dct["encodeRequest"] = dictify(self.encode_request)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._encode_request = (self._encode_request[0], True)

    def is_dirty(self):
        return any([self._encode_request[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SamlAuthParameters):
            return False
        return super(SamlAuthParameters, self).__eq__(other) and \
               self.encode_request == other.encode_request

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def encode_request(self):
        """
        *(default value: True)* Set to true to encode SAML authentication
        requests.

        :rtype: ``bool``
        """
        return self._encode_request[0]

    @encode_request.setter
    def encode_request(self, value):
        self._encode_request = (value, True)

class DNSConfig(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* DNS Client
    Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(DNSConfig, self).__init__()
        self._type = ("DNSConfig", True)
        self._node = (self.__undef__, True)
        self._domain = (self.__undef__, True)
        self._servers = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DNSConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._node = (data.get("node", obj.__undef__), dirty)
        if obj._node[0] is not None and obj._node[0] is not obj.__undef__:
            assert isinstance(obj._node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._node[0]))
            common.validate_format(obj._node[0], "objectReference", None, None)
        obj._domain = []
        for item in data.get("domain") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._domain.append(item)
        obj._domain = (obj._domain, dirty)
        obj._servers = []
        for item in data.get("servers") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "ipAddress", None, None)
            obj._servers.append(item)
        obj._servers = (obj._servers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DNSConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "node" == "type" or (self.node is not self.__undef__ and not (dirty and not self._node[1])):
            dct["node"] = dictify(self.node)
        if "domain" == "type" or (self.domain is not self.__undef__ and not (dirty and not self._domain[1])):
            dct["domain"] = dictify(self.domain)
        if "servers" == "type" or (self.servers is not self.__undef__ and not (dirty and not self._servers[1])):
            dct["servers"] = dictify(self.servers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._node = (self._node[0], True)
        self._domain = (self._domain[0], True)
        self._servers = (self._servers[0], True)

    def is_dirty(self):
        return any([self._node[1], self._domain[1], self._servers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DNSConfig):
            return False
        return super(DNSConfig, self).__eq__(other) and \
               self.node == other.node and \
               self.domain == other.domain and \
               self.servers == other.servers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def node(self):
        """
        The node on which to configure DNS.

        :rtype: ``basestring``
        """
        return self._node[0]

    @node.setter
    def node(self, value):
        self._node = (value, True)

    @property
    def domain(self):
        """
        One of more DNS domain names.

        :rtype: ``list`` of ``basestring``
        """
        return self._domain[0]

    @domain.setter
    def domain(self, value):
        self._domain = (value, True)

    @property
    def servers(self):
        """
        List of DNS servers.

        :rtype: ``list`` of ``basestring``
        """
        return self._servers[0]

    @servers.setter
    def servers(self, value):
        self._servers = (value, True)

class LinkParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Represents the
    parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(LinkParameters, self).__init__()
        self._type = ("LinkParameters", True)
        self._link_data = (self.__undef__, True)
        self._group = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LinkParameters, cls).from_dict(data, dirty, undef_enabled)
        if "linkData" not in data:
            raise ValueError("Missing required property \"linkData\".")
        if "linkData" in data and data["linkData"] is not None:
            obj._link_data = (factory.create_object(data["linkData"], "LinkData"), dirty)
            factory.validate_type(obj._link_data[0], "LinkData")
        else:
            obj._link_data = (obj.__undef__, dirty)
        if "group" not in data:
            raise ValueError("Missing required property \"group\".")
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "objectName", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LinkParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "link_data" == "type" or (self.link_data is not self.__undef__ and not (dirty and not self._link_data[1])):
            dct["linkData"] = dictify(self.link_data)
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._link_data = (self._link_data[0], True)
        self._group = (self._group[0], True)
        self._description = (self._description[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._link_data[1], self._group[1], self._description[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LinkParameters):
            return False
        return super(LinkParameters, self).__eq__(other) and \
               self.link_data == other.link_data and \
               self.group == other.group and \
               self.description == other.description and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def link_data(self):
        """
        Database specific data required for linking.

        :rtype: :py:class:`v1_8_1.web.vo.LinkData`
        """
        return self._link_data[0]

    @link_data.setter
    def link_data(self, value):
        self._link_data = (value, True)

    @property
    def group(self):
        """
        A reference to the group containing this container.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

    @property
    def description(self):
        """
        Optional user-provided description for the container.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def name(self):
        """
        DSource name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class StorageDeviceRemovalStatus(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The status of a device
    removal of the storage in the system.
    """
    def __init__(self, undef_enabled=True):
        super(StorageDeviceRemovalStatus, self).__init__()
        self._type = ("StorageDeviceRemovalStatus", True)
        self._copied = (self.__undef__, True)
        self._total = (self.__undef__, True)
        self._mapping_memory = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._state = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageDeviceRemovalStatus, cls).from_dict(data, dirty, undef_enabled)
        obj._copied = (data.get("copied", obj.__undef__), dirty)
        if obj._copied[0] is not None and obj._copied[0] is not obj.__undef__:
            assert isinstance(obj._copied[0], float), ("Expected one of [u'number'], but got %s" % type(obj._copied[0]))
            common.validate_format(obj._copied[0], "None", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        obj._mapping_memory = (data.get("mappingMemory", obj.__undef__), dirty)
        if obj._mapping_memory[0] is not None and obj._mapping_memory[0] is not obj.__undef__:
            assert isinstance(obj._mapping_memory[0], float), ("Expected one of [u'number'], but got %s" % type(obj._mapping_memory[0]))
            common.validate_format(obj._mapping_memory[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'], "Expected enum [u'NONE', u'ACTIVE', u'COMPLETED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageDeviceRemovalStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "copied" == "type" or (self.copied is not self.__undef__ and not (dirty and not self._copied[1])):
            dct["copied"] = dictify(self.copied)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        if "mapping_memory" == "type" or (self.mapping_memory is not self.__undef__ and not (dirty and not self._mapping_memory[1])):
            dct["mappingMemory"] = dictify(self.mapping_memory)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._copied = (self._copied[0], True)
        self._total = (self._total[0], True)
        self._mapping_memory = (self._mapping_memory[0], True)
        self._start_time = (self._start_time[0], True)
        self._state = (self._state[0], True)

    def is_dirty(self):
        return any([self._copied[1], self._total[1], self._mapping_memory[1], self._start_time[1], self._state[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageDeviceRemovalStatus):
            return False
        return super(StorageDeviceRemovalStatus, self).__eq__(other) and \
               self.copied == other.copied and \
               self.total == other.total and \
               self.mapping_memory == other.mapping_memory and \
               self.start_time == other.start_time and \
               self.state == other.state

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def copied(self):
        """
        Amount of data removed, in bytes.

        :rtype: ``float``
        """
        return self._copied[0]

    @copied.setter
    def copied(self, value):
        self._copied = (value, True)

    @property
    def total(self):
        """
        Total amount of data to remove (including completed), in bytes.

        :rtype: ``float``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

    @property
    def mapping_memory(self):
        """
        Memory used to account for removed devices, in bytes.

        :rtype: ``float``
        """
        return self._mapping_memory[0]

    @mapping_memory.setter
    def mapping_memory(self, value):
        self._mapping_memory = (value, True)

    @property
    def start_time(self):
        """
        Time removal was started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def state(self):
        """
        Removal state. *(permitted values: NONE, ACTIVE, COMPLETED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

class SourceUpgradeParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to upgrade a source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceUpgradeParameters, self).__init__()
        self._type = ("SourceUpgradeParameters", True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceUpgradeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "SourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "SourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceUpgradeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceUpgradeParameters):
            return False
        return super(SourceUpgradeParameters, self).__eq__(other) and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config that the source database upgrades to.

        :rtype: :py:class:`v1_8_1.web.vo.SourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class TimeflowPoint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* TimeFlow points
    represent a unique point within a TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPoint, self).__init__()
        self._type = ("TimeflowPoint", True)
        self._timestamp = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._timeflow[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPoint):
            return False
        return super(TimeflowPoint, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.timeflow == other.timeflow and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the TimeFlow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def location(self):
        """
        The TimeFlow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

class MySQLVersion(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Version of a MySQL
    installation.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLVersion, self).__init__()
        self._type = ("MySQLVersion", True)
        self._version = (self.__undef__, True)
        self._variant = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLVersion, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "mysqlVersion", None, None)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'CommunityServer', u'MariaDB'], "Expected enum [u'CommunityServer', u'MariaDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLVersion, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)
        self._variant = (self._variant[0], True)

    def is_dirty(self):
        return any([self._version[1], self._variant[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLVersion):
            return False
        return super(MySQLVersion, self).__eq__(other) and \
               self.version == other.version and \
               self.variant == other.variant

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Version of the MySQL installation.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def variant(self):
        """
        Variant of the MySQL installation. *(permitted values: CommunityServer,
        MariaDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

class TimeZone(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* This represents a time
    zone offset.
    """
    def __init__(self, undef_enabled=True):
        super(TimeZone, self).__init__()
        self._type = ("TimeZone", True)
        self._id = (self.__undef__, True)
        self._offset = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeZone, cls).from_dict(data, dirty, undef_enabled)
        if "id" not in data:
            raise ValueError("Missing required property \"id\".")
        obj._id = (data.get("id", obj.__undef__), dirty)
        if obj._id[0] is not None and obj._id[0] is not obj.__undef__:
            assert isinstance(obj._id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._id[0]))
            assert obj._id[0] in [u'ACT', u'AET', u'AGT', u'ART', u'AST', u'Africa/Abidjan', u'Africa/Accra', u'Africa/Addis_Ababa', u'Africa/Algiers', u'Africa/Asmara', u'Africa/Asmera', u'Africa/Bamako', u'Africa/Bangui', u'Africa/Banjul', u'Africa/Bissau', u'Africa/Blantyre', u'Africa/Brazzaville', u'Africa/Bujumbura', u'Africa/Cairo', u'Africa/Casablanca', u'Africa/Ceuta', u'Africa/Conakry', u'Africa/Dakar', u'Africa/Dar_es_Salaam', u'Africa/Djibouti', u'Africa/Douala', u'Africa/El_Aaiun', u'Africa/Freetown', u'Africa/Gaborone', u'Africa/Harare', u'Africa/Johannesburg', u'Africa/Juba', u'Africa/Kampala', u'Africa/Khartoum', u'Africa/Kigali', u'Africa/Kinshasa', u'Africa/Lagos', u'Africa/Libreville', u'Africa/Lome', u'Africa/Luanda', u'Africa/Lubumbashi', u'Africa/Lusaka', u'Africa/Malabo', u'Africa/Maputo', u'Africa/Maseru', u'Africa/Mbabane', u'Africa/Mogadishu', u'Africa/Monrovia', u'Africa/Nairobi', u'Africa/Ndjamena', u'Africa/Niamey', u'Africa/Nouakchott', u'Africa/Ouagadougou', u'Africa/Porto-Novo', u'Africa/Sao_Tome', u'Africa/Timbuktu', u'Africa/Tripoli', u'Africa/Tunis', u'Africa/Windhoek', u'America/Adak', u'America/Anchorage', u'America/Anguilla', u'America/Antigua', u'America/Araguaina', u'America/Argentina/Buenos_Aires', u'America/Argentina/Catamarca', u'America/Argentina/ComodRivadavia', u'America/Argentina/Cordoba', u'America/Argentina/Jujuy', u'America/Argentina/La_Rioja', u'America/Argentina/Mendoza', u'America/Argentina/Rio_Gallegos', u'America/Argentina/Salta', u'America/Argentina/San_Juan', u'America/Argentina/San_Luis', u'America/Argentina/Tucuman', u'America/Argentina/Ushuaia', u'America/Aruba', u'America/Asuncion', u'America/Atikokan', u'America/Atka', u'America/Bahia', u'America/Bahia_Banderas', u'America/Barbados', u'America/Belem', u'America/Belize', u'America/Blanc-Sablon', u'America/Boa_Vista', u'America/Bogota', u'America/Boise', u'America/Buenos_Aires', u'America/Cambridge_Bay', u'America/Campo_Grande', u'America/Cancun', u'America/Caracas', u'America/Catamarca', u'America/Cayenne', u'America/Cayman', u'America/Chicago', u'America/Chihuahua', u'America/Coral_Harbour', u'America/Cordoba', u'America/Costa_Rica', u'America/Creston', u'America/Cuiaba', u'America/Curacao', u'America/Danmarkshavn', u'America/Dawson', u'America/Dawson_Creek', u'America/Denver', u'America/Detroit', u'America/Dominica', u'America/Edmonton', u'America/Eirunepe', u'America/El_Salvador', u'America/Ensenada', u'America/Fort_Wayne', u'America/Fortaleza', u'America/Glace_Bay', u'America/Godthab', u'America/Goose_Bay', u'America/Grand_Turk', u'America/Grenada', u'America/Guadeloupe', u'America/Guatemala', u'America/Guayaquil', u'America/Guyana', u'America/Halifax', u'America/Havana', u'America/Hermosillo', u'America/Indiana/Indianapolis', u'America/Indiana/Knox', u'America/Indiana/Marengo', u'America/Indiana/Petersburg', u'America/Indiana/Tell_City', u'America/Indiana/Vevay', u'America/Indiana/Vincennes', u'America/Indiana/Winamac', u'America/Indianapolis', u'America/Inuvik', u'America/Iqaluit', u'America/Jamaica', u'America/Jujuy', u'America/Juneau', u'America/Kentucky/Louisville', u'America/Kentucky/Monticello', u'America/Knox_IN', u'America/Kralendijk', u'America/La_Paz', u'America/Lima', u'America/Los_Angeles', u'America/Louisville', u'America/Lower_Princes', u'America/Maceio', u'America/Managua', u'America/Manaus', u'America/Marigot', u'America/Martinique', u'America/Matamoros', u'America/Mazatlan', u'America/Mendoza', u'America/Menominee', u'America/Merida', u'America/Metlakatla', u'America/Mexico_City', u'America/Miquelon', u'America/Moncton', u'America/Monterrey', u'America/Montevideo', u'America/Montreal', u'America/Montserrat', u'America/Nassau', u'America/New_York', u'America/Nipigon', u'America/Nome', u'America/Noronha', u'America/North_Dakota/Beulah', u'America/North_Dakota/Center', u'America/North_Dakota/New_Salem', u'America/Ojinaga', u'America/Panama', u'America/Pangnirtung', u'America/Paramaribo', u'America/Phoenix', u'America/Port-au-Prince', u'America/Port_of_Spain', u'America/Porto_Acre', u'America/Porto_Velho', u'America/Puerto_Rico', u'America/Rainy_River', u'America/Rankin_Inlet', u'America/Recife', u'America/Regina', u'America/Resolute', u'America/Rio_Branco', u'America/Rosario', u'America/Santa_Isabel', u'America/Santarem', u'America/Santiago', u'America/Santo_Domingo', u'America/Sao_Paulo', u'America/Scoresbysund', u'America/Shiprock', u'America/Sitka', u'America/St_Barthelemy', u'America/St_Johns', u'America/St_Kitts', u'America/St_Lucia', u'America/St_Thomas', u'America/St_Vincent', u'America/Swift_Current', u'America/Tegucigalpa', u'America/Thule', u'America/Thunder_Bay', u'America/Tijuana', u'America/Toronto', u'America/Tortola', u'America/Vancouver', u'America/Virgin', u'America/Whitehorse', u'America/Winnipeg', u'America/Yakutat', u'America/Yellowknife', u'Antarctica/Casey', u'Antarctica/Davis', u'Antarctica/DumontDUrville', u'Antarctica/Macquarie', u'Antarctica/Mawson', u'Antarctica/McMurdo', u'Antarctica/Palmer', u'Antarctica/Rothera', u'Antarctica/South_Pole', u'Antarctica/Syowa', u'Antarctica/Troll', u'Antarctica/Vostok', u'Arctic/Longyearbyen', u'Asia/Aden', u'Asia/Almaty', u'Asia/Amman', u'Asia/Anadyr', u'Asia/Aqtau', u'Asia/Aqtobe', u'Asia/Ashgabat', u'Asia/Ashkhabad', u'Asia/Baghdad', u'Asia/Bahrain', u'Asia/Baku', u'Asia/Bangkok', u'Asia/Beirut', u'Asia/Bishkek', u'Asia/Brunei', u'Asia/Calcutta', u'Asia/Chita', u'Asia/Choibalsan', u'Asia/Chongqing', u'Asia/Chungking', u'Asia/Colombo', u'Asia/Dacca', u'Asia/Damascus', u'Asia/Dhaka', u'Asia/Dili', u'Asia/Dubai', u'Asia/Dushanbe', u'Asia/Gaza', u'Asia/Harbin', u'Asia/Hebron', u'Asia/Ho_Chi_Minh', u'Asia/Hong_Kong', u'Asia/Hovd', u'Asia/Irkutsk', u'Asia/Istanbul', u'Asia/Jakarta', u'Asia/Jayapura', u'Asia/Jerusalem', u'Asia/Kabul', u'Asia/Kamchatka', u'Asia/Karachi', u'Asia/Kashgar', u'Asia/Kathmandu', u'Asia/Katmandu', u'Asia/Khandyga', u'Asia/Kolkata', u'Asia/Krasnoyarsk', u'Asia/Kuala_Lumpur', u'Asia/Kuching', u'Asia/Kuwait', u'Asia/Macao', u'Asia/Macau', u'Asia/Magadan', u'Asia/Makassar', u'Asia/Manila', u'Asia/Muscat', u'Asia/Nicosia', u'Asia/Novokuznetsk', u'Asia/Novosibirsk', u'Asia/Omsk', u'Asia/Oral', u'Asia/Phnom_Penh', u'Asia/Pontianak', u'Asia/Pyongyang', u'Asia/Qatar', u'Asia/Qyzylorda', u'Asia/Rangoon', u'Asia/Riyadh', u'Asia/Saigon', u'Asia/Sakhalin', u'Asia/Samarkand', u'Asia/Seoul', u'Asia/Shanghai', u'Asia/Singapore', u'Asia/Srednekolymsk', u'Asia/Taipei', u'Asia/Tashkent', u'Asia/Tbilisi', u'Asia/Tehran', u'Asia/Tel_Aviv', u'Asia/Thimbu', u'Asia/Thimphu', u'Asia/Tokyo', u'Asia/Ujung_Pandang', u'Asia/Ulaanbaatar', u'Asia/Ulan_Bator', u'Asia/Urumqi', u'Asia/Ust-Nera', u'Asia/Vientiane', u'Asia/Vladivostok', u'Asia/Yakutsk', u'Asia/Yekaterinburg', u'Asia/Yerevan', u'Atlantic/Azores', u'Atlantic/Bermuda', u'Atlantic/Canary', u'Atlantic/Cape_Verde', u'Atlantic/Faeroe', u'Atlantic/Faroe', u'Atlantic/Jan_Mayen', u'Atlantic/Madeira', u'Atlantic/Reykjavik', u'Atlantic/South_Georgia', u'Atlantic/St_Helena', u'Atlantic/Stanley', u'Australia/ACT', u'Australia/Adelaide', u'Australia/Brisbane', u'Australia/Broken_Hill', u'Australia/Canberra', u'Australia/Currie', u'Australia/Darwin', u'Australia/Eucla', u'Australia/Hobart', u'Australia/LHI', u'Australia/Lindeman', u'Australia/Lord_Howe', u'Australia/Melbourne', u'Australia/NSW', u'Australia/North', u'Australia/Perth', u'Australia/Queensland', u'Australia/South', u'Australia/Sydney', u'Australia/Tasmania', u'Australia/Victoria', u'Australia/West', u'Australia/Yancowinna', u'BET', u'BST', u'Brazil/Acre', u'Brazil/DeNoronha', u'Brazil/East', u'Brazil/West', u'CAT', u'CET', u'CNT', u'CST', u'CST6CDT', u'CTT', u'Canada/Atlantic', u'Canada/Central', u'Canada/East-Saskatchewan', u'Canada/Eastern', u'Canada/Mountain', u'Canada/Newfoundland', u'Canada/Pacific', u'Canada/Saskatchewan', u'Canada/Yukon', u'Chile/Continental', u'Chile/EasterIsland', u'Cuba', u'EAT', u'ECT', u'EET', u'EST', u'EST5EDT', u'Egypt', u'Eire', u'Etc/GMT', u'Etc/GMT+0', u'Etc/GMT+1', u'Etc/GMT+10', u'Etc/GMT+11', u'Etc/GMT+12', u'Etc/GMT+2', u'Etc/GMT+3', u'Etc/GMT+4', u'Etc/GMT+5', u'Etc/GMT+6', u'Etc/GMT+7', u'Etc/GMT+8', u'Etc/GMT+9', u'Etc/GMT-0', u'Etc/GMT-1', u'Etc/GMT-10', u'Etc/GMT-11', u'Etc/GMT-12', u'Etc/GMT-13', u'Etc/GMT-14', u'Etc/GMT-2', u'Etc/GMT-3', u'Etc/GMT-4', u'Etc/GMT-5', u'Etc/GMT-6', u'Etc/GMT-7', u'Etc/GMT-8', u'Etc/GMT-9', u'Etc/GMT0', u'Etc/Greenwich', u'Etc/UCT', u'Etc/UTC', u'Etc/Universal', u'Etc/Zulu', u'Europe/Amsterdam', u'Europe/Andorra', u'Europe/Athens', u'Europe/Belfast', u'Europe/Belgrade', u'Europe/Berlin', u'Europe/Bratislava', u'Europe/Brussels', u'Europe/Bucharest', u'Europe/Budapest', u'Europe/Busingen', u'Europe/Chisinau', u'Europe/Copenhagen', u'Europe/Dublin', u'Europe/Gibraltar', u'Europe/Guernsey', u'Europe/Helsinki', u'Europe/Isle_of_Man', u'Europe/Istanbul', u'Europe/Jersey', u'Europe/Kaliningrad', u'Europe/Kiev', u'Europe/Lisbon', u'Europe/Ljubljana', u'Europe/London', u'Europe/Luxembourg', u'Europe/Madrid', u'Europe/Malta', u'Europe/Mariehamn', u'Europe/Minsk', u'Europe/Monaco', u'Europe/Moscow', u'Europe/Nicosia', u'Europe/Oslo', u'Europe/Paris', u'Europe/Podgorica', u'Europe/Prague', u'Europe/Riga', u'Europe/Rome', u'Europe/Samara', u'Europe/San_Marino', u'Europe/Sarajevo', u'Europe/Simferopol', u'Europe/Skopje', u'Europe/Sofia', u'Europe/Stockholm', u'Europe/Tallinn', u'Europe/Tirane', u'Europe/Tiraspol', u'Europe/Uzhgorod', u'Europe/Vaduz', u'Europe/Vatican', u'Europe/Vienna', u'Europe/Vilnius', u'Europe/Volgograd', u'Europe/Warsaw', u'Europe/Zagreb', u'Europe/Zaporozhye', u'Europe/Zurich', u'GB', u'GB-Eire', u'GMT', u'GMT0', u'Greenwich', u'HST', u'Hongkong', u'IET', u'IST', u'Iceland', u'Indian/Antananarivo', u'Indian/Chagos', u'Indian/Christmas', u'Indian/Cocos', u'Indian/Comoro', u'Indian/Kerguelen', u'Indian/Mahe', u'Indian/Maldives', u'Indian/Mauritius', u'Indian/Mayotte', u'Indian/Reunion', u'Iran', u'Israel', u'JST', u'Jamaica', u'Japan', u'Kwajalein', u'Libya', u'MET', u'MIT', u'MST', u'MST7MDT', u'Mexico/BajaNorte', u'Mexico/BajaSur', u'Mexico/General', u'NET', u'NST', u'NZ', u'NZ-CHAT', u'Navajo', u'PLT', u'PNT', u'PRC', u'PRT', u'PST', u'PST8PDT', u'Pacific/Apia', u'Pacific/Auckland', u'Pacific/Bougainville', u'Pacific/Chatham', u'Pacific/Chuuk', u'Pacific/Easter', u'Pacific/Efate', u'Pacific/Enderbury', u'Pacific/Fakaofo', u'Pacific/Fiji', u'Pacific/Funafuti', u'Pacific/Galapagos', u'Pacific/Gambier', u'Pacific/Guadalcanal', u'Pacific/Guam', u'Pacific/Honolulu', u'Pacific/Johnston', u'Pacific/Kiritimati', u'Pacific/Kosrae', u'Pacific/Kwajalein', u'Pacific/Majuro', u'Pacific/Marquesas', u'Pacific/Midway', u'Pacific/Nauru', u'Pacific/Niue', u'Pacific/Norfolk', u'Pacific/Noumea', u'Pacific/Pago_Pago', u'Pacific/Palau', u'Pacific/Pitcairn', u'Pacific/Pohnpei', u'Pacific/Ponape', u'Pacific/Port_Moresby', u'Pacific/Rarotonga', u'Pacific/Saipan', u'Pacific/Samoa', u'Pacific/Tahiti', u'Pacific/Tarawa', u'Pacific/Tongatapu', u'Pacific/Truk', u'Pacific/Wake', u'Pacific/Wallis', u'Pacific/Yap', u'Poland', u'Portugal', u'ROK', u'SST', u'Singapore', u'SystemV/AST4', u'SystemV/AST4ADT', u'SystemV/CST6', u'SystemV/CST6CDT', u'SystemV/EST5', u'SystemV/EST5EDT', u'SystemV/HST10', u'SystemV/MST7', u'SystemV/MST7MDT', u'SystemV/PST8', u'SystemV/PST8PDT', u'SystemV/YST9', u'SystemV/YST9YDT', u'Turkey', u'UCT', u'US/Alaska', u'US/Aleutian', u'US/Arizona', u'US/Central', u'US/East-Indiana', u'US/Eastern', u'US/Hawaii', u'US/Indiana-Starke', u'US/Michigan', u'US/Mountain', u'US/Pacific', u'US/Pacific-New', u'US/Samoa', u'UTC', u'Universal', u'VST', u'W-SU', u'WET', u'Zulu'], "Expected enum [u'ACT', u'AET', u'AGT', u'ART', u'AST', u'Africa/Abidjan', u'Africa/Accra', u'Africa/Addis_Ababa', u'Africa/Algiers', u'Africa/Asmara', u'Africa/Asmera', u'Africa/Bamako', u'Africa/Bangui', u'Africa/Banjul', u'Africa/Bissau', u'Africa/Blantyre', u'Africa/Brazzaville', u'Africa/Bujumbura', u'Africa/Cairo', u'Africa/Casablanca', u'Africa/Ceuta', u'Africa/Conakry', u'Africa/Dakar', u'Africa/Dar_es_Salaam', u'Africa/Djibouti', u'Africa/Douala', u'Africa/El_Aaiun', u'Africa/Freetown', u'Africa/Gaborone', u'Africa/Harare', u'Africa/Johannesburg', u'Africa/Juba', u'Africa/Kampala', u'Africa/Khartoum', u'Africa/Kigali', u'Africa/Kinshasa', u'Africa/Lagos', u'Africa/Libreville', u'Africa/Lome', u'Africa/Luanda', u'Africa/Lubumbashi', u'Africa/Lusaka', u'Africa/Malabo', u'Africa/Maputo', u'Africa/Maseru', u'Africa/Mbabane', u'Africa/Mogadishu', u'Africa/Monrovia', u'Africa/Nairobi', u'Africa/Ndjamena', u'Africa/Niamey', u'Africa/Nouakchott', u'Africa/Ouagadougou', u'Africa/Porto-Novo', u'Africa/Sao_Tome', u'Africa/Timbuktu', u'Africa/Tripoli', u'Africa/Tunis', u'Africa/Windhoek', u'America/Adak', u'America/Anchorage', u'America/Anguilla', u'America/Antigua', u'America/Araguaina', u'America/Argentina/Buenos_Aires', u'America/Argentina/Catamarca', u'America/Argentina/ComodRivadavia', u'America/Argentina/Cordoba', u'America/Argentina/Jujuy', u'America/Argentina/La_Rioja', u'America/Argentina/Mendoza', u'America/Argentina/Rio_Gallegos', u'America/Argentina/Salta', u'America/Argentina/San_Juan', u'America/Argentina/San_Luis', u'America/Argentina/Tucuman', u'America/Argentina/Ushuaia', u'America/Aruba', u'America/Asuncion', u'America/Atikokan', u'America/Atka', u'America/Bahia', u'America/Bahia_Banderas', u'America/Barbados', u'America/Belem', u'America/Belize', u'America/Blanc-Sablon', u'America/Boa_Vista', u'America/Bogota', u'America/Boise', u'America/Buenos_Aires', u'America/Cambridge_Bay', u'America/Campo_Grande', u'America/Cancun', u'America/Caracas', u'America/Catamarca', u'America/Cayenne', u'America/Cayman', u'America/Chicago', u'America/Chihuahua', u'America/Coral_Harbour', u'America/Cordoba', u'America/Costa_Rica', u'America/Creston', u'America/Cuiaba', u'America/Curacao', u'America/Danmarkshavn', u'America/Dawson', u'America/Dawson_Creek', u'America/Denver', u'America/Detroit', u'America/Dominica', u'America/Edmonton', u'America/Eirunepe', u'America/El_Salvador', u'America/Ensenada', u'America/Fort_Wayne', u'America/Fortaleza', u'America/Glace_Bay', u'America/Godthab', u'America/Goose_Bay', u'America/Grand_Turk', u'America/Grenada', u'America/Guadeloupe', u'America/Guatemala', u'America/Guayaquil', u'America/Guyana', u'America/Halifax', u'America/Havana', u'America/Hermosillo', u'America/Indiana/Indianapolis', u'America/Indiana/Knox', u'America/Indiana/Marengo', u'America/Indiana/Petersburg', u'America/Indiana/Tell_City', u'America/Indiana/Vevay', u'America/Indiana/Vincennes', u'America/Indiana/Winamac', u'America/Indianapolis', u'America/Inuvik', u'America/Iqaluit', u'America/Jamaica', u'America/Jujuy', u'America/Juneau', u'America/Kentucky/Louisville', u'America/Kentucky/Monticello', u'America/Knox_IN', u'America/Kralendijk', u'America/La_Paz', u'America/Lima', u'America/Los_Angeles', u'America/Louisville', u'America/Lower_Princes', u'America/Maceio', u'America/Managua', u'America/Manaus', u'America/Marigot', u'America/Martinique', u'America/Matamoros', u'America/Mazatlan', u'America/Mendoza', u'America/Menominee', u'America/Merida', u'America/Metlakatla', u'America/Mexico_City', u'America/Miquelon', u'America/Moncton', u'America/Monterrey', u'America/Montevideo', u'America/Montreal', u'America/Montserrat', u'America/Nassau', u'America/New_York', u'America/Nipigon', u'America/Nome', u'America/Noronha', u'America/North_Dakota/Beulah', u'America/North_Dakota/Center', u'America/North_Dakota/New_Salem', u'America/Ojinaga', u'America/Panama', u'America/Pangnirtung', u'America/Paramaribo', u'America/Phoenix', u'America/Port-au-Prince', u'America/Port_of_Spain', u'America/Porto_Acre', u'America/Porto_Velho', u'America/Puerto_Rico', u'America/Rainy_River', u'America/Rankin_Inlet', u'America/Recife', u'America/Regina', u'America/Resolute', u'America/Rio_Branco', u'America/Rosario', u'America/Santa_Isabel', u'America/Santarem', u'America/Santiago', u'America/Santo_Domingo', u'America/Sao_Paulo', u'America/Scoresbysund', u'America/Shiprock', u'America/Sitka', u'America/St_Barthelemy', u'America/St_Johns', u'America/St_Kitts', u'America/St_Lucia', u'America/St_Thomas', u'America/St_Vincent', u'America/Swift_Current', u'America/Tegucigalpa', u'America/Thule', u'America/Thunder_Bay', u'America/Tijuana', u'America/Toronto', u'America/Tortola', u'America/Vancouver', u'America/Virgin', u'America/Whitehorse', u'America/Winnipeg', u'America/Yakutat', u'America/Yellowknife', u'Antarctica/Casey', u'Antarctica/Davis', u'Antarctica/DumontDUrville', u'Antarctica/Macquarie', u'Antarctica/Mawson', u'Antarctica/McMurdo', u'Antarctica/Palmer', u'Antarctica/Rothera', u'Antarctica/South_Pole', u'Antarctica/Syowa', u'Antarctica/Troll', u'Antarctica/Vostok', u'Arctic/Longyearbyen', u'Asia/Aden', u'Asia/Almaty', u'Asia/Amman', u'Asia/Anadyr', u'Asia/Aqtau', u'Asia/Aqtobe', u'Asia/Ashgabat', u'Asia/Ashkhabad', u'Asia/Baghdad', u'Asia/Bahrain', u'Asia/Baku', u'Asia/Bangkok', u'Asia/Beirut', u'Asia/Bishkek', u'Asia/Brunei', u'Asia/Calcutta', u'Asia/Chita', u'Asia/Choibalsan', u'Asia/Chongqing', u'Asia/Chungking', u'Asia/Colombo', u'Asia/Dacca', u'Asia/Damascus', u'Asia/Dhaka', u'Asia/Dili', u'Asia/Dubai', u'Asia/Dushanbe', u'Asia/Gaza', u'Asia/Harbin', u'Asia/Hebron', u'Asia/Ho_Chi_Minh', u'Asia/Hong_Kong', u'Asia/Hovd', u'Asia/Irkutsk', u'Asia/Istanbul', u'Asia/Jakarta', u'Asia/Jayapura', u'Asia/Jerusalem', u'Asia/Kabul', u'Asia/Kamchatka', u'Asia/Karachi', u'Asia/Kashgar', u'Asia/Kathmandu', u'Asia/Katmandu', u'Asia/Khandyga', u'Asia/Kolkata', u'Asia/Krasnoyarsk', u'Asia/Kuala_Lumpur', u'Asia/Kuching', u'Asia/Kuwait', u'Asia/Macao', u'Asia/Macau', u'Asia/Magadan', u'Asia/Makassar', u'Asia/Manila', u'Asia/Muscat', u'Asia/Nicosia', u'Asia/Novokuznetsk', u'Asia/Novosibirsk', u'Asia/Omsk', u'Asia/Oral', u'Asia/Phnom_Penh', u'Asia/Pontianak', u'Asia/Pyongyang', u'Asia/Qatar', u'Asia/Qyzylorda', u'Asia/Rangoon', u'Asia/Riyadh', u'Asia/Saigon', u'Asia/Sakhalin', u'Asia/Samarkand', u'Asia/Seoul', u'Asia/Shanghai', u'Asia/Singapore', u'Asia/Srednekolymsk', u'Asia/Taipei', u'Asia/Tashkent', u'Asia/Tbilisi', u'Asia/Tehran', u'Asia/Tel_Aviv', u'Asia/Thimbu', u'Asia/Thimphu', u'Asia/Tokyo', u'Asia/Ujung_Pandang', u'Asia/Ulaanbaatar', u'Asia/Ulan_Bator', u'Asia/Urumqi', u'Asia/Ust-Nera', u'Asia/Vientiane', u'Asia/Vladivostok', u'Asia/Yakutsk', u'Asia/Yekaterinburg', u'Asia/Yerevan', u'Atlantic/Azores', u'Atlantic/Bermuda', u'Atlantic/Canary', u'Atlantic/Cape_Verde', u'Atlantic/Faeroe', u'Atlantic/Faroe', u'Atlantic/Jan_Mayen', u'Atlantic/Madeira', u'Atlantic/Reykjavik', u'Atlantic/South_Georgia', u'Atlantic/St_Helena', u'Atlantic/Stanley', u'Australia/ACT', u'Australia/Adelaide', u'Australia/Brisbane', u'Australia/Broken_Hill', u'Australia/Canberra', u'Australia/Currie', u'Australia/Darwin', u'Australia/Eucla', u'Australia/Hobart', u'Australia/LHI', u'Australia/Lindeman', u'Australia/Lord_Howe', u'Australia/Melbourne', u'Australia/NSW', u'Australia/North', u'Australia/Perth', u'Australia/Queensland', u'Australia/South', u'Australia/Sydney', u'Australia/Tasmania', u'Australia/Victoria', u'Australia/West', u'Australia/Yancowinna', u'BET', u'BST', u'Brazil/Acre', u'Brazil/DeNoronha', u'Brazil/East', u'Brazil/West', u'CAT', u'CET', u'CNT', u'CST', u'CST6CDT', u'CTT', u'Canada/Atlantic', u'Canada/Central', u'Canada/East-Saskatchewan', u'Canada/Eastern', u'Canada/Mountain', u'Canada/Newfoundland', u'Canada/Pacific', u'Canada/Saskatchewan', u'Canada/Yukon', u'Chile/Continental', u'Chile/EasterIsland', u'Cuba', u'EAT', u'ECT', u'EET', u'EST', u'EST5EDT', u'Egypt', u'Eire', u'Etc/GMT', u'Etc/GMT+0', u'Etc/GMT+1', u'Etc/GMT+10', u'Etc/GMT+11', u'Etc/GMT+12', u'Etc/GMT+2', u'Etc/GMT+3', u'Etc/GMT+4', u'Etc/GMT+5', u'Etc/GMT+6', u'Etc/GMT+7', u'Etc/GMT+8', u'Etc/GMT+9', u'Etc/GMT-0', u'Etc/GMT-1', u'Etc/GMT-10', u'Etc/GMT-11', u'Etc/GMT-12', u'Etc/GMT-13', u'Etc/GMT-14', u'Etc/GMT-2', u'Etc/GMT-3', u'Etc/GMT-4', u'Etc/GMT-5', u'Etc/GMT-6', u'Etc/GMT-7', u'Etc/GMT-8', u'Etc/GMT-9', u'Etc/GMT0', u'Etc/Greenwich', u'Etc/UCT', u'Etc/UTC', u'Etc/Universal', u'Etc/Zulu', u'Europe/Amsterdam', u'Europe/Andorra', u'Europe/Athens', u'Europe/Belfast', u'Europe/Belgrade', u'Europe/Berlin', u'Europe/Bratislava', u'Europe/Brussels', u'Europe/Bucharest', u'Europe/Budapest', u'Europe/Busingen', u'Europe/Chisinau', u'Europe/Copenhagen', u'Europe/Dublin', u'Europe/Gibraltar', u'Europe/Guernsey', u'Europe/Helsinki', u'Europe/Isle_of_Man', u'Europe/Istanbul', u'Europe/Jersey', u'Europe/Kaliningrad', u'Europe/Kiev', u'Europe/Lisbon', u'Europe/Ljubljana', u'Europe/London', u'Europe/Luxembourg', u'Europe/Madrid', u'Europe/Malta', u'Europe/Mariehamn', u'Europe/Minsk', u'Europe/Monaco', u'Europe/Moscow', u'Europe/Nicosia', u'Europe/Oslo', u'Europe/Paris', u'Europe/Podgorica', u'Europe/Prague', u'Europe/Riga', u'Europe/Rome', u'Europe/Samara', u'Europe/San_Marino', u'Europe/Sarajevo', u'Europe/Simferopol', u'Europe/Skopje', u'Europe/Sofia', u'Europe/Stockholm', u'Europe/Tallinn', u'Europe/Tirane', u'Europe/Tiraspol', u'Europe/Uzhgorod', u'Europe/Vaduz', u'Europe/Vatican', u'Europe/Vienna', u'Europe/Vilnius', u'Europe/Volgograd', u'Europe/Warsaw', u'Europe/Zagreb', u'Europe/Zaporozhye', u'Europe/Zurich', u'GB', u'GB-Eire', u'GMT', u'GMT0', u'Greenwich', u'HST', u'Hongkong', u'IET', u'IST', u'Iceland', u'Indian/Antananarivo', u'Indian/Chagos', u'Indian/Christmas', u'Indian/Cocos', u'Indian/Comoro', u'Indian/Kerguelen', u'Indian/Mahe', u'Indian/Maldives', u'Indian/Mauritius', u'Indian/Mayotte', u'Indian/Reunion', u'Iran', u'Israel', u'JST', u'Jamaica', u'Japan', u'Kwajalein', u'Libya', u'MET', u'MIT', u'MST', u'MST7MDT', u'Mexico/BajaNorte', u'Mexico/BajaSur', u'Mexico/General', u'NET', u'NST', u'NZ', u'NZ-CHAT', u'Navajo', u'PLT', u'PNT', u'PRC', u'PRT', u'PST', u'PST8PDT', u'Pacific/Apia', u'Pacific/Auckland', u'Pacific/Bougainville', u'Pacific/Chatham', u'Pacific/Chuuk', u'Pacific/Easter', u'Pacific/Efate', u'Pacific/Enderbury', u'Pacific/Fakaofo', u'Pacific/Fiji', u'Pacific/Funafuti', u'Pacific/Galapagos', u'Pacific/Gambier', u'Pacific/Guadalcanal', u'Pacific/Guam', u'Pacific/Honolulu', u'Pacific/Johnston', u'Pacific/Kiritimati', u'Pacific/Kosrae', u'Pacific/Kwajalein', u'Pacific/Majuro', u'Pacific/Marquesas', u'Pacific/Midway', u'Pacific/Nauru', u'Pacific/Niue', u'Pacific/Norfolk', u'Pacific/Noumea', u'Pacific/Pago_Pago', u'Pacific/Palau', u'Pacific/Pitcairn', u'Pacific/Pohnpei', u'Pacific/Ponape', u'Pacific/Port_Moresby', u'Pacific/Rarotonga', u'Pacific/Saipan', u'Pacific/Samoa', u'Pacific/Tahiti', u'Pacific/Tarawa', u'Pacific/Tongatapu', u'Pacific/Truk', u'Pacific/Wake', u'Pacific/Wallis', u'Pacific/Yap', u'Poland', u'Portugal', u'ROK', u'SST', u'Singapore', u'SystemV/AST4', u'SystemV/AST4ADT', u'SystemV/CST6', u'SystemV/CST6CDT', u'SystemV/EST5', u'SystemV/EST5EDT', u'SystemV/HST10', u'SystemV/MST7', u'SystemV/MST7MDT', u'SystemV/PST8', u'SystemV/PST8PDT', u'SystemV/YST9', u'SystemV/YST9YDT', u'Turkey', u'UCT', u'US/Alaska', u'US/Aleutian', u'US/Arizona', u'US/Central', u'US/East-Indiana', u'US/Eastern', u'US/Hawaii', u'US/Indiana-Starke', u'US/Michigan', u'US/Mountain', u'US/Pacific', u'US/Pacific-New', u'US/Samoa', u'UTC', u'Universal', u'VST', u'W-SU', u'WET', u'Zulu'] but got %s" % obj._id[0]
            common.validate_format(obj._id[0], "None", None, None)
        obj._offset = (data.get("offset", obj.__undef__), dirty)
        if obj._offset[0] is not None and obj._offset[0] is not obj.__undef__:
            assert isinstance(obj._offset[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._offset[0]))
            common.validate_format(obj._offset[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeZone, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "id" == "type" or (self.id is not self.__undef__ and not (dirty and not self._id[1])):
            dct["id"] = dictify(self.id)
        if "offset" == "type" or (self.offset is not self.__undef__ and not (dirty and not self._offset[1])):
            dct["offset"] = dictify(self.offset)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._id = (self._id[0], True)
        self._offset = (self._offset[0], True)

    def is_dirty(self):
        return any([self._id[1], self._offset[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeZone):
            return False
        return super(TimeZone, self).__eq__(other) and \
               self.id == other.id and \
               self.offset == other.offset

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def id(self):
        """
        The ID of this time zone. *(permitted values: ACT, AET, AGT, ART, AST,
        Africa/Abidjan, Africa/Accra, Africa/Addis_Ababa, Africa/Algiers,
        Africa/Asmara, Africa/Asmera, Africa/Bamako, Africa/Bangui,
        Africa/Banjul, Africa/Bissau, Africa/Blantyre, Africa/Brazzaville,
        Africa/Bujumbura, Africa/Cairo, Africa/Casablanca, Africa/Ceuta,
        Africa/Conakry, Africa/Dakar, Africa/Dar_es_Salaam, Africa/Djibouti,
        Africa/Douala, Africa/El_Aaiun, Africa/Freetown, Africa/Gaborone,
        Africa/Harare, Africa/Johannesburg, Africa/Juba, Africa/Kampala,
        Africa/Khartoum, Africa/Kigali, Africa/Kinshasa, Africa/Lagos,
        Africa/Libreville, Africa/Lome, Africa/Luanda, Africa/Lubumbashi,
        Africa/Lusaka, Africa/Malabo, Africa/Maputo, Africa/Maseru,
        Africa/Mbabane, Africa/Mogadishu, Africa/Monrovia, Africa/Nairobi,
        Africa/Ndjamena, Africa/Niamey, Africa/Nouakchott, Africa/Ouagadougou,
        Africa/Porto-Novo, Africa/Sao_Tome, Africa/Timbuktu, Africa/Tripoli,
        Africa/Tunis, Africa/Windhoek, America/Adak, America/Anchorage,
        America/Anguilla, America/Antigua, America/Araguaina,
        America/Argentina/Buenos_Aires, America/Argentina/Catamarca,
        America/Argentina/ComodRivadavia, America/Argentina/Cordoba,
        America/Argentina/Jujuy, America/Argentina/La_Rioja,
        America/Argentina/Mendoza, America/Argentina/Rio_Gallegos,
        America/Argentina/Salta, America/Argentina/San_Juan,
        America/Argentina/San_Luis, America/Argentina/Tucuman,
        America/Argentina/Ushuaia, America/Aruba, America/Asuncion,
        America/Atikokan, America/Atka, America/Bahia, America/Bahia_Banderas,
        America/Barbados, America/Belem, America/Belize, America/Blanc-Sablon,
        America/Boa_Vista, America/Bogota, America/Boise, America/Buenos_Aires,
        America/Cambridge_Bay, America/Campo_Grande, America/Cancun,
        America/Caracas, America/Catamarca, America/Cayenne, America/Cayman,
        America/Chicago, America/Chihuahua, America/Coral_Harbour,
        America/Cordoba, America/Costa_Rica, America/Creston, America/Cuiaba,
        America/Curacao, America/Danmarkshavn, America/Dawson,
        America/Dawson_Creek, America/Denver, America/Detroit,
        America/Dominica, America/Edmonton, America/Eirunepe,
        America/El_Salvador, America/Ensenada, America/Fort_Wayne,
        America/Fortaleza, America/Glace_Bay, America/Godthab,
        America/Goose_Bay, America/Grand_Turk, America/Grenada,
        America/Guadeloupe, America/Guatemala, America/Guayaquil,
        America/Guyana, America/Halifax, America/Havana, America/Hermosillo,
        America/Indiana/Indianapolis, America/Indiana/Knox,
        America/Indiana/Marengo, America/Indiana/Petersburg,
        America/Indiana/Tell_City, America/Indiana/Vevay,
        America/Indiana/Vincennes, America/Indiana/Winamac,
        America/Indianapolis, America/Inuvik, America/Iqaluit, America/Jamaica,
        America/Jujuy, America/Juneau, America/Kentucky/Louisville,
        America/Kentucky/Monticello, America/Knox_IN, America/Kralendijk,
        America/La_Paz, America/Lima, America/Los_Angeles, America/Louisville,
        America/Lower_Princes, America/Maceio, America/Managua, America/Manaus,
        America/Marigot, America/Martinique, America/Matamoros,
        America/Mazatlan, America/Mendoza, America/Menominee, America/Merida,
        America/Metlakatla, America/Mexico_City, America/Miquelon,
        America/Moncton, America/Monterrey, America/Montevideo,
        America/Montreal, America/Montserrat, America/Nassau, America/New_York,
        America/Nipigon, America/Nome, America/Noronha,
        America/North_Dakota/Beulah, America/North_Dakota/Center,
        America/North_Dakota/New_Salem, America/Ojinaga, America/Panama,
        America/Pangnirtung, America/Paramaribo, America/Phoenix, America/Port-
        au-Prince, America/Port_of_Spain, America/Porto_Acre,
        America/Porto_Velho, America/Puerto_Rico, America/Rainy_River,
        America/Rankin_Inlet, America/Recife, America/Regina, America/Resolute,
        America/Rio_Branco, America/Rosario, America/Santa_Isabel,
        America/Santarem, America/Santiago, America/Santo_Domingo,
        America/Sao_Paulo, America/Scoresbysund, America/Shiprock,
        America/Sitka, America/St_Barthelemy, America/St_Johns,
        America/St_Kitts, America/St_Lucia, America/St_Thomas,
        America/St_Vincent, America/Swift_Current, America/Tegucigalpa,
        America/Thule, America/Thunder_Bay, America/Tijuana, America/Toronto,
        America/Tortola, America/Vancouver, America/Virgin, America/Whitehorse,
        America/Winnipeg, America/Yakutat, America/Yellowknife,
        Antarctica/Casey, Antarctica/Davis, Antarctica/DumontDUrville,
        Antarctica/Macquarie, Antarctica/Mawson, Antarctica/McMurdo,
        Antarctica/Palmer, Antarctica/Rothera, Antarctica/South_Pole,
        Antarctica/Syowa, Antarctica/Troll, Antarctica/Vostok,
        Arctic/Longyearbyen, Asia/Aden, Asia/Almaty, Asia/Amman, Asia/Anadyr,
        Asia/Aqtau, Asia/Aqtobe, Asia/Ashgabat, Asia/Ashkhabad, Asia/Baghdad,
        Asia/Bahrain, Asia/Baku, Asia/Bangkok, Asia/Beirut, Asia/Bishkek,
        Asia/Brunei, Asia/Calcutta, Asia/Chita, Asia/Choibalsan,
        Asia/Chongqing, Asia/Chungking, Asia/Colombo, Asia/Dacca,
        Asia/Damascus, Asia/Dhaka, Asia/Dili, Asia/Dubai, Asia/Dushanbe,
        Asia/Gaza, Asia/Harbin, Asia/Hebron, Asia/Ho_Chi_Minh, Asia/Hong_Kong,
        Asia/Hovd, Asia/Irkutsk, Asia/Istanbul, Asia/Jakarta, Asia/Jayapura,
        Asia/Jerusalem, Asia/Kabul, Asia/Kamchatka, Asia/Karachi, Asia/Kashgar,
        Asia/Kathmandu, Asia/Katmandu, Asia/Khandyga, Asia/Kolkata,
        Asia/Krasnoyarsk, Asia/Kuala_Lumpur, Asia/Kuching, Asia/Kuwait,
        Asia/Macao, Asia/Macau, Asia/Magadan, Asia/Makassar, Asia/Manila,
        Asia/Muscat, Asia/Nicosia, Asia/Novokuznetsk, Asia/Novosibirsk,
        Asia/Omsk, Asia/Oral, Asia/Phnom_Penh, Asia/Pontianak, Asia/Pyongyang,
        Asia/Qatar, Asia/Qyzylorda, Asia/Rangoon, Asia/Riyadh, Asia/Saigon,
        Asia/Sakhalin, Asia/Samarkand, Asia/Seoul, Asia/Shanghai,
        Asia/Singapore, Asia/Srednekolymsk, Asia/Taipei, Asia/Tashkent,
        Asia/Tbilisi, Asia/Tehran, Asia/Tel_Aviv, Asia/Thimbu, Asia/Thimphu,
        Asia/Tokyo, Asia/Ujung_Pandang, Asia/Ulaanbaatar, Asia/Ulan_Bator,
        Asia/Urumqi, Asia/Ust-Nera, Asia/Vientiane, Asia/Vladivostok,
        Asia/Yakutsk, Asia/Yekaterinburg, Asia/Yerevan, Atlantic/Azores,
        Atlantic/Bermuda, Atlantic/Canary, Atlantic/Cape_Verde,
        Atlantic/Faeroe, Atlantic/Faroe, Atlantic/Jan_Mayen, Atlantic/Madeira,
        Atlantic/Reykjavik, Atlantic/South_Georgia, Atlantic/St_Helena,
        Atlantic/Stanley, Australia/ACT, Australia/Adelaide,
        Australia/Brisbane, Australia/Broken_Hill, Australia/Canberra,
        Australia/Currie, Australia/Darwin, Australia/Eucla, Australia/Hobart,
        Australia/LHI, Australia/Lindeman, Australia/Lord_Howe,
        Australia/Melbourne, Australia/NSW, Australia/North, Australia/Perth,
        Australia/Queensland, Australia/South, Australia/Sydney,
        Australia/Tasmania, Australia/Victoria, Australia/West,
        Australia/Yancowinna, BET, BST, Brazil/Acre, Brazil/DeNoronha,
        Brazil/East, Brazil/West, CAT, CET, CNT, CST, CST6CDT, CTT,
        Canada/Atlantic, Canada/Central, Canada/East-Saskatchewan,
        Canada/Eastern, Canada/Mountain, Canada/Newfoundland, Canada/Pacific,
        Canada/Saskatchewan, Canada/Yukon, Chile/Continental,
        Chile/EasterIsland, Cuba, EAT, ECT, EET, EST, EST5EDT, Egypt, Eire,
        Etc/GMT, Etc/GMT+0, Etc/GMT+1, Etc/GMT+10, Etc/GMT+11, Etc/GMT+12,
        Etc/GMT+2, Etc/GMT+3, Etc/GMT+4, Etc/GMT+5, Etc/GMT+6, Etc/GMT+7,
        Etc/GMT+8, Etc/GMT+9, Etc/GMT-0, Etc/GMT-1, Etc/GMT-10, Etc/GMT-11,
        Etc/GMT-12, Etc/GMT-13, Etc/GMT-14, Etc/GMT-2, Etc/GMT-3, Etc/GMT-4,
        Etc/GMT-5, Etc/GMT-6, Etc/GMT-7, Etc/GMT-8, Etc/GMT-9, Etc/GMT0,
        Etc/Greenwich, Etc/UCT, Etc/UTC, Etc/Universal, Etc/Zulu,
        Europe/Amsterdam, Europe/Andorra, Europe/Athens, Europe/Belfast,
        Europe/Belgrade, Europe/Berlin, Europe/Bratislava, Europe/Brussels,
        Europe/Bucharest, Europe/Budapest, Europe/Busingen, Europe/Chisinau,
        Europe/Copenhagen, Europe/Dublin, Europe/Gibraltar, Europe/Guernsey,
        Europe/Helsinki, Europe/Isle_of_Man, Europe/Istanbul, Europe/Jersey,
        Europe/Kaliningrad, Europe/Kiev, Europe/Lisbon, Europe/Ljubljana,
        Europe/London, Europe/Luxembourg, Europe/Madrid, Europe/Malta,
        Europe/Mariehamn, Europe/Minsk, Europe/Monaco, Europe/Moscow,
        Europe/Nicosia, Europe/Oslo, Europe/Paris, Europe/Podgorica,
        Europe/Prague, Europe/Riga, Europe/Rome, Europe/Samara,
        Europe/San_Marino, Europe/Sarajevo, Europe/Simferopol, Europe/Skopje,
        Europe/Sofia, Europe/Stockholm, Europe/Tallinn, Europe/Tirane,
        Europe/Tiraspol, Europe/Uzhgorod, Europe/Vaduz, Europe/Vatican,
        Europe/Vienna, Europe/Vilnius, Europe/Volgograd, Europe/Warsaw,
        Europe/Zagreb, Europe/Zaporozhye, Europe/Zurich, GB, GB-Eire, GMT,
        GMT0, Greenwich, HST, Hongkong, IET, IST, Iceland, Indian/Antananarivo,
        Indian/Chagos, Indian/Christmas, Indian/Cocos, Indian/Comoro,
        Indian/Kerguelen, Indian/Mahe, Indian/Maldives, Indian/Mauritius,
        Indian/Mayotte, Indian/Reunion, Iran, Israel, JST, Jamaica, Japan,
        Kwajalein, Libya, MET, MIT, MST, MST7MDT, Mexico/BajaNorte,
        Mexico/BajaSur, Mexico/General, NET, NST, NZ, NZ-CHAT, Navajo, PLT,
        PNT, PRC, PRT, PST, PST8PDT, Pacific/Apia, Pacific/Auckland,
        Pacific/Bougainville, Pacific/Chatham, Pacific/Chuuk, Pacific/Easter,
        Pacific/Efate, Pacific/Enderbury, Pacific/Fakaofo, Pacific/Fiji,
        Pacific/Funafuti, Pacific/Galapagos, Pacific/Gambier,
        Pacific/Guadalcanal, Pacific/Guam, Pacific/Honolulu, Pacific/Johnston,
        Pacific/Kiritimati, Pacific/Kosrae, Pacific/Kwajalein, Pacific/Majuro,
        Pacific/Marquesas, Pacific/Midway, Pacific/Nauru, Pacific/Niue,
        Pacific/Norfolk, Pacific/Noumea, Pacific/Pago_Pago, Pacific/Palau,
        Pacific/Pitcairn, Pacific/Pohnpei, Pacific/Ponape,
        Pacific/Port_Moresby, Pacific/Rarotonga, Pacific/Saipan, Pacific/Samoa,
        Pacific/Tahiti, Pacific/Tarawa, Pacific/Tongatapu, Pacific/Truk,
        Pacific/Wake, Pacific/Wallis, Pacific/Yap, Poland, Portugal, ROK, SST,
        Singapore, SystemV/AST4, SystemV/AST4ADT, SystemV/CST6,
        SystemV/CST6CDT, SystemV/EST5, SystemV/EST5EDT, SystemV/HST10,
        SystemV/MST7, SystemV/MST7MDT, SystemV/PST8, SystemV/PST8PDT,
        SystemV/YST9, SystemV/YST9YDT, Turkey, UCT, US/Alaska, US/Aleutian,
        US/Arizona, US/Central, US/East-Indiana, US/Eastern, US/Hawaii, US
        /Indiana-Starke, US/Michigan, US/Mountain, US/Pacific, US/Pacific-New,
        US/Samoa, UTC, Universal, VST, W-SU, WET, Zulu)*

        :rtype: ``basestring``
        """
        return self._id[0]

    @id.setter
    def id(self, value):
        self._id = (value, True)

    @property
    def offset(self):
        """
        The difference, in minutes, between UTC and local time. For example, if
        your time zone is UTC -5:00 (Eastern Standard Time), 300 will be
        returned. Daylight saving time prevents this value from being a
        constant even for a given locale.

        :rtype: ``int``
        """
        return self._offset[0]

    @offset.setter
    def offset(self, value):
        self._offset = (value, True)

class CredentialUpdateParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Parameters to update a
    Delphix user's password.
    """
    def __init__(self, undef_enabled=True):
        super(CredentialUpdateParameters, self).__init__()
        self._type = ("CredentialUpdateParameters", True)
        self._new_credential = (self.__undef__, True)
        self._old_credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CredentialUpdateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "newCredential" in data and data["newCredential"] is not None:
            obj._new_credential = (factory.create_object(data["newCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._new_credential[0], "PasswordCredential")
        else:
            obj._new_credential = (obj.__undef__, dirty)
        if "oldCredential" in data and data["oldCredential"] is not None:
            obj._old_credential = (factory.create_object(data["oldCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._old_credential[0], "PasswordCredential")
        else:
            obj._old_credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CredentialUpdateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "new_credential" == "type" or (self.new_credential is not self.__undef__ and not (dirty and not self._new_credential[1])):
            dct["newCredential"] = dictify(self.new_credential)
        if "old_credential" == "type" or (self.old_credential is not self.__undef__ and not (dirty and not self._old_credential[1])):
            dct["oldCredential"] = dictify(self.old_credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._new_credential = (self._new_credential[0], True)
        self._old_credential = (self._old_credential[0], True)

    def is_dirty(self):
        return any([self._new_credential[1], self._old_credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CredentialUpdateParameters):
            return False
        return super(CredentialUpdateParameters, self).__eq__(other) and \
               self.new_credential == other.new_credential and \
               self.old_credential == other.old_credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def new_credential(self):
        """
        The new credentials.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._new_credential[0]

    @new_credential.setter
    def new_credential(self, value):
        self._new_credential = (value, True)

    @property
    def old_credential(self):
        """
        The old credentials.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._old_credential[0]

    @old_credential.setter
    def old_credential(self, value):
        self._old_credential = (value, True)

class SwitchTimeflowParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The input parameters
    used for the TimeFlow switch operation.
    """
    def __init__(self, undef_enabled=True):
        super(SwitchTimeflowParameters, self).__init__()
        self._type = ("SwitchTimeflowParameters", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SwitchTimeflowParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SwitchTimeflowParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SwitchTimeflowParameters):
            return False
        return super(SwitchTimeflowParameters, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        The reference to the target TimeFlow that should be made the current
        TimeFlow.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class ToolkitVirtualSource(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A virtual source
    definition for toolkits.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitVirtualSource, self).__init__()
        self._type = ("ToolkitVirtualSource", True)
        self._status = (self.__undef__, True)
        self._initialize = (self.__undef__, True)
        self._configure = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._stop = (self.__undef__, True)
        self._start = (self.__undef__, True)
        self._unconfigure = (self.__undef__, True)
        self._reconfigure = (self.__undef__, True)
        self._pre_snapshot = (self.__undef__, True)
        self._mount_spec = (self.__undef__, True)
        self._post_snapshot = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._initialize = (data.get("initialize", obj.__undef__), dirty)
        if obj._initialize[0] is not None and obj._initialize[0] is not obj.__undef__:
            assert isinstance(obj._initialize[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._initialize[0]))
            common.validate_format(obj._initialize[0], "None", None, None)
        if "configure" not in data:
            raise ValueError("Missing required property \"configure\".")
        obj._configure = (data.get("configure", obj.__undef__), dirty)
        if obj._configure[0] is not None and obj._configure[0] is not obj.__undef__:
            assert isinstance(obj._configure[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._configure[0]))
            common.validate_format(obj._configure[0], "None", None, None)
        if "parameters" not in data:
            raise ValueError("Missing required property \"parameters\".")
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        if "stop" not in data:
            raise ValueError("Missing required property \"stop\".")
        obj._stop = (data.get("stop", obj.__undef__), dirty)
        if obj._stop[0] is not None and obj._stop[0] is not obj.__undef__:
            assert isinstance(obj._stop[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._stop[0]))
            common.validate_format(obj._stop[0], "None", None, None)
        if "start" not in data:
            raise ValueError("Missing required property \"start\".")
        obj._start = (data.get("start", obj.__undef__), dirty)
        if obj._start[0] is not None and obj._start[0] is not obj.__undef__:
            assert isinstance(obj._start[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start[0]))
            common.validate_format(obj._start[0], "None", None, None)
        if "unconfigure" not in data:
            raise ValueError("Missing required property \"unconfigure\".")
        obj._unconfigure = (data.get("unconfigure", obj.__undef__), dirty)
        if obj._unconfigure[0] is not None and obj._unconfigure[0] is not obj.__undef__:
            assert isinstance(obj._unconfigure[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._unconfigure[0]))
            common.validate_format(obj._unconfigure[0], "None", None, None)
        if "reconfigure" not in data:
            raise ValueError("Missing required property \"reconfigure\".")
        obj._reconfigure = (data.get("reconfigure", obj.__undef__), dirty)
        if obj._reconfigure[0] is not None and obj._reconfigure[0] is not obj.__undef__:
            assert isinstance(obj._reconfigure[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._reconfigure[0]))
            common.validate_format(obj._reconfigure[0], "None", None, None)
        if "preSnapshot" not in data:
            raise ValueError("Missing required property \"preSnapshot\".")
        obj._pre_snapshot = (data.get("preSnapshot", obj.__undef__), dirty)
        if obj._pre_snapshot[0] is not None and obj._pre_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._pre_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_snapshot[0]))
            common.validate_format(obj._pre_snapshot[0], "None", None, None)
        obj._mount_spec = (data.get("mountSpec", obj.__undef__), dirty)
        if obj._mount_spec[0] is not None and obj._mount_spec[0] is not obj.__undef__:
            assert isinstance(obj._mount_spec[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_spec[0]))
            common.validate_format(obj._mount_spec[0], "None", None, None)
        if "postSnapshot" not in data:
            raise ValueError("Missing required property \"postSnapshot\".")
        obj._post_snapshot = (data.get("postSnapshot", obj.__undef__), dirty)
        if obj._post_snapshot[0] is not None and obj._post_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._post_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_snapshot[0]))
            common.validate_format(obj._post_snapshot[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "initialize" == "type" or (self.initialize is not self.__undef__ and not (dirty and not self._initialize[1])):
            dct["initialize"] = dictify(self.initialize)
        if "configure" == "type" or (self.configure is not self.__undef__ and not (dirty and not self._configure[1])):
            dct["configure"] = dictify(self.configure)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "stop" == "type" or (self.stop is not self.__undef__ and not (dirty and not self._stop[1])):
            dct["stop"] = dictify(self.stop)
        if "start" == "type" or (self.start is not self.__undef__ and not (dirty and not self._start[1])):
            dct["start"] = dictify(self.start)
        if "unconfigure" == "type" or (self.unconfigure is not self.__undef__ and not (dirty and not self._unconfigure[1])):
            dct["unconfigure"] = dictify(self.unconfigure)
        if "reconfigure" == "type" or (self.reconfigure is not self.__undef__ and not (dirty and not self._reconfigure[1])):
            dct["reconfigure"] = dictify(self.reconfigure)
        if "pre_snapshot" == "type" or (self.pre_snapshot is not self.__undef__ and not (dirty and not self._pre_snapshot[1])):
            dct["preSnapshot"] = dictify(self.pre_snapshot)
        if "mount_spec" == "type" or (self.mount_spec is not self.__undef__ and not (dirty and not self._mount_spec[1])):
            dct["mountSpec"] = dictify(self.mount_spec)
        if "post_snapshot" == "type" or (self.post_snapshot is not self.__undef__ and not (dirty and not self._post_snapshot[1])):
            dct["postSnapshot"] = dictify(self.post_snapshot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._initialize = (self._initialize[0], True)
        self._configure = (self._configure[0], True)
        self._parameters = (self._parameters[0], True)
        self._stop = (self._stop[0], True)
        self._start = (self._start[0], True)
        self._unconfigure = (self._unconfigure[0], True)
        self._reconfigure = (self._reconfigure[0], True)
        self._pre_snapshot = (self._pre_snapshot[0], True)
        self._mount_spec = (self._mount_spec[0], True)
        self._post_snapshot = (self._post_snapshot[0], True)

    def is_dirty(self):
        return any([self._status[1], self._initialize[1], self._configure[1], self._parameters[1], self._stop[1], self._start[1], self._unconfigure[1], self._reconfigure[1], self._pre_snapshot[1], self._mount_spec[1], self._post_snapshot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitVirtualSource):
            return False
        return super(ToolkitVirtualSource, self).__eq__(other) and \
               self.status == other.status and \
               self.initialize == other.initialize and \
               self.configure == other.configure and \
               self.parameters == other.parameters and \
               self.stop == other.stop and \
               self.start == other.start and \
               self.unconfigure == other.unconfigure and \
               self.reconfigure == other.reconfigure and \
               self.pre_snapshot == other.pre_snapshot and \
               self.mount_spec == other.mount_spec and \
               self.post_snapshot == other.post_snapshot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The workflow script to run to determine if a virtual copy of the
        application is running. The script should output 'ACTIVE' if the
        application is running, 'INACTIVE' if the application is not running,
        and 'UNKNOWN' if the script encounters an unexpected problem.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def initialize(self):
        """
        A workflow script to run when creating an empty application.

        :rtype: ``basestring``
        """
        return self._initialize[0]

    @initialize.setter
    def initialize(self, value):
        self._initialize = (value, True)

    @property
    def configure(self):
        """
        A workflow script run when configuring a virtual copy of the
        application in a new environment.

        :rtype: ``basestring``
        """
        return self._configure[0]

    @configure.setter
    def configure(self, value):
        self._configure = (value, True)

    @property
    def parameters(self):
        """
        A user defined schema for the provisioning parameters.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def stop(self):
        """
        A workflow script to run when stopping a virtual copy of the
        application.

        :rtype: ``basestring``
        """
        return self._stop[0]

    @stop.setter
    def stop(self, value):
        self._stop = (value, True)

    @property
    def start(self):
        """
        A workflow script to run when starting a virtual copy of the
        application.

        :rtype: ``basestring``
        """
        return self._start[0]

    @start.setter
    def start(self, value):
        self._start = (value, True)

    @property
    def unconfigure(self):
        """
        A workflow script run when removing a virtual copy of the application
        from an environment (e.g. on delete, disable, or refresh).

        :rtype: ``basestring``
        """
        return self._unconfigure[0]

    @unconfigure.setter
    def unconfigure(self, value):
        self._unconfigure = (value, True)

    @property
    def reconfigure(self):
        """
        A workflow script run when returning a virtual copy of the appliction
        to an environment that it was previously removed from.

        :rtype: ``basestring``
        """
        return self._reconfigure[0]

    @reconfigure.setter
    def reconfigure(self, value):
        self._reconfigure = (value, True)

    @property
    def pre_snapshot(self):
        """
        A workflow script to run before taking a snapshot of a virtual copy of
        the application.

        :rtype: ``basestring``
        """
        return self._pre_snapshot[0]

    @pre_snapshot.setter
    def pre_snapshot(self, value):
        self._pre_snapshot = (value, True)

    @property
    def mount_spec(self):
        """
        A workflow script that specifies where the virtual copy of the
        application should be mounted.

        :rtype: ``basestring``
        """
        return self._mount_spec[0]

    @mount_spec.setter
    def mount_spec(self, value):
        self._mount_spec = (value, True)

    @property
    def post_snapshot(self):
        """
        A workflow script to run after taking a snapshot of a virtual copy of
        the application.

        :rtype: ``basestring``
        """
        return self._post_snapshot[0]

    @post_snapshot.setter
    def post_snapshot(self, value):
        self._post_snapshot = (value, True)

class PolicyApplyTargetParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Specifies the target
    to which a policy is applied.
    """
    def __init__(self, undef_enabled=True):
        super(PolicyApplyTargetParameters, self).__init__()
        self._type = ("PolicyApplyTargetParameters", True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PolicyApplyTargetParameters, cls).from_dict(data, dirty, undef_enabled)
        if "target" not in data:
            raise ValueError("Missing required property \"target\".")
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PolicyApplyTargetParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PolicyApplyTargetParameters):
            return False
        return super(PolicyApplyTargetParameters, self).__eq__(other) and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target(self):
        """
        Object reference of the target.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class JSDataParent(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The data parent of a
    REFRESH, RESTORE, UNDO, or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataParent, self).__init__()
        self._type = ("JSDataParent", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataParent, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataParent):
            return False
        return super(JSDataParent, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSDataChild(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A branch with data
    from a specific bookmark or PIT (point in time).
    """
    def __init__(self, undef_enabled=True):
        super(JSDataChild, self).__init__()
        self._type = ("JSDataChild", True)
        self._user_name = (self.__undef__, True)
        self._container_name = (self.__undef__, True)
        self._operation = (self.__undef__, True)
        self._branch_name = (self.__undef__, True)
        self._branch = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataChild, cls).from_dict(data, dirty, undef_enabled)
        obj._user_name = (data.get("userName", obj.__undef__), dirty)
        if obj._user_name[0] is not None and obj._user_name[0] is not obj.__undef__:
            assert isinstance(obj._user_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_name[0]))
            common.validate_format(obj._user_name[0], "None", None, 256)
        obj._container_name = (data.get("containerName", obj.__undef__), dirty)
        if obj._container_name[0] is not None and obj._container_name[0] is not obj.__undef__:
            assert isinstance(obj._container_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container_name[0]))
            common.validate_format(obj._container_name[0], "None", None, 256)
        obj._operation = (data.get("operation", obj.__undef__), dirty)
        if obj._operation[0] is not None and obj._operation[0] is not obj.__undef__:
            assert isinstance(obj._operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._operation[0]))
            assert obj._operation[0] in [u'REFRESH', u'RESTORE', u'CREATE_BRANCH', u'RESET'], "Expected enum [u'REFRESH', u'RESTORE', u'CREATE_BRANCH', u'RESET'] but got %s" % obj._operation[0]
            common.validate_format(obj._operation[0], "None", None, None)
        obj._branch_name = (data.get("branchName", obj.__undef__), dirty)
        if obj._branch_name[0] is not None and obj._branch_name[0] is not obj.__undef__:
            assert isinstance(obj._branch_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch_name[0]))
            common.validate_format(obj._branch_name[0], "None", None, 256)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataChild, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "user_name" == "type" or (self.user_name is not self.__undef__ and not (dirty and not self._user_name[1])):
            dct["userName"] = dictify(self.user_name)
        if "container_name" == "type" or (self.container_name is not self.__undef__ and not (dirty and not self._container_name[1])):
            dct["containerName"] = dictify(self.container_name)
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        if "branch_name" == "type" or (self.branch_name is not self.__undef__ and not (dirty and not self._branch_name[1])):
            dct["branchName"] = dictify(self.branch_name)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._user_name = (self._user_name[0], True)
        self._container_name = (self._container_name[0], True)
        self._operation = (self._operation[0], True)
        self._branch_name = (self._branch_name[0], True)
        self._branch = (self._branch[0], True)

    def is_dirty(self):
        return any([self._user_name[1], self._container_name[1], self._operation[1], self._branch_name[1], self._branch[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataChild):
            return False
        return super(JSDataChild, self).__eq__(other) and \
               self.user_name == other.user_name and \
               self.container_name == other.container_name and \
               self.operation == other.operation and \
               self.branch_name == other.branch_name and \
               self.branch == other.branch

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def user_name(self):
        """
        The username of the owner of the branch. This will be null if there is
        no owner.

        :rtype: ``basestring``
        """
        return self._user_name[0]

    @user_name.setter
    def user_name(self, value):
        self._user_name = (value, True)

    @property
    def container_name(self):
        """
        The name of the container.

        :rtype: ``basestring``
        """
        return self._container_name[0]

    @container_name.setter
    def container_name(self, value):
        self._container_name = (value, True)

    @property
    def operation(self):
        """
        The operation performed. *(permitted values: REFRESH, RESTORE,
        CREATE_BRANCH, RESET)*

        :rtype: ``basestring``
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

    @property
    def branch_name(self):
        """
        The name of the branch.

        :rtype: ``basestring``
        """
        return self._branch_name[0]

    @branch_name.setter
    def branch_name(self, value):
        self._branch_name = (value, True)

    @property
    def branch(self):
        """
        Reference to the branch. This will be null if the user does not have
        permission to see it.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

class FileMappingResult(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Result of a file
    mapping request.
    """
    def __init__(self, undef_enabled=True):
        super(FileMappingResult, self).__init__()
        self._type = ("FileMappingResult", True)
        self._mapped_files = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileMappingResult, cls).from_dict(data, dirty, undef_enabled)
        obj._mapped_files = (data.get("mappedFiles", obj.__undef__), dirty)
        if obj._mapped_files[0] is not None and obj._mapped_files[0] is not obj.__undef__:
            assert isinstance(obj._mapped_files[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._mapped_files[0]))
            common.validate_format(obj._mapped_files[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileMappingResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mapped_files" == "type" or (self.mapped_files is not self.__undef__ and not (dirty and not self._mapped_files[1])):
            dct["mappedFiles"] = dictify(self.mapped_files)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mapped_files = (self._mapped_files[0], True)

    def is_dirty(self):
        return any([self._mapped_files[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileMappingResult):
            return False
        return super(FileMappingResult, self).__eq__(other) and \
               self.mapped_files == other.mapped_files

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mapped_files(self):
        """
        Mapped files.

        :rtype: ``dict``
        """
        return self._mapped_files[0]

    @mapped_files.setter
    def mapped_files(self, value):
        self._mapped_files = (value, True)

class AlertFilter(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* AlertFilters are used
    by AlertProfiles to specify which alerts are of interest.
    """
    def __init__(self, undef_enabled=True):
        super(AlertFilter, self).__init__()
        self._type = ("AlertFilter", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertFilter, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertFilter):
            return False
        return super(AlertFilter, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSDataContainerUndoParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters used to
    undo an operation on a data container.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainerUndoParameters, self).__init__()
        self._type = ("JSDataContainerUndoParameters", True)
        self._operation = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainerUndoParameters, cls).from_dict(data, dirty, undef_enabled)
        if "operation" not in data:
            raise ValueError("Missing required property \"operation\".")
        obj._operation = (data.get("operation", obj.__undef__), dirty)
        if obj._operation[0] is not None and obj._operation[0] is not obj.__undef__:
            assert isinstance(obj._operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._operation[0]))
            common.validate_format(obj._operation[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainerUndoParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operation = (self._operation[0], True)

    def is_dirty(self):
        return any([self._operation[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainerUndoParameters):
            return False
        return super(JSDataContainerUndoParameters, self).__eq__(other) and \
               self.operation == other.operation

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operation(self):
        """
        The operation to undo. This is only valid for RESET, RESTORE, UNDO, and
        REFRESH operations.

        :rtype: ``basestring``
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

class ToolkitLinkedSource(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* A linked source
    definition for toolkits.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitLinkedSource, self).__init__()
        self._type = ("ToolkitLinkedSource", True)
        self._pre_snapshot = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._post_snapshot = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "preSnapshot" not in data:
            raise ValueError("Missing required property \"preSnapshot\".")
        obj._pre_snapshot = (data.get("preSnapshot", obj.__undef__), dirty)
        if obj._pre_snapshot[0] is not None and obj._pre_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._pre_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_snapshot[0]))
            common.validate_format(obj._pre_snapshot[0], "None", None, None)
        if "parameters" not in data:
            raise ValueError("Missing required property \"parameters\".")
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        if "postSnapshot" not in data:
            raise ValueError("Missing required property \"postSnapshot\".")
        obj._post_snapshot = (data.get("postSnapshot", obj.__undef__), dirty)
        if obj._post_snapshot[0] is not None and obj._post_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._post_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_snapshot[0]))
            common.validate_format(obj._post_snapshot[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "pre_snapshot" == "type" or (self.pre_snapshot is not self.__undef__ and not (dirty and not self._pre_snapshot[1])):
            dct["preSnapshot"] = dictify(self.pre_snapshot)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "post_snapshot" == "type" or (self.post_snapshot is not self.__undef__ and not (dirty and not self._post_snapshot[1])):
            dct["postSnapshot"] = dictify(self.post_snapshot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._pre_snapshot = (self._pre_snapshot[0], True)
        self._parameters = (self._parameters[0], True)
        self._post_snapshot = (self._post_snapshot[0], True)

    def is_dirty(self):
        return any([self._pre_snapshot[1], self._parameters[1], self._post_snapshot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitLinkedSource):
            return False
        return super(ToolkitLinkedSource, self).__eq__(other) and \
               self.pre_snapshot == other.pre_snapshot and \
               self.parameters == other.parameters and \
               self.post_snapshot == other.post_snapshot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def pre_snapshot(self):
        """
        A workflow script to run just prior to snapshotting the staged source.

        :rtype: ``basestring``
        """
        return self._pre_snapshot[0]

    @pre_snapshot.setter
    def pre_snapshot(self, value):
        self._pre_snapshot = (value, True)

    @property
    def parameters(self):
        """
        A user defined schema for the linking parameters.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def post_snapshot(self):
        """
        A workflow script to run immediately after snapshotting the staged
        source.

        :rtype: ``basestring``
        """
        return self._post_snapshot[0]

    @post_snapshot.setter
    def post_snapshot(self, value):
        self._post_snapshot = (value, True)

class JSOperationEndpoint(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The first and last
    JSOperation for a given data layout or branch.
    """
    def __init__(self, undef_enabled=True):
        super(JSOperationEndpoint, self).__init__()
        self._type = ("JSOperationEndpoint", True)
        self._last = (self.__undef__, True)
        self._first = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSOperationEndpoint, cls).from_dict(data, dirty, undef_enabled)
        obj._last = (data.get("last", obj.__undef__), dirty)
        if obj._last[0] is not None and obj._last[0] is not obj.__undef__:
            assert isinstance(obj._last[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last[0]))
            common.validate_format(obj._last[0], "objectReference", None, None)
        obj._first = (data.get("first", obj.__undef__), dirty)
        if obj._first[0] is not None and obj._first[0] is not obj.__undef__:
            assert isinstance(obj._first[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._first[0]))
            common.validate_format(obj._first[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSOperationEndpoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last" == "type" or (self.last is not self.__undef__ and not (dirty and not self._last[1])):
            dct["last"] = dictify(self.last)
        if "first" == "type" or (self.first is not self.__undef__ and not (dirty and not self._first[1])):
            dct["first"] = dictify(self.first)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last = (self._last[0], True)
        self._first = (self._first[0], True)

    def is_dirty(self):
        return any([self._last[1], self._first[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSOperationEndpoint):
            return False
        return super(JSOperationEndpoint, self).__eq__(other) and \
               self.last == other.last and \
               self.first == other.first

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last(self):
        """
        The last JSOperation.

        :rtype: ``basestring``
        """
        return self._last[0]

    @last.setter
    def last(self, value):
        self._last = (value, True)

    @property
    def first(self):
        """
        The first JSOperation.

        :rtype: ``basestring``
        """
        return self._first[0]

    @first.setter
    def first(self, value):
        self._first = (value, True)

class NamespaceFailoverParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to Namespace.failover.
    """
    def __init__(self, undef_enabled=True):
        super(NamespaceFailoverParameters, self).__init__()
        self._type = ("NamespaceFailoverParameters", True)
        self._smart_failover = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NamespaceFailoverParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._smart_failover = (data.get("smartFailover", obj.__undef__), dirty)
        if obj._smart_failover[0] is not None and obj._smart_failover[0] is not obj.__undef__:
            assert isinstance(obj._smart_failover[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._smart_failover[0]))
            common.validate_format(obj._smart_failover[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NamespaceFailoverParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "smart_failover" == "type" or (self.smart_failover is not self.__undef__ and not (dirty and not self._smart_failover[1])):
            dct["smartFailover"] = dictify(self.smart_failover)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._smart_failover = (self._smart_failover[0], True)

    def is_dirty(self):
        return any([self._smart_failover[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NamespaceFailoverParameters):
            return False
        return super(NamespaceFailoverParameters, self).__eq__(other) and \
               self.smart_failover == other.smart_failover

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def smart_failover(self):
        """
        Enable automatic conflict resolution during failover.

        :rtype: ``bool``
        """
        return self._smart_failover[0]

    @smart_failover.setter
    def smart_failover(self, value):
        self._smart_failover = (value, True)

class SourceEnableParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to enable a MSSQL, PostgreSQL, AppData, ASE or MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnableParameters, self).__init__()
        self._type = ("SourceEnableParameters", True)
        self._attempt_start = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._attempt_start = (data.get("attemptStart", obj.__undef__), dirty)
        if obj._attempt_start[0] is not None and obj._attempt_start[0] is not obj.__undef__:
            assert isinstance(obj._attempt_start[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._attempt_start[0]))
            common.validate_format(obj._attempt_start[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "attempt_start" == "type" or (self.attempt_start is not self.__undef__ and not (dirty and not self._attempt_start[1])):
            dct["attemptStart"] = dictify(self.attempt_start)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._attempt_start = (self._attempt_start[0], True)

    def is_dirty(self):
        return any([self._attempt_start[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnableParameters):
            return False
        return super(SourceEnableParameters, self).__eq__(other) and \
               self.attempt_start == other.attempt_start

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def attempt_start(self):
        """
        *(default value: True)* Whether to attempt a startup of the source
        after the enable.

        :rtype: ``bool``
        """
        return self._attempt_start[0]

    @attempt_start.setter
    def attempt_start(self, value):
        self._attempt_start = (value, True)

class AlertAction(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* An action taken in
    response to an alert being generated. These are aggregated into
    $AlertProfile objects that filter and direct alerts for each user. This is
    an abstract object type and cannot be directly instantiated.
    """
    def __init__(self, undef_enabled=True):
        super(AlertAction, self).__init__()
        self._type = ("AlertAction", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertAction, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertAction, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertAction):
            return False
        return super(AlertAction, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ToolkitDiscoveryDefinition(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Defines the discovery
    schemas and workflow scripts for a toolkit.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitDiscoveryDefinition, self).__init__()
        self._type = ("ToolkitDiscoveryDefinition", True)
        self._source_config_schema = (self.__undef__, True)
        self._source_config_name_field = (self.__undef__, True)
        self._repository_identity_fields = (self.__undef__, True)
        self._repository_schema = (self.__undef__, True)
        self._source_config_discovery = (self.__undef__, True)
        self._repository_discovery = (self.__undef__, True)
        self._repository_name_field = (self.__undef__, True)
        self._source_config_identity_fields = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitDiscoveryDefinition, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfigSchema" not in data:
            raise ValueError("Missing required property \"sourceConfigSchema\".")
        if "sourceConfigSchema" in data and data["sourceConfigSchema"] is not None:
            obj._source_config_schema = (data["sourceConfigSchema"], dirty)
        else:
            obj._source_config_schema = (obj.__undef__, dirty)
        if "sourceConfigNameField" not in data:
            raise ValueError("Missing required property \"sourceConfigNameField\".")
        obj._source_config_name_field = (data.get("sourceConfigNameField", obj.__undef__), dirty)
        if obj._source_config_name_field[0] is not None and obj._source_config_name_field[0] is not obj.__undef__:
            assert isinstance(obj._source_config_name_field[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_config_name_field[0]))
            common.validate_format(obj._source_config_name_field[0], "None", None, None)
        if "repositoryIdentityFields" not in data:
            raise ValueError("Missing required property \"repositoryIdentityFields\".")
        obj._repository_identity_fields = []
        for item in data.get("repositoryIdentityFields") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._repository_identity_fields.append(item)
        obj._repository_identity_fields = (obj._repository_identity_fields, dirty)
        if "repositorySchema" not in data:
            raise ValueError("Missing required property \"repositorySchema\".")
        if "repositorySchema" in data and data["repositorySchema"] is not None:
            obj._repository_schema = (data["repositorySchema"], dirty)
        else:
            obj._repository_schema = (obj.__undef__, dirty)
        if "sourceConfigDiscovery" not in data:
            raise ValueError("Missing required property \"sourceConfigDiscovery\".")
        obj._source_config_discovery = (data.get("sourceConfigDiscovery", obj.__undef__), dirty)
        if obj._source_config_discovery[0] is not None and obj._source_config_discovery[0] is not obj.__undef__:
            assert isinstance(obj._source_config_discovery[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_config_discovery[0]))
            common.validate_format(obj._source_config_discovery[0], "None", None, None)
        if "repositoryDiscovery" not in data:
            raise ValueError("Missing required property \"repositoryDiscovery\".")
        obj._repository_discovery = (data.get("repositoryDiscovery", obj.__undef__), dirty)
        if obj._repository_discovery[0] is not None and obj._repository_discovery[0] is not obj.__undef__:
            assert isinstance(obj._repository_discovery[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository_discovery[0]))
            common.validate_format(obj._repository_discovery[0], "None", None, None)
        if "repositoryNameField" not in data:
            raise ValueError("Missing required property \"repositoryNameField\".")
        obj._repository_name_field = (data.get("repositoryNameField", obj.__undef__), dirty)
        if obj._repository_name_field[0] is not None and obj._repository_name_field[0] is not obj.__undef__:
            assert isinstance(obj._repository_name_field[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository_name_field[0]))
            common.validate_format(obj._repository_name_field[0], "None", None, None)
        if "sourceConfigIdentityFields" not in data:
            raise ValueError("Missing required property \"sourceConfigIdentityFields\".")
        obj._source_config_identity_fields = []
        for item in data.get("sourceConfigIdentityFields") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._source_config_identity_fields.append(item)
        obj._source_config_identity_fields = (obj._source_config_identity_fields, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitDiscoveryDefinition, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config_schema" == "type" or (self.source_config_schema is not self.__undef__ and not (dirty and not self._source_config_schema[1])):
            dct["sourceConfigSchema"] = dictify(self.source_config_schema)
        if "source_config_name_field" == "type" or (self.source_config_name_field is not self.__undef__ and not (dirty and not self._source_config_name_field[1])):
            dct["sourceConfigNameField"] = dictify(self.source_config_name_field)
        if "repository_identity_fields" == "type" or (self.repository_identity_fields is not self.__undef__ and not (dirty and not self._repository_identity_fields[1])):
            dct["repositoryIdentityFields"] = dictify(self.repository_identity_fields)
        if "repository_schema" == "type" or (self.repository_schema is not self.__undef__ and not (dirty and not self._repository_schema[1])):
            dct["repositorySchema"] = dictify(self.repository_schema)
        if "source_config_discovery" == "type" or (self.source_config_discovery is not self.__undef__ and not (dirty and not self._source_config_discovery[1])):
            dct["sourceConfigDiscovery"] = dictify(self.source_config_discovery)
        if "repository_discovery" == "type" or (self.repository_discovery is not self.__undef__ and not (dirty and not self._repository_discovery[1])):
            dct["repositoryDiscovery"] = dictify(self.repository_discovery)
        if "repository_name_field" == "type" or (self.repository_name_field is not self.__undef__ and not (dirty and not self._repository_name_field[1])):
            dct["repositoryNameField"] = dictify(self.repository_name_field)
        if "source_config_identity_fields" == "type" or (self.source_config_identity_fields is not self.__undef__ and not (dirty and not self._source_config_identity_fields[1])):
            dct["sourceConfigIdentityFields"] = dictify(self.source_config_identity_fields)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config_schema = (self._source_config_schema[0], True)
        self._source_config_name_field = (self._source_config_name_field[0], True)
        self._repository_identity_fields = (self._repository_identity_fields[0], True)
        self._repository_schema = (self._repository_schema[0], True)
        self._source_config_discovery = (self._source_config_discovery[0], True)
        self._repository_discovery = (self._repository_discovery[0], True)
        self._repository_name_field = (self._repository_name_field[0], True)
        self._source_config_identity_fields = (self._source_config_identity_fields[0], True)

    def is_dirty(self):
        return any([self._source_config_schema[1], self._source_config_name_field[1], self._repository_identity_fields[1], self._repository_schema[1], self._source_config_discovery[1], self._repository_discovery[1], self._repository_name_field[1], self._source_config_identity_fields[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitDiscoveryDefinition):
            return False
        return super(ToolkitDiscoveryDefinition, self).__eq__(other) and \
               self.source_config_schema == other.source_config_schema and \
               self.source_config_name_field == other.source_config_name_field and \
               self.repository_identity_fields == other.repository_identity_fields and \
               self.repository_schema == other.repository_schema and \
               self.source_config_discovery == other.source_config_discovery and \
               self.repository_discovery == other.repository_discovery and \
               self.repository_name_field == other.repository_name_field and \
               self.source_config_identity_fields == other.source_config_identity_fields

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config_schema(self):
        """
        A user defined schema to represent the source config.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._source_config_schema[0]

    @source_config_schema.setter
    def source_config_schema(self, value):
        self._source_config_schema = (value, True)

    @property
    def source_config_name_field(self):
        """
        The field of the sourceConfigSchema to display to the end user for
        naming this source config.

        :rtype: ``basestring``
        """
        return self._source_config_name_field[0]

    @source_config_name_field.setter
    def source_config_name_field(self, value):
        self._source_config_name_field = (value, True)

    @property
    def repository_identity_fields(self):
        """
        A list of fields in the repositorySchema that collectively identify
        each discovered repository.

        :rtype: ``list`` of ``basestring``
        """
        return self._repository_identity_fields[0]

    @repository_identity_fields.setter
    def repository_identity_fields(self, value):
        self._repository_identity_fields = (value, True)

    @property
    def repository_schema(self):
        """
        A user defined schema to represent the repository.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._repository_schema[0]

    @repository_schema.setter
    def repository_schema(self, value):
        self._repository_schema = (value, True)

    @property
    def source_config_discovery(self):
        """
        A workflow script that discovers source configs on a target
        environment. The script must return a list of source configs matching
        the sourceConfigSchema.

        :rtype: ``basestring``
        """
        return self._source_config_discovery[0]

    @source_config_discovery.setter
    def source_config_discovery(self, value):
        self._source_config_discovery = (value, True)

    @property
    def repository_discovery(self):
        """
        A workflow script that discovers repositories on a target environment.
        The script must return a list of repositories matching the
        repositorySchema.

        :rtype: ``basestring``
        """
        return self._repository_discovery[0]

    @repository_discovery.setter
    def repository_discovery(self, value):
        self._repository_discovery = (value, True)

    @property
    def repository_name_field(self):
        """
        The field of the repositorySchema to display to the end user for naming
        this repository.

        :rtype: ``basestring``
        """
        return self._repository_name_field[0]

    @repository_name_field.setter
    def repository_name_field(self, value):
        self._repository_name_field = (value, True)

    @property
    def source_config_identity_fields(self):
        """
        A list of fields in the sourceConfigSchema that collectively identify
        each discovered source config.

        :rtype: ``list`` of ``basestring``
        """
        return self._source_config_identity_fields[0]

    @source_config_identity_fields.setter
    def source_config_identity_fields(self, value):
        self._source_config_identity_fields = (value, True)

class RollbackParameters(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* The parameters to use
    as input to rollback requests for MSSQL, PostgreSQL, AppData, ASE or MySQL.
    """
    def __init__(self, undef_enabled=True):
        super(RollbackParameters, self).__init__()
        self._type = ("RollbackParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RollbackParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RollbackParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RollbackParameters):
            return False
        return super(RollbackParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to roll the database
        back to.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class JDBCConnectivity(TypedObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TypedObject` *)* Mechanism to test JDBC
    connectivity of arbitrary databases.
    """
    def __init__(self, undef_enabled=True):
        super(JDBCConnectivity, self).__init__()
        self._type = ("JDBCConnectivity", True)
        self._url = (self.__undef__, True)
        self._password = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JDBCConnectivity, cls).from_dict(data, dirty, undef_enabled)
        if "url" not in data:
            raise ValueError("Missing required property \"url\".")
        obj._url = (data.get("url", obj.__undef__), dirty)
        if obj._url[0] is not None and obj._url[0] is not obj.__undef__:
            assert isinstance(obj._url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._url[0]))
            common.validate_format(obj._url[0], "None", None, None)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "None", None, None)
        if "user" not in data:
            raise ValueError("Missing required property \"user\".")
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JDBCConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "url" == "type" or (self.url is not self.__undef__ and not (dirty and not self._url[1])):
            dct["url"] = dictify(self.url)
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._url = (self._url[0], True)
        self._password = (self._password[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._url[1], self._password[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JDBCConnectivity):
            return False
        return super(JDBCConnectivity, self).__eq__(other) and \
               self.url == other.url and \
               self.password == other.password and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def url(self):
        """
        JDBC connection URL.

        :rtype: ``basestring``
        """
        return self._url[0]

    @url.setter
    def url(self, value):
        self._url = (value, True)

    @property
    def password(self):
        """
        Database password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

    @property
    def user(self):
        """
        Database username.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleRollbackParameters(RollbackParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.RollbackParameters` *)* The parameters
    to use as input to roll back Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRollbackParameters, self).__init__()
        self._type = ("OracleRollbackParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRollbackParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRollbackParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRollbackParameters):
            return False
        return super(OracleRollbackParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the user who has the required privileges to perform the
        rollback operation.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the user who has the required privileges to
        run the rollback operation.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class AlertActionEmail(AlertAction):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertAction` *)* An alert action that
    generates email in some form. This is an abstract type and cannot be
    instantiated directly.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmail, self).__init__()
        self._type = ("AlertActionEmail", True)
        self._format = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmail, cls).from_dict(data, dirty, undef_enabled)
        obj._format = (data.get("format", obj.__undef__), dirty)
        if obj._format[0] is not None and obj._format[0] is not obj.__undef__:
            assert isinstance(obj._format[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._format[0]))
            assert obj._format[0] in [u'HTML', u'TEXT', u'JSON'], "Expected enum [u'HTML', u'TEXT', u'JSON'] but got %s" % obj._format[0]
            common.validate_format(obj._format[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmail, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "format" == "type" or (self.format is not self.__undef__ and not (dirty and not self._format[1])):
            dct["format"] = dictify(self.format)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._format = (self._format[0], True)

    def is_dirty(self):
        return any([self._format[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmail):
            return False
        return super(AlertActionEmail, self).__eq__(other) and \
               self.format == other.format

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def format(self):
        """
        *(default value: HTML)* Email format to use. The HTML format will
        generate a multipart message containing both HTML and plain text. The
        TEXT format will explicitly generate text-only mail. The JSON format
        will generate a JSON object identical to the $Alert format returned
        through the web services API. *(permitted values: HTML, TEXT, JSON)*

        :rtype: ``basestring``
        """
        return self._format[0]

    @format.setter
    def format(self, value):
        self._format = (value, True)

class AlertActionEmailList(AlertActionEmail):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertActionEmail` *)* Alert action to
    email a list of users in response to an alert.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmailList, self).__init__()
        self._type = ("AlertActionEmailList", True)
        self._addresses = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmailList, cls).from_dict(data, dirty, undef_enabled)
        if "addresses" not in data:
            raise ValueError("Missing required property \"addresses\".")
        obj._addresses = []
        for item in data.get("addresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._addresses.append(item)
        obj._addresses = (obj._addresses, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmailList, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._addresses = (self._addresses[0], True)

    def is_dirty(self):
        return any([self._addresses[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmailList):
            return False
        return super(AlertActionEmailList, self).__eq__(other) and \
               self.addresses == other.addresses

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def addresses(self):
        """
        List of email addresses to send mail to.

        :rtype: ``list`` of ``basestring``
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

class AlertActionEmailUser(AlertActionEmail):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertActionEmail` *)* Alert action that
    sends email to the email address associated with the user.
    """
    def __init__(self, undef_enabled=True):
        super(AlertActionEmailUser, self).__init__()
        self._type = ("AlertActionEmailUser", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertActionEmailUser, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertActionEmailUser, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertActionEmailUser):
            return False
        return super(AlertActionEmailUser, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleEnableParameters(SourceEnableParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnableParameters` *)* The
    parameters to use as input to enable Oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleEnableParameters, self).__init__()
        self._type = ("OracleEnableParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleEnableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleEnableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleEnableParameters):
            return False
        return super(OracleEnableParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class ToolkitLinkedStagedSource(ToolkitLinkedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ToolkitLinkedSource` *)* A linked
    staged source definition for toolkits.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitLinkedStagedSource, self).__init__()
        self._type = ("ToolkitLinkedStagedSource", True)
        self._status = (self.__undef__, True)
        self._stop_staging = (self.__undef__, True)
        self._resync = (self.__undef__, True)
        self._start_staging = (self.__undef__, True)
        self._worker = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitLinkedStagedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        if "stopStaging" not in data:
            raise ValueError("Missing required property \"stopStaging\".")
        obj._stop_staging = (data.get("stopStaging", obj.__undef__), dirty)
        if obj._stop_staging[0] is not None and obj._stop_staging[0] is not obj.__undef__:
            assert isinstance(obj._stop_staging[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._stop_staging[0]))
            common.validate_format(obj._stop_staging[0], "None", None, None)
        if "resync" not in data:
            raise ValueError("Missing required property \"resync\".")
        obj._resync = (data.get("resync", obj.__undef__), dirty)
        if obj._resync[0] is not None and obj._resync[0] is not obj.__undef__:
            assert isinstance(obj._resync[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._resync[0]))
            common.validate_format(obj._resync[0], "None", None, None)
        if "startStaging" not in data:
            raise ValueError("Missing required property \"startStaging\".")
        obj._start_staging = (data.get("startStaging", obj.__undef__), dirty)
        if obj._start_staging[0] is not None and obj._start_staging[0] is not obj.__undef__:
            assert isinstance(obj._start_staging[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_staging[0]))
            common.validate_format(obj._start_staging[0], "None", None, None)
        obj._worker = (data.get("worker", obj.__undef__), dirty)
        if obj._worker[0] is not None and obj._worker[0] is not obj.__undef__:
            assert isinstance(obj._worker[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._worker[0]))
            common.validate_format(obj._worker[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitLinkedStagedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "stop_staging" == "type" or (self.stop_staging is not self.__undef__ and not (dirty and not self._stop_staging[1])):
            dct["stopStaging"] = dictify(self.stop_staging)
        if "resync" == "type" or (self.resync is not self.__undef__ and not (dirty and not self._resync[1])):
            dct["resync"] = dictify(self.resync)
        if "start_staging" == "type" or (self.start_staging is not self.__undef__ and not (dirty and not self._start_staging[1])):
            dct["startStaging"] = dictify(self.start_staging)
        if "worker" == "type" or (self.worker is not self.__undef__ and not (dirty and not self._worker[1])):
            dct["worker"] = dictify(self.worker)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._stop_staging = (self._stop_staging[0], True)
        self._resync = (self._resync[0], True)
        self._start_staging = (self._start_staging[0], True)
        self._worker = (self._worker[0], True)

    def is_dirty(self):
        return any([self._status[1], self._stop_staging[1], self._resync[1], self._start_staging[1], self._worker[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitLinkedStagedSource):
            return False
        return super(ToolkitLinkedStagedSource, self).__eq__(other) and \
               self.status == other.status and \
               self.stop_staging == other.stop_staging and \
               self.resync == other.resync and \
               self.start_staging == other.start_staging and \
               self.worker == other.worker

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        A workflow script that returns whether or not the data source is
        active/inactive. The script should exit with an exit status of ACTIVE
        if the data source is available. The script should exit with an exit
        status of INACTIVE if the data source is unavailable. An exit status of
        UNKNOWN implies the script encountered an unexpected state or error. If
        no status script is supplied, the dSource will always be in an active
        state while enabled.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def stop_staging(self):
        """
        A workflow script that stop the staged source. The staged files will be
        mounted and available. Upon completion of this workflow, the staged
        files will be unmounted.

        :rtype: ``basestring``
        """
        return self._stop_staging[0]

    @stop_staging.setter
    def stop_staging(self, value):
        self._stop_staging = (value, True)

    @property
    def resync(self):
        """
        A workflow script that builds the staging instance from production.

        :rtype: ``basestring``
        """
        return self._resync[0]

    @resync.setter
    def resync(self, value):
        self._resync = (value, True)

    @property
    def start_staging(self):
        """
        A workflow script that start the staged source. The staged files will
        be mounted and available.

        :rtype: ``basestring``
        """
        return self._start_staging[0]

    @start_staging.setter
    def start_staging(self, value):
        self._start_staging = (value, True)

    @property
    def worker(self):
        """
        A workflow script run periodically to monitor the health of the data
        source and staging environment. This script will be run every 10
        seconds.

        :rtype: ``basestring``
        """
        return self._worker[0]

    @worker.setter
    def worker(self, value):
        self._worker = (value, True)

class ToolkitLinkedDirectSource(ToolkitLinkedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ToolkitLinkedSource` *)* A linked
    source definition for toolkits that perform linking using direct file sync.
    """
    def __init__(self, undef_enabled=True):
        super(ToolkitLinkedDirectSource, self).__init__()
        self._type = ("ToolkitLinkedDirectSource", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ToolkitLinkedDirectSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ToolkitLinkedDirectSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ToolkitLinkedDirectSource):
            return False
        return super(ToolkitLinkedDirectSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AndFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* A container filter
    that combines other filters together using AND logic.
    """
    def __init__(self, undef_enabled=True):
        super(AndFilter, self).__init__()
        self._type = ("AndFilter", True)
        self._sub_filters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AndFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._sub_filters = []
        for item in data.get("subFilters") or []:
            obj._sub_filters.append(factory.create_object(item))
            factory.validate_type(obj._sub_filters[-1], "AlertFilter")
        obj._sub_filters = (obj._sub_filters, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AndFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "sub_filters" == "type" or (self.sub_filters is not self.__undef__ and not (dirty and not self._sub_filters[1])):
            dct["subFilters"] = dictify(self.sub_filters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._sub_filters = (self._sub_filters[0], True)

    def is_dirty(self):
        return any([self._sub_filters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AndFilter):
            return False
        return super(AndFilter, self).__eq__(other) and \
               self.sub_filters == other.sub_filters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def sub_filters(self):
        """
        Filters which are combined together using AND logic.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.AlertFilter`
        """
        return self._sub_filters[0]

    @sub_filters.setter
    def sub_filters(self, value):
        self._sub_filters = (value, True)

class SeverityFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* An alert filter that
    specifies which severity levels to match against.
    """
    def __init__(self, undef_enabled=True):
        super(SeverityFilter, self).__init__()
        self._type = ("SeverityFilter", True)
        self._severity_levels = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SeverityFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._severity_levels = []
        for item in data.get("severityLevels") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            assert item in [u'INFORMATIONAL', u'WARNING', u'CRITICAL', u'AUDIT'], "Expected enum [u'INFORMATIONAL', u'WARNING', u'CRITICAL', u'AUDIT'] but got %s" % item
            common.validate_format(item, "None", None, None)
            obj._severity_levels.append(item)
        obj._severity_levels = (obj._severity_levels, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SeverityFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "severity_levels" == "type" or (self.severity_levels is not self.__undef__ and not (dirty and not self._severity_levels[1])):
            dct["severityLevels"] = dictify(self.severity_levels)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._severity_levels = (self._severity_levels[0], True)

    def is_dirty(self):
        return any([self._severity_levels[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SeverityFilter):
            return False
        return super(SeverityFilter, self).__eq__(other) and \
               self.severity_levels == other.severity_levels

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def severity_levels(self):
        """
        List of severity levels. Only alerts matching one of the given severity
        levels are included.

        :rtype: ``list`` of ``basestring``
        """
        return self._severity_levels[0]

    @severity_levels.setter
    def severity_levels(self, value):
        self._severity_levels = (value, True)

class NotFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* A container filter
    that inverts the logic of another filter.
    """
    def __init__(self, undef_enabled=True):
        super(NotFilter, self).__init__()
        self._type = ("NotFilter", True)
        self._sub_filter = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NotFilter, cls).from_dict(data, dirty, undef_enabled)
        if "subFilter" in data and data["subFilter"] is not None:
            obj._sub_filter = (factory.create_object(data["subFilter"], "AlertFilter"), dirty)
            factory.validate_type(obj._sub_filter[0], "AlertFilter")
        else:
            obj._sub_filter = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NotFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "sub_filter" == "type" or (self.sub_filter is not self.__undef__ and not (dirty and not self._sub_filter[1])):
            dct["subFilter"] = dictify(self.sub_filter)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._sub_filter = (self._sub_filter[0], True)

    def is_dirty(self):
        return any([self._sub_filter[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NotFilter):
            return False
        return super(NotFilter, self).__eq__(other) and \
               self.sub_filter == other.sub_filter

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def sub_filter(self):
        """
        Filter whose logic is to be inverted.

        :rtype: :py:class:`v1_8_1.web.vo.AlertFilter`
        """
        return self._sub_filter[0]

    @sub_filter.setter
    def sub_filter(self, value):
        self._sub_filter = (value, True)

class TargetFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* An alert filter that
    specifies which targets to match against.
    """
    def __init__(self, undef_enabled=True):
        super(TargetFilter, self).__init__()
        self._type = ("TargetFilter", True)
        self._targets = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TargetFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._targets = []
        for item in data.get("targets") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._targets.append(item)
        obj._targets = (obj._targets, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TargetFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "targets" == "type" or (self.targets is not self.__undef__ and not (dirty and not self._targets[1])):
            dct["targets"] = dictify(self.targets)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._targets = (self._targets[0], True)

    def is_dirty(self):
        return any([self._targets[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TargetFilter):
            return False
        return super(TargetFilter, self).__eq__(other) and \
               self.targets == other.targets

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def targets(self):
        """
        List of object references. Only alerts related to one of the targets or
        its children are included.

        :rtype: ``list`` of ``basestring``
        """
        return self._targets[0]

    @targets.setter
    def targets(self, value):
        self._targets = (value, True)

class TargetOwnerFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* An alert filter which
    matches when an alert's target is owned by one of the specified users.
    """
    def __init__(self, undef_enabled=True):
        super(TargetOwnerFilter, self).__init__()
        self._type = ("TargetOwnerFilter", True)
        self._owners = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TargetOwnerFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._owners = []
        for item in data.get("owners") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._owners.append(item)
        obj._owners = (obj._owners, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TargetOwnerFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owners" == "type" or (self.owners is not self.__undef__ and not (dirty and not self._owners[1])):
            dct["owners"] = dictify(self.owners)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owners = (self._owners[0], True)

    def is_dirty(self):
        return any([self._owners[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TargetOwnerFilter):
            return False
        return super(TargetOwnerFilter, self).__eq__(other) and \
               self.owners == other.owners

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owners(self):
        """
        Target owners to match against.

        :rtype: ``list`` of ``basestring``
        """
        return self._owners[0]

    @owners.setter
    def owners(self, value):
        self._owners = (value, True)

class EventFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* An event filter that
    specifies which event types to match against.
    """
    def __init__(self, undef_enabled=True):
        super(EventFilter, self).__init__()
        self._type = ("EventFilter", True)
        self._event_types = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EventFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._event_types = []
        for item in data.get("eventTypes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._event_types.append(item)
        obj._event_types = (obj._event_types, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EventFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_types" == "type" or (self.event_types is not self.__undef__ and not (dirty and not self._event_types[1])):
            dct["eventTypes"] = dictify(self.event_types)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_types = (self._event_types[0], True)

    def is_dirty(self):
        return any([self._event_types[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EventFilter):
            return False
        return super(EventFilter, self).__eq__(other) and \
               self.event_types == other.event_types

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_types(self):
        """
        List of event types. Only alerts of the given event type are included.
        Each event type is a string representing the event class of the
        corresponding alerts. Wildcards are supported to include classes of
        events.

        :rtype: ``list`` of ``basestring``
        """
        return self._event_types[0]

    @event_types.setter
    def event_types(self, value):
        self._event_types = (value, True)

class OrFilter(AlertFilter):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AlertFilter` *)* A container filter
    that combines other filters together using OR logic.
    """
    def __init__(self, undef_enabled=True):
        super(OrFilter, self).__init__()
        self._type = ("OrFilter", True)
        self._sub_filters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OrFilter, cls).from_dict(data, dirty, undef_enabled)
        obj._sub_filters = []
        for item in data.get("subFilters") or []:
            obj._sub_filters.append(factory.create_object(item))
            factory.validate_type(obj._sub_filters[-1], "AlertFilter")
        obj._sub_filters = (obj._sub_filters, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OrFilter, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "sub_filters" == "type" or (self.sub_filters is not self.__undef__ and not (dirty and not self._sub_filters[1])):
            dct["subFilters"] = dictify(self.sub_filters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._sub_filters = (self._sub_filters[0], True)

    def is_dirty(self):
        return any([self._sub_filters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OrFilter):
            return False
        return super(OrFilter, self).__eq__(other) and \
               self.sub_filters == other.sub_filters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def sub_filters(self):
        """
        Filters which are combined together using OR logic.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.AlertFilter`
        """
        return self._sub_filters[0]

    @sub_filters.setter
    def sub_filters(self, value):
        self._sub_filters = (value, True)

class JSTimestampDataParent(JSDataParent):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataParent` *)* The timestamp data
    parent of a REFRESH, RESTORE, UNDO or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimestampDataParent, self).__init__()
        self._type = ("JSTimestampDataParent", True)
        self._branch_name = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimestampDataParent, cls).from_dict(data, dirty, undef_enabled)
        obj._branch_name = (data.get("branchName", obj.__undef__), dirty)
        if obj._branch_name[0] is not None and obj._branch_name[0] is not obj.__undef__:
            assert isinstance(obj._branch_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch_name[0]))
            common.validate_format(obj._branch_name[0], "None", None, 256)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimestampDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "branch_name" == "type" or (self.branch_name is not self.__undef__ and not (dirty and not self._branch_name[1])):
            dct["branchName"] = dictify(self.branch_name)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._branch_name = (self._branch_name[0], True)
        self._branch = (self._branch[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._branch_name[1], self._branch[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimestampDataParent):
            return False
        return super(JSTimestampDataParent, self).__eq__(other) and \
               self.branch_name == other.branch_name and \
               self.branch == other.branch and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def branch_name(self):
        """
        This will always contain the name of the branch, even if it has been
        deleted.

        :rtype: ``basestring``
        """
        return self._branch_name[0]

    @branch_name.setter
    def branch_name(self, value):
        self._branch_name = (value, True)

    @property
    def branch(self):
        """
        The branch this operation's data came from. This will be null if the
        branch has been deleted.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def time(self):
        """
        The data time on the branch that this operation's data came from.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class JSBookmarkDataParent(JSDataParent):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataParent` *)* The bookmark data
    parent of a RESTORE or CREATE_BRANCH operation.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmarkDataParent, self).__init__()
        self._type = ("JSBookmarkDataParent", True)
        self._bookmark = (self.__undef__, True)
        self._bookmark_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmarkDataParent, cls).from_dict(data, dirty, undef_enabled)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._bookmark_name = (data.get("bookmarkName", obj.__undef__), dirty)
        if obj._bookmark_name[0] is not None and obj._bookmark_name[0] is not obj.__undef__:
            assert isinstance(obj._bookmark_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark_name[0]))
            common.validate_format(obj._bookmark_name[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmarkDataParent, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "bookmark_name" == "type" or (self.bookmark_name is not self.__undef__ and not (dirty and not self._bookmark_name[1])):
            dct["bookmarkName"] = dictify(self.bookmark_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._bookmark_name = (self._bookmark_name[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._bookmark_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmarkDataParent):
            return False
        return super(JSBookmarkDataParent, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.bookmark_name == other.bookmark_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The bookmark that this operation's data came from. This will be null if
        the bookmark has been deleted.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def bookmark_name(self):
        """
        This will always contain the name of the bookmark, even if it has been
        deleted.

        :rtype: ``basestring``
        """
        return self._bookmark_name[0]

    @bookmark_name.setter
    def bookmark_name(self, value):
        self._bookmark_name = (value, True)

class VMwareTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within a VMware TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareTimeflowPoint, self).__init__()
        self._type = ("VMwareTimeflowPoint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareTimeflowPoint):
            return False
        return super(VMwareTimeflowPoint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within an MSSql database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlTimeflowPoint, self).__init__()
        self._type = ("MSSqlTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlTimeflowPoint):
            return False
        return super(MSSqlTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class OracleTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within an Oracle database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(OracleTimeflowPoint, self).__init__()
        self._type = ("OracleTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTimeflowPoint):
            return False
        return super(OracleTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class PgSQLTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within a PostgreSQL database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLTimeflowPoint, self).__init__()
        self._type = ("PgSQLTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLTimeflowPoint):
            return False
        return super(PgSQLTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class AppDataTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within an AppData TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataTimeflowPoint, self).__init__()
        self._type = ("AppDataTimeflowPoint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataTimeflowPoint):
            return False
        return super(AppDataTimeflowPoint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASETimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within a SAP ASE database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(ASETimeflowPoint, self).__init__()
        self._type = ("ASETimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASETimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASETimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASETimeflowPoint):
            return False
        return super(ASETimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class MySQLTimeflowPoint(TimeflowPoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPoint` *)* A unique point
    within a MySQL database TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLTimeflowPoint, self).__init__()
        self._type = ("MySQLTimeflowPoint", True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLTimeflowPoint, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLTimeflowPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLTimeflowPoint):
            return False
        return super(MySQLTimeflowPoint, self).__eq__(other) and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class MSSqlLinkedSourceUpgradeParameters(SourceUpgradeParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceUpgradeParameters` *)* The
    parameters to use as input to upgrade an MSSQL linked source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkedSourceUpgradeParameters, self).__init__()
        self._type = ("MSSqlLinkedSourceUpgradeParameters", True)
        self._source_config = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkedSourceUpgradeParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MSSqlDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MSSqlDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkedSourceUpgradeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkedSourceUpgradeParameters):
            return False
        return super(MSSqlLinkedSourceUpgradeParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config that the source database upgrades to.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def ppt_repository(self):
        """
        The SQL instance on the PPT environment that we want to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class OracleStopParameters(SourceStopParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceStopParameters` *)* The
    parameters to use as input to stop oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleStopParameters, self).__init__()
        self._type = ("OracleStopParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._abort = (self.__undef__, True)
        self._instances = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleStopParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._abort = (data.get("abort", obj.__undef__), dirty)
        if obj._abort[0] is not None and obj._abort[0] is not obj.__undef__:
            assert isinstance(obj._abort[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._abort[0]))
            common.validate_format(obj._abort[0], "None", None, None)
        obj._instances = []
        for item in data.get("instances") or []:
            assert isinstance(item, float), ("Expected one of [u'number'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._instances.append(item)
        obj._instances = (obj._instances, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleStopParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "abort" == "type" or (self.abort is not self.__undef__ and not (dirty and not self._abort[1])):
            dct["abort"] = dictify(self.abort)
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)
        self._abort = (self._abort[0], True)
        self._instances = (self._instances[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1], self._abort[1], self._instances[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleStopParameters):
            return False
        return super(OracleStopParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential and \
               self.abort == other.abort and \
               self.instances == other.instances

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def abort(self):
        """
        Whether to issue 'shutdown abort' to shutdown Oracle instances.

        :rtype: ``bool``
        """
        return self._abort[0]

    @abort.setter
    def abort(self, value):
        self._abort = (value, True)

    @property
    def instances(self):
        """
        List of specific Oracle instances to stop.

        :rtype: ``list`` of ``float``
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

class NetworkInterfaceUtilDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a NETWORK_INTERFACE_UTIL analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterfaceUtilDatapointStream, self).__init__()
        self._type = ("NetworkInterfaceUtilDatapointStream", True)
        self._network_interface = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterfaceUtilDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._network_interface = (data.get("networkInterface", obj.__undef__), dirty)
        if obj._network_interface[0] is not None and obj._network_interface[0] is not obj.__undef__:
            assert isinstance(obj._network_interface[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._network_interface[0]))
            common.validate_format(obj._network_interface[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterfaceUtilDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "network_interface" == "type" or (self.network_interface is not self.__undef__ and not (dirty and not self._network_interface[1])):
            dct["networkInterface"] = dictify(self.network_interface)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._network_interface = (self._network_interface[0], True)

    def is_dirty(self):
        return any([self._network_interface[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterfaceUtilDatapointStream):
            return False
        return super(NetworkInterfaceUtilDatapointStream, self).__eq__(other) and \
               self.network_interface == other.network_interface

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def network_interface(self):
        """
        Which network interface was utilized.

        :rtype: ``basestring``
        """
        return self._network_interface[0]

    @network_interface.setter
    def network_interface(self, value):
        self._network_interface = (value, True)

class VfsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a VFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(VfsOpsDatapointStream, self).__init__()
        self._type = ("VfsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VfsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VfsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VfsOpsDatapointStream):
            return False
        return super(VfsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class DxFsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a DxFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DxFsOpsDatapointStream, self).__init__()
        self._type = ("DxFsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DxFsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DxFsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DxFsOpsDatapointStream):
            return False
        return super(DxFsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class IScsiOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a iSCSI_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IScsiOpsDatapointStream, self).__init__()
        self._type = ("IScsiOpsDatapointStream", True)
        self._client = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IScsiOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "host", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IScsiOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._client = (self._client[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._client[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IScsiOpsDatapointStream):
            return False
        return super(IScsiOpsDatapointStream, self).__eq__(other) and \
               self.client == other.client and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def client(self):
        """
        Address of the client.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class CpuUtilDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a CPU_UTIL analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(CpuUtilDatapointStream, self).__init__()
        self._type = ("CpuUtilDatapointStream", True)
        self._cpu = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CpuUtilDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cpu = (data.get("cpu", obj.__undef__), dirty)
        if obj._cpu[0] is not None and obj._cpu[0] is not obj.__undef__:
            assert isinstance(obj._cpu[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._cpu[0]))
            common.validate_format(obj._cpu[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CpuUtilDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cpu" == "type" or (self.cpu is not self.__undef__ and not (dirty and not self._cpu[1])):
            dct["cpu"] = dictify(self.cpu)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cpu = (self._cpu[0], True)

    def is_dirty(self):
        return any([self._cpu[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CpuUtilDatapointStream):
            return False
        return super(CpuUtilDatapointStream, self).__eq__(other) and \
               self.cpu == other.cpu

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cpu(self):
        """
        Which CPU was utilized.

        :rtype: ``int``
        """
        return self._cpu[0]

    @cpu.setter
    def cpu(self, value):
        self._cpu = (value, True)

class TCPStatsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a TCP_STATS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(TCPStatsDatapointStream, self).__init__()
        self._type = ("TCPStatsDatapointStream", True)
        self._remote_port = (self.__undef__, True)
        self._local_address = (self.__undef__, True)
        self._local_port = (self.__undef__, True)
        self._remote_address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TCPStatsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_port = (data.get("remotePort", obj.__undef__), dirty)
        if obj._remote_port[0] is not None and obj._remote_port[0] is not obj.__undef__:
            assert isinstance(obj._remote_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._remote_port[0]))
            common.validate_format(obj._remote_port[0], "None", None, None)
        obj._local_address = (data.get("localAddress", obj.__undef__), dirty)
        if obj._local_address[0] is not None and obj._local_address[0] is not obj.__undef__:
            assert isinstance(obj._local_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._local_address[0]))
            common.validate_format(obj._local_address[0], "ipAddress", None, None)
        obj._local_port = (data.get("localPort", obj.__undef__), dirty)
        if obj._local_port[0] is not None and obj._local_port[0] is not obj.__undef__:
            assert isinstance(obj._local_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._local_port[0]))
            common.validate_format(obj._local_port[0], "None", None, None)
        obj._remote_address = (data.get("remoteAddress", obj.__undef__), dirty)
        if obj._remote_address[0] is not None and obj._remote_address[0] is not obj.__undef__:
            assert isinstance(obj._remote_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_address[0]))
            common.validate_format(obj._remote_address[0], "ipAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TCPStatsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_port" == "type" or (self.remote_port is not self.__undef__ and not (dirty and not self._remote_port[1])):
            dct["remotePort"] = dictify(self.remote_port)
        if "local_address" == "type" or (self.local_address is not self.__undef__ and not (dirty and not self._local_address[1])):
            dct["localAddress"] = dictify(self.local_address)
        if "local_port" == "type" or (self.local_port is not self.__undef__ and not (dirty and not self._local_port[1])):
            dct["localPort"] = dictify(self.local_port)
        if "remote_address" == "type" or (self.remote_address is not self.__undef__ and not (dirty and not self._remote_address[1])):
            dct["remoteAddress"] = dictify(self.remote_address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_port = (self._remote_port[0], True)
        self._local_address = (self._local_address[0], True)
        self._local_port = (self._local_port[0], True)
        self._remote_address = (self._remote_address[0], True)

    def is_dirty(self):
        return any([self._remote_port[1], self._local_address[1], self._local_port[1], self._remote_address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TCPStatsDatapointStream):
            return False
        return super(TCPStatsDatapointStream, self).__eq__(other) and \
               self.remote_port == other.remote_port and \
               self.local_address == other.local_address and \
               self.local_port == other.local_port and \
               self.remote_address == other.remote_address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_port(self):
        """
        The remote TCP port number.

        :rtype: ``int``
        """
        return self._remote_port[0]

    @remote_port.setter
    def remote_port(self, value):
        self._remote_port = (value, True)

    @property
    def local_address(self):
        """
        The local Delphix Engine IP address.

        :rtype: ``basestring``
        """
        return self._local_address[0]

    @local_address.setter
    def local_address(self, value):
        self._local_address = (value, True)

    @property
    def local_port(self):
        """
        The local TCP port number.

        :rtype: ``int``
        """
        return self._local_port[0]

    @local_port.setter
    def local_port(self, value):
        self._local_port = (value, True)

    @property
    def remote_address(self):
        """
        The remote IP address.

        :rtype: ``basestring``
        """
        return self._remote_address[0]

    @remote_address.setter
    def remote_address(self, value):
        self._remote_address = (value, True)

class DiskOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a DISK_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DiskOpsDatapointStream, self).__init__()
        self._type = ("DiskOpsDatapointStream", True)
        self._device = (self.__undef__, True)
        self._error = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DiskOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._device = (data.get("device", obj.__undef__), dirty)
        if obj._device[0] is not None and obj._device[0] is not obj.__undef__:
            assert isinstance(obj._device[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._device[0]))
            common.validate_format(obj._device[0], "None", None, None)
        obj._error = (data.get("error", obj.__undef__), dirty)
        if obj._error[0] is not None and obj._error[0] is not obj.__undef__:
            assert isinstance(obj._error[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._error[0]))
            common.validate_format(obj._error[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DiskOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "device" == "type" or (self.device is not self.__undef__ and not (dirty and not self._device[1])):
            dct["device"] = dictify(self.device)
        if "error" == "type" or (self.error is not self.__undef__ and not (dirty and not self._error[1])):
            dct["error"] = dictify(self.error)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._device = (self._device[0], True)
        self._error = (self._error[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._device[1], self._error[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DiskOpsDatapointStream):
            return False
        return super(DiskOpsDatapointStream, self).__eq__(other) and \
               self.device == other.device and \
               self.error == other.error and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def device(self):
        """
        Device the I/Os were issued to.

        :rtype: ``basestring``
        """
        return self._device[0]

    @device.setter
    def device(self, value):
        self._device = (value, True)

    @property
    def error(self):
        """
        Whether the I/Os resulted in errors.

        :rtype: ``bool``
        """
        return self._error[0]

    @error.setter
    def error(self, value):
        self._error = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class NfsOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from an NFS_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(NfsOpsDatapointStream, self).__init__()
        self._type = ("NfsOpsDatapointStream", True)
        self._cached = (self.__undef__, True)
        self._path = (self.__undef__, True)
        self._client = (self.__undef__, True)
        self._sync = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NfsOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._cached = (data.get("cached", obj.__undef__), dirty)
        if obj._cached[0] is not None and obj._cached[0] is not obj.__undef__:
            assert isinstance(obj._cached[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cached[0]))
            common.validate_format(obj._cached[0], "None", None, None)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "unixpath", None, None)
        obj._client = (data.get("client", obj.__undef__), dirty)
        if obj._client[0] is not None and obj._client[0] is not obj.__undef__:
            assert isinstance(obj._client[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._client[0]))
            common.validate_format(obj._client[0], "host", None, None)
        obj._sync = (data.get("sync", obj.__undef__), dirty)
        if obj._sync[0] is not None and obj._sync[0] is not obj.__undef__:
            assert isinstance(obj._sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._sync[0]))
            common.validate_format(obj._sync[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write'], "Expected enum [u'read', u'write'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NfsOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cached" == "type" or (self.cached is not self.__undef__ and not (dirty and not self._cached[1])):
            dct["cached"] = dictify(self.cached)
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "client" == "type" or (self.client is not self.__undef__ and not (dirty and not self._client[1])):
            dct["client"] = dictify(self.client)
        if "sync" == "type" or (self.sync is not self.__undef__ and not (dirty and not self._sync[1])):
            dct["sync"] = dictify(self.sync)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cached = (self._cached[0], True)
        self._path = (self._path[0], True)
        self._client = (self._client[0], True)
        self._sync = (self._sync[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._cached[1], self._path[1], self._client[1], self._sync[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NfsOpsDatapointStream):
            return False
        return super(NfsOpsDatapointStream, self).__eq__(other) and \
               self.cached == other.cached and \
               self.path == other.path and \
               self.client == other.client and \
               self.sync == other.sync and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cached(self):
        """
        Whether reads were cached.

        :rtype: ``bool``
        """
        return self._cached[0]

    @cached.setter
    def cached(self, value):
        self._cached = (value, True)

    @property
    def path(self):
        """
        Path of the affected file.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def client(self):
        """
        Address of the client.

        :rtype: ``basestring``
        """
        return self._client[0]

    @client.setter
    def client(self, value):
        self._client = (value, True)

    @property
    def sync(self):
        """
        Whether writes were synchronous.

        :rtype: ``bool``
        """
        return self._sync[0]

    @sync.setter
    def sync(self, value):
        self._sync = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class DxFsIoQueueOpsDatapointStream(DatapointStream):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatapointStream` *)* A stream of
    datapoints from a DxFS_IO_QUEUE_OPS analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(DxFsIoQueueOpsDatapointStream, self).__init__()
        self._type = ("DxFsIoQueueOpsDatapointStream", True)
        self._priority = (self.__undef__, True)
        self._op = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DxFsIoQueueOpsDatapointStream, cls).from_dict(data, dirty, undef_enabled)
        obj._priority = (data.get("priority", obj.__undef__), dirty)
        if obj._priority[0] is not None and obj._priority[0] is not obj.__undef__:
            assert isinstance(obj._priority[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._priority[0]))
            assert obj._priority[0] in [u'sync', u'cache/agg', u'asyncw', u'asyncr', u'resilver', u'scrub', u'ddt_prefetch'], "Expected enum [u'sync', u'cache/agg', u'asyncw', u'asyncr', u'resilver', u'scrub', u'ddt_prefetch'] but got %s" % obj._priority[0]
            common.validate_format(obj._priority[0], "None", None, None)
        obj._op = (data.get("op", obj.__undef__), dirty)
        if obj._op[0] is not None and obj._op[0] is not obj.__undef__:
            assert isinstance(obj._op[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._op[0]))
            assert obj._op[0] in [u'read', u'write', u'claim', u'free', u'ioctl', u'null'], "Expected enum [u'read', u'write', u'claim', u'free', u'ioctl', u'null'] but got %s" % obj._op[0]
            common.validate_format(obj._op[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DxFsIoQueueOpsDatapointStream, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "priority" == "type" or (self.priority is not self.__undef__ and not (dirty and not self._priority[1])):
            dct["priority"] = dictify(self.priority)
        if "op" == "type" or (self.op is not self.__undef__ and not (dirty and not self._op[1])):
            dct["op"] = dictify(self.op)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._priority = (self._priority[0], True)
        self._op = (self._op[0], True)

    def is_dirty(self):
        return any([self._priority[1], self._op[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DxFsIoQueueOpsDatapointStream):
            return False
        return super(DxFsIoQueueOpsDatapointStream, self).__eq__(other) and \
               self.priority == other.priority and \
               self.op == other.op

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def priority(self):
        """
        Priority of the I/O. *(permitted values: sync, cache/agg, asyncw,
        asyncr, resilver, scrub, ddt_prefetch)*

        :rtype: ``basestring``
        """
        return self._priority[0]

    @priority.setter
    def priority(self, value):
        self._priority = (value, True)

    @property
    def op(self):
        """
        I/O operation type. *(permitted values: read, write, claim, free,
        ioctl, null)*

        :rtype: ``basestring``
        """
        return self._op[0]

    @op.setter
    def op(self, value):
        self._op = (value, True)

class EmptyDatasetCreationParameters(VirtualDatasetCreationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.VirtualDatasetCreationParameters` *)*
    The parameters to use as input when creating a new empty virtual dataset.
    """
    def __init__(self, undef_enabled=True):
        super(EmptyDatasetCreationParameters, self).__init__()
        self._type = ("EmptyDatasetCreationParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EmptyDatasetCreationParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EmptyDatasetCreationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EmptyDatasetCreationParameters):
            return False
        return super(EmptyDatasetCreationParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ProvisionParameters(VirtualDatasetCreationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.VirtualDatasetCreationParameters` *)*
    The parameters to use as input when creating a new virtual dataset by
    provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(ProvisionParameters, self).__init__()
        self._type = ("ProvisionParameters", True)
        self._masking_job = (self.__undef__, True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._masking_job = (data.get("maskingJob", obj.__undef__), dirty)
        if obj._masking_job[0] is not None and obj._masking_job[0] is not obj.__undef__:
            assert isinstance(obj._masking_job[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._masking_job[0]))
            common.validate_format(obj._masking_job[0], "objectReference", None, None)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "masking_job" == "type" or (self.masking_job is not self.__undef__ and not (dirty and not self._masking_job[1])):
            dct["maskingJob"] = dictify(self.masking_job)
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._masking_job = (self._masking_job[0], True)
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._masking_job[1], self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProvisionParameters):
            return False
        return super(ProvisionParameters, self).__eq__(other) and \
               self.masking_job == other.masking_job and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def masking_job(self):
        """
        The Masking Job to be run when this dataset is provisioned or
        refreshed.

        :rtype: ``basestring``
        """
        return self._masking_job[0]

    @masking_job.setter
    def masking_job(self, value):
        self._masking_job = (value, True)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location to base provisioning
        on.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class RestorationDatasetParameters(VirtualDatasetCreationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.VirtualDatasetCreationParameters` *)*
    The parameters to use as input when creating a new restoration dataset.
    """
    def __init__(self, undef_enabled=True):
        super(RestorationDatasetParameters, self).__init__()
        self._type = ("RestorationDatasetParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RestorationDatasetParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RestorationDatasetParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RestorationDatasetParameters):
            return False
        return super(RestorationDatasetParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point, bookmark, or semantic location on which to base
        restoration.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class AppDataRestorationDatasetCreationParameters(RestorationDatasetParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.RestorationDatasetParameters` *)* The
    parameters to use as input when creating a new AppData restoration dataset.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataRestorationDatasetCreationParameters, self).__init__()
        self._type = ("AppDataRestorationDatasetCreationParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataRestorationDatasetCreationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "AppDataRestorationSource"), dirty)
            factory.validate_type(obj._source[0], "AppDataRestorationSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataRestorationDatasetCreationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataRestorationDatasetCreationParameters):
            return False
        return super(AppDataRestorationDatasetCreationParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external dataset instance.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataRestorationSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the created dataset.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class AppDataProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataProvisionParameters, self).__init__()
        self._type = ("AppDataProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "AppDataVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "AppDataVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataProvisionParameters):
            return False
        return super(AppDataProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class PgSQLProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLProvisionParameters, self).__init__()
        self._type = ("PgSQLProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "PgSQLVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "PgSQLVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "PgSQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "PgSQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "PgSQLDBClusterConfig"), dirty)
            factory.validate_type(obj._source_config[0], "PgSQLDBClusterConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLProvisionParameters):
            return False
        return super(PgSQLProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config for the source.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLDBClusterConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class MySQLProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision requests for MySQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLProvisionParameters, self).__init__()
        self._type = ("MySQLProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "MySQLVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "MySQLVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MySQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MySQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MySQLServerConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MySQLServerConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLProvisionParameters):
            return False
        return super(MySQLProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config for the source.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLServerConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class ASEProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision SAP ASE databases.
    """
    def __init__(self, undef_enabled=True):
        super(ASEProvisionParameters, self).__init__()
        self._type = ("ASEProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._truncate_log_on_checkpoint = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "ASEVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "ASEVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "ASEDBContainer"), dirty)
            factory.validate_type(obj._container[0], "ASEDBContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._truncate_log_on_checkpoint = (data.get("truncateLogOnCheckpoint", obj.__undef__), dirty)
        if obj._truncate_log_on_checkpoint[0] is not None and obj._truncate_log_on_checkpoint[0] is not obj.__undef__:
            assert isinstance(obj._truncate_log_on_checkpoint[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._truncate_log_on_checkpoint[0]))
            common.validate_format(obj._truncate_log_on_checkpoint[0], "None", None, None)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "ASEDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "ASEDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "truncate_log_on_checkpoint" == "type" or (self.truncate_log_on_checkpoint is not self.__undef__ and not (dirty and not self._truncate_log_on_checkpoint[1])):
            dct["truncateLogOnCheckpoint"] = dictify(self.truncate_log_on_checkpoint)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._truncate_log_on_checkpoint = (self._truncate_log_on_checkpoint[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._truncate_log_on_checkpoint[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEProvisionParameters):
            return False
        return super(ASEProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.truncate_log_on_checkpoint == other.truncate_log_on_checkpoint and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.ASEVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.ASEDBContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def truncate_log_on_checkpoint(self):
        """
        *(default value: True)* Set the "trunc log on chkpt" database option.

        :rtype: ``bool``
        """
        return self._truncate_log_on_checkpoint[0]

    @truncate_log_on_checkpoint.setter
    def truncate_log_on_checkpoint(self, value):
        self._truncate_log_on_checkpoint = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.ASEDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class OracleProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleProvisionParameters, self).__init__()
        self._type = ("OracleProvisionParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._physical_standby = (self.__undef__, True)
        self._source_config = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._new_dbid = (self.__undef__, True)
        self._open_resetlogs = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "OracleDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "OracleDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._physical_standby = (data.get("physicalStandby", obj.__undef__), dirty)
        if obj._physical_standby[0] is not None and obj._physical_standby[0] is not obj.__undef__:
            assert isinstance(obj._physical_standby[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._physical_standby[0]))
            common.validate_format(obj._physical_standby[0], "None", None, None)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleBaseDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleBaseDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "OracleVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._new_dbid = (data.get("newDBID", obj.__undef__), dirty)
        if obj._new_dbid[0] is not None and obj._new_dbid[0] is not obj.__undef__:
            assert isinstance(obj._new_dbid[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._new_dbid[0]))
            common.validate_format(obj._new_dbid[0], "None", None, None)
        obj._open_resetlogs = (data.get("openResetlogs", obj.__undef__), dirty)
        if obj._open_resetlogs[0] is not None and obj._open_resetlogs[0] is not obj.__undef__:
            assert isinstance(obj._open_resetlogs[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._open_resetlogs[0]))
            common.validate_format(obj._open_resetlogs[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "physical_standby" == "type" or (self.physical_standby is not self.__undef__ and not (dirty and not self._physical_standby[1])):
            dct["physicalStandby"] = dictify(self.physical_standby)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "new_dbid" == "type" or (self.new_dbid is not self.__undef__ and not (dirty and not self._new_dbid[1])):
            dct["newDBID"] = dictify(self.new_dbid)
        if "open_resetlogs" == "type" or (self.open_resetlogs is not self.__undef__ and not (dirty and not self._open_resetlogs[1])):
            dct["openResetlogs"] = dictify(self.open_resetlogs)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)
        self._container = (self._container[0], True)
        self._physical_standby = (self._physical_standby[0], True)
        self._source_config = (self._source_config[0], True)
        self._source = (self._source[0], True)
        self._new_dbid = (self._new_dbid[0], True)
        self._open_resetlogs = (self._open_resetlogs[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1], self._container[1], self._physical_standby[1], self._source_config[1], self._source[1], self._new_dbid[1], self._open_resetlogs[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleProvisionParameters):
            return False
        return super(OracleProvisionParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential and \
               self.container == other.container and \
               self.physical_standby == other.physical_standby and \
               self.source_config == other.source_config and \
               self.source == other.source and \
               self.new_dbid == other.new_dbid and \
               self.open_resetlogs == other.open_resetlogs

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.OracleDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def physical_standby(self):
        """
        Flag indicating whether the virtual database is provisioned as a
        physical standby database.

        :rtype: ``bool``
        """
        return self._physical_standby[0]

    @physical_standby.setter
    def physical_standby(self, value):
        self._physical_standby = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.OracleBaseDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.OracleVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def new_dbid(self):
        """
        Flag indicating whether to generate a new DBID for the provisioned
        database.

        :rtype: ``bool``
        """
        return self._new_dbid[0]

    @new_dbid.setter
    def new_dbid(self, value):
        self._new_dbid = (value, True)

    @property
    def open_resetlogs(self):
        """
        *(default value: True)* Flag indicating whether to open the database
        after provision.

        :rtype: ``bool``
        """
        return self._open_resetlogs[0]

    @open_resetlogs.setter
    def open_resetlogs(self, value):
        self._open_resetlogs = (value, True)

class VMwareProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision VMware.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareProvisionParameters, self).__init__()
        self._type = ("VMwareProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "VMwareVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "VMwareVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "VMwareContainer"), dirty)
            factory.validate_type(obj._container[0], "VMwareContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "VMwareMachineConfig"), dirty)
            factory.validate_type(obj._source_config[0], "VMwareMachineConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareProvisionParameters):
            return False
        return super(VMwareProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareMachineConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class MSSqlProvisionParameters(ProvisionParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ProvisionParameters` *)* The parameters
    to use as input to provision MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlProvisionParameters, self).__init__()
        self._type = ("MSSqlProvisionParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlProvisionParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "MSSqlVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "MSSqlVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MSSqlDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MSSqlDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MSSqlDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MSSqlDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlProvisionParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlProvisionParameters):
            return False
        return super(MSSqlProvisionParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external database instance.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the provisioned database.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class OracleDatabaseCreationParameters(EmptyDatasetCreationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.EmptyDatasetCreationParameters` *)* The
    parameters to use as input when creating a new Oracle database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseCreationParameters, self).__init__()
        self._type = ("OracleDatabaseCreationParameters", True)
        self._source_config = (self.__undef__, True)
        self._delphix_username = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._timezone_file_version = (self.__undef__, True)
        self._max_instances = (self.__undef__, True)
        self._max_data_files = (self.__undef__, True)
        self._force_logging = (self.__undef__, True)
        self._max_log_files = (self.__undef__, True)
        self._character_set = (self.__undef__, True)
        self._sys_datafile = (self.__undef__, True)
        self._max_log_history = (self.__undef__, True)
        self._temp_tablespace = (self.__undef__, True)
        self._grant_select_any_dictionary = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._redo_logs = (self.__undef__, True)
        self._sys_password = (self.__undef__, True)
        self._delphix_password = (self.__undef__, True)
        self._national_character_set = (self.__undef__, True)
        self._undo_tablespace = (self.__undef__, True)
        self._system_password = (self.__undef__, True)
        self._sysaux_datafile = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseCreationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleBaseDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleBaseDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "delphixUsername" not in data:
            raise ValueError("Missing required property \"delphixUsername\".")
        obj._delphix_username = (data.get("delphixUsername", obj.__undef__), dirty)
        if obj._delphix_username[0] is not None and obj._delphix_username[0] is not obj.__undef__:
            assert isinstance(obj._delphix_username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._delphix_username[0]))
            common.validate_format(obj._delphix_username[0], "None", None, None)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "OracleDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "OracleDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._timezone_file_version = (data.get("timezoneFileVersion", obj.__undef__), dirty)
        if obj._timezone_file_version[0] is not None and obj._timezone_file_version[0] is not obj.__undef__:
            assert isinstance(obj._timezone_file_version[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._timezone_file_version[0]))
            common.validate_format(obj._timezone_file_version[0], "None", None, None)
        obj._max_instances = (data.get("maxInstances", obj.__undef__), dirty)
        if obj._max_instances[0] is not None and obj._max_instances[0] is not obj.__undef__:
            assert isinstance(obj._max_instances[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._max_instances[0]))
            common.validate_format(obj._max_instances[0], "None", None, None)
        obj._max_data_files = (data.get("maxDataFiles", obj.__undef__), dirty)
        if obj._max_data_files[0] is not None and obj._max_data_files[0] is not obj.__undef__:
            assert isinstance(obj._max_data_files[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._max_data_files[0]))
            common.validate_format(obj._max_data_files[0], "None", None, None)
        obj._force_logging = (data.get("forceLogging", obj.__undef__), dirty)
        if obj._force_logging[0] is not None and obj._force_logging[0] is not obj.__undef__:
            assert isinstance(obj._force_logging[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._force_logging[0]))
            common.validate_format(obj._force_logging[0], "None", None, None)
        obj._max_log_files = (data.get("maxLogFiles", obj.__undef__), dirty)
        if obj._max_log_files[0] is not None and obj._max_log_files[0] is not obj.__undef__:
            assert isinstance(obj._max_log_files[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._max_log_files[0]))
            common.validate_format(obj._max_log_files[0], "None", None, None)
        obj._character_set = (data.get("characterSet", obj.__undef__), dirty)
        if obj._character_set[0] is not None and obj._character_set[0] is not obj.__undef__:
            assert isinstance(obj._character_set[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._character_set[0]))
            common.validate_format(obj._character_set[0], "None", None, None)
        if "sysDatafile" in data and data["sysDatafile"] is not None:
            obj._sys_datafile = (factory.create_object(data["sysDatafile"], "OracleSystemDatafileSpecification"), dirty)
            factory.validate_type(obj._sys_datafile[0], "OracleSystemDatafileSpecification")
        else:
            obj._sys_datafile = (obj.__undef__, dirty)
        obj._max_log_history = (data.get("maxLogHistory", obj.__undef__), dirty)
        if obj._max_log_history[0] is not None and obj._max_log_history[0] is not obj.__undef__:
            assert isinstance(obj._max_log_history[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._max_log_history[0]))
            common.validate_format(obj._max_log_history[0], "None", None, None)
        if "tempTablespace" in data and data["tempTablespace"] is not None:
            obj._temp_tablespace = (factory.create_object(data["tempTablespace"], "OracleTempfileSpecification"), dirty)
            factory.validate_type(obj._temp_tablespace[0], "OracleTempfileSpecification")
        else:
            obj._temp_tablespace = (obj.__undef__, dirty)
        obj._grant_select_any_dictionary = (data.get("grantSelectAnyDictionary", obj.__undef__), dirty)
        if obj._grant_select_any_dictionary[0] is not None and obj._grant_select_any_dictionary[0] is not obj.__undef__:
            assert isinstance(obj._grant_select_any_dictionary[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._grant_select_any_dictionary[0]))
            common.validate_format(obj._grant_select_any_dictionary[0], "None", None, None)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleWarehouseSource"), dirty)
            factory.validate_type(obj._source[0], "OracleWarehouseSource")
        else:
            obj._source = (obj.__undef__, dirty)
        obj._redo_logs = []
        for item in data.get("redoLogs") or []:
            obj._redo_logs.append(factory.create_object(item))
            factory.validate_type(obj._redo_logs[-1], "OracleRedoLogFileSpecification")
        obj._redo_logs = (obj._redo_logs, dirty)
        if "sysPassword" not in data:
            raise ValueError("Missing required property \"sysPassword\".")
        obj._sys_password = (data.get("sysPassword", obj.__undef__), dirty)
        if obj._sys_password[0] is not None and obj._sys_password[0] is not obj.__undef__:
            assert isinstance(obj._sys_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._sys_password[0]))
            common.validate_format(obj._sys_password[0], "password", None, None)
        if "delphixPassword" not in data:
            raise ValueError("Missing required property \"delphixPassword\".")
        obj._delphix_password = (data.get("delphixPassword", obj.__undef__), dirty)
        if obj._delphix_password[0] is not None and obj._delphix_password[0] is not obj.__undef__:
            assert isinstance(obj._delphix_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._delphix_password[0]))
            common.validate_format(obj._delphix_password[0], "password", None, None)
        obj._national_character_set = (data.get("nationalCharacterSet", obj.__undef__), dirty)
        if obj._national_character_set[0] is not None and obj._national_character_set[0] is not obj.__undef__:
            assert isinstance(obj._national_character_set[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._national_character_set[0]))
            assert obj._national_character_set[0] in [u'AL16UTF16', u'UTF8'], "Expected enum [u'AL16UTF16', u'UTF8'] but got %s" % obj._national_character_set[0]
            common.validate_format(obj._national_character_set[0], "None", None, None)
        if "undoTablespace" in data and data["undoTablespace"] is not None:
            obj._undo_tablespace = (factory.create_object(data["undoTablespace"], "OracleUndoDatafileSpecification"), dirty)
            factory.validate_type(obj._undo_tablespace[0], "OracleUndoDatafileSpecification")
        else:
            obj._undo_tablespace = (obj.__undef__, dirty)
        if "systemPassword" not in data:
            raise ValueError("Missing required property \"systemPassword\".")
        obj._system_password = (data.get("systemPassword", obj.__undef__), dirty)
        if obj._system_password[0] is not None and obj._system_password[0] is not obj.__undef__:
            assert isinstance(obj._system_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._system_password[0]))
            common.validate_format(obj._system_password[0], "password", None, None)
        if "sysauxDatafile" in data and data["sysauxDatafile"] is not None:
            obj._sysaux_datafile = (factory.create_object(data["sysauxDatafile"], "OracleSysauxDatafileSpecification"), dirty)
            factory.validate_type(obj._sysaux_datafile[0], "OracleSysauxDatafileSpecification")
        else:
            obj._sysaux_datafile = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseCreationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "delphix_username" == "type" or (self.delphix_username is not self.__undef__ and not (dirty and not self._delphix_username[1])):
            dct["delphixUsername"] = dictify(self.delphix_username)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "timezone_file_version" == "type" or (self.timezone_file_version is not self.__undef__ and not (dirty and not self._timezone_file_version[1])):
            dct["timezoneFileVersion"] = dictify(self.timezone_file_version)
        if "max_instances" == "type" or (self.max_instances is not self.__undef__ and not (dirty and not self._max_instances[1])):
            dct["maxInstances"] = dictify(self.max_instances)
        if "max_data_files" == "type" or (self.max_data_files is not self.__undef__ and not (dirty and not self._max_data_files[1])):
            dct["maxDataFiles"] = dictify(self.max_data_files)
        if "force_logging" == "type" or (self.force_logging is not self.__undef__ and not (dirty and not self._force_logging[1])):
            dct["forceLogging"] = dictify(self.force_logging)
        if "max_log_files" == "type" or (self.max_log_files is not self.__undef__ and not (dirty and not self._max_log_files[1])):
            dct["maxLogFiles"] = dictify(self.max_log_files)
        if "character_set" == "type" or (self.character_set is not self.__undef__ and not (dirty and not self._character_set[1])):
            dct["characterSet"] = dictify(self.character_set)
        if "sys_datafile" == "type" or (self.sys_datafile is not self.__undef__ and not (dirty and not self._sys_datafile[1])):
            dct["sysDatafile"] = dictify(self.sys_datafile)
        if "max_log_history" == "type" or (self.max_log_history is not self.__undef__ and not (dirty and not self._max_log_history[1])):
            dct["maxLogHistory"] = dictify(self.max_log_history)
        if "temp_tablespace" == "type" or (self.temp_tablespace is not self.__undef__ and not (dirty and not self._temp_tablespace[1])):
            dct["tempTablespace"] = dictify(self.temp_tablespace)
        if "grant_select_any_dictionary" == "type" or (self.grant_select_any_dictionary is not self.__undef__ and not (dirty and not self._grant_select_any_dictionary[1])):
            dct["grantSelectAnyDictionary"] = dictify(self.grant_select_any_dictionary)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "redo_logs" == "type" or (self.redo_logs is not self.__undef__ and not (dirty and not self._redo_logs[1])):
            dct["redoLogs"] = dictify(self.redo_logs)
        if "sys_password" == "type" or (self.sys_password is not self.__undef__ and not (dirty and not self._sys_password[1])):
            dct["sysPassword"] = dictify(self.sys_password)
        if "delphix_password" == "type" or (self.delphix_password is not self.__undef__ and not (dirty and not self._delphix_password[1])):
            dct["delphixPassword"] = dictify(self.delphix_password)
        if "national_character_set" == "type" or (self.national_character_set is not self.__undef__ and not (dirty and not self._national_character_set[1])):
            dct["nationalCharacterSet"] = dictify(self.national_character_set)
        if "undo_tablespace" == "type" or (self.undo_tablespace is not self.__undef__ and not (dirty and not self._undo_tablespace[1])):
            dct["undoTablespace"] = dictify(self.undo_tablespace)
        if "system_password" == "type" or (self.system_password is not self.__undef__ and not (dirty and not self._system_password[1])):
            dct["systemPassword"] = dictify(self.system_password)
        if "sysaux_datafile" == "type" or (self.sysaux_datafile is not self.__undef__ and not (dirty and not self._sysaux_datafile[1])):
            dct["sysauxDatafile"] = dictify(self.sysaux_datafile)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._delphix_username = (self._delphix_username[0], True)
        self._container = (self._container[0], True)
        self._timezone_file_version = (self._timezone_file_version[0], True)
        self._max_instances = (self._max_instances[0], True)
        self._max_data_files = (self._max_data_files[0], True)
        self._force_logging = (self._force_logging[0], True)
        self._max_log_files = (self._max_log_files[0], True)
        self._character_set = (self._character_set[0], True)
        self._sys_datafile = (self._sys_datafile[0], True)
        self._max_log_history = (self._max_log_history[0], True)
        self._temp_tablespace = (self._temp_tablespace[0], True)
        self._grant_select_any_dictionary = (self._grant_select_any_dictionary[0], True)
        self._source = (self._source[0], True)
        self._redo_logs = (self._redo_logs[0], True)
        self._sys_password = (self._sys_password[0], True)
        self._delphix_password = (self._delphix_password[0], True)
        self._national_character_set = (self._national_character_set[0], True)
        self._undo_tablespace = (self._undo_tablespace[0], True)
        self._system_password = (self._system_password[0], True)
        self._sysaux_datafile = (self._sysaux_datafile[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._delphix_username[1], self._container[1], self._timezone_file_version[1], self._max_instances[1], self._max_data_files[1], self._force_logging[1], self._max_log_files[1], self._character_set[1], self._sys_datafile[1], self._max_log_history[1], self._temp_tablespace[1], self._grant_select_any_dictionary[1], self._source[1], self._redo_logs[1], self._sys_password[1], self._delphix_password[1], self._national_character_set[1], self._undo_tablespace[1], self._system_password[1], self._sysaux_datafile[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseCreationParameters):
            return False
        return super(OracleDatabaseCreationParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.delphix_username == other.delphix_username and \
               self.container == other.container and \
               self.timezone_file_version == other.timezone_file_version and \
               self.max_instances == other.max_instances and \
               self.max_data_files == other.max_data_files and \
               self.force_logging == other.force_logging and \
               self.max_log_files == other.max_log_files and \
               self.character_set == other.character_set and \
               self.sys_datafile == other.sys_datafile and \
               self.max_log_history == other.max_log_history and \
               self.temp_tablespace == other.temp_tablespace and \
               self.grant_select_any_dictionary == other.grant_select_any_dictionary and \
               self.source == other.source and \
               self.redo_logs == other.redo_logs and \
               self.sys_password == other.sys_password and \
               self.delphix_password == other.delphix_password and \
               self.national_character_set == other.national_character_set and \
               self.undo_tablespace == other.undo_tablespace and \
               self.system_password == other.system_password and \
               self.sysaux_datafile == other.sysaux_datafile

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.OracleBaseDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def delphix_username(self):
        """
        The name of the Delphix database user.

        :rtype: ``basestring``
        """
        return self._delphix_username[0]

    @delphix_username.setter
    def delphix_username(self, value):
        self._delphix_username = (value, True)

    @property
    def container(self):
        """
        The new container for the created database.

        :rtype: :py:class:`v1_8_1.web.vo.OracleDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def timezone_file_version(self):
        """
        Indicates the timezone file version that will be used to create the
        database.

        :rtype: ``int``
        """
        return self._timezone_file_version[0]

    @timezone_file_version.setter
    def timezone_file_version(self, value):
        self._timezone_file_version = (value, True)

    @property
    def max_instances(self):
        """
        *(default value: 32)* The maximum number of instances that can
        simultaneously have this database mounted and open.

        :rtype: ``int``
        """
        return self._max_instances[0]

    @max_instances.setter
    def max_instances(self, value):
        self._max_instances = (value, True)

    @property
    def max_data_files(self):
        """
        *(default value: 32)* The initial sizing of the data files section of
        the control file at CREATE DATABASE or CREATE CONTROLFILE time.

        :rtype: ``int``
        """
        return self._max_data_files[0]

    @max_data_files.setter
    def max_data_files(self, value):
        self._max_data_files = (value, True)

    @property
    def force_logging(self):
        """
        Puts the database into FORCE LOGGING mode. Oracle Database will log all
        changes in the database except for changes in temporary tablespaces and
        temporary segments.

        :rtype: ``bool``
        """
        return self._force_logging[0]

    @force_logging.setter
    def force_logging(self, value):
        self._force_logging = (value, True)

    @property
    def max_log_files(self):
        """
        *(default value: 64)* The maximum number of redo log files that can
        ever be created for the database.

        :rtype: ``int``
        """
        return self._max_log_files[0]

    @max_log_files.setter
    def max_log_files(self, value):
        self._max_log_files = (value, True)

    @property
    def character_set(self):
        """
        *(default value: AL32UTF8)* The character set the database uses to
        store data.

        :rtype: ``basestring``
        """
        return self._character_set[0]

    @character_set.setter
    def character_set(self, value):
        self._character_set = (value, True)

    @property
    def sys_datafile(self):
        """
        The datafile for the SYSTEM tablespace. If no filename is provided,
        Oracle-managed files will be used.

        :rtype: :py:class:`v1_8_1.web.vo.OracleSystemDatafileSpecification`
        """
        return self._sys_datafile[0]

    @sys_datafile.setter
    def sys_datafile(self, value):
        self._sys_datafile = (value, True)

    @property
    def max_log_history(self):
        """
        *(default value: 100)* The maximum number of archived redo log files
        for automatic media recovery of Oracle RAC.

        :rtype: ``int``
        """
        return self._max_log_history[0]

    @max_log_history.setter
    def max_log_history(self, value):
        self._max_log_history = (value, True)

    @property
    def temp_tablespace(self):
        """
        The tempfile for the database. If no filename is provided, Oracle-
        managed files will be used.

        :rtype: :py:class:`v1_8_1.web.vo.OracleTempfileSpecification`
        """
        return self._temp_tablespace[0]

    @temp_tablespace.setter
    def temp_tablespace(self, value):
        self._temp_tablespace = (value, True)

    @property
    def grant_select_any_dictionary(self):
        """
        *(default value: True)* Grants the SELECT ANY DICTIONARY system
        privilege to the Delphix database user. If disabled, the Delphix
        database user will only have SELECT access to a limited set of views.

        :rtype: ``bool``
        """
        return self._grant_select_any_dictionary[0]

    @grant_select_any_dictionary.setter
    def grant_select_any_dictionary(self, value):
        self._grant_select_any_dictionary = (value, True)

    @property
    def source(self):
        """
        The source that describes the created database instance.

        :rtype: :py:class:`v1_8_1.web.vo.OracleWarehouseSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def redo_logs(self):
        """
        The redo log files. If no filename is provided, Oracle-managed files
        will be used.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.OracleRedoLogFileSpecification`
        """
        return self._redo_logs[0]

    @redo_logs.setter
    def redo_logs(self, value):
        self._redo_logs = (value, True)

    @property
    def sys_password(self):
        """
        The password for the SYS user.

        :rtype: ``basestring``
        """
        return self._sys_password[0]

    @sys_password.setter
    def sys_password(self, value):
        self._sys_password = (value, True)

    @property
    def delphix_password(self):
        """
        The password for the Delphix database user.

        :rtype: ``basestring``
        """
        return self._delphix_password[0]

    @delphix_password.setter
    def delphix_password(self, value):
        self._delphix_password = (value, True)

    @property
    def national_character_set(self):
        """
        *(default value: AL16UTF16)* The national character set used to store
        data in columns specifically defined as NCHAR, NCLOB, or NVARCHAR2.
        *(permitted values: AL16UTF16, UTF8)*

        :rtype: ``basestring``
        """
        return self._national_character_set[0]

    @national_character_set.setter
    def national_character_set(self, value):
        self._national_character_set = (value, True)

    @property
    def undo_tablespace(self):
        """
        The datafile to be used for undo data. If no filename is provided,
        Oracle-managed files will be used.

        :rtype: :py:class:`v1_8_1.web.vo.OracleUndoDatafileSpecification`
        """
        return self._undo_tablespace[0]

    @undo_tablespace.setter
    def undo_tablespace(self, value):
        self._undo_tablespace = (value, True)

    @property
    def system_password(self):
        """
        The password for the SYSTEM user.

        :rtype: ``basestring``
        """
        return self._system_password[0]

    @system_password.setter
    def system_password(self, value):
        self._system_password = (value, True)

    @property
    def sysaux_datafile(self):
        """
        The datafile for the SYSAUX tablespace. If no filename is provided,
        Oracle-managed files will be used.

        :rtype: :py:class:`v1_8_1.web.vo.OracleSysauxDatafileSpecification`
        """
        return self._sysaux_datafile[0]

    @sysaux_datafile.setter
    def sysaux_datafile(self, value):
        self._sysaux_datafile = (value, True)

class AppDataEmptyVFilesCreationParameters(EmptyDatasetCreationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.EmptyDatasetCreationParameters` *)* The
    parameters to use as input when creating a new empty vFiles dataset.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataEmptyVFilesCreationParameters, self).__init__()
        self._type = ("AppDataEmptyVFilesCreationParameters", True)
        self._source = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataEmptyVFilesCreationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "AppDataVirtualSource"), dirty)
            factory.validate_type(obj._source[0], "AppDataVirtualSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataEmptyVFilesCreationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source = (self._source[0], True)
        self._container = (self._container[0], True)
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source[1], self._container[1], self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataEmptyVFilesCreationParameters):
            return False
        return super(AppDataEmptyVFilesCreationParameters, self).__eq__(other) and \
               self.source == other.source and \
               self.container == other.container and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source(self):
        """
        The source that describes an external dataset instance.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataVirtualSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def container(self):
        """
        The new container for the created dataset.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def source_config(self):
        """
        The source config including dynamically discovered attributes of the
        source.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class MSSqlFailoverClusterListener(MSSqlBaseClusterListener):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterListener` *)* The
    representation of a SQL Server Failover Cluster Listener.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlFailoverClusterListener, self).__init__()
        self._type = ("MSSqlFailoverClusterListener", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlFailoverClusterListener, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlFailoverClusterListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlFailoverClusterListener):
            return False
        return super(MSSqlFailoverClusterListener, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlAvailabilityGroupListener(MSSqlBaseClusterListener):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterListener` *)* The
    representation of a SQL Server Availability Group Listener.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlAvailabilityGroupListener, self).__init__()
        self._type = ("MSSqlAvailabilityGroupListener", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlAvailabilityGroupListener, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlAvailabilityGroupListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlAvailabilityGroupListener):
            return False
        return super(MSSqlAvailabilityGroupListener, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of a PostgreSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBContainerRuntime, self).__init__()
        self._type = ("PgSQLDBContainerRuntime", True)
        self._last_restored_wal_segment = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._last_restored_wal_segment = (data.get("lastRestoredWALSegment", obj.__undef__), dirty)
        if obj._last_restored_wal_segment[0] is not None and obj._last_restored_wal_segment[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_wal_segment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_wal_segment[0]))
            common.validate_format(obj._last_restored_wal_segment[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_restored_wal_segment" == "type" or (self.last_restored_wal_segment is not self.__undef__ and not (dirty and not self._last_restored_wal_segment[1])):
            dct["lastRestoredWALSegment"] = dictify(self.last_restored_wal_segment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_restored_wal_segment = (self._last_restored_wal_segment[0], True)

    def is_dirty(self):
        return any([self._last_restored_wal_segment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBContainerRuntime):
            return False
        return super(PgSQLDBContainerRuntime, self).__eq__(other) and \
               self.last_restored_wal_segment == other.last_restored_wal_segment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_restored_wal_segment(self):
        """
        The ID of the WAL segment that was last restored in this container (if
        applicable).

        :rtype: ``basestring``
        """
        return self._last_restored_wal_segment[0]

    @last_restored_wal_segment.setter
    def last_restored_wal_segment(self, value):
        self._last_restored_wal_segment = (value, True)

class ASEDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of an SAP ASE database container.
    """
    def __init__(self, undef_enabled=True):
        super(ASEDBContainerRuntime, self).__init__()
        self._type = ("ASEDBContainerRuntime", True)
        self._last_restored_backup_date = (self.__undef__, True)
        self._last_restored_backup_time_zone = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._last_restored_backup_date = (data.get("lastRestoredBackupDate", obj.__undef__), dirty)
        if obj._last_restored_backup_date[0] is not None and obj._last_restored_backup_date[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_backup_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_backup_date[0]))
            common.validate_format(obj._last_restored_backup_date[0], "date", None, None)
        obj._last_restored_backup_time_zone = (data.get("lastRestoredBackupTimeZone", obj.__undef__), dirty)
        if obj._last_restored_backup_time_zone[0] is not None and obj._last_restored_backup_time_zone[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_backup_time_zone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_backup_time_zone[0]))
            common.validate_format(obj._last_restored_backup_time_zone[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_restored_backup_date" == "type" or (self.last_restored_backup_date is not self.__undef__ and not (dirty and not self._last_restored_backup_date[1])):
            dct["lastRestoredBackupDate"] = dictify(self.last_restored_backup_date)
        if "last_restored_backup_time_zone" == "type" or (self.last_restored_backup_time_zone is not self.__undef__ and not (dirty and not self._last_restored_backup_time_zone[1])):
            dct["lastRestoredBackupTimeZone"] = dictify(self.last_restored_backup_time_zone)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_restored_backup_date = (self._last_restored_backup_date[0], True)
        self._last_restored_backup_time_zone = (self._last_restored_backup_time_zone[0], True)

    def is_dirty(self):
        return any([self._last_restored_backup_date[1], self._last_restored_backup_time_zone[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEDBContainerRuntime):
            return False
        return super(ASEDBContainerRuntime, self).__eq__(other) and \
               self.last_restored_backup_date == other.last_restored_backup_date and \
               self.last_restored_backup_time_zone == other.last_restored_backup_time_zone

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_restored_backup_date(self):
        """
        The source database backupset that was last restored in this container.

        :rtype: ``basestring``
        """
        return self._last_restored_backup_date[0]

    @last_restored_backup_date.setter
    def last_restored_backup_date(self, value):
        self._last_restored_backup_date = (value, True)

    @property
    def last_restored_backup_time_zone(self):
        """
        The timezone for the last restored source database backupset in this
        container.

        :rtype: ``basestring``
        """
        return self._last_restored_backup_time_zone[0]

    @last_restored_backup_time_zone.setter
    def last_restored_backup_time_zone(self, value):
        self._last_restored_backup_time_zone = (value, True)

class AppDataContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of an AppData container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataContainerRuntime, self).__init__()
        self._type = ("AppDataContainerRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataContainerRuntime):
            return False
        return super(AppDataContainerRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of a MSSQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDBContainerRuntime, self).__init__()
        self._type = ("MSSqlDBContainerRuntime", True)
        self._last_restored_backup_set_uuid = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._last_restored_backup_set_uuid = (data.get("lastRestoredBackupSetUUID", obj.__undef__), dirty)
        if obj._last_restored_backup_set_uuid[0] is not None and obj._last_restored_backup_set_uuid[0] is not obj.__undef__:
            assert isinstance(obj._last_restored_backup_set_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_restored_backup_set_uuid[0]))
            common.validate_format(obj._last_restored_backup_set_uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_restored_backup_set_uuid" == "type" or (self.last_restored_backup_set_uuid is not self.__undef__ and not (dirty and not self._last_restored_backup_set_uuid[1])):
            dct["lastRestoredBackupSetUUID"] = dictify(self.last_restored_backup_set_uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_restored_backup_set_uuid = (self._last_restored_backup_set_uuid[0], True)

    def is_dirty(self):
        return any([self._last_restored_backup_set_uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDBContainerRuntime):
            return False
        return super(MSSqlDBContainerRuntime, self).__eq__(other) and \
               self.last_restored_backup_set_uuid == other.last_restored_backup_set_uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_restored_backup_set_uuid(self):
        """
        The UUID of the source database backupset that was last restored in
        this container.

        :rtype: ``basestring``
        """
        return self._last_restored_backup_set_uuid[0]

    @last_restored_backup_set_uuid.setter
    def last_restored_backup_set_uuid(self, value):
        self._last_restored_backup_set_uuid = (value, True)

class VMwareContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of a VMware container.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareContainerRuntime, self).__init__()
        self._type = ("VMwareContainerRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareContainerRuntime):
            return False
        return super(VMwareContainerRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of a MySQL database container.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLDBContainerRuntime, self).__init__()
        self._type = ("MySQLDBContainerRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLDBContainerRuntime):
            return False
        return super(MySQLDBContainerRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleDBContainerRuntime(DBContainerRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DBContainerRuntime` *)* Runtime
    properties of an Oracle database container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDBContainerRuntime, self).__init__()
        self._type = ("OracleDBContainerRuntime", True)
        self._cross_platform_eligible = (self.__undef__, True)
        self._live_source_eligible = (self.__undef__, True)
        self._cross_platform_script_uploaded = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDBContainerRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._cross_platform_eligible = (data.get("crossPlatformEligible", obj.__undef__), dirty)
        if obj._cross_platform_eligible[0] is not None and obj._cross_platform_eligible[0] is not obj.__undef__:
            assert isinstance(obj._cross_platform_eligible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cross_platform_eligible[0]))
            common.validate_format(obj._cross_platform_eligible[0], "None", None, None)
        obj._live_source_eligible = (data.get("liveSourceEligible", obj.__undef__), dirty)
        if obj._live_source_eligible[0] is not None and obj._live_source_eligible[0] is not obj.__undef__:
            assert isinstance(obj._live_source_eligible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._live_source_eligible[0]))
            common.validate_format(obj._live_source_eligible[0], "None", None, None)
        obj._cross_platform_script_uploaded = (data.get("crossPlatformScriptUploaded", obj.__undef__), dirty)
        if obj._cross_platform_script_uploaded[0] is not None and obj._cross_platform_script_uploaded[0] is not obj.__undef__:
            assert isinstance(obj._cross_platform_script_uploaded[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cross_platform_script_uploaded[0]))
            common.validate_format(obj._cross_platform_script_uploaded[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDBContainerRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cross_platform_eligible" == "type" or (self.cross_platform_eligible is not self.__undef__ and not (dirty and not self._cross_platform_eligible[1])):
            dct["crossPlatformEligible"] = dictify(self.cross_platform_eligible)
        if "live_source_eligible" == "type" or (self.live_source_eligible is not self.__undef__ and not (dirty and not self._live_source_eligible[1])):
            dct["liveSourceEligible"] = dictify(self.live_source_eligible)
        if "cross_platform_script_uploaded" == "type" or (self.cross_platform_script_uploaded is not self.__undef__ and not (dirty and not self._cross_platform_script_uploaded[1])):
            dct["crossPlatformScriptUploaded"] = dictify(self.cross_platform_script_uploaded)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cross_platform_eligible = (self._cross_platform_eligible[0], True)
        self._live_source_eligible = (self._live_source_eligible[0], True)
        self._cross_platform_script_uploaded = (self._cross_platform_script_uploaded[0], True)

    def is_dirty(self):
        return any([self._cross_platform_eligible[1], self._live_source_eligible[1], self._cross_platform_script_uploaded[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDBContainerRuntime):
            return False
        return super(OracleDBContainerRuntime, self).__eq__(other) and \
               self.cross_platform_eligible == other.cross_platform_eligible and \
               self.live_source_eligible == other.live_source_eligible and \
               self.cross_platform_script_uploaded == other.cross_platform_script_uploaded

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cross_platform_eligible(self):
        """
        Indicates whether or not the given container is cross-platform eligible
        or not.

        :rtype: ``bool``
        """
        return self._cross_platform_eligible[0]

    @cross_platform_eligible.setter
    def cross_platform_eligible(self, value):
        self._cross_platform_eligible = (value, True)

    @property
    def live_source_eligible(self):
        """
        Indicates whether or not a LiveSource can be added to the given
        container.

        :rtype: ``bool``
        """
        return self._live_source_eligible[0]

    @live_source_eligible.setter
    def live_source_eligible(self, value):
        self._live_source_eligible = (value, True)

    @property
    def cross_platform_script_uploaded(self):
        """
        Indicates whether or not the given container has a cross-platform user
        script uploaded.

        :rtype: ``bool``
        """
        return self._cross_platform_script_uploaded[0]

    @cross_platform_script_uploaded.setter
    def cross_platform_script_uploaded(self, value):
        self._cross_platform_script_uploaded = (value, True)

class OracleCustomEnvVarFile(OracleCustomEnvVar):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVar` *)* Dictates an
    environment file to be sourced when the Delphix Engine administers an
    Oracle virtual database. This environment file must be available on the
    target environment. This type also includes parameters which will be passed
    to the environment file when it is sourced.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarFile, self).__init__()
        self._type = ("OracleCustomEnvVarFile", True)
        self._path_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarFile, cls).from_dict(data, dirty, undef_enabled)
        if "pathParameters" not in data:
            raise ValueError("Missing required property \"pathParameters\".")
        obj._path_parameters = (data.get("pathParameters", obj.__undef__), dirty)
        if obj._path_parameters[0] is not None and obj._path_parameters[0] is not obj.__undef__:
            assert isinstance(obj._path_parameters[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path_parameters[0]))
            common.validate_format(obj._path_parameters[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarFile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "path_parameters" == "type" or (self.path_parameters is not self.__undef__ and not (dirty and not self._path_parameters[1])):
            dct["pathParameters"] = dictify(self.path_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._path_parameters = (self._path_parameters[0], True)

    def is_dirty(self):
        return any([self._path_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarFile):
            return False
        return super(OracleCustomEnvVarFile, self).__eq__(other) and \
               self.path_parameters == other.path_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def path_parameters(self):
        """
        A string of whitespace-separated parameters to be passed to the source
        command. The first parameter must be an absolute path to a file that
        exists on the target environment. Every subsequent parameter will be
        treated as an argument interpreted by the environment file.

        :rtype: ``basestring``
        """
        return self._path_parameters[0]

    @path_parameters.setter
    def path_parameters(self, value):
        self._path_parameters = (value, True)

class OracleCustomEnvVarPair(OracleCustomEnvVar):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVar` *)* Dictates a
    single environment variable name and value to be set when the Delphix
    Engine administers an Oracle virtual database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarPair, self).__init__()
        self._type = ("OracleCustomEnvVarPair", True)
        self._var_name = (self.__undef__, True)
        self._var_value = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarPair, cls).from_dict(data, dirty, undef_enabled)
        if "varName" not in data:
            raise ValueError("Missing required property \"varName\".")
        obj._var_name = (data.get("varName", obj.__undef__), dirty)
        if obj._var_name[0] is not None and obj._var_name[0] is not obj.__undef__:
            assert isinstance(obj._var_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._var_name[0]))
            common.validate_format(obj._var_name[0], "None", None, None)
        if "varValue" not in data:
            raise ValueError("Missing required property \"varValue\".")
        obj._var_value = (data.get("varValue", obj.__undef__), dirty)
        if obj._var_value[0] is not None and obj._var_value[0] is not obj.__undef__:
            assert isinstance(obj._var_value[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._var_value[0]))
            common.validate_format(obj._var_value[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarPair, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "var_name" == "type" or (self.var_name is not self.__undef__ and not (dirty and not self._var_name[1])):
            dct["varName"] = dictify(self.var_name)
        if "var_value" == "type" or (self.var_value is not self.__undef__ and not (dirty and not self._var_value[1])):
            dct["varValue"] = dictify(self.var_value)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._var_name = (self._var_name[0], True)
        self._var_value = (self._var_value[0], True)

    def is_dirty(self):
        return any([self._var_name[1], self._var_value[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarPair):
            return False
        return super(OracleCustomEnvVarPair, self).__eq__(other) and \
               self.var_name == other.var_name and \
               self.var_value == other.var_value

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def var_name(self):
        """
        The name of the environment variable.

        :rtype: ``basestring``
        """
        return self._var_name[0]

    @var_name.setter
    def var_name(self, value):
        self._var_name = (value, True)

    @property
    def var_value(self):
        """
        The value of the environment variable.

        :rtype: ``basestring``
        """
        return self._var_value[0]

    @var_value.setter
    def var_value(self, value):
        self._var_value = (value, True)

class OracleCustomEnvVarSIPair(OracleCustomEnvVarPair):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVarPair` *)* Dictates a
    single environment variable name and value to be set when the Delphix
    Engine administers an Oracle virtual database.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarSIPair, self).__init__()
        self._type = ("OracleCustomEnvVarSIPair", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarSIPair, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarSIPair, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarSIPair):
            return False
        return super(OracleCustomEnvVarSIPair, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleCustomEnvVarRACPair(OracleCustomEnvVarPair):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVarPair` *)* Dictates a
    single environment variable name and value to be set when the Delphix
    Engine administers an Oracle virtual database. For a RAC environment, the
    cluster node where the target pair is valid must also be specified.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarRACPair, self).__init__()
        self._type = ("OracleCustomEnvVarRACPair", True)
        self._cluster_node = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarRACPair, cls).from_dict(data, dirty, undef_enabled)
        if "clusterNode" not in data:
            raise ValueError("Missing required property \"clusterNode\".")
        obj._cluster_node = (data.get("clusterNode", obj.__undef__), dirty)
        if obj._cluster_node[0] is not None and obj._cluster_node[0] is not obj.__undef__:
            assert isinstance(obj._cluster_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_node[0]))
            common.validate_format(obj._cluster_node[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarRACPair, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cluster_node" == "type" or (self.cluster_node is not self.__undef__ and not (dirty and not self._cluster_node[1])):
            dct["clusterNode"] = dictify(self.cluster_node)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cluster_node = (self._cluster_node[0], True)

    def is_dirty(self):
        return any([self._cluster_node[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarRACPair):
            return False
        return super(OracleCustomEnvVarRACPair, self).__eq__(other) and \
               self.cluster_node == other.cluster_node

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cluster_node(self):
        """
        The cluster node on which the environment variable is relevant.

        :rtype: ``basestring``
        """
        return self._cluster_node[0]

    @cluster_node.setter
    def cluster_node(self, value):
        self._cluster_node = (value, True)

class OracleCustomEnvVarSIFile(OracleCustomEnvVarFile):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVarFile` *)* Dictates an
    environment file to be sourced when the Delphix Engine administers an
    Oracle virtual database. This environment file must be available on the
    target environment. This type also includes parameters which will be passed
    to the environment file when it is sourced.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarSIFile, self).__init__()
        self._type = ("OracleCustomEnvVarSIFile", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarSIFile, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarSIFile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarSIFile):
            return False
        return super(OracleCustomEnvVarSIFile, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleCustomEnvVarRACFile(OracleCustomEnvVarFile):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleCustomEnvVarFile` *)* Dictates an
    environment file to be sourced when the Delphix Engine administers an
    Oracle virtual database. This environment file must be available on the
    target environment. This type also includes parameters which will be passed
    to the environment file when it is sourced. For a RAC environment, the
    cluster node where the target environment file exists must also be
    specified.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCustomEnvVarRACFile, self).__init__()
        self._type = ("OracleCustomEnvVarRACFile", True)
        self._cluster_node = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCustomEnvVarRACFile, cls).from_dict(data, dirty, undef_enabled)
        if "clusterNode" not in data:
            raise ValueError("Missing required property \"clusterNode\".")
        obj._cluster_node = (data.get("clusterNode", obj.__undef__), dirty)
        if obj._cluster_node[0] is not None and obj._cluster_node[0] is not obj.__undef__:
            assert isinstance(obj._cluster_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_node[0]))
            common.validate_format(obj._cluster_node[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCustomEnvVarRACFile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cluster_node" == "type" or (self.cluster_node is not self.__undef__ and not (dirty and not self._cluster_node[1])):
            dct["clusterNode"] = dictify(self.cluster_node)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cluster_node = (self._cluster_node[0], True)

    def is_dirty(self):
        return any([self._cluster_node[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCustomEnvVarRACFile):
            return False
        return super(OracleCustomEnvVarRACFile, self).__eq__(other) and \
               self.cluster_node == other.cluster_node

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cluster_node(self):
        """
        The cluster node on which the target environment file exists.

        :rtype: ``basestring``
        """
        return self._cluster_node[0]

    @cluster_node.setter
    def cluster_node(self, value):
        self._cluster_node = (value, True)

class HistoricalConsumerCapacityData(BaseConsumerCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseConsumerCapacityData` *)*
    Historical data about a particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalConsumerCapacityData, self).__init__()
        self._type = ("HistoricalConsumerCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalConsumerCapacityData):
            return False
        return super(HistoricalConsumerCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class CurrentConsumerCapacityData(BaseConsumerCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseConsumerCapacityData` *)* Current
    data about a particular capacity consumer.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentConsumerCapacityData, self).__init__()
        self._type = ("CurrentConsumerCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentConsumerCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentConsumerCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentConsumerCapacityData):
            return False
        return super(CurrentConsumerCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataExportParameters(ExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ExportParameters` *)* The parameters to
    use as input to export AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataExportParameters, self).__init__()
        self._type = ("AppDataExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "AppDataSourceConfig"), dirty)
            factory.validate_type(obj._source_config[0], "AppDataSourceConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "AppDataFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "AppDataFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataExportParameters):
            return False
        return super(AppDataExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSourceConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class DbExportParameters(ExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ExportParameters` *)* The parameters to
    use as input for export requests.
    """
    def __init__(self, undef_enabled=True):
        super(DbExportParameters, self).__init__()
        self._type = ("DbExportParameters", True)
        self._config_params = (self.__undef__, True)
        self._recover_database = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DbExportParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        obj._recover_database = (data.get("recoverDatabase", obj.__undef__), dirty)
        if obj._recover_database[0] is not None and obj._recover_database[0] is not obj.__undef__:
            assert isinstance(obj._recover_database[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._recover_database[0]))
            common.validate_format(obj._recover_database[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DbExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "recover_database" == "type" or (self.recover_database is not self.__undef__ and not (dirty and not self._recover_database[1])):
            dct["recoverDatabase"] = dictify(self.recover_database)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._recover_database = (self._recover_database[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._recover_database[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DbExportParameters):
            return False
        return super(DbExportParameters, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.recover_database == other.recover_database

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        Database-specific configuration parameters.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def recover_database(self):
        """
        *(default value: True)* If specified, then take the exported database
        through recovery procedures, if necessary, to reach a consistent point.

        :rtype: ``bool``
        """
        return self._recover_database[0]

    @recover_database.setter
    def recover_database(self, value):
        self._recover_database = (value, True)

class MSSqlExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DbExportParameters` *)* The parameters
    to use as input to export MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlExportParameters, self).__init__()
        self._type = ("MSSqlExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)
        self._recovery_model = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MSSqlDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MSSqlDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "TimeflowFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "TimeflowFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        obj._recovery_model = (data.get("recoveryModel", obj.__undef__), dirty)
        if obj._recovery_model[0] is not None and obj._recovery_model[0] is not obj.__undef__:
            assert isinstance(obj._recovery_model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._recovery_model[0]))
            assert obj._recovery_model[0] in [u'SIMPLE', u'BULK_LOGGED', u'FULL'], "Expected enum [u'SIMPLE', u'BULK_LOGGED', u'FULL'] but got %s" % obj._recovery_model[0]
            common.validate_format(obj._recovery_model[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        if "recovery_model" == "type" or (self.recovery_model is not self.__undef__ and not (dirty and not self._recovery_model[1])):
            dct["recoveryModel"] = dictify(self.recovery_model)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)
        self._recovery_model = (self._recovery_model[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._filesystem_layout[1], self._recovery_model[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlExportParameters):
            return False
        return super(MSSqlExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.filesystem_layout == other.filesystem_layout and \
               self.recovery_model == other.recovery_model

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

    @property
    def recovery_model(self):
        """
        *(default value: FULL)* Recovery model of the database. *(permitted
        values: SIMPLE, BULK_LOGGED, FULL)*

        :rtype: ``basestring``
        """
        return self._recovery_model[0]

    @recovery_model.setter
    def recovery_model(self, value):
        self._recovery_model = (value, True)

class OracleExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DbExportParameters` *)* The parameters
    to use as input to export Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleExportParameters, self).__init__()
        self._type = ("OracleExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._dsp_options = (self.__undef__, True)
        self._file_parallelism = (self.__undef__, True)
        self._open_database = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "dspOptions" in data and data["dspOptions"] is not None:
            obj._dsp_options = (factory.create_object(data["dspOptions"], "DSPOptions"), dirty)
            factory.validate_type(obj._dsp_options[0], "DSPOptions")
        else:
            obj._dsp_options = (obj.__undef__, dirty)
        obj._file_parallelism = (data.get("fileParallelism", obj.__undef__), dirty)
        if obj._file_parallelism[0] is not None and obj._file_parallelism[0] is not obj.__undef__:
            assert isinstance(obj._file_parallelism[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._file_parallelism[0]))
            common.validate_format(obj._file_parallelism[0], "None", None, None)
        obj._open_database = (data.get("openDatabase", obj.__undef__), dirty)
        if obj._open_database[0] is not None and obj._open_database[0] is not obj.__undef__:
            assert isinstance(obj._open_database[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._open_database[0]))
            common.validate_format(obj._open_database[0], "None", None, None)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "TimeflowFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "TimeflowFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "dsp_options" == "type" or (self.dsp_options is not self.__undef__ and not (dirty and not self._dsp_options[1])):
            dct["dspOptions"] = dictify(self.dsp_options)
        if "file_parallelism" == "type" or (self.file_parallelism is not self.__undef__ and not (dirty and not self._file_parallelism[1])):
            dct["fileParallelism"] = dictify(self.file_parallelism)
        if "open_database" == "type" or (self.open_database is not self.__undef__ and not (dirty and not self._open_database[1])):
            dct["openDatabase"] = dictify(self.open_database)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._dsp_options = (self._dsp_options[0], True)
        self._file_parallelism = (self._file_parallelism[0], True)
        self._open_database = (self._open_database[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._dsp_options[1], self._file_parallelism[1], self._open_database[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleExportParameters):
            return False
        return super(OracleExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.dsp_options == other.dsp_options and \
               self.file_parallelism == other.file_parallelism and \
               self.open_database == other.open_database and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_8_1.web.vo.OracleDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def dsp_options(self):
        """
        DSP options for export.

        :rtype: :py:class:`v1_8_1.web.vo.DSPOptions`
        """
        return self._dsp_options[0]

    @dsp_options.setter
    def dsp_options(self, value):
        self._dsp_options = (value, True)

    @property
    def file_parallelism(self):
        """
        *(default value: 3)* Number of files to stream in parallel across the
        network.

        :rtype: ``int``
        """
        return self._file_parallelism[0]

    @file_parallelism.setter
    def file_parallelism(self, value):
        self._file_parallelism = (value, True)

    @property
    def open_database(self):
        """
        *(default value: True)* Open the database after recovery. This can have
        a true value only if 'recoverDatabase' is true.

        :rtype: ``bool``
        """
        return self._open_database[0]

    @open_database.setter
    def open_database(self, value):
        self._open_database = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class MySQLExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DbExportParameters` *)* The parameters
    to use as input to export MySQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLExportParameters, self).__init__()
        self._type = ("MySQLExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "MySQLServerConfig"), dirty)
            factory.validate_type(obj._source_config[0], "MySQLServerConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "TimeflowFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "TimeflowFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLExportParameters):
            return False
        return super(MySQLExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLServerConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class PgSQLExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DbExportParameters` *)* The parameters
    to use as input to export PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLExportParameters, self).__init__()
        self._type = ("PgSQLExportParameters", True)
        self._source_config = (self.__undef__, True)
        self._ident_entries = (self.__undef__, True)
        self._hba_entries = (self.__undef__, True)
        self._filesystem_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "PgSQLDBClusterConfig"), dirty)
            factory.validate_type(obj._source_config[0], "PgSQLDBClusterConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        obj._ident_entries = []
        for item in data.get("identEntries") or []:
            obj._ident_entries.append(factory.create_object(item))
            factory.validate_type(obj._ident_entries[-1], "PgSQLIdentEntry")
        obj._ident_entries = (obj._ident_entries, dirty)
        obj._hba_entries = []
        for item in data.get("hbaEntries") or []:
            obj._hba_entries.append(factory.create_object(item))
            factory.validate_type(obj._hba_entries[-1], "PgSQLHBAEntry")
        obj._hba_entries = (obj._hba_entries, dirty)
        if "filesystemLayout" not in data:
            raise ValueError("Missing required property \"filesystemLayout\".")
        if "filesystemLayout" in data and data["filesystemLayout"] is not None:
            obj._filesystem_layout = (factory.create_object(data["filesystemLayout"], "TimeflowFilesystemLayout"), dirty)
            factory.validate_type(obj._filesystem_layout[0], "TimeflowFilesystemLayout")
        else:
            obj._filesystem_layout = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "ident_entries" == "type" or (self.ident_entries is not self.__undef__ and not (dirty and not self._ident_entries[1])):
            dct["identEntries"] = dictify(self.ident_entries)
        if "hba_entries" == "type" or (self.hba_entries is not self.__undef__ and not (dirty and not self._hba_entries[1])):
            dct["hbaEntries"] = dictify(self.hba_entries)
        if "filesystem_layout" == "type" or (self.filesystem_layout is not self.__undef__ and not (dirty and not self._filesystem_layout[1])):
            dct["filesystemLayout"] = dictify(self.filesystem_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)
        self._ident_entries = (self._ident_entries[0], True)
        self._hba_entries = (self._hba_entries[0], True)
        self._filesystem_layout = (self._filesystem_layout[0], True)

    def is_dirty(self):
        return any([self._source_config[1], self._ident_entries[1], self._hba_entries[1], self._filesystem_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLExportParameters):
            return False
        return super(PgSQLExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config and \
               self.ident_entries == other.ident_entries and \
               self.hba_entries == other.hba_entries and \
               self.filesystem_layout == other.filesystem_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLDBClusterConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def ident_entries(self):
        """
        Entries in the PostgreSQL username map file (pg_ident.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLIdentEntry`
        """
        return self._ident_entries[0]

    @ident_entries.setter
    def ident_entries(self, value):
        self._ident_entries = (value, True)

    @property
    def hba_entries(self):
        """
        Entries in the PostgreSQL host-based authentication file (pg_hba.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLHBAEntry`
        """
        return self._hba_entries[0]

    @hba_entries.setter
    def hba_entries(self, value):
        self._hba_entries = (value, True)

    @property
    def filesystem_layout(self):
        """
        The filesystem configuration of the exported database.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowFilesystemLayout`
        """
        return self._filesystem_layout[0]

    @filesystem_layout.setter
    def filesystem_layout(self, value):
        self._filesystem_layout = (value, True)

class ASEExportParameters(DbExportParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DbExportParameters` *)* The parameters
    to use as input to export SAP ASE databases.
    """
    def __init__(self, undef_enabled=True):
        super(ASEExportParameters, self).__init__()
        self._type = ("ASEExportParameters", True)
        self._source_config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEExportParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "ASEDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "ASEDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEExportParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_config = (self._source_config[0], True)

    def is_dirty(self):
        return any([self._source_config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEExportParameters):
            return False
        return super(ASEExportParameters, self).__eq__(other) and \
               self.source_config == other.source_config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_config(self):
        """
        The source config to use when creating the exported DB.

        :rtype: :py:class:`v1_8_1.web.vo.ASEDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

class MSSqlLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* MSSQL specific parameters
    for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkData, self).__init__()
        self._type = ("MSSqlLinkData", True)
        self._operations = (self.__undef__, True)
        self._backup_uuid = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._encryption_key = (self.__undef__, True)
        self._backup_location_credentials = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._shared_backup_location = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._ppt_host_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._backup_location_user = (self.__undef__, True)
        self._delphix_managed = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._backup_uuid = (data.get("backupUUID", obj.__undef__), dirty)
        if obj._backup_uuid[0] is not None and obj._backup_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_uuid[0]))
            common.validate_format(obj._backup_uuid[0], "None", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'], "Expected enum [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        obj._encryption_key = (data.get("encryptionKey", obj.__undef__), dirty)
        if obj._encryption_key[0] is not None and obj._encryption_key[0] is not obj.__undef__:
            assert isinstance(obj._encryption_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._encryption_key[0]))
            common.validate_format(obj._encryption_key[0], "None", None, None)
        if "backupLocationCredentials" in data and data["backupLocationCredentials"] is not None:
            obj._backup_location_credentials = (factory.create_object(data["backupLocationCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._backup_location_credentials[0], "PasswordCredential")
        else:
            obj._backup_location_credentials = (obj.__undef__, dirty)
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        obj._shared_backup_location = (data.get("sharedBackupLocation", obj.__undef__), dirty)
        if obj._shared_backup_location[0] is not None and obj._shared_backup_location[0] is not obj.__undef__:
            assert isinstance(obj._shared_backup_location[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._shared_backup_location[0]))
            common.validate_format(obj._shared_backup_location[0], "None", None, 260)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        obj._backup_location_user = (data.get("backupLocationUser", obj.__undef__), dirty)
        if obj._backup_location_user[0] is not None and obj._backup_location_user[0] is not obj.__undef__:
            assert isinstance(obj._backup_location_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_location_user[0]))
            common.validate_format(obj._backup_location_user[0], "None", None, 256)
        obj._delphix_managed = (data.get("delphixManaged", obj.__undef__), dirty)
        if obj._delphix_managed[0] is not None and obj._delphix_managed[0] is not obj.__undef__:
            assert isinstance(obj._delphix_managed[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._delphix_managed[0]))
            common.validate_format(obj._delphix_managed[0], "None", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "backup_uuid" == "type" or (self.backup_uuid is not self.__undef__ and not (dirty and not self._backup_uuid[1])):
            dct["backupUUID"] = dictify(self.backup_uuid)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "encryption_key" == "type" or (self.encryption_key is not self.__undef__ and not (dirty and not self._encryption_key[1])):
            dct["encryptionKey"] = dictify(self.encryption_key)
        if "backup_location_credentials" == "type" or (self.backup_location_credentials is not self.__undef__ and not (dirty and not self._backup_location_credentials[1])):
            dct["backupLocationCredentials"] = dictify(self.backup_location_credentials)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "shared_backup_location" == "type" or (self.shared_backup_location is not self.__undef__ and not (dirty and not self._shared_backup_location[1])):
            dct["sharedBackupLocation"] = dictify(self.shared_backup_location)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "backup_location_user" == "type" or (self.backup_location_user is not self.__undef__ and not (dirty and not self._backup_location_user[1])):
            dct["backupLocationUser"] = dictify(self.backup_location_user)
        if "delphix_managed" == "type" or (self.delphix_managed is not self.__undef__ and not (dirty and not self._delphix_managed[1])):
            dct["delphixManaged"] = dictify(self.delphix_managed)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._backup_uuid = (self._backup_uuid[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._db_user = (self._db_user[0], True)
        self._encryption_key = (self._encryption_key[0], True)
        self._backup_location_credentials = (self._backup_location_credentials[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._shared_backup_location = (self._shared_backup_location[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._backup_location_user = (self._backup_location_user[0], True)
        self._delphix_managed = (self._delphix_managed[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._config = (self._config[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._backup_uuid[1], self._external_file_path[1], self._validated_sync_mode[1], self._db_user[1], self._encryption_key[1], self._backup_location_credentials[1], self._source_host_user[1], self._shared_backup_location[1], self._staging_post_script[1], self._ppt_host_user[1], self._db_credentials[1], self._backup_location_user[1], self._delphix_managed[1], self._staging_pre_script[1], self._config[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkData):
            return False
        return super(MSSqlLinkData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.backup_uuid == other.backup_uuid and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.db_user == other.db_user and \
               self.encryption_key == other.encryption_key and \
               self.backup_location_credentials == other.backup_location_credentials and \
               self.source_host_user == other.source_host_user and \
               self.shared_backup_location == other.shared_backup_location and \
               self.staging_post_script == other.staging_post_script and \
               self.ppt_host_user == other.ppt_host_user and \
               self.db_credentials == other.db_credentials and \
               self.backup_location_user == other.backup_location_user and \
               self.delphix_managed == other.delphix_managed and \
               self.staging_pre_script == other.staging_pre_script and \
               self.config == other.config and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def backup_uuid(self):
        """
        The UUID of the full or differential backup of the source database to
        restore from for the first dSource snapshot. The backup should be
        present in the shared backup location for the source database. This
        property is relevant only when loading from an existing backup.

        :rtype: ``basestring``
        """
        return self._backup_uuid[0]

    @backup_uuid.setter
    def backup_uuid(self, value):
        self._backup_uuid = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: TRANSACTION_LOG)* Specifies the backup types validated
        sync will use to synchronize the dSource with the source database.
        *(permitted values: TRANSACTION_LOG, FULL_OR_DIFFERENTIAL, FULL, NONE)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def db_user(self):
        """
        The user name for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def encryption_key(self):
        """
        The encryption key to use when restoring encrypted backups.

        :rtype: ``basestring``
        """
        return self._encryption_key[0]

    @encryption_key.setter
    def encryption_key(self, value):
        self._encryption_key = (value, True)

    @property
    def backup_location_credentials(self):
        """
        The password for accessing the shared backup location.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._backup_location_credentials[0]

    @backup_location_credentials.setter
    def backup_location_credentials(self, value):
        self._backup_location_credentials = (value, True)

    @property
    def source_host_user(self):
        """
        Information about the host OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def shared_backup_location(self):
        """
        Shared source database backup location.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._shared_backup_location[0]

    @shared_backup_location.setter
    def shared_backup_location(self, value):
        self._shared_backup_location = (value, True)

    @property
    def staging_post_script(self):
        """
        A user-provided PowerShell script or executable to run after restoring
        from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def ppt_host_user(self):
        """
        Information about the host OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def backup_location_user(self):
        """
        The user for accessing the shared backup location.

        :rtype: ``basestring``
        """
        return self._backup_location_user[0]

    @backup_location_user.setter
    def backup_location_user(self, value):
        self._backup_location_user = (value, True)

    @property
    def delphix_managed(self):
        """
        Specifies whether Delphix should managed the backups for this
        container.

        :rtype: ``bool``
        """
        return self._delphix_managed[0]

    @delphix_managed.setter
    def delphix_managed(self, value):
        self._delphix_managed = (value, True)

    @property
    def staging_pre_script(self):
        """
        A user-provided PowerShell script or executable to run prior to
        restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def ppt_repository(self):
        """
        The SQL instance on the PPT environment that we want to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class PgSQLLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* PostgreSQL specific
    parameters for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLLinkData, self).__init__()
        self._type = ("PgSQLLinkData", True)
        self._operations = (self.__undef__, True)
        self._ppt_host_user = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._config = (self._config[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._ppt_host_user[1], self._external_file_path[1], self._connection_database[1], self._db_user[1], self._db_credentials[1], self._config[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLLinkData):
            return False
        return super(PgSQLLinkData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.ppt_host_user == other.ppt_host_user and \
               self.external_file_path == other.external_file_path and \
               self.connection_database == other.connection_database and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials and \
               self.config == other.config and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def ppt_host_user(self):
        """
        Information about the host OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def external_file_path(self):
        """
        The external file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def connection_database(self):
        """
        *(default value: postgres)* The database that must be used to run SQL
        queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def db_user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credential of the database cluster user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def ppt_repository(self):
        """
        The Postgres installation on the PPT environment that will be used for
        pre-provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class VMwareLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* Represents the VMware
    specific parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareLinkData, self).__init__()
        self._type = ("VMwareLinkData", True)
        self._config = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)
        self._environment_user = (self._environment_user[0], True)

    def is_dirty(self):
        return any([self._config[1], self._environment_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareLinkData):
            return False
        return super(VMwareLinkData, self).__eq__(other) and \
               self.config == other.config and \
               self.environment_user == other.environment_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def environment_user(self):
        """
        The OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

class ASELinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* SAP ASE specific
    parameters for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(ASELinkData, self).__init__()
        self._type = ("ASELinkData", True)
        self._operations = (self.__undef__, True)
        self._staging_repository = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._load_location = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._dump_credentials = (self.__undef__, True)
        self._staging_host_user = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._sync_parameters = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._load_backup_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASELinkData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "stagingRepository" not in data:
            raise ValueError("Missing required property \"stagingRepository\".")
        obj._staging_repository = (data.get("stagingRepository", obj.__undef__), dirty)
        if obj._staging_repository[0] is not None and obj._staging_repository[0] is not obj.__undef__:
            assert isinstance(obj._staging_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_repository[0]))
            common.validate_format(obj._staging_repository[0], "objectReference", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        if "loadLocation" in data and data["loadLocation"] is not None:
            obj._load_location = (factory.create_object(data["loadLocation"], "ASEBackupLocation"), dirty)
            factory.validate_type(obj._load_location[0], "ASEBackupLocation")
        else:
            obj._load_location = (obj.__undef__, dirty)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'ENABLED', u'DISABLED'], "Expected enum [u'ENABLED', u'DISABLED'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        if "dumpCredentials" in data and data["dumpCredentials"] is not None:
            obj._dump_credentials = (factory.create_object(data["dumpCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._dump_credentials[0], "PasswordCredential")
        else:
            obj._dump_credentials = (obj.__undef__, dirty)
        if "stagingHostUser" not in data:
            raise ValueError("Missing required property \"stagingHostUser\".")
        obj._staging_host_user = (data.get("stagingHostUser", obj.__undef__), dirty)
        if obj._staging_host_user[0] is not None and obj._staging_host_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_host_user[0]))
            common.validate_format(obj._staging_host_user[0], "objectReference", None, None)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "sourceHostUser" not in data:
            raise ValueError("Missing required property \"sourceHostUser\".")
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        if "syncParameters" not in data:
            raise ValueError("Missing required property \"syncParameters\".")
        if "syncParameters" in data and data["syncParameters"] is not None:
            obj._sync_parameters = (factory.create_object(data["syncParameters"], "ASESyncParameters"), dirty)
            factory.validate_type(obj._sync_parameters[0], "ASESyncParameters")
        else:
            obj._sync_parameters = (obj.__undef__, dirty)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "loadBackupPath" not in data:
            raise ValueError("Missing required property \"loadBackupPath\".")
        obj._load_backup_path = (data.get("loadBackupPath", obj.__undef__), dirty)
        if obj._load_backup_path[0] is not None and obj._load_backup_path[0] is not obj.__undef__:
            assert isinstance(obj._load_backup_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._load_backup_path[0]))
            common.validate_format(obj._load_backup_path[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASELinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "staging_repository" == "type" or (self.staging_repository is not self.__undef__ and not (dirty and not self._staging_repository[1])):
            dct["stagingRepository"] = dictify(self.staging_repository)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "load_location" == "type" or (self.load_location is not self.__undef__ and not (dirty and not self._load_location[1])):
            dct["loadLocation"] = dictify(self.load_location)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "dump_credentials" == "type" or (self.dump_credentials is not self.__undef__ and not (dirty and not self._dump_credentials[1])):
            dct["dumpCredentials"] = dictify(self.dump_credentials)
        if "staging_host_user" == "type" or (self.staging_host_user is not self.__undef__ and not (dirty and not self._staging_host_user[1])):
            dct["stagingHostUser"] = dictify(self.staging_host_user)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "sync_parameters" == "type" or (self.sync_parameters is not self.__undef__ and not (dirty and not self._sync_parameters[1])):
            dct["syncParameters"] = dictify(self.sync_parameters)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "load_backup_path" == "type" or (self.load_backup_path is not self.__undef__ and not (dirty and not self._load_backup_path[1])):
            dct["loadBackupPath"] = dictify(self.load_backup_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._staging_repository = (self._staging_repository[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._load_location = (self._load_location[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._dump_credentials = (self._dump_credentials[0], True)
        self._staging_host_user = (self._staging_host_user[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._db_user = (self._db_user[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._sync_parameters = (self._sync_parameters[0], True)
        self._config = (self._config[0], True)
        self._load_backup_path = (self._load_backup_path[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._staging_repository[1], self._staging_pre_script[1], self._load_location[1], self._external_file_path[1], self._validated_sync_mode[1], self._dump_credentials[1], self._staging_host_user[1], self._staging_post_script[1], self._db_credentials[1], self._db_user[1], self._source_host_user[1], self._sync_parameters[1], self._config[1], self._load_backup_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASELinkData):
            return False
        return super(ASELinkData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.staging_repository == other.staging_repository and \
               self.staging_pre_script == other.staging_pre_script and \
               self.load_location == other.load_location and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.dump_credentials == other.dump_credentials and \
               self.staging_host_user == other.staging_host_user and \
               self.staging_post_script == other.staging_post_script and \
               self.db_credentials == other.db_credentials and \
               self.db_user == other.db_user and \
               self.source_host_user == other.source_host_user and \
               self.sync_parameters == other.sync_parameters and \
               self.config == other.config and \
               self.load_backup_path == other.load_backup_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def staging_repository(self):
        """
        The SAP ASE instance on the staging environment that we want to use for
        validated sync.

        :rtype: ``basestring``
        """
        return self._staging_repository[0]

    @staging_repository.setter
    def staging_repository(self, value):
        self._staging_repository = (value, True)

    @property
    def staging_pre_script(self):
        """
        A user-provided shell script or executable to run prior to restoring
        from a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def load_location(self):
        """
        Backup location to use for loading backups from the source.

        :rtype: :py:class:`v1_8_1.web.vo.ASEBackupLocation`
        """
        return self._load_location[0]

    @load_location.setter
    def load_location(self, value):
        self._load_location = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: ENABLED)* Specifies the validated sync mode to
        synchronize the dSource with the source database. *(permitted values:
        ENABLED, DISABLED)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def dump_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._dump_credentials[0]

    @dump_credentials.setter
    def dump_credentials(self, value):
        self._dump_credentials = (value, True)

    @property
    def staging_host_user(self):
        """
        Information about the host OS user on the staging environment to use
        for linking.

        :rtype: ``basestring``
        """
        return self._staging_host_user[0]

    @staging_host_user.setter
    def staging_host_user(self, value):
        self._staging_host_user = (value, True)

    @property
    def staging_post_script(self):
        """
        A user-provided shell script or executable to run after restoring from
        a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def db_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def db_user(self):
        """
        The user name for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def source_host_user(self):
        """
        Information about the host OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def sync_parameters(self):
        """
        Sync parameters for the container.

        :rtype: :py:class:`v1_8_1.web.vo.ASESyncParameters`
        """
        return self._sync_parameters[0]

    @sync_parameters.setter
    def sync_parameters(self, value):
        self._sync_parameters = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def load_backup_path(self):
        """
        Source database backup location.

        :rtype: ``basestring``
        """
        return self._load_backup_path[0]

    @load_backup_path.setter
    def load_backup_path(self, value):
        self._load_backup_path = (value, True)

class OracleBaseLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* Represents common
    parameters to link all Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleBaseLinkData, self).__init__()
        self._type = ("OracleBaseLinkData", True)
        self._operations = (self.__undef__, True)
        self._pre_provisioning_enabled = (self.__undef__, True)
        self._number_of_connections = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._diagnose_no_logging_faults = (self.__undef__, True)
        self._files_per_set = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)
        self._check_logical = (self.__undef__, True)
        self._backup_level_enabled = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)
        self._link_now = (self.__undef__, True)
        self._rman_channels = (self.__undef__, True)
        self._encrypted_linking_enabled = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._skip_space_check = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._double_sync = (self.__undef__, True)
        self._compressed_linking_enabled = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleBaseLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._pre_provisioning_enabled = (data.get("preProvisioningEnabled", obj.__undef__), dirty)
        if obj._pre_provisioning_enabled[0] is not None and obj._pre_provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._pre_provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._pre_provisioning_enabled[0]))
            common.validate_format(obj._pre_provisioning_enabled[0], "None", None, None)
        obj._number_of_connections = (data.get("numberOfConnections", obj.__undef__), dirty)
        if obj._number_of_connections[0] is not None and obj._number_of_connections[0] is not obj.__undef__:
            assert isinstance(obj._number_of_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._number_of_connections[0]))
            common.validate_format(obj._number_of_connections[0], "None", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._diagnose_no_logging_faults = (data.get("diagnoseNoLoggingFaults", obj.__undef__), dirty)
        if obj._diagnose_no_logging_faults[0] is not None and obj._diagnose_no_logging_faults[0] is not obj.__undef__:
            assert isinstance(obj._diagnose_no_logging_faults[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._diagnose_no_logging_faults[0]))
            common.validate_format(obj._diagnose_no_logging_faults[0], "None", None, None)
        obj._files_per_set = (data.get("filesPerSet", obj.__undef__), dirty)
        if obj._files_per_set[0] is not None and obj._files_per_set[0] is not obj.__undef__:
            assert isinstance(obj._files_per_set[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._files_per_set[0]))
            common.validate_format(obj._files_per_set[0], "None", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        obj._check_logical = (data.get("checkLogical", obj.__undef__), dirty)
        if obj._check_logical[0] is not None and obj._check_logical[0] is not obj.__undef__:
            assert isinstance(obj._check_logical[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._check_logical[0]))
            common.validate_format(obj._check_logical[0], "None", None, None)
        obj._backup_level_enabled = (data.get("backupLevelEnabled", obj.__undef__), dirty)
        if obj._backup_level_enabled[0] is not None and obj._backup_level_enabled[0] is not obj.__undef__:
            assert isinstance(obj._backup_level_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._backup_level_enabled[0]))
            common.validate_format(obj._backup_level_enabled[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "OracleSourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "OracleSourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        obj._link_now = (data.get("linkNow", obj.__undef__), dirty)
        if obj._link_now[0] is not None and obj._link_now[0] is not obj.__undef__:
            assert isinstance(obj._link_now[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._link_now[0]))
            common.validate_format(obj._link_now[0], "None", None, None)
        obj._rman_channels = (data.get("rmanChannels", obj.__undef__), dirty)
        if obj._rman_channels[0] is not None and obj._rman_channels[0] is not obj.__undef__:
            assert isinstance(obj._rman_channels[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._rman_channels[0]))
            common.validate_format(obj._rman_channels[0], "None", None, None)
        obj._encrypted_linking_enabled = (data.get("encryptedLinkingEnabled", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled[0] is not None and obj._encrypted_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled[0]))
            common.validate_format(obj._encrypted_linking_enabled[0], "None", None, None)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        obj._skip_space_check = (data.get("skipSpaceCheck", obj.__undef__), dirty)
        if obj._skip_space_check[0] is not None and obj._skip_space_check[0] is not obj.__undef__:
            assert isinstance(obj._skip_space_check[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._skip_space_check[0]))
            common.validate_format(obj._skip_space_check[0], "None", None, None)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._double_sync = (data.get("doubleSync", obj.__undef__), dirty)
        if obj._double_sync[0] is not None and obj._double_sync[0] is not obj.__undef__:
            assert isinstance(obj._double_sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._double_sync[0]))
            common.validate_format(obj._double_sync[0], "None", None, None)
        obj._compressed_linking_enabled = (data.get("compressedLinkingEnabled", obj.__undef__), dirty)
        if obj._compressed_linking_enabled[0] is not None and obj._compressed_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._compressed_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compressed_linking_enabled[0]))
            common.validate_format(obj._compressed_linking_enabled[0], "None", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleBaseLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "pre_provisioning_enabled" == "type" or (self.pre_provisioning_enabled is not self.__undef__ and not (dirty and not self._pre_provisioning_enabled[1])):
            dct["preProvisioningEnabled"] = dictify(self.pre_provisioning_enabled)
        if "number_of_connections" == "type" or (self.number_of_connections is not self.__undef__ and not (dirty and not self._number_of_connections[1])):
            dct["numberOfConnections"] = dictify(self.number_of_connections)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "diagnose_no_logging_faults" == "type" or (self.diagnose_no_logging_faults is not self.__undef__ and not (dirty and not self._diagnose_no_logging_faults[1])):
            dct["diagnoseNoLoggingFaults"] = dictify(self.diagnose_no_logging_faults)
        if "files_per_set" == "type" or (self.files_per_set is not self.__undef__ and not (dirty and not self._files_per_set[1])):
            dct["filesPerSet"] = dictify(self.files_per_set)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        if "check_logical" == "type" or (self.check_logical is not self.__undef__ and not (dirty and not self._check_logical[1])):
            dct["checkLogical"] = dictify(self.check_logical)
        if "backup_level_enabled" == "type" or (self.backup_level_enabled is not self.__undef__ and not (dirty and not self._backup_level_enabled[1])):
            dct["backupLevelEnabled"] = dictify(self.backup_level_enabled)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        if "link_now" == "type" or (self.link_now is not self.__undef__ and not (dirty and not self._link_now[1])):
            dct["linkNow"] = dictify(self.link_now)
        if "rman_channels" == "type" or (self.rman_channels is not self.__undef__ and not (dirty and not self._rman_channels[1])):
            dct["rmanChannels"] = dictify(self.rman_channels)
        if "encrypted_linking_enabled" == "type" or (self.encrypted_linking_enabled is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled[1])):
            dct["encryptedLinkingEnabled"] = dictify(self.encrypted_linking_enabled)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "skip_space_check" == "type" or (self.skip_space_check is not self.__undef__ and not (dirty and not self._skip_space_check[1])):
            dct["skipSpaceCheck"] = dictify(self.skip_space_check)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "double_sync" == "type" or (self.double_sync is not self.__undef__ and not (dirty and not self._double_sync[1])):
            dct["doubleSync"] = dictify(self.double_sync)
        if "compressed_linking_enabled" == "type" or (self.compressed_linking_enabled is not self.__undef__ and not (dirty and not self._compressed_linking_enabled[1])):
            dct["compressedLinkingEnabled"] = dictify(self.compressed_linking_enabled)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._pre_provisioning_enabled = (self._pre_provisioning_enabled[0], True)
        self._number_of_connections = (self._number_of_connections[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._diagnose_no_logging_faults = (self._diagnose_no_logging_faults[0], True)
        self._files_per_set = (self._files_per_set[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)
        self._check_logical = (self._check_logical[0], True)
        self._backup_level_enabled = (self._backup_level_enabled[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)
        self._link_now = (self._link_now[0], True)
        self._rman_channels = (self._rman_channels[0], True)
        self._encrypted_linking_enabled = (self._encrypted_linking_enabled[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._db_user = (self._db_user[0], True)
        self._skip_space_check = (self._skip_space_check[0], True)
        self._config = (self._config[0], True)
        self._double_sync = (self._double_sync[0], True)
        self._compressed_linking_enabled = (self._compressed_linking_enabled[0], True)
        self._db_credentials = (self._db_credentials[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._pre_provisioning_enabled[1], self._number_of_connections[1], self._external_file_path[1], self._diagnose_no_logging_faults[1], self._files_per_set[1], self._bandwidth_limit[1], self._check_logical[1], self._backup_level_enabled[1], self._sourcing_policy[1], self._link_now[1], self._rman_channels[1], self._encrypted_linking_enabled[1], self._environment_user[1], self._db_user[1], self._skip_space_check[1], self._config[1], self._double_sync[1], self._compressed_linking_enabled[1], self._db_credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleBaseLinkData):
            return False
        return super(OracleBaseLinkData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.pre_provisioning_enabled == other.pre_provisioning_enabled and \
               self.number_of_connections == other.number_of_connections and \
               self.external_file_path == other.external_file_path and \
               self.diagnose_no_logging_faults == other.diagnose_no_logging_faults and \
               self.files_per_set == other.files_per_set and \
               self.bandwidth_limit == other.bandwidth_limit and \
               self.check_logical == other.check_logical and \
               self.backup_level_enabled == other.backup_level_enabled and \
               self.sourcing_policy == other.sourcing_policy and \
               self.link_now == other.link_now and \
               self.rman_channels == other.rman_channels and \
               self.encrypted_linking_enabled == other.encrypted_linking_enabled and \
               self.environment_user == other.environment_user and \
               self.db_user == other.db_user and \
               self.skip_space_check == other.skip_space_check and \
               self.config == other.config and \
               self.double_sync == other.double_sync and \
               self.compressed_linking_enabled == other.compressed_linking_enabled and \
               self.db_credentials == other.db_credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def pre_provisioning_enabled(self):
        """
        If true, pre-provisioning will be performed after every sync.

        :rtype: ``bool``
        """
        return self._pre_provisioning_enabled[0]

    @pre_provisioning_enabled.setter
    def pre_provisioning_enabled(self, value):
        self._pre_provisioning_enabled = (value, True)

    @property
    def number_of_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use
        during SnapSync.

        :rtype: ``int``
        """
        return self._number_of_connections[0]

    @number_of_connections.setter
    def number_of_connections(self, value):
        self._number_of_connections = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def diagnose_no_logging_faults(self):
        """
        *(default value: True)* If true, NOLOGGING operations on this container
        are treated as faults and cannot be resolved manually. Otherwise, these
        operations are ignored.

        :rtype: ``bool``
        """
        return self._diagnose_no_logging_faults[0]

    @diagnose_no_logging_faults.setter
    def diagnose_no_logging_faults(self, value):
        self._diagnose_no_logging_faults = (value, True)

    @property
    def files_per_set(self):
        """
        *(default value: 5)* Number of data files to include in each RMAN
        backup set.

        :rtype: ``int``
        """
        return self._files_per_set[0]

    @files_per_set.setter
    def files_per_set(self, value):
        self._files_per_set = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for SnapSync and LogSync network traffic. A
        value of 0 means no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

    @property
    def check_logical(self):
        """
        True if extended block checking should be used for this linked
        database.

        :rtype: ``bool``
        """
        return self._check_logical[0]

    @check_logical.setter
    def check_logical(self, value):
        self._check_logical = (value, True)

    @property
    def backup_level_enabled(self):
        """
        Defines whether backup level is enabled.

        :rtype: ``bool``
        """
        return self._backup_level_enabled[0]

    @backup_level_enabled.setter
    def backup_level_enabled(self, value):
        self._backup_level_enabled = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing LogSync and SnapSync across sources.

        :rtype: :py:class:`v1_8_1.web.vo.OracleSourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

    @property
    def link_now(self):
        """
        True if initial load should be done immediately.

        :rtype: ``bool``
        """
        return self._link_now[0]

    @link_now.setter
    def link_now(self, value):
        self._link_now = (value, True)

    @property
    def rman_channels(self):
        """
        *(default value: 2)* Number of parallel channels to use.

        :rtype: ``int``
        """
        return self._rman_channels[0]

    @rman_channels.setter
    def rman_channels(self, value):
        self._rman_channels = (value, True)

    @property
    def encrypted_linking_enabled(self):
        """
        True if SnapSync data from the source should be retrieved through an
        encrypted connection. Enabling this feature can decrease the
        performance of SnapSync from the source but has no impact on the
        performance of VDBs created from the retrieved data.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled[0]

    @encrypted_linking_enabled.setter
    def encrypted_linking_enabled(self, value):
        self._encrypted_linking_enabled = (value, True)

    @property
    def environment_user(self):
        """
        Information about the OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def db_user(self):
        """
        The name of the DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def skip_space_check(self):
        """
        Skip check that tests if there is enough space available to store the
        database in the Delphix Engine. The Delphix Engine estimates how much
        space a database will occupy after compression and prevents SnapSync if
        insufficient space is available. This safeguard can be overridden using
        this option. This may be useful when linking highly compressible
        databases.

        :rtype: ``bool``
        """
        return self._skip_space_check[0]

    @skip_space_check.setter
    def skip_space_check(self, value):
        self._skip_space_check = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def double_sync(self):
        """
        True if two SnapSyncs should be performed in immediate succession to
        reduce the number of logs required to provision the snapshot. This may
        significantly reduce the time necessary to provision from a snapshot.

        :rtype: ``bool``
        """
        return self._double_sync[0]

    @double_sync.setter
    def double_sync(self, value):
        self._double_sync = (value, True)

    @property
    def compressed_linking_enabled(self):
        """
        *(default value: True)* True if SnapSync data from the source should be
        compressed over the network. Enabling this feature will reduce network
        bandwidth consumption and may significantly improve throughput,
        especially over slow network.

        :rtype: ``bool``
        """
        return self._compressed_linking_enabled[0]

    @compressed_linking_enabled.setter
    def compressed_linking_enabled(self, value):
        self._compressed_linking_enabled = (value, True)

    @property
    def db_credentials(self):
        """
        The password for the DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

class MySQLLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* MySQL specific parameters
    for a link request.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLLinkData, self).__init__()
        self._type = ("MySQLLinkData", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._staging_repository = (self.__undef__, True)
        self._staging_port = (self.__undef__, True)
        self._staging_host_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._sync_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLLinkData, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "stagingRepository" not in data:
            raise ValueError("Missing required property \"stagingRepository\".")
        obj._staging_repository = (data.get("stagingRepository", obj.__undef__), dirty)
        if obj._staging_repository[0] is not None and obj._staging_repository[0] is not obj.__undef__:
            assert isinstance(obj._staging_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_repository[0]))
            common.validate_format(obj._staging_repository[0], "objectReference", None, None)
        if "stagingPort" not in data:
            raise ValueError("Missing required property \"stagingPort\".")
        obj._staging_port = (data.get("stagingPort", obj.__undef__), dirty)
        if obj._staging_port[0] is not None and obj._staging_port[0] is not obj.__undef__:
            assert isinstance(obj._staging_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._staging_port[0]))
            common.validate_format(obj._staging_port[0], "None", None, None)
        obj._staging_host_user = (data.get("stagingHostUser", obj.__undef__), dirty)
        if obj._staging_host_user[0] is not None and obj._staging_host_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_host_user[0]))
            common.validate_format(obj._staging_host_user[0], "objectReference", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "syncParameters" not in data:
            raise ValueError("Missing required property \"syncParameters\".")
        if "syncParameters" in data and data["syncParameters"] is not None:
            obj._sync_parameters = (factory.create_object(data["syncParameters"], "MySQLSyncParameters"), dirty)
            factory.validate_type(obj._sync_parameters[0], "MySQLSyncParameters")
        else:
            obj._sync_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "staging_repository" == "type" or (self.staging_repository is not self.__undef__ and not (dirty and not self._staging_repository[1])):
            dct["stagingRepository"] = dictify(self.staging_repository)
        if "staging_port" == "type" or (self.staging_port is not self.__undef__ and not (dirty and not self._staging_port[1])):
            dct["stagingPort"] = dictify(self.staging_port)
        if "staging_host_user" == "type" or (self.staging_host_user is not self.__undef__ and not (dirty and not self._staging_host_user[1])):
            dct["stagingHostUser"] = dictify(self.staging_host_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "sync_parameters" == "type" or (self.sync_parameters is not self.__undef__ and not (dirty and not self._sync_parameters[1])):
            dct["syncParameters"] = dictify(self.sync_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._staging_repository = (self._staging_repository[0], True)
        self._staging_port = (self._staging_port[0], True)
        self._staging_host_user = (self._staging_host_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._db_user = (self._db_user[0], True)
        self._config = (self._config[0], True)
        self._sync_parameters = (self._sync_parameters[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._staging_repository[1], self._staging_port[1], self._staging_host_user[1], self._db_credentials[1], self._db_user[1], self._config[1], self._sync_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLLinkData):
            return False
        return super(MySQLLinkData, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.staging_repository == other.staging_repository and \
               self.staging_port == other.staging_port and \
               self.staging_host_user == other.staging_host_user and \
               self.db_credentials == other.db_credentials and \
               self.db_user == other.db_user and \
               self.config == other.config and \
               self.sync_parameters == other.sync_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MySQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def staging_repository(self):
        """
        The MySQL installation on the staging environment that will be used for
        validated sync.

        :rtype: ``basestring``
        """
        return self._staging_repository[0]

    @staging_repository.setter
    def staging_repository(self, value):
        self._staging_repository = (value, True)

    @property
    def staging_port(self):
        """
        The port on the staging host that the MySQL staging server can listen
        on for TCP/IP connections.

        :rtype: ``int``
        """
        return self._staging_port[0]

    @staging_port.setter
    def staging_port(self, value):
        self._staging_port = (value, True)

    @property
    def staging_host_user(self):
        """
        OS user on the staging host to use for linking.

        :rtype: ``basestring``
        """
        return self._staging_host_user[0]

    @staging_host_user.setter
    def staging_host_user(self, value):
        self._staging_host_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credentials for the database user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def db_user(self):
        """
        The database username.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def sync_parameters(self):
        """
        Sync parameters for the container.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLSyncParameters`
        """
        return self._sync_parameters[0]

    @sync_parameters.setter
    def sync_parameters(self, value):
        self._sync_parameters = (value, True)

class AppDataLinkData(LinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LinkData` *)* Represents the AppData
    specific parameters of a link request.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkData, self).__init__()
        self._type = ("AppDataLinkData", True)
        self._operations = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        if "parameters" not in data:
            raise ValueError("Missing required property \"parameters\".")
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._environment_user[1], self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkData):
            return False
        return super(AppDataLinkData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.environment_user == other.environment_user and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def environment_user(self):
        """
        The OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def parameters(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class AppDataDirectLinkData(AppDataLinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataLinkData` *)* Represents the
    AppData specific parameters of a link request for a source directly
    replicated into the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataDirectLinkData, self).__init__()
        self._type = ("AppDataDirectLinkData", True)
        self._excludes = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._follow_symlinks = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataDirectLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "excludes" not in data:
            raise ValueError("Missing required property \"excludes\".")
        obj._excludes = []
        for item in data.get("excludes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._excludes.append(item)
        obj._excludes = (obj._excludes, dirty)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "followSymlinks" not in data:
            raise ValueError("Missing required property \"followSymlinks\".")
        obj._follow_symlinks = []
        for item in data.get("followSymlinks") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._follow_symlinks.append(item)
        obj._follow_symlinks = (obj._follow_symlinks, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataDirectLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "excludes" == "type" or (self.excludes is not self.__undef__ and not (dirty and not self._excludes[1])):
            dct["excludes"] = dictify(self.excludes)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "follow_symlinks" == "type" or (self.follow_symlinks is not self.__undef__ and not (dirty and not self._follow_symlinks[1])):
            dct["followSymlinks"] = dictify(self.follow_symlinks)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._excludes = (self._excludes[0], True)
        self._config = (self._config[0], True)
        self._follow_symlinks = (self._follow_symlinks[0], True)

    def is_dirty(self):
        return any([self._excludes[1], self._config[1], self._follow_symlinks[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataDirectLinkData):
            return False
        return super(AppDataDirectLinkData, self).__eq__(other) and \
               self.excludes == other.excludes and \
               self.config == other.config and \
               self.follow_symlinks == other.follow_symlinks

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def excludes(self):
        """
        List of subdirectories in the source to exclude when syncing data.
        These paths are relative to the root of the source directory.

        :rtype: ``list`` of ``basestring``
        """
        return self._excludes[0]

    @excludes.setter
    def excludes(self, value):
        self._excludes = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def follow_symlinks(self):
        """
        List of symlinks in the source to follow when syncing data. These paths
        are relative to the root of the source directory. All other symlinks
        are preserved.

        :rtype: ``list`` of ``basestring``
        """
        return self._follow_symlinks[0]

    @follow_symlinks.setter
    def follow_symlinks(self, value):
        self._follow_symlinks = (value, True)

class AppDataStagedLinkData(AppDataLinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataLinkData` *)* Represents the
    AppData specific parameters of a link request for a source with a staging
    source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataStagedLinkData, self).__init__()
        self._type = ("AppDataStagedLinkData", True)
        self._staging_environment = (self.__undef__, True)
        self._staging_mount_base = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._staging_environment_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataStagedLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "stagingEnvironment" not in data:
            raise ValueError("Missing required property \"stagingEnvironment\".")
        obj._staging_environment = (data.get("stagingEnvironment", obj.__undef__), dirty)
        if obj._staging_environment[0] is not None and obj._staging_environment[0] is not obj.__undef__:
            assert isinstance(obj._staging_environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_environment[0]))
            common.validate_format(obj._staging_environment[0], "objectReference", None, None)
        if "stagingMountBase" not in data:
            raise ValueError("Missing required property \"stagingMountBase\".")
        obj._staging_mount_base = (data.get("stagingMountBase", obj.__undef__), dirty)
        if obj._staging_mount_base[0] is not None and obj._staging_mount_base[0] is not obj.__undef__:
            assert isinstance(obj._staging_mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_mount_base[0]))
            common.validate_format(obj._staging_mount_base[0], "None", None, 256)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "stagingEnvironmentUser" not in data:
            raise ValueError("Missing required property \"stagingEnvironmentUser\".")
        obj._staging_environment_user = (data.get("stagingEnvironmentUser", obj.__undef__), dirty)
        if obj._staging_environment_user[0] is not None and obj._staging_environment_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_environment_user[0]))
            common.validate_format(obj._staging_environment_user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataStagedLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "staging_environment" == "type" or (self.staging_environment is not self.__undef__ and not (dirty and not self._staging_environment[1])):
            dct["stagingEnvironment"] = dictify(self.staging_environment)
        if "staging_mount_base" == "type" or (self.staging_mount_base is not self.__undef__ and not (dirty and not self._staging_mount_base[1])):
            dct["stagingMountBase"] = dictify(self.staging_mount_base)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "staging_environment_user" == "type" or (self.staging_environment_user is not self.__undef__ and not (dirty and not self._staging_environment_user[1])):
            dct["stagingEnvironmentUser"] = dictify(self.staging_environment_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._staging_environment = (self._staging_environment[0], True)
        self._staging_mount_base = (self._staging_mount_base[0], True)
        self._config = (self._config[0], True)
        self._staging_environment_user = (self._staging_environment_user[0], True)

    def is_dirty(self):
        return any([self._staging_environment[1], self._staging_mount_base[1], self._config[1], self._staging_environment_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataStagedLinkData):
            return False
        return super(AppDataStagedLinkData, self).__eq__(other) and \
               self.staging_environment == other.staging_environment and \
               self.staging_mount_base == other.staging_mount_base and \
               self.config == other.config and \
               self.staging_environment_user == other.staging_environment_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def staging_environment(self):
        """
        The environment used as an intermediate stage to pull data into
        Delphix.

        :rtype: ``basestring``
        """
        return self._staging_environment[0]

    @staging_environment.setter
    def staging_environment(self, value):
        self._staging_environment = (value, True)

    @property
    def staging_mount_base(self):
        """
        The base mount point for the NFS mount on the staging environment.

        :rtype: ``basestring``
        """
        return self._staging_mount_base[0]

    @staging_mount_base.setter
    def staging_mount_base(self, value):
        self._staging_mount_base = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def staging_environment_user(self):
        """
        The environment user used to access the staging environment.

        :rtype: ``basestring``
        """
        return self._staging_environment_user[0]

    @staging_environment_user.setter
    def staging_environment_user(self, value):
        self._staging_environment_user = (value, True)

class OracleLinkData(OracleBaseLinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseLinkData` *)* Represents
    parameters to link non-pluggable Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLinkData, self).__init__()
        self._type = ("OracleLinkData", True)
        self._non_sys_user = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._non_sys_credentials = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLinkData, cls).from_dict(data, dirty, undef_enabled)
        obj._non_sys_user = (data.get("nonSysUser", obj.__undef__), dirty)
        if obj._non_sys_user[0] is not None and obj._non_sys_user[0] is not obj.__undef__:
            assert isinstance(obj._non_sys_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._non_sys_user[0]))
            common.validate_format(obj._non_sys_user[0], "None", None, 30)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "nonSysCredentials" in data and data["nonSysCredentials"] is not None:
            obj._non_sys_credentials = (factory.create_object(data["nonSysCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._non_sys_credentials[0], "PasswordCredential")
        else:
            obj._non_sys_credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "non_sys_user" == "type" or (self.non_sys_user is not self.__undef__ and not (dirty and not self._non_sys_user[1])):
            dct["nonSysUser"] = dictify(self.non_sys_user)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "non_sys_credentials" == "type" or (self.non_sys_credentials is not self.__undef__ and not (dirty and not self._non_sys_credentials[1])):
            dct["nonSysCredentials"] = dictify(self.non_sys_credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._non_sys_user = (self._non_sys_user[0], True)
        self._config = (self._config[0], True)
        self._non_sys_credentials = (self._non_sys_credentials[0], True)

    def is_dirty(self):
        return any([self._non_sys_user[1], self._config[1], self._non_sys_credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLinkData):
            return False
        return super(OracleLinkData, self).__eq__(other) and \
               self.non_sys_user == other.non_sys_user and \
               self.config == other.config and \
               self.non_sys_credentials == other.non_sys_credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def non_sys_user(self):
        """
        Non-SYS database user to access this database.

        :rtype: ``basestring``
        """
        return self._non_sys_user[0]

    @non_sys_user.setter
    def non_sys_user(self, value):
        self._non_sys_user = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def non_sys_credentials(self):
        """
        Non-SYS database credentials to access this database.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._non_sys_credentials[0]

    @non_sys_credentials.setter
    def non_sys_credentials(self, value):
        self._non_sys_credentials = (value, True)

class OraclePDBLinkData(OracleBaseLinkData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseLinkData` *)* Represents
    parameters to link a Oracle pluggable database.
    """
    def __init__(self, undef_enabled=True):
        super(OraclePDBLinkData, self).__init__()
        self._type = ("OraclePDBLinkData", True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OraclePDBLinkData, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OraclePDBLinkData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OraclePDBLinkData):
            return False
        return super(OraclePDBLinkData, self).__eq__(other) and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class OracleStartParameters(SourceStartParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceStartParameters` *)* The
    parameters to use as input to start oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleStartParameters, self).__init__()
        self._type = ("OracleStartParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._instances = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleStartParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._instances = []
        for item in data.get("instances") or []:
            assert isinstance(item, float), ("Expected one of [u'number'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._instances.append(item)
        obj._instances = (obj._instances, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleStartParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)
        self._instances = (self._instances[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1], self._instances[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleStartParameters):
            return False
        return super(OracleStartParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential and \
               self.instances == other.instances

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def instances(self):
        """
        List of specific Oracle instances to start.

        :rtype: ``list`` of ``float``
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

class MSSqlSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a SQL server source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSourceConnectionInfo, self).__init__()
        self._type = ("MSSqlSourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._instance_jdbc_string = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._instance_jdbc_string = (data.get("instanceJDBCString", obj.__undef__), dirty)
        if obj._instance_jdbc_string[0] is not None and obj._instance_jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._instance_jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_jdbc_string[0]))
            common.validate_format(obj._instance_jdbc_string[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "instance_jdbc_string" == "type" or (self.instance_jdbc_string is not self.__undef__ and not (dirty and not self._instance_jdbc_string[1])):
            dct["instanceJDBCString"] = dictify(self.instance_jdbc_string)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._instance_jdbc_string = (self._instance_jdbc_string[0], True)
        self._instance_name = (self._instance_name[0], True)
        self._port = (self._port[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._host[1], self._instance_jdbc_string[1], self._instance_name[1], self._port[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSourceConnectionInfo):
            return False
        return super(MSSqlSourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.instance_jdbc_string == other.instance_jdbc_string and \
               self.instance_name == other.instance_name and \
               self.port == other.port and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def instance_jdbc_string(self):
        """
        The JDBC string used to connect to the SQL server instance.

        :rtype: ``basestring``
        """
        return self._instance_jdbc_string[0]

    @instance_jdbc_string.setter
    def instance_jdbc_string(self, value):
        self._instance_jdbc_string = (value, True)

    @property
    def instance_name(self):
        """
        The name of the instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

    @property
    def port(self):
        """
        The port number used to connect to the source.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class VMwareSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to the VM.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareSourceConnectionInfo, self).__init__()
        self._type = ("VMwareSourceConnectionInfo", True)
        self._ip_address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._ip_address = (data.get("ipAddress", obj.__undef__), dirty)
        if obj._ip_address[0] is not None and obj._ip_address[0] is not obj.__undef__:
            assert isinstance(obj._ip_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ip_address[0]))
            common.validate_format(obj._ip_address[0], "ipAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ip_address" == "type" or (self.ip_address is not self.__undef__ and not (dirty and not self._ip_address[1])):
            dct["ipAddress"] = dictify(self.ip_address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ip_address = (self._ip_address[0], True)

    def is_dirty(self):
        return any([self._ip_address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareSourceConnectionInfo):
            return False
        return super(VMwareSourceConnectionInfo, self).__eq__(other) and \
               self.ip_address == other.ip_address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ip_address(self):
        """
        The IP address used to connect to the VM.

        :rtype: ``basestring``
        """
        return self._ip_address[0]

    @ip_address.setter
    def ip_address(self, value):
        self._ip_address = (value, True)

class MySQLSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSourceConnectionInfo, self).__init__()
        self._type = ("MySQLSourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._jdbc_string = (self.__undef__, True)
        self._data_directory = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._jdbc_string = (data.get("jdbcString", obj.__undef__), dirty)
        if obj._jdbc_string[0] is not None and obj._jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_string[0]))
            common.validate_format(obj._jdbc_string[0], "None", None, None)
        obj._data_directory = (data.get("dataDirectory", obj.__undef__), dirty)
        if obj._data_directory[0] is not None and obj._data_directory[0] is not obj.__undef__:
            assert isinstance(obj._data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_directory[0]))
            common.validate_format(obj._data_directory[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "jdbc_string" == "type" or (self.jdbc_string is not self.__undef__ and not (dirty and not self._jdbc_string[1])):
            dct["jdbcString"] = dictify(self.jdbc_string)
        if "data_directory" == "type" or (self.data_directory is not self.__undef__ and not (dirty and not self._data_directory[1])):
            dct["dataDirectory"] = dictify(self.data_directory)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._jdbc_string = (self._jdbc_string[0], True)
        self._data_directory = (self._data_directory[0], True)
        self._user = (self._user[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._host[1], self._jdbc_string[1], self._data_directory[1], self._user[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSourceConnectionInfo):
            return False
        return super(MySQLSourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.jdbc_string == other.jdbc_string and \
               self.data_directory == other.data_directory and \
               self.user == other.user and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def jdbc_string(self):
        """
        The JDBC string used to connect to the MySQL server instance.

        :rtype: ``basestring``
        """
        return self._jdbc_string[0]

    @jdbc_string.setter
    def jdbc_string(self, value):
        self._jdbc_string = (value, True)

    @property
    def data_directory(self):
        """
        The data directory for the MySQL server.

        :rtype: ``basestring``
        """
        return self._data_directory[0]

    @data_directory.setter
    def data_directory(self, value):
        self._data_directory = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def port(self):
        """
        The port on which the MySQL server for the data directory is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class AppDataSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to the application source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceConnectionInfo, self).__init__()
        self._type = ("AppDataSourceConnectionInfo", True)
        self._path = (self.__undef__, True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "None", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._path = (self._path[0], True)
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._path[1], self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceConnectionInfo):
            return False
        return super(AppDataSourceConnectionInfo, self).__eq__(other) and \
               self.path == other.path and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def path(self):
        """
        The path where the application data is located on the host.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class PgSQLSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSourceConnectionInfo, self).__init__()
        self._type = ("PgSQLSourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._jdbc_string = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._pg_data_directory = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._jdbc_string = (data.get("jdbcString", obj.__undef__), dirty)
        if obj._jdbc_string[0] is not None and obj._jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_string[0]))
            common.validate_format(obj._jdbc_string[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._pg_data_directory = (data.get("pgDataDirectory", obj.__undef__), dirty)
        if obj._pg_data_directory[0] is not None and obj._pg_data_directory[0] is not obj.__undef__:
            assert isinstance(obj._pg_data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pg_data_directory[0]))
            common.validate_format(obj._pg_data_directory[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "jdbc_string" == "type" or (self.jdbc_string is not self.__undef__ and not (dirty and not self._jdbc_string[1])):
            dct["jdbcString"] = dictify(self.jdbc_string)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "pg_data_directory" == "type" or (self.pg_data_directory is not self.__undef__ and not (dirty and not self._pg_data_directory[1])):
            dct["pgDataDirectory"] = dictify(self.pg_data_directory)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._jdbc_string = (self._jdbc_string[0], True)
        self._port = (self._port[0], True)
        self._pg_data_directory = (self._pg_data_directory[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._host[1], self._jdbc_string[1], self._port[1], self._pg_data_directory[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSourceConnectionInfo):
            return False
        return super(PgSQLSourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.jdbc_string == other.jdbc_string and \
               self.port == other.port and \
               self.pg_data_directory == other.pg_data_directory and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def jdbc_string(self):
        """
        The JDBC string used to connect to the PostgreSQL server instance.

        :rtype: ``basestring``
        """
        return self._jdbc_string[0]

    @jdbc_string.setter
    def jdbc_string(self, value):
        self._jdbc_string = (value, True)

    @property
    def port(self):
        """
        The port on which the PostgresSQL server for the cluster is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def pg_data_directory(self):
        """
        The data directory for the PostgreSQL cluster.

        :rtype: ``basestring``
        """
        return self._pg_data_directory[0]

    @pg_data_directory.setter
    def pg_data_directory(self, value):
        self._pg_data_directory = (value, True)

    @property
    def user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleSourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to a single instance Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourceConnectionInfo, self).__init__()
        self._type = ("OracleSourceConnectionInfo", True)
        self._jdbc_strings = (self.__undef__, True)
        self._oracle_home = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._jdbc_strings = []
        for item in data.get("jdbcStrings") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._jdbc_strings.append(item)
        obj._jdbc_strings = (obj._jdbc_strings, dirty)
        obj._oracle_home = (data.get("oracleHome", obj.__undef__), dirty)
        if obj._oracle_home[0] is not None and obj._oracle_home[0] is not obj.__undef__:
            assert isinstance(obj._oracle_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._oracle_home[0]))
            common.validate_format(obj._oracle_home[0], "None", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "jdbc_strings" == "type" or (self.jdbc_strings is not self.__undef__ and not (dirty and not self._jdbc_strings[1])):
            dct["jdbcStrings"] = dictify(self.jdbc_strings)
        if "oracle_home" == "type" or (self.oracle_home is not self.__undef__ and not (dirty and not self._oracle_home[1])):
            dct["oracleHome"] = dictify(self.oracle_home)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._jdbc_strings = (self._jdbc_strings[0], True)
        self._oracle_home = (self._oracle_home[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._jdbc_strings[1], self._oracle_home[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourceConnectionInfo):
            return False
        return super(OracleSourceConnectionInfo, self).__eq__(other) and \
               self.jdbc_strings == other.jdbc_strings and \
               self.oracle_home == other.oracle_home and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def jdbc_strings(self):
        """
        The JDBC strings used to connect to the source.

        :rtype: ``list`` of ``basestring``
        """
        return self._jdbc_strings[0]

    @jdbc_strings.setter
    def jdbc_strings(self, value):
        self._jdbc_strings = (value, True)

    @property
    def oracle_home(self):
        """
        The Oracle installation home.

        :rtype: ``basestring``
        """
        return self._oracle_home[0]

    @oracle_home.setter
    def oracle_home(self, value):
        self._oracle_home = (value, True)

    @property
    def database_name(self):
        """
        The database name.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class ASESourceConnectionInfo(SourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConnectionInfo` *)* Contains
    information that can be used to connect to an SAP ASE source.
    """
    def __init__(self, undef_enabled=True):
        super(ASESourceConnectionInfo, self).__init__()
        self._type = ("ASESourceConnectionInfo", True)
        self._host = (self.__undef__, True)
        self._jdbc_string = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._database_name = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._jdbc_string = (data.get("jdbcString", obj.__undef__), dirty)
        if obj._jdbc_string[0] is not None and obj._jdbc_string[0] is not obj.__undef__:
            assert isinstance(obj._jdbc_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._jdbc_string[0]))
            common.validate_format(obj._jdbc_string[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "jdbc_string" == "type" or (self.jdbc_string is not self.__undef__ and not (dirty and not self._jdbc_string[1])):
            dct["jdbcString"] = dictify(self.jdbc_string)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._jdbc_string = (self._jdbc_string[0], True)
        self._user = (self._user[0], True)
        self._database_name = (self._database_name[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._host[1], self._jdbc_string[1], self._user[1], self._database_name[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESourceConnectionInfo):
            return False
        return super(ASESourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host and \
               self.jdbc_string == other.jdbc_string and \
               self.user == other.user and \
               self.database_name == other.database_name and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        Host to use for connecting to the source.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def jdbc_string(self):
        """
        The JDBC string used to connect to the source.

        :rtype: ``basestring``
        """
        return self._jdbc_string[0]

    @jdbc_string.setter
    def jdbc_string(self, value):
        self._jdbc_string = (value, True)

    @property
    def user(self):
        """
        User to use for connecting to the source.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def database_name(self):
        """
        The database name of the source.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

    @property
    def port(self):
        """
        Port to use for connecting to the source.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class OracleSISourceConnectionInfo(OracleSourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleSourceConnectionInfo` *)*
    Contains information that can be used to connect to a single instance
    Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSISourceConnectionInfo, self).__init__()
        self._type = ("OracleSISourceConnectionInfo", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSISourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSISourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSISourceConnectionInfo):
            return False
        return super(OracleSISourceConnectionInfo, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The hostname or IP address of the host where the source resides.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class OracleRACSourceConnectionInfo(OracleSourceConnectionInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleSourceConnectionInfo` *)*
    Contains information that can be used to connect to a single instance
    Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACSourceConnectionInfo, self).__init__()
        self._type = ("OracleRACSourceConnectionInfo", True)
        self._remote_listener = (self.__undef__, True)
        self._nodes = (self.__undef__, True)
        self._crs_cluster_home = (self.__undef__, True)
        self._scan = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACSourceConnectionInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_listener = (data.get("remoteListener", obj.__undef__), dirty)
        if obj._remote_listener[0] is not None and obj._remote_listener[0] is not obj.__undef__:
            assert isinstance(obj._remote_listener[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_listener[0]))
            common.validate_format(obj._remote_listener[0], "None", None, None)
        obj._nodes = []
        for item in data.get("nodes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._nodes.append(item)
        obj._nodes = (obj._nodes, dirty)
        obj._crs_cluster_home = (data.get("crsClusterHome", obj.__undef__), dirty)
        if obj._crs_cluster_home[0] is not None and obj._crs_cluster_home[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_home[0]))
            common.validate_format(obj._crs_cluster_home[0], "None", None, None)
        obj._scan = (data.get("scan", obj.__undef__), dirty)
        if obj._scan[0] is not None and obj._scan[0] is not obj.__undef__:
            assert isinstance(obj._scan[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._scan[0]))
            common.validate_format(obj._scan[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACSourceConnectionInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_listener" == "type" or (self.remote_listener is not self.__undef__ and not (dirty and not self._remote_listener[1])):
            dct["remoteListener"] = dictify(self.remote_listener)
        if "nodes" == "type" or (self.nodes is not self.__undef__ and not (dirty and not self._nodes[1])):
            dct["nodes"] = dictify(self.nodes)
        if "crs_cluster_home" == "type" or (self.crs_cluster_home is not self.__undef__ and not (dirty and not self._crs_cluster_home[1])):
            dct["crsClusterHome"] = dictify(self.crs_cluster_home)
        if "scan" == "type" or (self.scan is not self.__undef__ and not (dirty and not self._scan[1])):
            dct["scan"] = dictify(self.scan)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_listener = (self._remote_listener[0], True)
        self._nodes = (self._nodes[0], True)
        self._crs_cluster_home = (self._crs_cluster_home[0], True)
        self._scan = (self._scan[0], True)

    def is_dirty(self):
        return any([self._remote_listener[1], self._nodes[1], self._crs_cluster_home[1], self._scan[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACSourceConnectionInfo):
            return False
        return super(OracleRACSourceConnectionInfo, self).__eq__(other) and \
               self.remote_listener == other.remote_listener and \
               self.nodes == other.nodes and \
               self.crs_cluster_home == other.crs_cluster_home and \
               self.scan == other.scan

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_listener(self):
        """
        The default remote_listener parameter to be used for databases on the
        cluster.

        :rtype: ``basestring``
        """
        return self._remote_listener[0]

    @remote_listener.setter
    def remote_listener(self, value):
        self._remote_listener = (value, True)

    @property
    def nodes(self):
        """
        The addresses for the nodes on which the source resides.

        :rtype: ``list`` of ``basestring``
        """
        return self._nodes[0]

    @nodes.setter
    def nodes(self, value):
        self._nodes = (value, True)

    @property
    def crs_cluster_home(self):
        """
        The location of the cluster installation.

        :rtype: ``basestring``
        """
        return self._crs_cluster_home[0]

    @crs_cluster_home.setter
    def crs_cluster_home(self, value):
        self._crs_cluster_home = (value, True)

    @property
    def scan(self):
        """
        The Single Client Access Name of the cluster (11.2 and greater clusters
        only).

        :rtype: ``basestring``
        """
        return self._scan[0]

    @scan.setter
    def scan(self, value):
        self._scan = (value, True)

class RunCommandOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that runs a shell command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunCommandOperation, self).__init__()
        self._type = ("RunCommandOperation", True)
        self._output_schema = (self.__undef__, True)
        self._variables = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._command = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunCommandOperation, cls).from_dict(data, dirty, undef_enabled)
        if "outputSchema" in data and data["outputSchema"] is not None:
            obj._output_schema = (data["outputSchema"], dirty)
        else:
            obj._output_schema = (obj.__undef__, dirty)
        obj._variables = (data.get("variables", obj.__undef__), dirty)
        if obj._variables[0] is not None and obj._variables[0] is not obj.__undef__:
            assert isinstance(obj._variables[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._variables[0]))
            common.validate_format(obj._variables[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunCommandOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "output_schema" == "type" or (self.output_schema is not self.__undef__ and not (dirty and not self._output_schema[1])):
            dct["outputSchema"] = dictify(self.output_schema)
        if "variables" == "type" or (self.variables is not self.__undef__ and not (dirty and not self._variables[1])):
            dct["variables"] = dictify(self.variables)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._output_schema = (self._output_schema[0], True)
        self._variables = (self._variables[0], True)
        self._environment = (self._environment[0], True)
        self._host = (self._host[0], True)
        self._command = (self._command[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._output_schema[1], self._variables[1], self._environment[1], self._host[1], self._command[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunCommandOperation):
            return False
        return super(RunCommandOperation, self).__eq__(other) and \
               self.output_schema == other.output_schema and \
               self.variables == other.variables and \
               self.environment == other.environment and \
               self.host == other.host and \
               self.command == other.command and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def output_schema(self):
        """
        An optional user defined schema for the expected output of this
        function.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._output_schema[0]

    @output_schema.setter
    def output_schema(self, value):
        self._output_schema = (value, True)

    @property
    def variables(self):
        """
        Environment variables to set when executing the command.

        :rtype: ``dict``
        """
        return self._variables[0]

    @variables.setter
    def variables(self, value):
        self._variables = (value, True)

    @property
    def environment(self):
        """
        The environment to execute the command on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def host(self):
        """
        The host to execute the command on.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def command(self):
        """
        The shell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

    @property
    def user(self):
        """
        The environment user to execute the command as.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class DiscoverOracleListenerOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* Discovers Oracle
    listeners on target host.
    """
    def __init__(self, undef_enabled=True):
        super(DiscoverOracleListenerOperation, self).__init__()
        self._type = ("DiscoverOracleListenerOperation", True)
        self._environment = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DiscoverOracleListenerOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DiscoverOracleListenerOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)

    def is_dirty(self):
        return any([self._environment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DiscoverOracleListenerOperation):
            return False
        return super(DiscoverOracleListenerOperation, self).__eq__(other) and \
               self.environment == other.environment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        The environment to run discovery on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

class RunSyncOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that runs sync from the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunSyncOperation, self).__init__()
        self._type = ("RunSyncOperation", True)
        self._exclude_paths = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._source_directory = (self.__undef__, True)
        self._follow_symlink_paths = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunSyncOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._exclude_paths = []
        for item in data.get("excludePaths") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._exclude_paths.append(item)
        obj._exclude_paths = (obj._exclude_paths, dirty)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        obj._source_directory = (data.get("sourceDirectory", obj.__undef__), dirty)
        if obj._source_directory[0] is not None and obj._source_directory[0] is not obj.__undef__:
            assert isinstance(obj._source_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_directory[0]))
            common.validate_format(obj._source_directory[0], "None", None, None)
        obj._follow_symlink_paths = []
        for item in data.get("followSymlinkPaths") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._follow_symlink_paths.append(item)
        obj._follow_symlink_paths = (obj._follow_symlink_paths, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunSyncOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "exclude_paths" == "type" or (self.exclude_paths is not self.__undef__ and not (dirty and not self._exclude_paths[1])):
            dct["excludePaths"] = dictify(self.exclude_paths)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "source_directory" == "type" or (self.source_directory is not self.__undef__ and not (dirty and not self._source_directory[1])):
            dct["sourceDirectory"] = dictify(self.source_directory)
        if "follow_symlink_paths" == "type" or (self.follow_symlink_paths is not self.__undef__ and not (dirty and not self._follow_symlink_paths[1])):
            dct["followSymlinkPaths"] = dictify(self.follow_symlink_paths)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._exclude_paths = (self._exclude_paths[0], True)
        self._environment = (self._environment[0], True)
        self._host = (self._host[0], True)
        self._user = (self._user[0], True)
        self._source_directory = (self._source_directory[0], True)
        self._follow_symlink_paths = (self._follow_symlink_paths[0], True)

    def is_dirty(self):
        return any([self._exclude_paths[1], self._environment[1], self._host[1], self._user[1], self._source_directory[1], self._follow_symlink_paths[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunSyncOperation):
            return False
        return super(RunSyncOperation, self).__eq__(other) and \
               self.exclude_paths == other.exclude_paths and \
               self.environment == other.environment and \
               self.host == other.host and \
               self.user == other.user and \
               self.source_directory == other.source_directory and \
               self.follow_symlink_paths == other.follow_symlink_paths

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def exclude_paths(self):
        """
        List of subdirectories in the source to exclude when syncing data.
        These paths are relative to the root of the source directory.

        :rtype: ``list`` of ``basestring``
        """
        return self._exclude_paths[0]

    @exclude_paths.setter
    def exclude_paths(self, value):
        self._exclude_paths = (value, True)

    @property
    def environment(self):
        """
        The environment to sync from.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def host(self):
        """
        The host on which to sync.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def user(self):
        """
        The environment user to use when syncing.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def source_directory(self):
        """
        The directory data is copied from.

        :rtype: ``basestring``
        """
        return self._source_directory[0]

    @source_directory.setter
    def source_directory(self, value):
        self._source_directory = (value, True)

    @property
    def follow_symlink_paths(self):
        """
        List of symlinks in the source to follow when syncing data. These paths
        are relative to the root of the source directory. All other symlinks
        are preserved.

        :rtype: ``list`` of ``basestring``
        """
        return self._follow_symlink_paths[0]

    @follow_symlink_paths.setter
    def follow_symlink_paths(self, value):
        self._follow_symlink_paths = (value, True)

class SourceOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that can be performed on sources.
    """
    def __init__(self, undef_enabled=True):
        super(SourceOperation, self).__init__()
        self._type = ("SourceOperation", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceOperation, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceOperation):
            return False
        return super(SourceOperation, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class RunExpectOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that runs an expect command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunExpectOperation, self).__init__()
        self._type = ("RunExpectOperation", True)
        self._environment = (self.__undef__, True)
        self._variables = (self.__undef__, True)
        self._command = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunExpectOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._variables = (data.get("variables", obj.__undef__), dirty)
        if obj._variables[0] is not None and obj._variables[0] is not obj.__undef__:
            assert isinstance(obj._variables[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._variables[0]))
            common.validate_format(obj._variables[0], "None", None, None)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunExpectOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "variables" == "type" or (self.variables is not self.__undef__ and not (dirty and not self._variables[1])):
            dct["variables"] = dictify(self.variables)
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._variables = (self._variables[0], True)
        self._command = (self._command[0], True)
        self._host = (self._host[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._variables[1], self._command[1], self._host[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunExpectOperation):
            return False
        return super(RunExpectOperation, self).__eq__(other) and \
               self.environment == other.environment and \
               self.variables == other.variables and \
               self.command == other.command and \
               self.host == other.host and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        The environment to execute the command on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def variables(self):
        """
        Environment variables to set when executing the command.

        :rtype: ``dict``
        """
        return self._variables[0]

    @variables.setter
    def variables(self, value):
        self._variables = (value, True)

    @property
    def command(self):
        """
        The expect command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

    @property
    def host(self):
        """
        The host to execute the command on.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def user(self):
        """
        The environment user to execute the command as.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class RegisterOracleHomeOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* Register a manually
    created Oracle Home with the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(RegisterOracleHomeOperation, self).__init__()
        self._type = ("RegisterOracleHomeOperation", True)
        self._environment = (self.__undef__, True)
        self._install_home = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RegisterOracleHomeOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._install_home = (data.get("installHome", obj.__undef__), dirty)
        if obj._install_home[0] is not None and obj._install_home[0] is not obj.__undef__:
            assert isinstance(obj._install_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._install_home[0]))
            common.validate_format(obj._install_home[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RegisterOracleHomeOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "install_home" == "type" or (self.install_home is not self.__undef__ and not (dirty and not self._install_home[1])):
            dct["installHome"] = dictify(self.install_home)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._install_home = (self._install_home[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._install_home[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RegisterOracleHomeOperation):
            return False
        return super(RegisterOracleHomeOperation, self).__eq__(other) and \
               self.environment == other.environment and \
               self.install_home == other.install_home

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        The environment to run discovery on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def install_home(self):
        """
        Absolute path to the Oracle installation home to register.

        :rtype: ``basestring``
        """
        return self._install_home[0]

    @install_home.setter
    def install_home(self, value):
        self._install_home = (value, True)

class RunMaskingJobOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* An operation that runs a
    Masking Job on the local Delphix Masking Engine instance.
    """
    def __init__(self, undef_enabled=True):
        super(RunMaskingJobOperation, self).__init__()
        self._type = ("RunMaskingJobOperation", True)
        self._host = (self.__undef__, True)
        self._application_id = (self.__undef__, True)
        self._masking_job_id = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunMaskingJobOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        obj._application_id = (data.get("applicationId", obj.__undef__), dirty)
        if obj._application_id[0] is not None and obj._application_id[0] is not obj.__undef__:
            assert isinstance(obj._application_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application_id[0]))
            common.validate_format(obj._application_id[0], "None", None, None)
        obj._masking_job_id = (data.get("maskingJobId", obj.__undef__), dirty)
        if obj._masking_job_id[0] is not None and obj._masking_job_id[0] is not obj.__undef__:
            assert isinstance(obj._masking_job_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._masking_job_id[0]))
            common.validate_format(obj._masking_job_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunMaskingJobOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if dirty and "host" in dct:
            del dct["host"]
        if "application_id" == "type" or (self.application_id is not self.__undef__ and not (dirty and not self._application_id[1])):
            dct["applicationId"] = dictify(self.application_id)
        if dirty and "applicationId" in dct:
            del dct["applicationId"]
        if "masking_job_id" == "type" or (self.masking_job_id is not self.__undef__ and not (dirty and not self._masking_job_id[1])):
            dct["maskingJobId"] = dictify(self.masking_job_id)
        if dirty and "maskingJobId" in dct:
            del dct["maskingJobId"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._application_id = (self._application_id[0], True)
        self._masking_job_id = (self._masking_job_id[0], True)

    def is_dirty(self):
        return any([self._host[1], self._application_id[1], self._masking_job_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunMaskingJobOperation):
            return False
        return super(RunMaskingJobOperation, self).__eq__(other) and \
               self.host == other.host and \
               self.application_id == other.application_id and \
               self.masking_job_id == other.masking_job_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The location this Masking Job will be executed on.

        :rtype: ``basestring``
        """
        return self._host[0]

    @property
    def application_id(self):
        """
        The application ID of the Masking Job to be executed.

        :rtype: ``basestring``
        """
        return self._application_id[0]

    @property
    def masking_job_id(self):
        """
        The Masking Job ID of the Masking Job to be executed.

        :rtype: ``basestring``
        """
        return self._masking_job_id[0]

class RunPowerShellOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that runs a PowerShell command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunPowerShellOperation, self).__init__()
        self._type = ("RunPowerShellOperation", True)
        self._output_schema = (self.__undef__, True)
        self._variables = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._command = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunPowerShellOperation, cls).from_dict(data, dirty, undef_enabled)
        if "outputSchema" in data and data["outputSchema"] is not None:
            obj._output_schema = (data["outputSchema"], dirty)
        else:
            obj._output_schema = (obj.__undef__, dirty)
        obj._variables = (data.get("variables", obj.__undef__), dirty)
        if obj._variables[0] is not None and obj._variables[0] is not obj.__undef__:
            assert isinstance(obj._variables[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._variables[0]))
            common.validate_format(obj._variables[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunPowerShellOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "output_schema" == "type" or (self.output_schema is not self.__undef__ and not (dirty and not self._output_schema[1])):
            dct["outputSchema"] = dictify(self.output_schema)
        if "variables" == "type" or (self.variables is not self.__undef__ and not (dirty and not self._variables[1])):
            dct["variables"] = dictify(self.variables)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._output_schema = (self._output_schema[0], True)
        self._variables = (self._variables[0], True)
        self._environment = (self._environment[0], True)
        self._host = (self._host[0], True)
        self._command = (self._command[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._output_schema[1], self._variables[1], self._environment[1], self._host[1], self._command[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunPowerShellOperation):
            return False
        return super(RunPowerShellOperation, self).__eq__(other) and \
               self.output_schema == other.output_schema and \
               self.variables == other.variables and \
               self.environment == other.environment and \
               self.host == other.host and \
               self.command == other.command and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def output_schema(self):
        """
        An optional user defined schema for the expected output of this
        function.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._output_schema[0]

    @output_schema.setter
    def output_schema(self, value):
        self._output_schema = (value, True)

    @property
    def variables(self):
        """
        Environment variables to set when executing the command.

        :rtype: ``dict``
        """
        return self._variables[0]

    @variables.setter
    def variables(self, value):
        self._variables = (value, True)

    @property
    def environment(self):
        """
        The environment to execute the command on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def host(self):
        """
        The host to execute the command on.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def command(self):
        """
        The PowerShell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

    @property
    def user(self):
        """
        The environment user to execute the command as.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class RunBashOperation(Operation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Operation` *)* A user-specifiable
    operation that runs a shell command on the target host using the Delphix
    supplied Bash shell.
    """
    def __init__(self, undef_enabled=True):
        super(RunBashOperation, self).__init__()
        self._type = ("RunBashOperation", True)
        self._output_schema = (self.__undef__, True)
        self._login_shell = (self.__undef__, True)
        self._variables = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._command = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunBashOperation, cls).from_dict(data, dirty, undef_enabled)
        if "outputSchema" in data and data["outputSchema"] is not None:
            obj._output_schema = (data["outputSchema"], dirty)
        else:
            obj._output_schema = (obj.__undef__, dirty)
        obj._login_shell = (data.get("loginShell", obj.__undef__), dirty)
        if obj._login_shell[0] is not None and obj._login_shell[0] is not obj.__undef__:
            assert isinstance(obj._login_shell[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._login_shell[0]))
            common.validate_format(obj._login_shell[0], "None", None, None)
        obj._variables = (data.get("variables", obj.__undef__), dirty)
        if obj._variables[0] is not None and obj._variables[0] is not obj.__undef__:
            assert isinstance(obj._variables[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._variables[0]))
            common.validate_format(obj._variables[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunBashOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "output_schema" == "type" or (self.output_schema is not self.__undef__ and not (dirty and not self._output_schema[1])):
            dct["outputSchema"] = dictify(self.output_schema)
        if "login_shell" == "type" or (self.login_shell is not self.__undef__ and not (dirty and not self._login_shell[1])):
            dct["loginShell"] = dictify(self.login_shell)
        if "variables" == "type" or (self.variables is not self.__undef__ and not (dirty and not self._variables[1])):
            dct["variables"] = dictify(self.variables)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._output_schema = (self._output_schema[0], True)
        self._login_shell = (self._login_shell[0], True)
        self._variables = (self._variables[0], True)
        self._environment = (self._environment[0], True)
        self._host = (self._host[0], True)
        self._command = (self._command[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._output_schema[1], self._login_shell[1], self._variables[1], self._environment[1], self._host[1], self._command[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunBashOperation):
            return False
        return super(RunBashOperation, self).__eq__(other) and \
               self.output_schema == other.output_schema and \
               self.login_shell == other.login_shell and \
               self.variables == other.variables and \
               self.environment == other.environment and \
               self.host == other.host and \
               self.command == other.command and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def output_schema(self):
        """
        An optional user defined schema for the expected output of this
        function.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._output_schema[0]

    @output_schema.setter
    def output_schema(self, value):
        self._output_schema = (value, True)

    @property
    def login_shell(self):
        """
        Invoke the bash shell with the --login option which causes profile
        files to be sourced as if bash is running as a login shell. See bash(1)
        for more details.

        :rtype: ``bool``
        """
        return self._login_shell[0]

    @login_shell.setter
    def login_shell(self, value):
        self._login_shell = (value, True)

    @property
    def variables(self):
        """
        Environment variables to set when executing the command.

        :rtype: ``dict``
        """
        return self._variables[0]

    @variables.setter
    def variables(self, value):
        self._variables = (value, True)

    @property
    def environment(self):
        """
        The environment to execute the command on.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def host(self):
        """
        The host to execute the command on.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def command(self):
        """
        The shell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

    @property
    def user(self):
        """
        The environment user to execute the command as.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class RunMaskingJobOnSourceOperation(SourceOperation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceOperation` *)* An operation that
    runs a Masking Job on the local Delphix Masking Engine instance.
    """
    def __init__(self, undef_enabled=True):
        super(RunMaskingJobOnSourceOperation, self).__init__()
        self._type = ("RunMaskingJobOnSourceOperation", True)
        self._application_id = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._masking_job_id = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunMaskingJobOnSourceOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._application_id = (data.get("applicationId", obj.__undef__), dirty)
        if obj._application_id[0] is not None and obj._application_id[0] is not obj.__undef__:
            assert isinstance(obj._application_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application_id[0]))
            common.validate_format(obj._application_id[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._masking_job_id = (data.get("maskingJobId", obj.__undef__), dirty)
        if obj._masking_job_id[0] is not None and obj._masking_job_id[0] is not obj.__undef__:
            assert isinstance(obj._masking_job_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._masking_job_id[0]))
            common.validate_format(obj._masking_job_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunMaskingJobOnSourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "application_id" == "type" or (self.application_id is not self.__undef__ and not (dirty and not self._application_id[1])):
            dct["applicationId"] = dictify(self.application_id)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "masking_job_id" == "type" or (self.masking_job_id is not self.__undef__ and not (dirty and not self._masking_job_id[1])):
            dct["maskingJobId"] = dictify(self.masking_job_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._application_id = (self._application_id[0], True)
        self._name = (self._name[0], True)
        self._masking_job_id = (self._masking_job_id[0], True)

    def is_dirty(self):
        return any([self._application_id[1], self._name[1], self._masking_job_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunMaskingJobOnSourceOperation):
            return False
        return super(RunMaskingJobOnSourceOperation, self).__eq__(other) and \
               self.application_id == other.application_id and \
               self.name == other.name and \
               self.masking_job_id == other.masking_job_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def application_id(self):
        """
        The application ID of the Masking Job to be executed.

        :rtype: ``basestring``
        """
        return self._application_id[0]

    @application_id.setter
    def application_id(self, value):
        self._application_id = (value, True)

    @property
    def name(self):
        """
        The name of the Masking Job to be executed.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def masking_job_id(self):
        """
        The Masking Job ID of the Masking Job to be executed.

        :rtype: ``basestring``
        """
        return self._masking_job_id[0]

    @masking_job_id.setter
    def masking_job_id(self, value):
        self._masking_job_id = (value, True)

class RunCommandOnSourceOperation(SourceOperation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceOperation` *)* A user-specifiable
    operation that runs a shell command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunCommandOnSourceOperation, self).__init__()
        self._type = ("RunCommandOnSourceOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunCommandOnSourceOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunCommandOnSourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunCommandOnSourceOperation):
            return False
        return super(RunCommandOnSourceOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The shell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class RunExpectOnSourceOperation(SourceOperation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceOperation` *)* A user-specifiable
    operation that runs an expect script on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunExpectOnSourceOperation, self).__init__()
        self._type = ("RunExpectOnSourceOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunExpectOnSourceOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunExpectOnSourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunExpectOnSourceOperation):
            return False
        return super(RunExpectOnSourceOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The expect command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class RunBashOnSourceOperation(SourceOperation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceOperation` *)* A user-specifiable
    operation that runs a shell command on the target host using the Delphix
    supplied Bash shell.
    """
    def __init__(self, undef_enabled=True):
        super(RunBashOnSourceOperation, self).__init__()
        self._type = ("RunBashOnSourceOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunBashOnSourceOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunBashOnSourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunBashOnSourceOperation):
            return False
        return super(RunBashOnSourceOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The shell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class RunPowerShellOnSourceOperation(SourceOperation):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceOperation` *)* A user-specifiable
    operation that runs a PowerShell command on the target host.
    """
    def __init__(self, undef_enabled=True):
        super(RunPowerShellOnSourceOperation, self).__init__()
        self._type = ("RunPowerShellOnSourceOperation", True)
        self._command = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RunPowerShellOnSourceOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._command = (data.get("command", obj.__undef__), dirty)
        if obj._command[0] is not None and obj._command[0] is not obj.__undef__:
            assert isinstance(obj._command[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._command[0]))
            common.validate_format(obj._command[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RunPowerShellOnSourceOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "command" == "type" or (self.command is not self.__undef__ and not (dirty and not self._command[1])):
            dct["command"] = dictify(self.command)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._command = (self._command[0], True)

    def is_dirty(self):
        return any([self._command[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RunPowerShellOnSourceOperation):
            return False
        return super(RunPowerShellOnSourceOperation, self).__eq__(other) and \
               self.command == other.command

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def command(self):
        """
        The PowerShell command to execute on the target host.

        :rtype: ``basestring``
        """
        return self._command[0]

    @command.setter
    def command(self, value):
        self._command = (value, True)

class OracleDisableParameters(SourceDisableParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceDisableParameters` *)* The
    parameters to use as input to disable oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDisableParameters, self).__init__()
        self._type = ("OracleDisableParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDisableParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDisableParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDisableParameters):
            return False
        return super(OracleDisableParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the provision operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the provision
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class StatisticEnumAxis(StatisticAxis):
    """
    *(extends* :py:class:`v1_8_1.web.vo.StatisticAxis` *)* The attributes of a
    statistic axis which is an enum type.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticEnumAxis, self).__init__()
        self._type = ("StatisticEnumAxis", True)
        self._enum_values = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticEnumAxis, cls).from_dict(data, dirty, undef_enabled)
        obj._enum_values = []
        for item in data.get("enumValues") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._enum_values.append(item)
        obj._enum_values = (obj._enum_values, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticEnumAxis, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "enum_values" == "type" or (self.enum_values is not self.__undef__ and not (dirty and not self._enum_values[1])):
            dct["enumValues"] = dictify(self.enum_values)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._enum_values = (self._enum_values[0], True)

    def is_dirty(self):
        return any([self._enum_values[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticEnumAxis):
            return False
        return super(StatisticEnumAxis, self).__eq__(other) and \
               self.enum_values == other.enum_values

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def enum_values(self):
        """
        The set of values that are allowed for this axis.

        :rtype: ``list`` of ``basestring``
        """
        return self._enum_values[0]

    @enum_values.setter
    def enum_values(self, value):
        self._enum_values = (value, True)

class JSDataContainerCreateParameters(JSDataLayoutCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataLayoutCreateParameters` *)* The
    parameters used to create a data container.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainerCreateParameters, self).__init__()
        self._type = ("JSDataContainerCreateParameters", True)
        self._owners = (self.__undef__, True)
        self._template = (self.__undef__, True)
        self._timeline_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainerCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._owners = []
        for item in data.get("owners") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._owners.append(item)
        obj._owners = (obj._owners, dirty)
        if "template" not in data:
            raise ValueError("Missing required property \"template\".")
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        if "timelinePointParameters" not in data:
            raise ValueError("Missing required property \"timelinePointParameters\".")
        if "timelinePointParameters" in data and data["timelinePointParameters"] is not None:
            obj._timeline_point_parameters = (factory.create_object(data["timelinePointParameters"], "JSTimelinePointParameters"), dirty)
            factory.validate_type(obj._timeline_point_parameters[0], "JSTimelinePointParameters")
        else:
            obj._timeline_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainerCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owners" == "type" or (self.owners is not self.__undef__ and not (dirty and not self._owners[1])):
            dct["owners"] = dictify(self.owners)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        if "timeline_point_parameters" == "type" or (self.timeline_point_parameters is not self.__undef__ and not (dirty and not self._timeline_point_parameters[1])):
            dct["timelinePointParameters"] = dictify(self.timeline_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owners = (self._owners[0], True)
        self._template = (self._template[0], True)
        self._timeline_point_parameters = (self._timeline_point_parameters[0], True)

    def is_dirty(self):
        return any([self._owners[1], self._template[1], self._timeline_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainerCreateParameters):
            return False
        return super(JSDataContainerCreateParameters, self).__eq__(other) and \
               self.owners == other.owners and \
               self.template == other.template and \
               self.timeline_point_parameters == other.timeline_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owners(self):
        """
        A reference to the list of users that own this data container.

        :rtype: ``list`` of ``basestring``
        """
        return self._owners[0]

    @owners.setter
    def owners(self, value):
        self._owners = (value, True)

    @property
    def template(self):
        """
        A reference to the template that this data container is provisioned
        from.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

    @property
    def timeline_point_parameters(self):
        """
        Create the data container with initial data specified by this Jet
        Stream timeline point.

        :rtype: :py:class:`v1_8_1.web.vo.JSTimelinePointParameters`
        """
        return self._timeline_point_parameters[0]

    @timeline_point_parameters.setter
    def timeline_point_parameters(self, value):
        self._timeline_point_parameters = (value, True)

class JSDataTemplateCreateParameters(JSDataLayoutCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataLayoutCreateParameters` *)* The
    parameters used to create a data template.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataTemplateCreateParameters, self).__init__()
        self._type = ("JSDataTemplateCreateParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataTemplateCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataTemplateCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataTemplateCreateParameters):
            return False
        return super(JSDataTemplateCreateParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible PgSQL repositories.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLCompatibilityCriteria, self).__init__()
        self._type = ("PgSQLCompatibilityCriteria", True)
        self._segment_size = (self.__undef__, True)
        self._variant = (self.__undef__, True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._segment_size = (data.get("segmentSize", obj.__undef__), dirty)
        if obj._segment_size[0] is not None and obj._segment_size[0] is not obj.__undef__:
            assert isinstance(obj._segment_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._segment_size[0]))
            common.validate_format(obj._segment_size[0], "None", None, None)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'PostgreSQL', u'EnterpriseDB'], "Expected enum [u'PostgreSQL', u'EnterpriseDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "pgsqlVersion", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "segment_size" == "type" or (self.segment_size is not self.__undef__ and not (dirty and not self._segment_size[1])):
            dct["segmentSize"] = dictify(self.segment_size)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._segment_size = (self._segment_size[0], True)
        self._variant = (self._variant[0], True)
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._segment_size[1], self._variant[1], self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLCompatibilityCriteria):
            return False
        return super(PgSQLCompatibilityCriteria, self).__eq__(other) and \
               self.segment_size == other.segment_size and \
               self.variant == other.variant and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def segment_size(self):
        """
        Selected repositories have this size WAL segments.

        :rtype: ``int``
        """
        return self._segment_size[0]

    @segment_size.setter
    def segment_size(self, value):
        self._segment_size = (value, True)

    @property
    def variant(self):
        """
        Selected repositories will match this variant of the PostgreSQL
        distribution. *(permitted values: PostgreSQL, EnterpriseDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class ASECompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for filtering the list of available SAP ASE
    repositories.
    """
    def __init__(self, undef_enabled=True):
        super(ASECompatibilityCriteria, self).__init__()
        self._type = ("ASECompatibilityCriteria", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASECompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASECompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASECompatibilityCriteria):
            return False
        return super(ASECompatibilityCriteria, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible MySQL repositories.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLCompatibilityCriteria, self).__init__()
        self._type = ("MySQLCompatibilityCriteria", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        if "version" in data and data["version"] is not None:
            obj._version = (factory.create_object(data["version"], "MySQLVersion"), dirty)
            factory.validate_type(obj._version[0], "MySQLVersion")
        else:
            obj._version = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLCompatibilityCriteria):
            return False
        return super(MySQLCompatibilityCriteria, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Version of the MySQL installation.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLVersion`
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class MSSqlCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible MSSql repositories.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlCompatibilityCriteria, self).__init__()
        self._type = ("MSSqlCompatibilityCriteria", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlCompatibilityCriteria):
            return False
        return super(MSSqlCompatibilityCriteria, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class OracleCompatibilityCriteria(CompatibilityCriteria):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibilityCriteria` *)* The
    compatibility criteria to use for selecting compatible Oracle repositories.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCompatibilityCriteria, self).__init__()
        self._type = ("OracleCompatibilityCriteria", True)
        self._version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCompatibilityCriteria, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCompatibilityCriteria, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)

    def is_dirty(self):
        return any([self._version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCompatibilityCriteria):
            return False
        return super(OracleCompatibilityCriteria, self).__eq__(other) and \
               self.version == other.version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Selected repositories are this database version. In case of upgrade,
        selected repositories are strictly greater than this database version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

class OracleRACInstance(OracleInstance):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleInstance` *)* The representation
    of an Oracle Database RAC Instance Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACInstance, self).__init__()
        self._type = ("OracleRACInstance", True)
        self._node = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._node = (data.get("node", obj.__undef__), dirty)
        if obj._node[0] is not None and obj._node[0] is not obj.__undef__:
            assert isinstance(obj._node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._node[0]))
            common.validate_format(obj._node[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "node" == "type" or (self.node is not self.__undef__ and not (dirty and not self._node[1])):
            dct["node"] = dictify(self.node)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._node = (self._node[0], True)

    def is_dirty(self):
        return any([self._node[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACInstance):
            return False
        return super(OracleRACInstance, self).__eq__(other) and \
               self.node == other.node

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def node(self):
        """
        Reference to the Oracle cluster node that the RAC instance is running
        on.

        :rtype: ``basestring``
        """
        return self._node[0]

    @node.setter
    def node(self, value):
        self._node = (value, True)

class Action(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* Represents an
    action, a permanent record of activity on the server.
    """
    def __init__(self, undef_enabled=True):
        super(Action, self).__init__()
        self._type = ("Action", True)
        self._end_time = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._parent_action = (self.__undef__, True)
        self._failure_message_code = (self.__undef__, True)
        self._action_type = (self.__undef__, True)
        self._failure_description = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._report = (self.__undef__, True)
        self._user_agent = (self.__undef__, True)
        self._work_source = (self.__undef__, True)
        self._work_source_name = (self.__undef__, True)
        self._failure_action = (self.__undef__, True)
        self._details = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Action, cls).from_dict(data, dirty, undef_enabled)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'], "Expected enum [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._parent_action = (data.get("parentAction", obj.__undef__), dirty)
        if obj._parent_action[0] is not None and obj._parent_action[0] is not obj.__undef__:
            assert isinstance(obj._parent_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_action[0]))
            common.validate_format(obj._parent_action[0], "objectReference", None, None)
        obj._failure_message_code = (data.get("failureMessageCode", obj.__undef__), dirty)
        if obj._failure_message_code[0] is not None and obj._failure_message_code[0] is not obj.__undef__:
            assert isinstance(obj._failure_message_code[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._failure_message_code[0]))
            common.validate_format(obj._failure_message_code[0], "None", None, None)
        obj._action_type = (data.get("actionType", obj.__undef__), dirty)
        if obj._action_type[0] is not None and obj._action_type[0] is not obj.__undef__:
            assert isinstance(obj._action_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action_type[0]))
            common.validate_format(obj._action_type[0], "None", None, None)
        obj._failure_description = (data.get("failureDescription", obj.__undef__), dirty)
        if obj._failure_description[0] is not None and obj._failure_description[0] is not obj.__undef__:
            assert isinstance(obj._failure_description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._failure_description[0]))
            common.validate_format(obj._failure_description[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._report = (data.get("report", obj.__undef__), dirty)
        if obj._report[0] is not None and obj._report[0] is not obj.__undef__:
            assert isinstance(obj._report[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._report[0]))
            common.validate_format(obj._report[0], "None", None, None)
        obj._user_agent = (data.get("userAgent", obj.__undef__), dirty)
        if obj._user_agent[0] is not None and obj._user_agent[0] is not obj.__undef__:
            assert isinstance(obj._user_agent[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_agent[0]))
            common.validate_format(obj._user_agent[0], "None", None, None)
        obj._work_source = (data.get("workSource", obj.__undef__), dirty)
        if obj._work_source[0] is not None and obj._work_source[0] is not obj.__undef__:
            assert isinstance(obj._work_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._work_source[0]))
            assert obj._work_source[0] in [u'WEBSERVICE', u'POLICY', u'SYSTEM'], "Expected enum [u'WEBSERVICE', u'POLICY', u'SYSTEM'] but got %s" % obj._work_source[0]
            common.validate_format(obj._work_source[0], "None", None, None)
        obj._work_source_name = (data.get("workSourceName", obj.__undef__), dirty)
        if obj._work_source_name[0] is not None and obj._work_source_name[0] is not obj.__undef__:
            assert isinstance(obj._work_source_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._work_source_name[0]))
            common.validate_format(obj._work_source_name[0], "None", None, None)
        obj._failure_action = (data.get("failureAction", obj.__undef__), dirty)
        if obj._failure_action[0] is not None and obj._failure_action[0] is not obj.__undef__:
            assert isinstance(obj._failure_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._failure_action[0]))
            common.validate_format(obj._failure_action[0], "None", None, None)
        obj._details = (data.get("details", obj.__undef__), dirty)
        if obj._details[0] is not None and obj._details[0] is not obj.__undef__:
            assert isinstance(obj._details[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._details[0]))
            common.validate_format(obj._details[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Action, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "parent_action" == "type" or (self.parent_action is not self.__undef__ and not (dirty and not self._parent_action[1])):
            dct["parentAction"] = dictify(self.parent_action)
        if "failure_message_code" == "type" or (self.failure_message_code is not self.__undef__ and not (dirty and not self._failure_message_code[1])):
            dct["failureMessageCode"] = dictify(self.failure_message_code)
        if "action_type" == "type" or (self.action_type is not self.__undef__ and not (dirty and not self._action_type[1])):
            dct["actionType"] = dictify(self.action_type)
        if "failure_description" == "type" or (self.failure_description is not self.__undef__ and not (dirty and not self._failure_description[1])):
            dct["failureDescription"] = dictify(self.failure_description)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "report" == "type" or (self.report is not self.__undef__ and not (dirty and not self._report[1])):
            dct["report"] = dictify(self.report)
        if "user_agent" == "type" or (self.user_agent is not self.__undef__ and not (dirty and not self._user_agent[1])):
            dct["userAgent"] = dictify(self.user_agent)
        if "work_source" == "type" or (self.work_source is not self.__undef__ and not (dirty and not self._work_source[1])):
            dct["workSource"] = dictify(self.work_source)
        if "work_source_name" == "type" or (self.work_source_name is not self.__undef__ and not (dirty and not self._work_source_name[1])):
            dct["workSourceName"] = dictify(self.work_source_name)
        if "failure_action" == "type" or (self.failure_action is not self.__undef__ and not (dirty and not self._failure_action[1])):
            dct["failureAction"] = dictify(self.failure_action)
        if "details" == "type" or (self.details is not self.__undef__ and not (dirty and not self._details[1])):
            dct["details"] = dictify(self.details)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_time = (self._end_time[0], True)
        self._title = (self._title[0], True)
        self._user = (self._user[0], True)
        self._state = (self._state[0], True)
        self._parent_action = (self._parent_action[0], True)
        self._failure_message_code = (self._failure_message_code[0], True)
        self._action_type = (self._action_type[0], True)
        self._failure_description = (self._failure_description[0], True)
        self._start_time = (self._start_time[0], True)
        self._report = (self._report[0], True)
        self._user_agent = (self._user_agent[0], True)
        self._work_source = (self._work_source[0], True)
        self._work_source_name = (self._work_source_name[0], True)
        self._failure_action = (self._failure_action[0], True)
        self._details = (self._details[0], True)

    def is_dirty(self):
        return any([self._end_time[1], self._title[1], self._user[1], self._state[1], self._parent_action[1], self._failure_message_code[1], self._action_type[1], self._failure_description[1], self._start_time[1], self._report[1], self._user_agent[1], self._work_source[1], self._work_source_name[1], self._failure_action[1], self._details[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Action):
            return False
        return super(Action, self).__eq__(other) and \
               self.end_time == other.end_time and \
               self.title == other.title and \
               self.user == other.user and \
               self.state == other.state and \
               self.parent_action == other.parent_action and \
               self.failure_message_code == other.failure_message_code and \
               self.action_type == other.action_type and \
               self.failure_description == other.failure_description and \
               self.start_time == other.start_time and \
               self.report == other.report and \
               self.user_agent == other.user_agent and \
               self.work_source == other.work_source and \
               self.work_source_name == other.work_source_name and \
               self.failure_action == other.failure_action and \
               self.details == other.details

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_time(self):
        """
        The time the action completed.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def title(self):
        """
        Action title.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def user(self):
        """
        User who initiated the action.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def state(self):
        """
        State of the action. *(permitted values: EXECUTING, WAITING, COMPLETED,
        FAILED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def parent_action(self):
        """
        The parent action of this action.

        :rtype: ``basestring``
        """
        return self._parent_action[0]

    @parent_action.setter
    def parent_action(self, value):
        self._parent_action = (value, True)

    @property
    def failure_message_code(self):
        """
        Message ID associated with the event.

        :rtype: ``basestring``
        """
        return self._failure_message_code[0]

    @failure_message_code.setter
    def failure_message_code(self, value):
        self._failure_message_code = (value, True)

    @property
    def action_type(self):
        """
        Action type.

        :rtype: ``basestring``
        """
        return self._action_type[0]

    @action_type.setter
    def action_type(self, value):
        self._action_type = (value, True)

    @property
    def failure_description(self):
        """
        Details of the action failure.

        :rtype: ``basestring``
        """
        return self._failure_description[0]

    @failure_description.setter
    def failure_description(self, value):
        self._failure_description = (value, True)

    @property
    def start_time(self):
        """
        The time the action occurred. For long running processes, this
        represents the starting time.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def report(self):
        """
        Report of progress and warnings for some actions.

        :rtype: ``basestring``
        """
        return self._report[0]

    @report.setter
    def report(self, value):
        self._report = (value, True)

    @property
    def user_agent(self):
        """
        Name of client software used to initiate the action.

        :rtype: ``basestring``
        """
        return self._user_agent[0]

    @user_agent.setter
    def user_agent(self, value):
        self._user_agent = (value, True)

    @property
    def work_source(self):
        """
        Origin of the work that caused the action. *(permitted values:
        WEBSERVICE, POLICY, SYSTEM)*

        :rtype: ``basestring``
        """
        return self._work_source[0]

    @work_source.setter
    def work_source(self, value):
        self._work_source = (value, True)

    @property
    def work_source_name(self):
        """
        Name of user or policy that initiated the action.

        :rtype: ``basestring``
        """
        return self._work_source_name[0]

    @work_source_name.setter
    def work_source_name(self, value):
        self._work_source_name = (value, True)

    @property
    def failure_action(self):
        """
        Action to be taken to resolve the failure.

        :rtype: ``basestring``
        """
        return self._failure_action[0]

    @failure_action.setter
    def failure_action(self, value):
        self._failure_action = (value, True)

    @property
    def details(self):
        """
        Plain text description of the action.

        :rtype: ``basestring``
        """
        return self._details[0]

    @details.setter
    def details(self, value):
        self._details = (value, True)

class Alert(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* An alert
    describing an event for a given object.
    """
    def __init__(self, undef_enabled=True):
        super(Alert, self).__init__()
        self._type = ("Alert", True)
        self._event_response = (self.__undef__, True)
        self._event_title = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._event_description = (self.__undef__, True)
        self._event_severity = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._event_command_output = (self.__undef__, True)
        self._event_action = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._event = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Alert, cls).from_dict(data, dirty, undef_enabled)
        obj._event_response = (data.get("eventResponse", obj.__undef__), dirty)
        if obj._event_response[0] is not None and obj._event_response[0] is not obj.__undef__:
            assert isinstance(obj._event_response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_response[0]))
            common.validate_format(obj._event_response[0], "None", None, None)
        obj._event_title = (data.get("eventTitle", obj.__undef__), dirty)
        if obj._event_title[0] is not None and obj._event_title[0] is not obj.__undef__:
            assert isinstance(obj._event_title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_title[0]))
            common.validate_format(obj._event_title[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._event_description = (data.get("eventDescription", obj.__undef__), dirty)
        if obj._event_description[0] is not None and obj._event_description[0] is not obj.__undef__:
            assert isinstance(obj._event_description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_description[0]))
            common.validate_format(obj._event_description[0], "None", None, None)
        obj._event_severity = (data.get("eventSeverity", obj.__undef__), dirty)
        if obj._event_severity[0] is not None and obj._event_severity[0] is not obj.__undef__:
            assert isinstance(obj._event_severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_severity[0]))
            assert obj._event_severity[0] in [u'INFORMATIONAL', u'WARNING', u'CRITICAL', u'AUDIT'], "Expected enum [u'INFORMATIONAL', u'WARNING', u'CRITICAL', u'AUDIT'] but got %s" % obj._event_severity[0]
            common.validate_format(obj._event_severity[0], "None", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._event_command_output = (data.get("eventCommandOutput", obj.__undef__), dirty)
        if obj._event_command_output[0] is not None and obj._event_command_output[0] is not obj.__undef__:
            assert isinstance(obj._event_command_output[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_command_output[0]))
            common.validate_format(obj._event_command_output[0], "None", None, None)
        obj._event_action = (data.get("eventAction", obj.__undef__), dirty)
        if obj._event_action[0] is not None and obj._event_action[0] is not obj.__undef__:
            assert isinstance(obj._event_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_action[0]))
            common.validate_format(obj._event_action[0], "None", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._event = (data.get("event", obj.__undef__), dirty)
        if obj._event[0] is not None and obj._event[0] is not obj.__undef__:
            assert isinstance(obj._event[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event[0]))
            common.validate_format(obj._event[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Alert, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_response" == "type" or (self.event_response is not self.__undef__ and not (dirty and not self._event_response[1])):
            dct["eventResponse"] = dictify(self.event_response)
        if "event_title" == "type" or (self.event_title is not self.__undef__ and not (dirty and not self._event_title[1])):
            dct["eventTitle"] = dictify(self.event_title)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "event_description" == "type" or (self.event_description is not self.__undef__ and not (dirty and not self._event_description[1])):
            dct["eventDescription"] = dictify(self.event_description)
        if "event_severity" == "type" or (self.event_severity is not self.__undef__ and not (dirty and not self._event_severity[1])):
            dct["eventSeverity"] = dictify(self.event_severity)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "event_command_output" == "type" or (self.event_command_output is not self.__undef__ and not (dirty and not self._event_command_output[1])):
            dct["eventCommandOutput"] = dictify(self.event_command_output)
        if "event_action" == "type" or (self.event_action is not self.__undef__ and not (dirty and not self._event_action[1])):
            dct["eventAction"] = dictify(self.event_action)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "event" == "type" or (self.event is not self.__undef__ and not (dirty and not self._event[1])):
            dct["event"] = dictify(self.event)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_response = (self._event_response[0], True)
        self._event_title = (self._event_title[0], True)
        self._target = (self._target[0], True)
        self._event_description = (self._event_description[0], True)
        self._event_severity = (self._event_severity[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._event_command_output = (self._event_command_output[0], True)
        self._event_action = (self._event_action[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._target_name = (self._target_name[0], True)
        self._event = (self._event[0], True)

    def is_dirty(self):
        return any([self._event_response[1], self._event_title[1], self._target[1], self._event_description[1], self._event_severity[1], self._timestamp[1], self._event_command_output[1], self._event_action[1], self._target_object_type[1], self._target_name[1], self._event[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Alert):
            return False
        return super(Alert, self).__eq__(other) and \
               self.event_response == other.event_response and \
               self.event_title == other.event_title and \
               self.target == other.target and \
               self.event_description == other.event_description and \
               self.event_severity == other.event_severity and \
               self.timestamp == other.timestamp and \
               self.event_command_output == other.event_command_output and \
               self.event_action == other.event_action and \
               self.target_object_type == other.target_object_type and \
               self.target_name == other.target_name and \
               self.event == other.event

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_response(self):
        """
        Event response.

        :rtype: ``basestring``
        """
        return self._event_response[0]

    @event_response.setter
    def event_response(self, value):
        self._event_response = (value, True)

    @property
    def event_title(self):
        """
        Event title.

        :rtype: ``basestring``
        """
        return self._event_title[0]

    @event_title.setter
    def event_title(self, value):
        self._event_title = (value, True)

    @property
    def target(self):
        """
        Reference to target object.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def event_description(self):
        """
        Event description.

        :rtype: ``basestring``
        """
        return self._event_description[0]

    @event_description.setter
    def event_description(self, value):
        self._event_description = (value, True)

    @property
    def event_severity(self):
        """
        Event severity. *(permitted values: INFORMATIONAL, WARNING, CRITICAL,
        AUDIT)*

        :rtype: ``basestring``
        """
        return self._event_severity[0]

    @event_severity.setter
    def event_severity(self, value):
        self._event_severity = (value, True)

    @property
    def timestamp(self):
        """
        Time at which event occurred.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def event_command_output(self):
        """
        Additional text associated with the event. This text is not localized
        and is only provided for certain alerts. For example, if an alert is
        caused by a post script failure, the output of the post script may be
        included here to assist with debugging the failure.

        :rtype: ``basestring``
        """
        return self._event_command_output[0]

    @event_command_output.setter
    def event_command_output(self, value):
        self._event_command_output = (value, True)

    @property
    def event_action(self):
        """
        Event recommended action.

        :rtype: ``basestring``
        """
        return self._event_action[0]

    @event_action.setter
    def event_action(self, value):
        self._event_action = (value, True)

    @property
    def target_object_type(self):
        """
        Type of target object.

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def target_name(self):
        """
        Name of target object.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def event(self):
        """
        Event class.

        :rtype: ``basestring``
        """
        return self._event[0]

    @event.setter
    def event(self, value):
        self._event = (value, True)

class UserObject(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* Super schema for
    all schemas representing user-visible objects.
    """
    def __init__(self, undef_enabled=True):
        super(UserObject, self).__init__()
        self._type = ("UserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "objectName", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UserObject):
            return False
        return super(UserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class Fault(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* A representation
    of a fault, with associated user object.
    """
    def __init__(self, undef_enabled=True):
        super(Fault, self).__init__()
        self._type = ("Fault", True)
        self._status = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._date_resolved = (self.__undef__, True)
        self._resolution_comments = (self.__undef__, True)
        self._date_diagnosed = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._action = (self.__undef__, True)
        self._bundle_id = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._severity = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Fault, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'ACTIVE', u'RESOLVED', u'IGNORED'], "Expected enum [u'ACTIVE', u'RESOLVED', u'IGNORED'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._date_resolved = (data.get("dateResolved", obj.__undef__), dirty)
        if obj._date_resolved[0] is not None and obj._date_resolved[0] is not obj.__undef__:
            assert isinstance(obj._date_resolved[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_resolved[0]))
            common.validate_format(obj._date_resolved[0], "date", None, None)
        obj._resolution_comments = (data.get("resolutionComments", obj.__undef__), dirty)
        if obj._resolution_comments[0] is not None and obj._resolution_comments[0] is not obj.__undef__:
            assert isinstance(obj._resolution_comments[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._resolution_comments[0]))
            common.validate_format(obj._resolution_comments[0], "None", None, None)
        obj._date_diagnosed = (data.get("dateDiagnosed", obj.__undef__), dirty)
        if obj._date_diagnosed[0] is not None and obj._date_diagnosed[0] is not obj.__undef__:
            assert isinstance(obj._date_diagnosed[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_diagnosed[0]))
            common.validate_format(obj._date_diagnosed[0], "date", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._bundle_id = (data.get("bundleID", obj.__undef__), dirty)
        if obj._bundle_id[0] is not None and obj._bundle_id[0] is not obj.__undef__:
            assert isinstance(obj._bundle_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bundle_id[0]))
            common.validate_format(obj._bundle_id[0], "None", None, None)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING'], "Expected enum [u'CRITICAL', u'WARNING'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Fault, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "date_resolved" == "type" or (self.date_resolved is not self.__undef__ and not (dirty and not self._date_resolved[1])):
            dct["dateResolved"] = dictify(self.date_resolved)
        if "resolution_comments" == "type" or (self.resolution_comments is not self.__undef__ and not (dirty and not self._resolution_comments[1])):
            dct["resolutionComments"] = dictify(self.resolution_comments)
        if "date_diagnosed" == "type" or (self.date_diagnosed is not self.__undef__ and not (dirty and not self._date_diagnosed[1])):
            dct["dateDiagnosed"] = dictify(self.date_diagnosed)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "bundle_id" == "type" or (self.bundle_id is not self.__undef__ and not (dirty and not self._bundle_id[1])):
            dct["bundleID"] = dictify(self.bundle_id)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._description = (self._description[0], True)
        self._title = (self._title[0], True)
        self._date_resolved = (self._date_resolved[0], True)
        self._resolution_comments = (self._resolution_comments[0], True)
        self._date_diagnosed = (self._date_diagnosed[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._target = (self._target[0], True)
        self._action = (self._action[0], True)
        self._bundle_id = (self._bundle_id[0], True)
        self._target_name = (self._target_name[0], True)
        self._response = (self._response[0], True)
        self._severity = (self._severity[0], True)

    def is_dirty(self):
        return any([self._status[1], self._description[1], self._title[1], self._date_resolved[1], self._resolution_comments[1], self._date_diagnosed[1], self._target_object_type[1], self._target[1], self._action[1], self._bundle_id[1], self._target_name[1], self._response[1], self._severity[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Fault):
            return False
        return super(Fault, self).__eq__(other) and \
               self.status == other.status and \
               self.description == other.description and \
               self.title == other.title and \
               self.date_resolved == other.date_resolved and \
               self.resolution_comments == other.resolution_comments and \
               self.date_diagnosed == other.date_diagnosed and \
               self.target_object_type == other.target_object_type and \
               self.target == other.target and \
               self.action == other.action and \
               self.bundle_id == other.bundle_id and \
               self.target_name == other.target_name and \
               self.response == other.response and \
               self.severity == other.severity

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the fault. This can be ACTIVE, RESOLVED or IGNORED.
        *(permitted values: ACTIVE, RESOLVED, IGNORED)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def description(self):
        """
        Full description of the fault.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def title(self):
        """
        Summary of the fault.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def date_resolved(self):
        """
        The date when the fault was resolved.

        :rtype: ``basestring``
        """
        return self._date_resolved[0]

    @date_resolved.setter
    def date_resolved(self, value):
        self._date_resolved = (value, True)

    @property
    def resolution_comments(self):
        """
        A comment that describes the fault resolution.

        :rtype: ``basestring``
        """
        return self._resolution_comments[0]

    @resolution_comments.setter
    def resolution_comments(self, value):
        self._resolution_comments = (value, True)

    @property
    def date_diagnosed(self):
        """
        The date when the fault was diagnosed.

        :rtype: ``basestring``
        """
        return self._date_diagnosed[0]

    @date_diagnosed.setter
    def date_diagnosed(self, value):
        self._date_diagnosed = (value, True)

    @property
    def target_object_type(self):
        """
        The user-visible Delphix object that is faulted.

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def target(self):
        """
        The user-visible Delphix object that is faulted.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def action(self):
        """
        A suggested user action.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def bundle_id(self):
        """
        A unique dot delimited identifier associated with the fault.

        :rtype: ``basestring``
        """
        return self._bundle_id[0]

    @bundle_id.setter
    def bundle_id(self, value):
        self._bundle_id = (value, True)

    @property
    def target_name(self):
        """
        The name of the faulted object at the time the fault was diagnosed.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def response(self):
        """
        The automated response taken by the system.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def severity(self):
        """
        The severity of the fault event. This can either be CRITICAL or
        WARNING. *(permitted values: CRITICAL, WARNING)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

class JSBookmarkCheckoutCount(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* The number of
    times a bookmark has been checked out. This means it was used as input to a
    RESTORE, CREATE_BRANCH, or RESET operation. The bookmark checkout count is
    kept separately on replicated templates.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmarkCheckoutCount, self).__init__()
        self._type = ("JSBookmarkCheckoutCount", True)
        self._bookmark = (self.__undef__, True)
        self._checkout_count = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmarkCheckoutCount, cls).from_dict(data, dirty, undef_enabled)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._checkout_count = (data.get("checkoutCount", obj.__undef__), dirty)
        if obj._checkout_count[0] is not None and obj._checkout_count[0] is not obj.__undef__:
            assert isinstance(obj._checkout_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._checkout_count[0]))
            common.validate_format(obj._checkout_count[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmarkCheckoutCount, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "checkout_count" == "type" or (self.checkout_count is not self.__undef__ and not (dirty and not self._checkout_count[1])):
            dct["checkoutCount"] = dictify(self.checkout_count)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)
        self._checkout_count = (self._checkout_count[0], True)

    def is_dirty(self):
        return any([self._bookmark[1], self._checkout_count[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmarkCheckoutCount):
            return False
        return super(JSBookmarkCheckoutCount, self).__eq__(other) and \
               self.bookmark == other.bookmark and \
               self.checkout_count == other.checkout_count

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The bookmark that this checkout count is associated with.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def checkout_count(self):
        """
        The number of times the bookmark has been checked out. This means it
        was used as input to a RESTORE, CREATE_BRANCH, or RESET operation. This
        should not be replicated.

        :rtype: ``int``
        """
        return self._checkout_count[0]

    @checkout_count.setter
    def checkout_count(self, value):
        self._checkout_count = (value, True)

class SNMPManager(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* SNMP manager
    configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SNMPManager, self).__init__()
        self._type = ("SNMPManager", True)
        self._address = (self.__undef__, True)
        self._use_inform = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._last_send_status = (self.__undef__, True)
        self._community_string = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SNMPManager, cls).from_dict(data, dirty, undef_enabled)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._use_inform = (data.get("useInform", obj.__undef__), dirty)
        if obj._use_inform[0] is not None and obj._use_inform[0] is not obj.__undef__:
            assert isinstance(obj._use_inform[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_inform[0]))
            common.validate_format(obj._use_inform[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._last_send_status = (data.get("lastSendStatus", obj.__undef__), dirty)
        if obj._last_send_status[0] is not None and obj._last_send_status[0] is not obj.__undef__:
            assert isinstance(obj._last_send_status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_send_status[0]))
            assert obj._last_send_status[0] in [u'FAILED', u'SUCCEEDED', u'PENDING', u'UNCHECKED'], "Expected enum [u'FAILED', u'SUCCEEDED', u'PENDING', u'UNCHECKED'] but got %s" % obj._last_send_status[0]
            common.validate_format(obj._last_send_status[0], "None", None, None)
        obj._community_string = (data.get("communityString", obj.__undef__), dirty)
        if obj._community_string[0] is not None and obj._community_string[0] is not obj.__undef__:
            assert isinstance(obj._community_string[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._community_string[0]))
            common.validate_format(obj._community_string[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SNMPManager, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "use_inform" == "type" or (self.use_inform is not self.__undef__ and not (dirty and not self._use_inform[1])):
            dct["useInform"] = dictify(self.use_inform)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "last_send_status" == "type" or (self.last_send_status is not self.__undef__ and not (dirty and not self._last_send_status[1])):
            dct["lastSendStatus"] = dictify(self.last_send_status)
        if dirty and "lastSendStatus" in dct:
            del dct["lastSendStatus"]
        if "community_string" == "type" or (self.community_string is not self.__undef__ and not (dirty and not self._community_string[1])):
            dct["communityString"] = dictify(self.community_string)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._address = (self._address[0], True)
        self._use_inform = (self._use_inform[0], True)
        self._port = (self._port[0], True)
        self._last_send_status = (self._last_send_status[0], True)
        self._community_string = (self._community_string[0], True)

    def is_dirty(self):
        return any([self._address[1], self._use_inform[1], self._port[1], self._last_send_status[1], self._community_string[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SNMPManager):
            return False
        return super(SNMPManager, self).__eq__(other) and \
               self.address == other.address and \
               self.use_inform == other.use_inform and \
               self.port == other.port and \
               self.last_send_status == other.last_send_status and \
               self.community_string == other.community_string

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def address(self):
        """
        SNMP manager host.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def use_inform(self):
        """
        True if INFORM messages are to be sent to this manager, false for TRAP
        messages.

        :rtype: ``bool``
        """
        return self._use_inform[0]

    @use_inform.setter
    def use_inform(self, value):
        self._use_inform = (value, True)

    @property
    def port(self):
        """
        *(default value: 162)* SNMP manager port number.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def last_send_status(self):
        """
        *(default value: PENDING)* Describes if the most recent attempt to send
        a trap succeeded or failed. *(permitted values: FAILED, SUCCEEDED,
        PENDING, UNCHECKED)*

        :rtype: ``basestring``
        """
        return self._last_send_status[0]

    @property
    def community_string(self):
        """
        SNMP manager community string.

        :rtype: ``basestring``
        """
        return self._community_string[0]

    @community_string.setter
    def community_string(self, value):
        self._community_string = (value, True)

class JSUsageData(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* Usage data used
    to draw graphs on the Jet Stream pages.
    """
    def __init__(self, undef_enabled=True):
        super(JSUsageData, self).__init__()
        self._type = ("JSUsageData", True)
        self._start_date = (self.__undef__, True)
        self._usage_object = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSUsageData, cls).from_dict(data, dirty, undef_enabled)
        obj._start_date = (data.get("startDate", obj.__undef__), dirty)
        if obj._start_date[0] is not None and obj._start_date[0] is not obj.__undef__:
            assert isinstance(obj._start_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_date[0]))
            common.validate_format(obj._start_date[0], "date", None, None)
        obj._usage_object = (data.get("usageObject", obj.__undef__), dirty)
        if obj._usage_object[0] is not None and obj._usage_object[0] is not obj.__undef__:
            assert isinstance(obj._usage_object[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._usage_object[0]))
            common.validate_format(obj._usage_object[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSUsageData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "start_date" == "type" or (self.start_date is not self.__undef__ and not (dirty and not self._start_date[1])):
            dct["startDate"] = dictify(self.start_date)
        if "usage_object" == "type" or (self.usage_object is not self.__undef__ and not (dirty and not self._usage_object[1])):
            dct["usageObject"] = dictify(self.usage_object)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._start_date = (self._start_date[0], True)
        self._usage_object = (self._usage_object[0], True)

    def is_dirty(self):
        return any([self._start_date[1], self._usage_object[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSUsageData):
            return False
        return super(JSUsageData, self).__eq__(other) and \
               self.start_date == other.start_date and \
               self.usage_object == other.usage_object

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def start_date(self):
        """
        The date at the beginning of the time period this datapoint corresponds
        to. The time period itself varies between datapoint types.

        :rtype: ``basestring``
        """
        return self._start_date[0]

    @start_date.setter
    def start_date(self, value):
        self._start_date = (value, True)

    @property
    def usage_object(self):
        """
        The object the usage data is centered around.

        :rtype: ``basestring``
        """
        return self._usage_object[0]

    @usage_object.setter
    def usage_object(self, value):
        self._usage_object = (value, True)

class HostPrivilegeElevationProfileScript(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* A script that is
    part of a profile for elevating user privileges on a host.
    """
    def __init__(self, undef_enabled=True):
        super(HostPrivilegeElevationProfileScript, self).__init__()
        self._type = ("HostPrivilegeElevationProfileScript", True)
        self._profile = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._contents = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostPrivilegeElevationProfileScript, cls).from_dict(data, dirty, undef_enabled)
        obj._profile = (data.get("profile", obj.__undef__), dirty)
        if obj._profile[0] is not None and obj._profile[0] is not obj.__undef__:
            assert isinstance(obj._profile[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._profile[0]))
            common.validate_format(obj._profile[0], "objectReference", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._contents = (data.get("contents", obj.__undef__), dirty)
        if obj._contents[0] is not None and obj._contents[0] is not obj.__undef__:
            assert isinstance(obj._contents[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._contents[0]))
            common.validate_format(obj._contents[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostPrivilegeElevationProfileScript, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "profile" == "type" or (self.profile is not self.__undef__ and not (dirty and not self._profile[1])):
            dct["profile"] = dictify(self.profile)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "contents" == "type" or (self.contents is not self.__undef__ and not (dirty and not self._contents[1])):
            dct["contents"] = dictify(self.contents)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._profile = (self._profile[0], True)
        self._name = (self._name[0], True)
        self._contents = (self._contents[0], True)

    def is_dirty(self):
        return any([self._profile[1], self._name[1], self._contents[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostPrivilegeElevationProfileScript):
            return False
        return super(HostPrivilegeElevationProfileScript, self).__eq__(other) and \
               self.profile == other.profile and \
               self.name == other.name and \
               self.contents == other.contents

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def profile(self):
        """
        The privilege elevation profile to which this script belongs.

        :rtype: ``basestring``
        """
        return self._profile[0]

    @profile.setter
    def profile(self, value):
        self._profile = (value, True)

    @property
    def name(self):
        """
        The privilege elevation profile script name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def contents(self):
        """
        The contents of the privilege elevation profile script.

        :rtype: ``basestring``
        """
        return self._contents[0]

    @contents.setter
    def contents(self, value):
        self._contents = (value, True)

class HostPrivilegeElevationProfile(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* Profile for
    elevating user privileges on a host.
    """
    def __init__(self, undef_enabled=True):
        super(HostPrivilegeElevationProfile, self).__init__()
        self._type = ("HostPrivilegeElevationProfile", True)
        self._version = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._is_default = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostPrivilegeElevationProfile, cls).from_dict(data, dirty, undef_enabled)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._is_default = (data.get("isDefault", obj.__undef__), dirty)
        if obj._is_default[0] is not None and obj._is_default[0] is not obj.__undef__:
            assert isinstance(obj._is_default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._is_default[0]))
            common.validate_format(obj._is_default[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostPrivilegeElevationProfile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "is_default" == "type" or (self.is_default is not self.__undef__ and not (dirty and not self._is_default[1])):
            dct["isDefault"] = dictify(self.is_default)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._version = (self._version[0], True)
        self._name = (self._name[0], True)
        self._is_default = (self._is_default[0], True)

    def is_dirty(self):
        return any([self._version[1], self._name[1], self._is_default[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostPrivilegeElevationProfile):
            return False
        return super(HostPrivilegeElevationProfile, self).__eq__(other) and \
               self.version == other.version and \
               self.name == other.name and \
               self.is_default == other.is_default

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def version(self):
        """
        Privilege elevation profile version.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def name(self):
        """
        The privilege elevation profile name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def is_default(self):
        """
        True if this is the default privilege elevation profile for new
        environments.

        :rtype: ``bool``
        """
        return self._is_default[0]

    @is_default.setter
    def is_default(self, value):
        self._is_default = (value, True)

class AlertProfile(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* A profile that
    describes a set of actions to take in response to an alert being generated.
    """
    def __init__(self, undef_enabled=True):
        super(AlertProfile, self).__init__()
        self._type = ("AlertProfile", True)
        self._filter_spec = (self.__undef__, True)
        self._actions = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AlertProfile, cls).from_dict(data, dirty, undef_enabled)
        if "filterSpec" in data and data["filterSpec"] is not None:
            obj._filter_spec = (factory.create_object(data["filterSpec"], "AlertFilter"), dirty)
            factory.validate_type(obj._filter_spec[0], "AlertFilter")
        else:
            obj._filter_spec = (obj.__undef__, dirty)
        obj._actions = []
        for item in data.get("actions") or []:
            obj._actions.append(factory.create_object(item))
            factory.validate_type(obj._actions[-1], "AlertAction")
        obj._actions = (obj._actions, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AlertProfile, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "filter_spec" == "type" or (self.filter_spec is not self.__undef__ and not (dirty and not self._filter_spec[1])):
            dct["filterSpec"] = dictify(self.filter_spec)
        if "actions" == "type" or (self.actions is not self.__undef__ and not (dirty and not self._actions[1])):
            dct["actions"] = dictify(self.actions)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._filter_spec = (self._filter_spec[0], True)
        self._actions = (self._actions[0], True)

    def is_dirty(self):
        return any([self._filter_spec[1], self._actions[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AlertProfile):
            return False
        return super(AlertProfile, self).__eq__(other) and \
               self.filter_spec == other.filter_spec and \
               self.actions == other.actions

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def filter_spec(self):
        """
        Specifies which alerts should be matched by this profile.

        :rtype: :py:class:`v1_8_1.web.vo.AlertFilter`
        """
        return self._filter_spec[0]

    @filter_spec.setter
    def filter_spec(self, value):
        self._filter_spec = (value, True)

    @property
    def actions(self):
        """
        List of actions to take. Only alerts visible to the user and matching
        the optional filters are included. If there are multiple actions with
        the same result (such as emailing a user), only one result is acted
        upon.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.AlertAction`
        """
        return self._actions[0]

    @actions.setter
    def actions(self, value):
        self._actions = (value, True)

class FaultEffect(PersistentObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PersistentObject` *)* An error
    affecting a user object whose root cause is a fault. A fault effect can
    only be resolved by resolving the fault which is its root cause.
    """
    def __init__(self, undef_enabled=True):
        super(FaultEffect, self).__init__()
        self._type = ("FaultEffect", True)
        self._severity = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._root_cause = (self.__undef__, True)
        self._caused_by = (self.__undef__, True)
        self._response = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._action = (self.__undef__, True)
        self._bundle_id = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._date_diagnosed = (self.__undef__, True)
        self._description = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FaultEffect, cls).from_dict(data, dirty, undef_enabled)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'CRITICAL', u'WARNING'], "Expected enum [u'CRITICAL', u'WARNING'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._root_cause = (data.get("rootCause", obj.__undef__), dirty)
        if obj._root_cause[0] is not None and obj._root_cause[0] is not obj.__undef__:
            assert isinstance(obj._root_cause[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._root_cause[0]))
            common.validate_format(obj._root_cause[0], "objectReference", None, None)
        obj._caused_by = (data.get("causedBy", obj.__undef__), dirty)
        if obj._caused_by[0] is not None and obj._caused_by[0] is not obj.__undef__:
            assert isinstance(obj._caused_by[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._caused_by[0]))
            common.validate_format(obj._caused_by[0], "objectReference", None, None)
        obj._response = (data.get("response", obj.__undef__), dirty)
        if obj._response[0] is not None and obj._response[0] is not obj.__undef__:
            assert isinstance(obj._response[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._response[0]))
            common.validate_format(obj._response[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._bundle_id = (data.get("bundleID", obj.__undef__), dirty)
        if obj._bundle_id[0] is not None and obj._bundle_id[0] is not obj.__undef__:
            assert isinstance(obj._bundle_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bundle_id[0]))
            common.validate_format(obj._bundle_id[0], "None", None, None)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._date_diagnosed = (data.get("dateDiagnosed", obj.__undef__), dirty)
        if obj._date_diagnosed[0] is not None and obj._date_diagnosed[0] is not obj.__undef__:
            assert isinstance(obj._date_diagnosed[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_diagnosed[0]))
            common.validate_format(obj._date_diagnosed[0], "date", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FaultEffect, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "root_cause" == "type" or (self.root_cause is not self.__undef__ and not (dirty and not self._root_cause[1])):
            dct["rootCause"] = dictify(self.root_cause)
        if "caused_by" == "type" or (self.caused_by is not self.__undef__ and not (dirty and not self._caused_by[1])):
            dct["causedBy"] = dictify(self.caused_by)
        if "response" == "type" or (self.response is not self.__undef__ and not (dirty and not self._response[1])):
            dct["response"] = dictify(self.response)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "bundle_id" == "type" or (self.bundle_id is not self.__undef__ and not (dirty and not self._bundle_id[1])):
            dct["bundleID"] = dictify(self.bundle_id)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "date_diagnosed" == "type" or (self.date_diagnosed is not self.__undef__ and not (dirty and not self._date_diagnosed[1])):
            dct["dateDiagnosed"] = dictify(self.date_diagnosed)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._severity = (self._severity[0], True)
        self._title = (self._title[0], True)
        self._root_cause = (self._root_cause[0], True)
        self._caused_by = (self._caused_by[0], True)
        self._response = (self._response[0], True)
        self._target = (self._target[0], True)
        self._action = (self._action[0], True)
        self._bundle_id = (self._bundle_id[0], True)
        self._target_name = (self._target_name[0], True)
        self._date_diagnosed = (self._date_diagnosed[0], True)
        self._description = (self._description[0], True)

    def is_dirty(self):
        return any([self._severity[1], self._title[1], self._root_cause[1], self._caused_by[1], self._response[1], self._target[1], self._action[1], self._bundle_id[1], self._target_name[1], self._date_diagnosed[1], self._description[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FaultEffect):
            return False
        return super(FaultEffect, self).__eq__(other) and \
               self.severity == other.severity and \
               self.title == other.title and \
               self.root_cause == other.root_cause and \
               self.caused_by == other.caused_by and \
               self.response == other.response and \
               self.target == other.target and \
               self.action == other.action and \
               self.bundle_id == other.bundle_id and \
               self.target_name == other.target_name and \
               self.date_diagnosed == other.date_diagnosed and \
               self.description == other.description

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def severity(self):
        """
        The severity of the fault effect. This can either be CRITICAL or
        WARNING. *(permitted values: CRITICAL, WARNING)*

        :rtype: ``basestring``
        """
        return self._severity[0]

    @severity.setter
    def severity(self, value):
        self._severity = (value, True)

    @property
    def title(self):
        """
        Summary of the fault effect.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def root_cause(self):
        """
        The root cause of this fault effect. Resolving the fault effect can
        only occur by resolving its root cause.

        :rtype: ``basestring``
        """
        return self._root_cause[0]

    @root_cause.setter
    def root_cause(self, value):
        self._root_cause = (value, True)

    @property
    def caused_by(self):
        """
        The cause of the fault effect, in case there is a chain of fault
        effects originating from the root cause which resulted in this effect.

        :rtype: ``basestring``
        """
        return self._caused_by[0]

    @caused_by.setter
    def caused_by(self, value):
        self._caused_by = (value, True)

    @property
    def response(self):
        """
        The automated response taken by the system.

        :rtype: ``basestring``
        """
        return self._response[0]

    @response.setter
    def response(self, value):
        self._response = (value, True)

    @property
    def target(self):
        """
        The user-visible Delphix object that has a fault effect.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def action(self):
        """
        A suggested user action.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def bundle_id(self):
        """
        A unique dot delimited identifier associated with the fault effect.

        :rtype: ``basestring``
        """
        return self._bundle_id[0]

    @bundle_id.setter
    def bundle_id(self, value):
        self._bundle_id = (value, True)

    @property
    def target_name(self):
        """
        The name of the user-visible Delphix object that has a fault effect.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def date_diagnosed(self):
        """
        The date when the root cause fault was diagnosed.

        :rtype: ``basestring``
        """
        return self._date_diagnosed[0]

    @date_diagnosed.setter
    def date_diagnosed(self, value):
        self._date_diagnosed = (value, True)

    @property
    def description(self):
        """
        Full description of the fault effect.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

class JSWeeklyOperationCount(JSUsageData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSUsageData` *)* Information about the
    number of operations on a data container each week for up to 30 weeks.
    """
    def __init__(self, undef_enabled=True):
        super(JSWeeklyOperationCount, self).__init__()
        self._type = ("JSWeeklyOperationCount", True)
        self._weekly_duration = (self.__undef__, True)
        self._weekly_count = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSWeeklyOperationCount, cls).from_dict(data, dirty, undef_enabled)
        obj._weekly_duration = (data.get("weeklyDuration", obj.__undef__), dirty)
        if obj._weekly_duration[0] is not None and obj._weekly_duration[0] is not obj.__undef__:
            assert isinstance(obj._weekly_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._weekly_duration[0]))
            common.validate_format(obj._weekly_duration[0], "None", None, None)
        obj._weekly_count = (data.get("weeklyCount", obj.__undef__), dirty)
        if obj._weekly_count[0] is not None and obj._weekly_count[0] is not obj.__undef__:
            assert isinstance(obj._weekly_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._weekly_count[0]))
            common.validate_format(obj._weekly_count[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSWeeklyOperationCount, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "weekly_duration" == "type" or (self.weekly_duration is not self.__undef__ and not (dirty and not self._weekly_duration[1])):
            dct["weeklyDuration"] = dictify(self.weekly_duration)
        if "weekly_count" == "type" or (self.weekly_count is not self.__undef__ and not (dirty and not self._weekly_count[1])):
            dct["weeklyCount"] = dictify(self.weekly_count)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._weekly_duration = (self._weekly_duration[0], True)
        self._weekly_count = (self._weekly_count[0], True)

    def is_dirty(self):
        return any([self._weekly_duration[1], self._weekly_count[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSWeeklyOperationCount):
            return False
        return super(JSWeeklyOperationCount, self).__eq__(other) and \
               self.weekly_duration == other.weekly_duration and \
               self.weekly_count == other.weekly_count

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def weekly_duration(self):
        """
        The total time spent in seconds running all operations during the
        specified week.

        :rtype: ``int``
        """
        return self._weekly_duration[0]

    @weekly_duration.setter
    def weekly_duration(self, value):
        self._weekly_duration = (value, True)

    @property
    def weekly_count(self):
        """
        The number of operations run against a data container in the specified
        week.

        :rtype: ``int``
        """
        return self._weekly_count[0]

    @weekly_count.setter
    def weekly_count(self, value):
        self._weekly_count = (value, True)

class JSDailyOperationDuration(JSUsageData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSUsageData` *)* Information about the
    durations of a specific operation type for a data container over the past
    week.
    """
    def __init__(self, undef_enabled=True):
        super(JSDailyOperationDuration, self).__init__()
        self._type = ("JSDailyOperationDuration", True)
        self._daily_average_duration = (self.__undef__, True)
        self._daily_count = (self.__undef__, True)
        self._daily_min_duration = (self.__undef__, True)
        self._operation = (self.__undef__, True)
        self._daily_max_duration = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDailyOperationDuration, cls).from_dict(data, dirty, undef_enabled)
        obj._daily_average_duration = (data.get("dailyAverageDuration", obj.__undef__), dirty)
        if obj._daily_average_duration[0] is not None and obj._daily_average_duration[0] is not obj.__undef__:
            assert isinstance(obj._daily_average_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._daily_average_duration[0]))
            common.validate_format(obj._daily_average_duration[0], "None", None, None)
        obj._daily_count = (data.get("dailyCount", obj.__undef__), dirty)
        if obj._daily_count[0] is not None and obj._daily_count[0] is not obj.__undef__:
            assert isinstance(obj._daily_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._daily_count[0]))
            common.validate_format(obj._daily_count[0], "None", None, None)
        obj._daily_min_duration = (data.get("dailyMinDuration", obj.__undef__), dirty)
        if obj._daily_min_duration[0] is not None and obj._daily_min_duration[0] is not obj.__undef__:
            assert isinstance(obj._daily_min_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._daily_min_duration[0]))
            common.validate_format(obj._daily_min_duration[0], "None", None, None)
        obj._operation = (data.get("operation", obj.__undef__), dirty)
        if obj._operation[0] is not None and obj._operation[0] is not obj.__undef__:
            assert isinstance(obj._operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._operation[0]))
            assert obj._operation[0] in [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'RESTORE', u'UNDO'], "Expected enum [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'RESTORE', u'UNDO'] but got %s" % obj._operation[0]
            common.validate_format(obj._operation[0], "None", None, None)
        obj._daily_max_duration = (data.get("dailyMaxDuration", obj.__undef__), dirty)
        if obj._daily_max_duration[0] is not None and obj._daily_max_duration[0] is not obj.__undef__:
            assert isinstance(obj._daily_max_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._daily_max_duration[0]))
            common.validate_format(obj._daily_max_duration[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDailyOperationDuration, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "daily_average_duration" == "type" or (self.daily_average_duration is not self.__undef__ and not (dirty and not self._daily_average_duration[1])):
            dct["dailyAverageDuration"] = dictify(self.daily_average_duration)
        if "daily_count" == "type" or (self.daily_count is not self.__undef__ and not (dirty and not self._daily_count[1])):
            dct["dailyCount"] = dictify(self.daily_count)
        if "daily_min_duration" == "type" or (self.daily_min_duration is not self.__undef__ and not (dirty and not self._daily_min_duration[1])):
            dct["dailyMinDuration"] = dictify(self.daily_min_duration)
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        if "daily_max_duration" == "type" or (self.daily_max_duration is not self.__undef__ and not (dirty and not self._daily_max_duration[1])):
            dct["dailyMaxDuration"] = dictify(self.daily_max_duration)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._daily_average_duration = (self._daily_average_duration[0], True)
        self._daily_count = (self._daily_count[0], True)
        self._daily_min_duration = (self._daily_min_duration[0], True)
        self._operation = (self._operation[0], True)
        self._daily_max_duration = (self._daily_max_duration[0], True)

    def is_dirty(self):
        return any([self._daily_average_duration[1], self._daily_count[1], self._daily_min_duration[1], self._operation[1], self._daily_max_duration[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDailyOperationDuration):
            return False
        return super(JSDailyOperationDuration, self).__eq__(other) and \
               self.daily_average_duration == other.daily_average_duration and \
               self.daily_count == other.daily_count and \
               self.daily_min_duration == other.daily_min_duration and \
               self.operation == other.operation and \
               self.daily_max_duration == other.daily_max_duration

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def daily_average_duration(self):
        """
        The average duration in seconds of running the specified operation in
        the past day.

        :rtype: ``int``
        """
        return self._daily_average_duration[0]

    @daily_average_duration.setter
    def daily_average_duration(self, value):
        self._daily_average_duration = (value, True)

    @property
    def daily_count(self):
        """
        The number of times the specified operation was run in the past day.

        :rtype: ``int``
        """
        return self._daily_count[0]

    @daily_count.setter
    def daily_count(self, value):
        self._daily_count = (value, True)

    @property
    def daily_min_duration(self):
        """
        The minimum duration in seconds of running the specified operation in
        the past day.

        :rtype: ``int``
        """
        return self._daily_min_duration[0]

    @daily_min_duration.setter
    def daily_min_duration(self, value):
        self._daily_min_duration = (value, True)

    @property
    def operation(self):
        """
        The operation performed. *(permitted values: REFRESH, RESET,
        CREATE_BRANCH, RESTORE, UNDO)*

        :rtype: ``basestring``
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

    @property
    def daily_max_duration(self):
        """
        The maximum duration in seconds of running the specified operation in
        the past day.

        :rtype: ``int``
        """
        return self._daily_max_duration[0]

    @daily_max_duration.setter
    def daily_max_duration(self, value):
        self._daily_max_duration = (value, True)

class ReplicationSourceState(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* State of a replication
    spec.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationSourceState, self).__init__()
        self._type = ("ReplicationSourceState", True)
        self._last_point = (self.__undef__, True)
        self._spec = (self.__undef__, True)
        self._active_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationSourceState, cls).from_dict(data, dirty, undef_enabled)
        obj._last_point = (data.get("lastPoint", obj.__undef__), dirty)
        if obj._last_point[0] is not None and obj._last_point[0] is not obj.__undef__:
            assert isinstance(obj._last_point[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_point[0]))
            common.validate_format(obj._last_point[0], "objectReference", None, None)
        obj._spec = (data.get("spec", obj.__undef__), dirty)
        if obj._spec[0] is not None and obj._spec[0] is not obj.__undef__:
            assert isinstance(obj._spec[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._spec[0]))
            common.validate_format(obj._spec[0], "objectReference", None, None)
        obj._active_point = (data.get("activePoint", obj.__undef__), dirty)
        if obj._active_point[0] is not None and obj._active_point[0] is not obj.__undef__:
            assert isinstance(obj._active_point[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._active_point[0]))
            common.validate_format(obj._active_point[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationSourceState, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_point" == "type" or (self.last_point is not self.__undef__ and not (dirty and not self._last_point[1])):
            dct["lastPoint"] = dictify(self.last_point)
        if "spec" == "type" or (self.spec is not self.__undef__ and not (dirty and not self._spec[1])):
            dct["spec"] = dictify(self.spec)
        if "active_point" == "type" or (self.active_point is not self.__undef__ and not (dirty and not self._active_point[1])):
            dct["activePoint"] = dictify(self.active_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_point = (self._last_point[0], True)
        self._spec = (self._spec[0], True)
        self._active_point = (self._active_point[0], True)

    def is_dirty(self):
        return any([self._last_point[1], self._spec[1], self._active_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationSourceState):
            return False
        return super(ReplicationSourceState, self).__eq__(other) and \
               self.last_point == other.last_point and \
               self.spec == other.spec and \
               self.active_point == other.active_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_point(self):
        """
        The last serialization point sent. This can be null prior to the first
        replication run.

        :rtype: ``basestring``
        """
        return self._last_point[0]

    @last_point.setter
    def last_point(self, value):
        self._last_point = (value, True)

    @property
    def spec(self):
        """
        A reference to the replication specification responsible for the
        current state.

        :rtype: ``basestring``
        """
        return self._spec[0]

    @spec.setter
    def spec(self, value):
        self._spec = (value, True)

    @property
    def active_point(self):
        """
        The active serialization point, currently being sent or about to be
        sent to replication targets.

        :rtype: ``basestring``
        """
        return self._active_point[0]

    @active_point.setter
    def active_point(self, value):
        self._active_point = (value, True)

class NetworkInterface(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Configuration of an IP
    interface.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterface, self).__init__()
        self._type = ("NetworkInterface", True)
        self._mac_address = (self.__undef__, True)
        self._addresses = (self.__undef__, True)
        self._mtu = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._data_node = (self.__undef__, True)
        self._device = (self.__undef__, True)
        self._mtu_range = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterface, cls).from_dict(data, dirty, undef_enabled)
        obj._mac_address = (data.get("macAddress", obj.__undef__), dirty)
        if obj._mac_address[0] is not None and obj._mac_address[0] is not obj.__undef__:
            assert isinstance(obj._mac_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mac_address[0]))
            common.validate_format(obj._mac_address[0], "macAddress", None, None)
        obj._addresses = []
        for item in data.get("addresses") or []:
            obj._addresses.append(factory.create_object(item))
            factory.validate_type(obj._addresses[-1], "InterfaceAddress")
        obj._addresses = (obj._addresses, dirty)
        obj._mtu = (data.get("mtu", obj.__undef__), dirty)
        if obj._mtu[0] is not None and obj._mtu[0] is not obj.__undef__:
            assert isinstance(obj._mtu[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._mtu[0]))
            common.validate_format(obj._mtu[0], "None", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'OK', u'DOWN', u'FAILED'], "Expected enum [u'OK', u'DOWN', u'FAILED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        obj._device = (data.get("device", obj.__undef__), dirty)
        if obj._device[0] is not None and obj._device[0] is not obj.__undef__:
            assert isinstance(obj._device[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._device[0]))
            common.validate_format(obj._device[0], "None", None, None)
        obj._mtu_range = (data.get("mtuRange", obj.__undef__), dirty)
        if obj._mtu_range[0] is not None and obj._mtu_range[0] is not obj.__undef__:
            assert isinstance(obj._mtu_range[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mtu_range[0]))
            common.validate_format(obj._mtu_range[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterface, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mac_address" == "type" or (self.mac_address is not self.__undef__ and not (dirty and not self._mac_address[1])):
            dct["macAddress"] = dictify(self.mac_address)
        if "addresses" == "type" or (self.addresses is not self.__undef__ and not (dirty and not self._addresses[1])):
            dct["addresses"] = dictify(self.addresses)
        if "mtu" == "type" or (self.mtu is not self.__undef__ and not (dirty and not self._mtu[1])):
            dct["mtu"] = dictify(self.mtu)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        if "device" == "type" or (self.device is not self.__undef__ and not (dirty and not self._device[1])):
            dct["device"] = dictify(self.device)
        if "mtu_range" == "type" or (self.mtu_range is not self.__undef__ and not (dirty and not self._mtu_range[1])):
            dct["mtuRange"] = dictify(self.mtu_range)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mac_address = (self._mac_address[0], True)
        self._addresses = (self._addresses[0], True)
        self._mtu = (self._mtu[0], True)
        self._state = (self._state[0], True)
        self._data_node = (self._data_node[0], True)
        self._device = (self._device[0], True)
        self._mtu_range = (self._mtu_range[0], True)

    def is_dirty(self):
        return any([self._mac_address[1], self._addresses[1], self._mtu[1], self._state[1], self._data_node[1], self._device[1], self._mtu_range[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterface):
            return False
        return super(NetworkInterface, self).__eq__(other) and \
               self.mac_address == other.mac_address and \
               self.addresses == other.addresses and \
               self.mtu == other.mtu and \
               self.state == other.state and \
               self.data_node == other.data_node and \
               self.device == other.device and \
               self.mtu_range == other.mtu_range

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mac_address(self):
        """
        The MAC address associated with this interface.

        :rtype: ``basestring``
        """
        return self._mac_address[0]

    @mac_address.setter
    def mac_address(self, value):
        self._mac_address = (value, True)

    @property
    def addresses(self):
        """
        List of IP addresses assigned to the interface.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.InterfaceAddress`
        """
        return self._addresses[0]

    @addresses.setter
    def addresses(self, value):
        self._addresses = (value, True)

    @property
    def mtu(self):
        """
        The maximum transmission unit for this interface.

        :rtype: ``int``
        """
        return self._mtu[0]

    @mtu.setter
    def mtu(self, value):
        self._mtu = (value, True)

    @property
    def state(self):
        """
        The state of the interface. *(permitted values: OK, DOWN, FAILED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def data_node(self):
        """
        The data node to which the network inteface is attached.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

    @property
    def device(self):
        """
        The name of the device over which this interface is configured.

        :rtype: ``basestring``
        """
        return self._device[0]

    @device.setter
    def device(self, value):
        self._device = (value, True)

    @property
    def mtu_range(self):
        """
        The range of possible values for the mtu property.

        :rtype: ``basestring``
        """
        return self._mtu_range[0]

    @mtu_range.setter
    def mtu_range(self, value):
        self._mtu_range = (value, True)

class ReplicationObjectSpecification(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* The list of objects and
    the specification needed to replicate them.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationObjectSpecification, self).__init__()
        self._type = ("ReplicationObjectSpecification", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationObjectSpecification, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationObjectSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationObjectSpecification):
            return False
        return super(ReplicationObjectSpecification, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class Policy(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* The base policy type.
    """
    def __init__(self, undef_enabled=True):
        super(Policy, self).__init__()
        self._type = ("Policy", True)
        self._default = (self.__undef__, True)
        self._effective_type = (self.__undef__, True)
        self._customized = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Policy, cls).from_dict(data, dirty, undef_enabled)
        obj._default = (data.get("default", obj.__undef__), dirty)
        if obj._default[0] is not None and obj._default[0] is not obj.__undef__:
            assert isinstance(obj._default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._default[0]))
            common.validate_format(obj._default[0], "None", None, None)
        obj._effective_type = (data.get("effectiveType", obj.__undef__), dirty)
        if obj._effective_type[0] is not None and obj._effective_type[0] is not obj.__undef__:
            assert isinstance(obj._effective_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._effective_type[0]))
            assert obj._effective_type[0] in [u'DIRECT_APPLIED', u'INHERITED'], "Expected enum [u'DIRECT_APPLIED', u'INHERITED'] but got %s" % obj._effective_type[0]
            common.validate_format(obj._effective_type[0], "None", None, None)
        obj._customized = (data.get("customized", obj.__undef__), dirty)
        if obj._customized[0] is not None and obj._customized[0] is not obj.__undef__:
            assert isinstance(obj._customized[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._customized[0]))
            common.validate_format(obj._customized[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Policy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "default" == "type" or (self.default is not self.__undef__ and not (dirty and not self._default[1])):
            dct["default"] = dictify(self.default)
        if "effective_type" == "type" or (self.effective_type is not self.__undef__ and not (dirty and not self._effective_type[1])):
            dct["effectiveType"] = dictify(self.effective_type)
        if "customized" == "type" or (self.customized is not self.__undef__ and not (dirty and not self._customized[1])):
            dct["customized"] = dictify(self.customized)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._default = (self._default[0], True)
        self._effective_type = (self._effective_type[0], True)
        self._customized = (self._customized[0], True)

    def is_dirty(self):
        return any([self._default[1], self._effective_type[1], self._customized[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Policy):
            return False
        return super(Policy, self).__eq__(other) and \
               self.default == other.default and \
               self.effective_type == other.effective_type and \
               self.customized == other.customized

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def default(self):
        """
        True if this is the default policy created when the system is setup.
        Default policies cannot be deleted.

        :rtype: ``bool``
        """
        return self._default[0]

    @default.setter
    def default(self, value):
        self._default = (value, True)

    @property
    def effective_type(self):
        """
        Whether this policy has been directly applied or inherited. See the
        effectivePolicies parameter of the list call for details. *(permitted
        values: DIRECT_APPLIED, INHERITED)*

        :rtype: ``basestring``
        """
        return self._effective_type[0]

    @effective_type.setter
    def effective_type(self, value):
        self._effective_type = (value, True)

    @property
    def customized(self):
        """
        True if this policy is customized specifically for one object.
        Customized policies cannot be shared between objects.

        :rtype: ``bool``
        """
        return self._customized[0]

    @customized.setter
    def customized(self, value):
        self._customized = (value, True)

class X509Certificate(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* X509 Certificate.
    """
    def __init__(self, undef_enabled=True):
        super(X509Certificate, self).__init__()
        self._type = ("X509Certificate", True)
        self._accepted = (self.__undef__, True)
        self._sha1_fingerprint = (self.__undef__, True)
        self._valid_to = (self.__undef__, True)
        self._serial_number = (self.__undef__, True)
        self._issued_by_dn = (self.__undef__, True)
        self._md5_fingerprint = (self.__undef__, True)
        self._valid_from = (self.__undef__, True)
        self._issued_to_dn = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(X509Certificate, cls).from_dict(data, dirty, undef_enabled)
        obj._accepted = (data.get("accepted", obj.__undef__), dirty)
        if obj._accepted[0] is not None and obj._accepted[0] is not obj.__undef__:
            assert isinstance(obj._accepted[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._accepted[0]))
            common.validate_format(obj._accepted[0], "None", None, None)
        obj._sha1_fingerprint = (data.get("sha1Fingerprint", obj.__undef__), dirty)
        if obj._sha1_fingerprint[0] is not None and obj._sha1_fingerprint[0] is not obj.__undef__:
            assert isinstance(obj._sha1_fingerprint[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._sha1_fingerprint[0]))
            common.validate_format(obj._sha1_fingerprint[0], "None", None, None)
        obj._valid_to = (data.get("validTo", obj.__undef__), dirty)
        if obj._valid_to[0] is not None and obj._valid_to[0] is not obj.__undef__:
            assert isinstance(obj._valid_to[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._valid_to[0]))
            common.validate_format(obj._valid_to[0], "None", None, None)
        obj._serial_number = (data.get("serialNumber", obj.__undef__), dirty)
        if obj._serial_number[0] is not None and obj._serial_number[0] is not obj.__undef__:
            assert isinstance(obj._serial_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._serial_number[0]))
            common.validate_format(obj._serial_number[0], "None", None, None)
        obj._issued_by_dn = (data.get("issuedByDN", obj.__undef__), dirty)
        if obj._issued_by_dn[0] is not None and obj._issued_by_dn[0] is not obj.__undef__:
            assert isinstance(obj._issued_by_dn[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._issued_by_dn[0]))
            common.validate_format(obj._issued_by_dn[0], "None", None, None)
        obj._md5_fingerprint = (data.get("md5Fingerprint", obj.__undef__), dirty)
        if obj._md5_fingerprint[0] is not None and obj._md5_fingerprint[0] is not obj.__undef__:
            assert isinstance(obj._md5_fingerprint[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._md5_fingerprint[0]))
            common.validate_format(obj._md5_fingerprint[0], "None", None, None)
        obj._valid_from = (data.get("validFrom", obj.__undef__), dirty)
        if obj._valid_from[0] is not None and obj._valid_from[0] is not obj.__undef__:
            assert isinstance(obj._valid_from[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._valid_from[0]))
            common.validate_format(obj._valid_from[0], "None", None, None)
        obj._issued_to_dn = (data.get("issuedToDN", obj.__undef__), dirty)
        if obj._issued_to_dn[0] is not None and obj._issued_to_dn[0] is not obj.__undef__:
            assert isinstance(obj._issued_to_dn[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._issued_to_dn[0]))
            common.validate_format(obj._issued_to_dn[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(X509Certificate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "accepted" == "type" or (self.accepted is not self.__undef__ and not (dirty and not self._accepted[1])):
            dct["accepted"] = dictify(self.accepted)
        if "sha1_fingerprint" == "type" or (self.sha1_fingerprint is not self.__undef__ and not (dirty and not self._sha1_fingerprint[1])):
            dct["sha1Fingerprint"] = dictify(self.sha1_fingerprint)
        if "valid_to" == "type" or (self.valid_to is not self.__undef__ and not (dirty and not self._valid_to[1])):
            dct["validTo"] = dictify(self.valid_to)
        if "serial_number" == "type" or (self.serial_number is not self.__undef__ and not (dirty and not self._serial_number[1])):
            dct["serialNumber"] = dictify(self.serial_number)
        if "issued_by_dn" == "type" or (self.issued_by_dn is not self.__undef__ and not (dirty and not self._issued_by_dn[1])):
            dct["issuedByDN"] = dictify(self.issued_by_dn)
        if "md5_fingerprint" == "type" or (self.md5_fingerprint is not self.__undef__ and not (dirty and not self._md5_fingerprint[1])):
            dct["md5Fingerprint"] = dictify(self.md5_fingerprint)
        if "valid_from" == "type" or (self.valid_from is not self.__undef__ and not (dirty and not self._valid_from[1])):
            dct["validFrom"] = dictify(self.valid_from)
        if "issued_to_dn" == "type" or (self.issued_to_dn is not self.__undef__ and not (dirty and not self._issued_to_dn[1])):
            dct["issuedToDN"] = dictify(self.issued_to_dn)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._accepted = (self._accepted[0], True)
        self._sha1_fingerprint = (self._sha1_fingerprint[0], True)
        self._valid_to = (self._valid_to[0], True)
        self._serial_number = (self._serial_number[0], True)
        self._issued_by_dn = (self._issued_by_dn[0], True)
        self._md5_fingerprint = (self._md5_fingerprint[0], True)
        self._valid_from = (self._valid_from[0], True)
        self._issued_to_dn = (self._issued_to_dn[0], True)

    def is_dirty(self):
        return any([self._accepted[1], self._sha1_fingerprint[1], self._valid_to[1], self._serial_number[1], self._issued_by_dn[1], self._md5_fingerprint[1], self._valid_from[1], self._issued_to_dn[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, X509Certificate):
            return False
        return super(X509Certificate, self).__eq__(other) and \
               self.accepted == other.accepted and \
               self.sha1_fingerprint == other.sha1_fingerprint and \
               self.valid_to == other.valid_to and \
               self.serial_number == other.serial_number and \
               self.issued_by_dn == other.issued_by_dn and \
               self.md5_fingerprint == other.md5_fingerprint and \
               self.valid_from == other.valid_from and \
               self.issued_to_dn == other.issued_to_dn

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def accepted(self):
        """
        Delphix trusts this certificate .

        :rtype: ``bool``
        """
        return self._accepted[0]

    @accepted.setter
    def accepted(self, value):
        self._accepted = (value, True)

    @property
    def sha1_fingerprint(self):
        """
        SHA-1 fingerprint.

        :rtype: ``basestring``
        """
        return self._sha1_fingerprint[0]

    @sha1_fingerprint.setter
    def sha1_fingerprint(self, value):
        self._sha1_fingerprint = (value, True)

    @property
    def valid_to(self):
        """
        End of validity.

        :rtype: ``basestring``
        """
        return self._valid_to[0]

    @valid_to.setter
    def valid_to(self, value):
        self._valid_to = (value, True)

    @property
    def serial_number(self):
        """
        Certificate serial number.

        :rtype: ``basestring``
        """
        return self._serial_number[0]

    @serial_number.setter
    def serial_number(self, value):
        self._serial_number = (value, True)

    @property
    def issued_by_dn(self):
        """
        Issuer of this certificate.

        :rtype: ``basestring``
        """
        return self._issued_by_dn[0]

    @issued_by_dn.setter
    def issued_by_dn(self, value):
        self._issued_by_dn = (value, True)

    @property
    def md5_fingerprint(self):
        """
        MD5 fingerprint.

        :rtype: ``basestring``
        """
        return self._md5_fingerprint[0]

    @md5_fingerprint.setter
    def md5_fingerprint(self, value):
        self._md5_fingerprint = (value, True)

    @property
    def valid_from(self):
        """
        Start of validity.

        :rtype: ``basestring``
        """
        return self._valid_from[0]

    @valid_from.setter
    def valid_from(self, value):
        self._valid_from = (value, True)

    @property
    def issued_to_dn(self):
        """
        Distinguished name of subject of this certificate.

        :rtype: ``basestring``
        """
        return self._issued_to_dn[0]

    @issued_to_dn.setter
    def issued_to_dn(self, value):
        self._issued_to_dn = (value, True)

class NamedUserObject(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Super schema for all
    schemas representing user-visible objects that have a name.
    """
    def __init__(self, undef_enabled=True):
        super(NamedUserObject, self).__init__()
        self._type = ("NamedUserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NamedUserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NamedUserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NamedUserObject):
            return False
        return super(NamedUserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class ReplicationSpec(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Replication setup.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationSpec, self).__init__()
        self._type = ("ReplicationSpec", True)
        self._object_specification = (self.__undef__, True)
        self._number_of_connections = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._schedule = (self.__undef__, True)
        self._encrypted = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._use_system_socks_setting = (self.__undef__, True)
        self._target_credential = (self.__undef__, True)
        self._target_principal = (self.__undef__, True)
        self._target_port = (self.__undef__, True)
        self._target_host = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationSpec, cls).from_dict(data, dirty, undef_enabled)
        if "objectSpecification" in data and data["objectSpecification"] is not None:
            obj._object_specification = (factory.create_object(data["objectSpecification"], "ReplicationObjectSpecification"), dirty)
            factory.validate_type(obj._object_specification[0], "ReplicationObjectSpecification")
        else:
            obj._object_specification = (obj.__undef__, dirty)
        obj._number_of_connections = (data.get("numberOfConnections", obj.__undef__), dirty)
        if obj._number_of_connections[0] is not None and obj._number_of_connections[0] is not obj.__undef__:
            assert isinstance(obj._number_of_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._number_of_connections[0]))
            common.validate_format(obj._number_of_connections[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._schedule = (data.get("schedule", obj.__undef__), dirty)
        if obj._schedule[0] is not None and obj._schedule[0] is not obj.__undef__:
            assert isinstance(obj._schedule[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._schedule[0]))
            common.validate_format(obj._schedule[0], "None", 1, 256)
        obj._encrypted = (data.get("encrypted", obj.__undef__), dirty)
        if obj._encrypted[0] is not None and obj._encrypted[0] is not obj.__undef__:
            assert isinstance(obj._encrypted[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted[0]))
            common.validate_format(obj._encrypted[0], "None", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", 1, 256)
        obj._use_system_socks_setting = (data.get("useSystemSocksSetting", obj.__undef__), dirty)
        if obj._use_system_socks_setting[0] is not None and obj._use_system_socks_setting[0] is not obj.__undef__:
            assert isinstance(obj._use_system_socks_setting[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_system_socks_setting[0]))
            common.validate_format(obj._use_system_socks_setting[0], "None", None, None)
        if "targetCredential" in data and data["targetCredential"] is not None:
            obj._target_credential = (factory.create_object(data["targetCredential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._target_credential[0], "PasswordCredential")
        else:
            obj._target_credential = (obj.__undef__, dirty)
        obj._target_principal = (data.get("targetPrincipal", obj.__undef__), dirty)
        if obj._target_principal[0] is not None and obj._target_principal[0] is not obj.__undef__:
            assert isinstance(obj._target_principal[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_principal[0]))
            common.validate_format(obj._target_principal[0], "None", None, None)
        obj._target_port = (data.get("targetPort", obj.__undef__), dirty)
        if obj._target_port[0] is not None and obj._target_port[0] is not obj.__undef__:
            assert isinstance(obj._target_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._target_port[0]))
            common.validate_format(obj._target_port[0], "None", None, None)
        obj._target_host = (data.get("targetHost", obj.__undef__), dirty)
        if obj._target_host[0] is not None and obj._target_host[0] is not obj.__undef__:
            assert isinstance(obj._target_host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_host[0]))
            common.validate_format(obj._target_host[0], "host", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ReplicationSpecRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ReplicationSpecRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationSpec, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_specification" == "type" or (self.object_specification is not self.__undef__ and not (dirty and not self._object_specification[1])):
            dct["objectSpecification"] = dictify(self.object_specification)
        if "number_of_connections" == "type" or (self.number_of_connections is not self.__undef__ and not (dirty and not self._number_of_connections[1])):
            dct["numberOfConnections"] = dictify(self.number_of_connections)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "schedule" == "type" or (self.schedule is not self.__undef__ and not (dirty and not self._schedule[1])):
            dct["schedule"] = dictify(self.schedule)
        if "encrypted" == "type" or (self.encrypted is not self.__undef__ and not (dirty and not self._encrypted[1])):
            dct["encrypted"] = dictify(self.encrypted)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "use_system_socks_setting" == "type" or (self.use_system_socks_setting is not self.__undef__ and not (dirty and not self._use_system_socks_setting[1])):
            dct["useSystemSocksSetting"] = dictify(self.use_system_socks_setting)
        if "target_credential" == "type" or (self.target_credential is not self.__undef__ and not (dirty and not self._target_credential[1])):
            dct["targetCredential"] = dictify(self.target_credential)
        if "target_principal" == "type" or (self.target_principal is not self.__undef__ and not (dirty and not self._target_principal[1])):
            dct["targetPrincipal"] = dictify(self.target_principal)
        if "target_port" == "type" or (self.target_port is not self.__undef__ and not (dirty and not self._target_port[1])):
            dct["targetPort"] = dictify(self.target_port)
        if "target_host" == "type" or (self.target_host is not self.__undef__ and not (dirty and not self._target_host[1])):
            dct["targetHost"] = dictify(self.target_host)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_specification = (self._object_specification[0], True)
        self._number_of_connections = (self._number_of_connections[0], True)
        self._description = (self._description[0], True)
        self._schedule = (self._schedule[0], True)
        self._encrypted = (self._encrypted[0], True)
        self._enabled = (self._enabled[0], True)
        self._tag = (self._tag[0], True)
        self._use_system_socks_setting = (self._use_system_socks_setting[0], True)
        self._target_credential = (self._target_credential[0], True)
        self._target_principal = (self._target_principal[0], True)
        self._target_port = (self._target_port[0], True)
        self._target_host = (self._target_host[0], True)
        self._runtime = (self._runtime[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)

    def is_dirty(self):
        return any([self._object_specification[1], self._number_of_connections[1], self._description[1], self._schedule[1], self._encrypted[1], self._enabled[1], self._tag[1], self._use_system_socks_setting[1], self._target_credential[1], self._target_principal[1], self._target_port[1], self._target_host[1], self._runtime[1], self._bandwidth_limit[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationSpec):
            return False
        return super(ReplicationSpec, self).__eq__(other) and \
               self.object_specification == other.object_specification and \
               self.number_of_connections == other.number_of_connections and \
               self.description == other.description and \
               self.schedule == other.schedule and \
               self.encrypted == other.encrypted and \
               self.enabled == other.enabled and \
               self.tag == other.tag and \
               self.use_system_socks_setting == other.use_system_socks_setting and \
               self.target_credential == other.target_credential and \
               self.target_principal == other.target_principal and \
               self.target_port == other.target_port and \
               self.target_host == other.target_host and \
               self.runtime == other.runtime and \
               self.bandwidth_limit == other.bandwidth_limit

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_specification(self):
        """
        Specification of the objects to replicate.

        :rtype: :py:class:`v1_8_1.web.vo.ReplicationObjectSpecification`
        """
        return self._object_specification[0]

    @object_specification.setter
    def object_specification(self, value):
        self._object_specification = (value, True)

    @property
    def number_of_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use.

        :rtype: ``int``
        """
        return self._number_of_connections[0]

    @number_of_connections.setter
    def number_of_connections(self, value):
        self._number_of_connections = (value, True)

    @property
    def description(self):
        """
        Description of this replication spec.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def schedule(self):
        """
        Replication schedule in the form of a quartz-formatted string.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._schedule[0]

    @schedule.setter
    def schedule(self, value):
        self._schedule = (value, True)

    @property
    def encrypted(self):
        """
        Encrypt replication network traffic.

        :rtype: ``bool``
        """
        return self._encrypted[0]

    @encrypted.setter
    def encrypted(self, value):
        self._encrypted = (value, True)

    @property
    def enabled(self):
        """
        Indication whether the replication spec schedule is enabled or not.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def tag(self):
        """
        Globally unique identifier for this replication spec.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def use_system_socks_setting(self):
        """
        Connect to the replication target host via the system-wide SOCKS proxy.

        :rtype: ``bool``
        """
        return self._use_system_socks_setting[0]

    @use_system_socks_setting.setter
    def use_system_socks_setting(self, value):
        self._use_system_socks_setting = (value, True)

    @property
    def target_credential(self):
        """
        Credential used to authenticate to the replication target host.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._target_credential[0]

    @target_credential.setter
    def target_credential(self, value):
        self._target_credential = (value, True)

    @property
    def target_principal(self):
        """
        Principal name used to authenticate to the replication target host.

        :rtype: ``basestring``
        """
        return self._target_principal[0]

    @target_principal.setter
    def target_principal(self, value):
        self._target_principal = (value, True)

    @property
    def target_port(self):
        """
        *(default value: 8415)* Target TCP port number for the Delphix Session
        Protocol.

        :rtype: ``int``
        """
        return self._target_port[0]

    @target_port.setter
    def target_port(self, value):
        self._target_port = (value, True)

    @property
    def target_host(self):
        """
        Replication target host address.

        :rtype: ``basestring``
        """
        return self._target_host[0]

    @target_host.setter
    def target_host(self, value):
        self._target_host = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this replication spec.

        :rtype: :py:class:`v1_8_1.web.vo.ReplicationSpecRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for replication network traffic. A value of 0
        means no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

class Transformation(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* A data platform
    agnostic transformation object.
    """
    def __init__(self, undef_enabled=True):
        super(Transformation, self).__init__()
        self._type = ("Transformation", True)
        self._operations = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._platform_params = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Transformation, cls).from_dict(data, dirty, undef_enabled)
        obj._operations = []
        for item in data.get("operations") or []:
            obj._operations.append(factory.create_object(item))
            factory.validate_type(obj._operations[-1], "SourceOperation")
        obj._operations = (obj._operations, dirty)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        if "platformParams" in data and data["platformParams"] is not None:
            obj._platform_params = (factory.create_object(data["platformParams"], "BasePlatformParameters"), dirty)
            factory.validate_type(obj._platform_params[0], "BasePlatformParameters")
        else:
            obj._platform_params = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Transformation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "platform_params" == "type" or (self.platform_params is not self.__undef__ and not (dirty and not self._platform_params[1])):
            dct["platformParams"] = dictify(self.platform_params)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._container = (self._container[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._repository = (self._repository[0], True)
        self._platform_params = (self._platform_params[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._container[1], self._environment_user[1], self._repository[1], self._platform_params[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Transformation):
            return False
        return super(Transformation, self).__eq__(other) and \
               self.operations == other.operations and \
               self.container == other.container and \
               self.environment_user == other.environment_user and \
               self.repository == other.repository and \
               self.platform_params == other.platform_params

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        Operations to perform when this transformation is applied.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def container(self):
        """
        A reference to the container which is a transformed version of the
        parent container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def environment_user(self):
        """
        Reference to the user used during application of the transformation.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def repository(self):
        """
        Reference to the repository used during application of the
        transformation.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def platform_params(self):
        """
        Platform-specific parameters that are stored on a transformation.

        :rtype: :py:class:`v1_8_1.web.vo.BasePlatformParameters`
        """
        return self._platform_params[0]

    @platform_params.setter
    def platform_params(self, value):
        self._platform_params = (value, True)

class MaskingJob(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* The Delphix Engine
    record of an existing Masking Job.
    """
    def __init__(self, undef_enabled=True):
        super(MaskingJob, self).__init__()
        self._type = ("MaskingJob", True)
        self._associated_container = (self.__undef__, True)
        self._application_id = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._masking_job_id = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MaskingJob, cls).from_dict(data, dirty, undef_enabled)
        obj._associated_container = (data.get("associatedContainer", obj.__undef__), dirty)
        if obj._associated_container[0] is not None and obj._associated_container[0] is not obj.__undef__:
            assert isinstance(obj._associated_container[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._associated_container[0]))
            common.validate_format(obj._associated_container[0], "objectReference", None, None)
        obj._application_id = (data.get("applicationId", obj.__undef__), dirty)
        if obj._application_id[0] is not None and obj._application_id[0] is not obj.__undef__:
            assert isinstance(obj._application_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._application_id[0]))
            common.validate_format(obj._application_id[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "objectName", None, 256)
        obj._masking_job_id = (data.get("maskingJobId", obj.__undef__), dirty)
        if obj._masking_job_id[0] is not None and obj._masking_job_id[0] is not obj.__undef__:
            assert isinstance(obj._masking_job_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._masking_job_id[0]))
            common.validate_format(obj._masking_job_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MaskingJob, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "associated_container" == "type" or (self.associated_container is not self.__undef__ and not (dirty and not self._associated_container[1])):
            dct["associatedContainer"] = dictify(self.associated_container)
        if "application_id" == "type" or (self.application_id is not self.__undef__ and not (dirty and not self._application_id[1])):
            dct["applicationId"] = dictify(self.application_id)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "masking_job_id" == "type" or (self.masking_job_id is not self.__undef__ and not (dirty and not self._masking_job_id[1])):
            dct["maskingJobId"] = dictify(self.masking_job_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._associated_container = (self._associated_container[0], True)
        self._application_id = (self._application_id[0], True)
        self._name = (self._name[0], True)
        self._masking_job_id = (self._masking_job_id[0], True)

    def is_dirty(self):
        return any([self._associated_container[1], self._application_id[1], self._name[1], self._masking_job_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MaskingJob):
            return False
        return super(MaskingJob, self).__eq__(other) and \
               self.associated_container == other.associated_container and \
               self.application_id == other.application_id and \
               self.name == other.name and \
               self.masking_job_id == other.masking_job_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def associated_container(self):
        """
        A reference to the container that the Masking Job is intended to
        operate on.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._associated_container[0]

    @associated_container.setter
    def associated_container(self, value):
        self._associated_container = (value, True)

    @property
    def application_id(self):
        """
        The application id from the Delphix Masking Engine instance that
        specifies the desired Masking Job.

        :rtype: ``basestring``
        """
        return self._application_id[0]

    @application_id.setter
    def application_id(self, value):
        self._application_id = (value, True)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def masking_job_id(self):
        """
        The masking job id from the Delphix Masking Engine instance that
        specifies the desired Masking Job.

        :rtype: ``basestring``
        """
        return self._masking_job_id[0]

    @masking_job_id.setter
    def masking_job_id(self, value):
        self._masking_job_id = (value, True)

class Role(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Describes a role as
    applied to a user on an object.
    """
    def __init__(self, undef_enabled=True):
        super(Role, self).__init__()
        self._type = ("Role", True)
        self._immutable = (self.__undef__, True)
        self._permissions = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Role, cls).from_dict(data, dirty, undef_enabled)
        obj._immutable = (data.get("immutable", obj.__undef__), dirty)
        if obj._immutable[0] is not None and obj._immutable[0] is not obj.__undef__:
            assert isinstance(obj._immutable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._immutable[0]))
            common.validate_format(obj._immutable[0], "None", None, None)
        obj._permissions = []
        for item in data.get("permissions") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._permissions.append(item)
        obj._permissions = (obj._permissions, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Role, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "immutable" == "type" or (self.immutable is not self.__undef__ and not (dirty and not self._immutable[1])):
            dct["immutable"] = dictify(self.immutable)
        if "permissions" == "type" or (self.permissions is not self.__undef__ and not (dirty and not self._permissions[1])):
            dct["permissions"] = dictify(self.permissions)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._immutable = (self._immutable[0], True)
        self._permissions = (self._permissions[0], True)

    def is_dirty(self):
        return any([self._immutable[1], self._permissions[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Role):
            return False
        return super(Role, self).__eq__(other) and \
               self.immutable == other.immutable and \
               self.permissions == other.permissions

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def immutable(self):
        """
        Determines if the role can be modified or not. Some roles are shipped
        with the Delphix Engine and cannot be changed.

        :rtype: ``bool``
        """
        return self._immutable[0]

    @immutable.setter
    def immutable(self, value):
        self._immutable = (value, True)

    @property
    def permissions(self):
        """
        List of permissions contained in the role.

        :rtype: ``list`` of ``basestring``
        """
        return self._permissions[0]

    @permissions.setter
    def permissions(self, value):
        self._permissions = (value, True)

class Source(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* A source represents an
    external database instance outside the Delphix system.
    """
    def __init__(self, undef_enabled=True):
        super(Source, self).__init__()
        self._type = ("Source", True)
        self._status = (self.__undef__, True)
        self._staging = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._virtual = (self.__undef__, True)
        self._restoration = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._linked = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Source, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'DEFAULT', u'PENDING_UPGRADE'], "Expected enum [u'DEFAULT', u'PENDING_UPGRADE'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._staging = (data.get("staging", obj.__undef__), dirty)
        if obj._staging[0] is not None and obj._staging[0] is not obj.__undef__:
            assert isinstance(obj._staging[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging[0]))
            common.validate_format(obj._staging[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._virtual = (data.get("virtual", obj.__undef__), dirty)
        if obj._virtual[0] is not None and obj._virtual[0] is not obj.__undef__:
            assert isinstance(obj._virtual[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._virtual[0]))
            common.validate_format(obj._virtual[0], "None", None, None)
        obj._restoration = (data.get("restoration", obj.__undef__), dirty)
        if obj._restoration[0] is not None and obj._restoration[0] is not obj.__undef__:
            assert isinstance(obj._restoration[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._restoration[0]))
            common.validate_format(obj._restoration[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "SourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._linked = (data.get("linked", obj.__undef__), dirty)
        if obj._linked[0] is not None and obj._linked[0] is not obj.__undef__:
            assert isinstance(obj._linked[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._linked[0]))
            common.validate_format(obj._linked[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Source, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "staging" == "type" or (self.staging is not self.__undef__ and not (dirty and not self._staging[1])):
            dct["staging"] = dictify(self.staging)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "virtual" == "type" or (self.virtual is not self.__undef__ and not (dirty and not self._virtual[1])):
            dct["virtual"] = dictify(self.virtual)
        if "restoration" == "type" or (self.restoration is not self.__undef__ and not (dirty and not self._restoration[1])):
            dct["restoration"] = dictify(self.restoration)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "linked" == "type" or (self.linked is not self.__undef__ and not (dirty and not self._linked[1])):
            dct["linked"] = dictify(self.linked)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._staging = (self._staging[0], True)
        self._description = (self._description[0], True)
        self._virtual = (self._virtual[0], True)
        self._restoration = (self._restoration[0], True)
        self._container = (self._container[0], True)
        self._runtime = (self._runtime[0], True)
        self._config = (self._config[0], True)
        self._linked = (self._linked[0], True)

    def is_dirty(self):
        return any([self._status[1], self._staging[1], self._description[1], self._virtual[1], self._restoration[1], self._container[1], self._runtime[1], self._config[1], self._linked[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Source):
            return False
        return super(Source, self).__eq__(other) and \
               self.status == other.status and \
               self.staging == other.staging and \
               self.description == other.description and \
               self.virtual == other.virtual and \
               self.restoration == other.restoration and \
               self.container == other.container and \
               self.runtime == other.runtime and \
               self.config == other.config and \
               self.linked == other.linked

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Status of this source. *(permitted values: DEFAULT, PENDING_UPGRADE)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def staging(self):
        """
        Flag indicating whether the source is used as a staging source for pre-
        provisioning. Staging sources are managed by the Delphix system.

        :rtype: ``bool``
        """
        return self._staging[0]

    @staging.setter
    def staging(self, value):
        self._staging = (value, True)

    @property
    def description(self):
        """
        A user-provided description of the source.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def virtual(self):
        """
        Flag indicating whether the source is a virtual source in the Delphix
        system.

        :rtype: ``bool``
        """
        return self._virtual[0]

    @virtual.setter
    def virtual(self, value):
        self._virtual = (value, True)

    @property
    def restoration(self):
        """
        Flag indicating whether the source is a restoration source in the
        Delphix system.

        :rtype: ``bool``
        """
        return self._restoration[0]

    @restoration.setter
    def restoration(self, value):
        self._restoration = (value, True)

    @property
    def container(self):
        """
        Reference to the container being fed by this source, if any.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.SourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def linked(self):
        """
        Flag indicating whether the source is a linked source in the Delphix
        system.

        :rtype: ``bool``
        """
        return self._linked[0]

    @linked.setter
    def linked(self, value):
        self._linked = (value, True)

class LocaleSettings(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Global locale settings.
    """
    def __init__(self, undef_enabled=True):
        super(LocaleSettings, self).__init__()
        self._type = ("LocaleSettings", True)
        self._locale = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LocaleSettings, cls).from_dict(data, dirty, undef_enabled)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            common.validate_format(obj._locale[0], "locale", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LocaleSettings, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._locale = (self._locale[0], True)

    def is_dirty(self):
        return any([self._locale[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LocaleSettings):
            return False
        return super(LocaleSettings, self).__eq__(other) and \
               self.locale == other.locale

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def locale(self):
        """
        *(default value: en-US)* System default locale as an IETF BCP 47
        language tag, defaults to 'en-US'.

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

class ReadonlyNamedUserObject(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Super schema for all
    schemas representing user-visible objects that have a read-only 'name'.
    """
    def __init__(self, undef_enabled=True):
        super(ReadonlyNamedUserObject, self).__init__()
        self._type = ("ReadonlyNamedUserObject", True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReadonlyNamedUserObject, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReadonlyNamedUserObject, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if dirty and "name" in dct:
            del dct["name"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReadonlyNamedUserObject):
            return False
        return super(ReadonlyNamedUserObject, self).__eq__(other) and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

class MaskingServiceConfig(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* Configuration for the
    Masking Service this Engine communicates with.
    """
    def __init__(self, undef_enabled=True):
        super(MaskingServiceConfig, self).__init__()
        self._type = ("MaskingServiceConfig", True)
        self._username = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._server = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MaskingServiceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        obj._server = (data.get("server", obj.__undef__), dirty)
        if obj._server[0] is not None and obj._server[0] is not obj.__undef__:
            assert isinstance(obj._server[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server[0]))
            common.validate_format(obj._server[0], "host", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MaskingServiceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "server" == "type" or (self.server is not self.__undef__ and not (dirty and not self._server[1])):
            dct["server"] = dictify(self.server)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credentials = (self._credentials[0], True)
        self._port = (self._port[0], True)
        self._name = (self._name[0], True)
        self._server = (self._server[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credentials[1], self._port[1], self._name[1], self._server[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MaskingServiceConfig):
            return False
        return super(MaskingServiceConfig, self).__eq__(other) and \
               self.username == other.username and \
               self.credentials == other.credentials and \
               self.port == other.port and \
               self.name == other.name and \
               self.server == other.server

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        Username to use when authenticating to the server.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credentials(self):
        """
        Password to use when authenticating to the server.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def port(self):
        """
        Port number to use.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def name(self):
        """
        Object name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def server(self):
        """
        IP address or hostname of server hosting Masking Service.

        :rtype: ``basestring``
        """
        return self._server[0]

    @server.setter
    def server(self, value):
        self._server = (value, True)

class SourceEnvironment(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* The generic source
    environment schema.
    """
    def __init__(self, undef_enabled=True):
        super(SourceEnvironment, self).__init__()
        self._type = ("SourceEnvironment", True)
        self._primary_user = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._description = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._primary_user = (data.get("primaryUser", obj.__undef__), dirty)
        if obj._primary_user[0] is not None and obj._primary_user[0] is not obj.__undef__:
            assert isinstance(obj._primary_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._primary_user[0]))
            common.validate_format(obj._primary_user[0], "objectReference", None, None)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "primary_user" == "type" or (self.primary_user is not self.__undef__ and not (dirty and not self._primary_user[1])):
            dct["primaryUser"] = dictify(self.primary_user)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._primary_user = (self._primary_user[0], True)
        self._enabled = (self._enabled[0], True)
        self._description = (self._description[0], True)

    def is_dirty(self):
        return any([self._primary_user[1], self._enabled[1], self._description[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceEnvironment):
            return False
        return super(SourceEnvironment, self).__eq__(other) and \
               self.primary_user == other.primary_user and \
               self.enabled == other.enabled and \
               self.description == other.description

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def primary_user(self):
        """
        A reference to the primary user for this environment.

        :rtype: ``basestring``
        """
        return self._primary_user[0]

    @primary_user.setter
    def primary_user(self, value):
        self._primary_user = (value, True)

    @property
    def enabled(self):
        """
        Indicates whether the source environment is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def description(self):
        """
        The environment description.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

class SerializationPoint(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* A serialization point
    represents the data and metadata associated with a replication spec at a
    point in time.
    """
    def __init__(self, undef_enabled=True):
        super(SerializationPoint, self).__init__()
        self._type = ("SerializationPoint", True)
        self._elapsed_time_nanos = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._bytes_transferred = (self.__undef__, True)
        self._average_throughput = (self.__undef__, True)
        self._data_timestamp = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SerializationPoint, cls).from_dict(data, dirty, undef_enabled)
        obj._elapsed_time_nanos = (data.get("elapsedTimeNanos", obj.__undef__), dirty)
        if obj._elapsed_time_nanos[0] is not None and obj._elapsed_time_nanos[0] is not obj.__undef__:
            assert isinstance(obj._elapsed_time_nanos[0], float), ("Expected one of [u'number'], but got %s" % type(obj._elapsed_time_nanos[0]))
            common.validate_format(obj._elapsed_time_nanos[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, None)
        obj._bytes_transferred = (data.get("bytesTransferred", obj.__undef__), dirty)
        if obj._bytes_transferred[0] is not None and obj._bytes_transferred[0] is not obj.__undef__:
            assert isinstance(obj._bytes_transferred[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bytes_transferred[0]))
            common.validate_format(obj._bytes_transferred[0], "None", None, None)
        obj._average_throughput = (data.get("averageThroughput", obj.__undef__), dirty)
        if obj._average_throughput[0] is not None and obj._average_throughput[0] is not obj.__undef__:
            assert isinstance(obj._average_throughput[0], float), ("Expected one of [u'number'], but got %s" % type(obj._average_throughput[0]))
            common.validate_format(obj._average_throughput[0], "None", None, None)
        obj._data_timestamp = (data.get("dataTimestamp", obj.__undef__), dirty)
        if obj._data_timestamp[0] is not None and obj._data_timestamp[0] is not obj.__undef__:
            assert isinstance(obj._data_timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_timestamp[0]))
            common.validate_format(obj._data_timestamp[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SerializationPoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "elapsed_time_nanos" == "type" or (self.elapsed_time_nanos is not self.__undef__ and not (dirty and not self._elapsed_time_nanos[1])):
            dct["elapsedTimeNanos"] = dictify(self.elapsed_time_nanos)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "bytes_transferred" == "type" or (self.bytes_transferred is not self.__undef__ and not (dirty and not self._bytes_transferred[1])):
            dct["bytesTransferred"] = dictify(self.bytes_transferred)
        if "average_throughput" == "type" or (self.average_throughput is not self.__undef__ and not (dirty and not self._average_throughput[1])):
            dct["averageThroughput"] = dictify(self.average_throughput)
        if "data_timestamp" == "type" or (self.data_timestamp is not self.__undef__ and not (dirty and not self._data_timestamp[1])):
            dct["dataTimestamp"] = dictify(self.data_timestamp)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._elapsed_time_nanos = (self._elapsed_time_nanos[0], True)
        self._tag = (self._tag[0], True)
        self._bytes_transferred = (self._bytes_transferred[0], True)
        self._average_throughput = (self._average_throughput[0], True)
        self._data_timestamp = (self._data_timestamp[0], True)

    def is_dirty(self):
        return any([self._elapsed_time_nanos[1], self._tag[1], self._bytes_transferred[1], self._average_throughput[1], self._data_timestamp[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SerializationPoint):
            return False
        return super(SerializationPoint, self).__eq__(other) and \
               self.elapsed_time_nanos == other.elapsed_time_nanos and \
               self.tag == other.tag and \
               self.bytes_transferred == other.bytes_transferred and \
               self.average_throughput == other.average_throughput and \
               self.data_timestamp == other.data_timestamp

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def elapsed_time_nanos(self):
        """
        The elapsed time spent sending the serialization point (nanoseconds).

        :rtype: ``float``
        """
        return self._elapsed_time_nanos[0]

    @elapsed_time_nanos.setter
    def elapsed_time_nanos(self, value):
        self._elapsed_time_nanos = (value, True)

    @property
    def tag(self):
        """
        An arbitrary string used to map the serialization point to a
        corresponding replication spec or namespace.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def bytes_transferred(self):
        """
        Bytes of the serialization point which have been transferred.

        :rtype: ``int``
        """
        return self._bytes_transferred[0]

    @bytes_transferred.setter
    def bytes_transferred(self, value):
        self._bytes_transferred = (value, True)

    @property
    def average_throughput(self):
        """
        Average throughput of the transfer of the serialization point
        (bytes/s).

        :rtype: ``float``
        """
        return self._average_throughput[0]

    @average_throughput.setter
    def average_throughput(self, value):
        self._average_throughput = (value, True)

    @property
    def data_timestamp(self):
        """
        Timestamp of the data being stored in the serialization point.

        :rtype: ``basestring``
        """
        return self._data_timestamp[0]

    @data_timestamp.setter
    def data_timestamp(self, value):
        self._data_timestamp = (value, True)

class ReplicationTargetState(UserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.UserObject` *)* State of a replication
    at the target.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationTargetState, self).__init__()
        self._type = ("ReplicationTargetState", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationTargetState, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationTargetState, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationTargetState):
            return False
        return super(ReplicationTargetState, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class WindowsCluster(SourceEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironment` *)* A Windows
    cluster environment.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsCluster, self).__init__()
        self._type = ("WindowsCluster", True)
        self._proxy = (self.__undef__, True)
        self._target_proxy = (self.__undef__, True)
        self._address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsCluster, cls).from_dict(data, dirty, undef_enabled)
        obj._proxy = (data.get("proxy", obj.__undef__), dirty)
        if obj._proxy[0] is not None and obj._proxy[0] is not obj.__undef__:
            assert isinstance(obj._proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._proxy[0]))
            common.validate_format(obj._proxy[0], "objectReference", None, None)
        obj._target_proxy = (data.get("targetProxy", obj.__undef__), dirty)
        if obj._target_proxy[0] is not None and obj._target_proxy[0] is not obj.__undef__:
            assert isinstance(obj._target_proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_proxy[0]))
            common.validate_format(obj._target_proxy[0], "objectReference", None, None)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsCluster, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "proxy" == "type" or (self.proxy is not self.__undef__ and not (dirty and not self._proxy[1])):
            dct["proxy"] = dictify(self.proxy)
        if "target_proxy" == "type" or (self.target_proxy is not self.__undef__ and not (dirty and not self._target_proxy[1])):
            dct["targetProxy"] = dictify(self.target_proxy)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._proxy = (self._proxy[0], True)
        self._target_proxy = (self._target_proxy[0], True)
        self._address = (self._address[0], True)

    def is_dirty(self):
        return any([self._proxy[1], self._target_proxy[1], self._address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsCluster):
            return False
        return super(WindowsCluster, self).__eq__(other) and \
               self.proxy == other.proxy and \
               self.target_proxy == other.target_proxy and \
               self.address == other.address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def proxy(self):
        """
        A reference to the proxy that will be used to discover the cluster.

        :rtype: ``basestring``
        """
        return self._proxy[0]

    @proxy.setter
    def proxy(self, value):
        self._proxy = (value, True)

    @property
    def target_proxy(self):
        """
        A reference to the proxy host that will be used for cluster support
        operations.

        :rtype: ``basestring``
        """
        return self._target_proxy[0]

    @target_proxy.setter
    def target_proxy(self, value):
        self._target_proxy = (value, True)

    @property
    def address(self):
        """
        The address that will be used to perform discovery on the cluster.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

class OracleCluster(SourceEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironment` *)* The
    representation of an oracle cluster environment object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCluster, self).__init__()
        self._type = ("OracleCluster", True)
        self._remote_listener = (self.__undef__, True)
        self._scan_manual = (self.__undef__, True)
        self._scan = (self.__undef__, True)
        self._cluster_user = (self.__undef__, True)
        self._crs_cluster_name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._crs_cluster_home = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCluster, cls).from_dict(data, dirty, undef_enabled)
        obj._remote_listener = (data.get("remoteListener", obj.__undef__), dirty)
        if obj._remote_listener[0] is not None and obj._remote_listener[0] is not obj.__undef__:
            assert isinstance(obj._remote_listener[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_listener[0]))
            common.validate_format(obj._remote_listener[0], "None", None, 256)
        obj._scan_manual = (data.get("scanManual", obj.__undef__), dirty)
        if obj._scan_manual[0] is not None and obj._scan_manual[0] is not obj.__undef__:
            assert isinstance(obj._scan_manual[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._scan_manual[0]))
            common.validate_format(obj._scan_manual[0], "None", None, None)
        obj._scan = (data.get("scan", obj.__undef__), dirty)
        if obj._scan[0] is not None and obj._scan[0] is not obj.__undef__:
            assert isinstance(obj._scan[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._scan[0]))
            common.validate_format(obj._scan[0], "None", None, 256)
        obj._cluster_user = (data.get("clusterUser", obj.__undef__), dirty)
        if obj._cluster_user[0] is not None and obj._cluster_user[0] is not obj.__undef__:
            assert isinstance(obj._cluster_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_user[0]))
            common.validate_format(obj._cluster_user[0], "objectReference", None, None)
        obj._crs_cluster_name = (data.get("crsClusterName", obj.__undef__), dirty)
        if obj._crs_cluster_name[0] is not None and obj._crs_cluster_name[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_name[0]))
            common.validate_format(obj._crs_cluster_name[0], "None", None, 15)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, 14)
        obj._crs_cluster_home = (data.get("crsClusterHome", obj.__undef__), dirty)
        if obj._crs_cluster_home[0] is not None and obj._crs_cluster_home[0] is not obj.__undef__:
            assert isinstance(obj._crs_cluster_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_cluster_home[0]))
            common.validate_format(obj._crs_cluster_home[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCluster, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "remote_listener" == "type" or (self.remote_listener is not self.__undef__ and not (dirty and not self._remote_listener[1])):
            dct["remoteListener"] = dictify(self.remote_listener)
        if "scan_manual" == "type" or (self.scan_manual is not self.__undef__ and not (dirty and not self._scan_manual[1])):
            dct["scanManual"] = dictify(self.scan_manual)
        if "scan" == "type" or (self.scan is not self.__undef__ and not (dirty and not self._scan[1])):
            dct["scan"] = dictify(self.scan)
        if "cluster_user" == "type" or (self.cluster_user is not self.__undef__ and not (dirty and not self._cluster_user[1])):
            dct["clusterUser"] = dictify(self.cluster_user)
        if "crs_cluster_name" == "type" or (self.crs_cluster_name is not self.__undef__ and not (dirty and not self._crs_cluster_name[1])):
            dct["crsClusterName"] = dictify(self.crs_cluster_name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "crs_cluster_home" == "type" or (self.crs_cluster_home is not self.__undef__ and not (dirty and not self._crs_cluster_home[1])):
            dct["crsClusterHome"] = dictify(self.crs_cluster_home)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._remote_listener = (self._remote_listener[0], True)
        self._scan_manual = (self._scan_manual[0], True)
        self._scan = (self._scan[0], True)
        self._cluster_user = (self._cluster_user[0], True)
        self._crs_cluster_name = (self._crs_cluster_name[0], True)
        self._version = (self._version[0], True)
        self._crs_cluster_home = (self._crs_cluster_home[0], True)

    def is_dirty(self):
        return any([self._remote_listener[1], self._scan_manual[1], self._scan[1], self._cluster_user[1], self._crs_cluster_name[1], self._version[1], self._crs_cluster_home[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCluster):
            return False
        return super(OracleCluster, self).__eq__(other) and \
               self.remote_listener == other.remote_listener and \
               self.scan_manual == other.scan_manual and \
               self.scan == other.scan and \
               self.cluster_user == other.cluster_user and \
               self.crs_cluster_name == other.crs_cluster_name and \
               self.version == other.version and \
               self.crs_cluster_home == other.crs_cluster_home

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def remote_listener(self):
        """
        The default remote_listener parameter to be used for databases on the
        cluster.

        :rtype: ``basestring``
        """
        return self._remote_listener[0]

    @remote_listener.setter
    def remote_listener(self, value):
        self._remote_listener = (value, True)

    @property
    def scan_manual(self):
        """
        Indicates whether the Single Client Access Name of the cluster is
        manually configured.

        :rtype: ``bool``
        """
        return self._scan_manual[0]

    @scan_manual.setter
    def scan_manual(self, value):
        self._scan_manual = (value, True)

    @property
    def scan(self):
        """
        The Single Client Access Name of the cluster (11.2 and greater clusters
        only).

        :rtype: ``basestring``
        """
        return self._scan[0]

    @scan.setter
    def scan(self, value):
        self._scan = (value, True)

    @property
    def cluster_user(self):
        """
        A reference to the cluster user.

        :rtype: ``basestring``
        """
        return self._cluster_user[0]

    @cluster_user.setter
    def cluster_user(self, value):
        self._cluster_user = (value, True)

    @property
    def crs_cluster_name(self):
        """
        The name of the cluster.

        :rtype: ``basestring``
        """
        return self._crs_cluster_name[0]

    @crs_cluster_name.setter
    def crs_cluster_name(self, value):
        self._crs_cluster_name = (value, True)

    @property
    def version(self):
        """
        The version of the cluster.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def crs_cluster_home(self):
        """
        The location of the cluster installation.

        :rtype: ``basestring``
        """
        return self._crs_cluster_home[0]

    @crs_cluster_home.setter
    def crs_cluster_home(self, value):
        self._crs_cluster_home = (value, True)

class HostEnvironment(SourceEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironment` *)* The
    representation of an host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(HostEnvironment, self).__init__()
        self._type = ("HostEnvironment", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostEnvironment):
            return False
        return super(HostEnvironment, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The reference to the associated host.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class VMwareHostEnvironment(HostEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostEnvironment` *)* The representation
    of a VMware host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareHostEnvironment, self).__init__()
        self._type = ("VMwareHostEnvironment", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareHostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareHostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareHostEnvironment):
            return False
        return super(VMwareHostEnvironment, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class WindowsHostEnvironment(HostEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostEnvironment` *)* The representation
    of a windows host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHostEnvironment, self).__init__()
        self._type = ("WindowsHostEnvironment", True)
        self._proxy = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        obj._proxy = (data.get("proxy", obj.__undef__), dirty)
        if obj._proxy[0] is not None and obj._proxy[0] is not obj.__undef__:
            assert isinstance(obj._proxy[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._proxy[0]))
            common.validate_format(obj._proxy[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "proxy" == "type" or (self.proxy is not self.__undef__ and not (dirty and not self._proxy[1])):
            dct["proxy"] = dictify(self.proxy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._proxy = (self._proxy[0], True)

    def is_dirty(self):
        return any([self._proxy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHostEnvironment):
            return False
        return super(WindowsHostEnvironment, self).__eq__(other) and \
               self.proxy == other.proxy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def proxy(self):
        """
        The reference to the proxy associated with the host.

        :rtype: ``basestring``
        """
        return self._proxy[0]

    @proxy.setter
    def proxy(self, value):
        self._proxy = (value, True)

class UnixHostEnvironment(HostEnvironment):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostEnvironment` *)* The representation
    of a unix host environment object.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHostEnvironment, self).__init__()
        self._type = ("UnixHostEnvironment", True)
        self._ase_host_environment_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHostEnvironment, cls).from_dict(data, dirty, undef_enabled)
        if "aseHostEnvironmentParameters" in data and data["aseHostEnvironmentParameters"] is not None:
            obj._ase_host_environment_parameters = (factory.create_object(data["aseHostEnvironmentParameters"], "ASEHostEnvironmentParameters"), dirty)
            factory.validate_type(obj._ase_host_environment_parameters[0], "ASEHostEnvironmentParameters")
        else:
            obj._ase_host_environment_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHostEnvironment, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ase_host_environment_parameters" == "type" or (self.ase_host_environment_parameters is not self.__undef__ and not (dirty and not self._ase_host_environment_parameters[1])):
            dct["aseHostEnvironmentParameters"] = dictify(self.ase_host_environment_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ase_host_environment_parameters = (self._ase_host_environment_parameters[0], True)

    def is_dirty(self):
        return any([self._ase_host_environment_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHostEnvironment):
            return False
        return super(UnixHostEnvironment, self).__eq__(other) and \
               self.ase_host_environment_parameters == other.ase_host_environment_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ase_host_environment_parameters(self):
        """
        Parameters for an environment with SAP ASE instances.

        :rtype: :py:class:`v1_8_1.web.vo.ASEHostEnvironmentParameters`
        """
        return self._ase_host_environment_parameters[0]

    @ase_host_environment_parameters.setter
    def ase_host_environment_parameters(self, value):
        self._ase_host_environment_parameters = (value, True)

class Domain(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Represents
    the root container of all objects on the system.
    """
    def __init__(self, undef_enabled=True):
        super(Domain, self).__init__()
        self._type = ("Domain", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Domain, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Domain, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Domain):
            return False
        return super(Domain, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class Permission(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Describes
    a permission to perform an operation on an object in the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(Permission, self).__init__()
        self._type = ("Permission", True)
        self._action_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Permission, cls).from_dict(data, dirty, undef_enabled)
        obj._action_type = (data.get("actionType", obj.__undef__), dirty)
        if obj._action_type[0] is not None and obj._action_type[0] is not obj.__undef__:
            assert isinstance(obj._action_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action_type[0]))
            common.validate_format(obj._action_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Permission, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action_type" == "type" or (self.action_type is not self.__undef__ and not (dirty and not self._action_type[1])):
            dct["actionType"] = dictify(self.action_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action_type = (self._action_type[0], True)

    def is_dirty(self):
        return any([self._action_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Permission):
            return False
        return super(Permission, self).__eq__(other) and \
               self.action_type == other.action_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action_type(self):
        """
        Name of the action governed by the permission.

        :rtype: ``basestring``
        """
        return self._action_type[0]

    @action_type.setter
    def action_type(self, value):
        self._action_type = (value, True)

class SourceConfig(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* The source
    config represents the dynamically discovered attributes of a source.
    """
    def __init__(self, undef_enabled=True):
        super(SourceConfig, self).__init__()
        self._type = ("SourceConfig", True)
        self._discovered = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._linking_enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._linking_enabled = (data.get("linkingEnabled", obj.__undef__), dirty)
        if obj._linking_enabled[0] is not None and obj._linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._linking_enabled[0]))
            common.validate_format(obj._linking_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "linking_enabled" == "type" or (self.linking_enabled is not self.__undef__ and not (dirty and not self._linking_enabled[1])):
            dct["linkingEnabled"] = dictify(self.linking_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._repository = (self._repository[0], True)
        self._linking_enabled = (self._linking_enabled[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._environment_user[1], self._repository[1], self._linking_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceConfig):
            return False
        return super(SourceConfig, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.environment_user == other.environment_user and \
               self.repository == other.repository and \
               self.linking_enabled == other.linking_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this source was discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def environment_user(self):
        """
        The user used to create and manage the configuration.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def linking_enabled(self):
        """
        *(default value: True)* Whether this source should be used for linking.

        :rtype: ``bool``
        """
        return self._linking_enabled[0]

    @linking_enabled.setter
    def linking_enabled(self, value):
        self._linking_enabled = (value, True)

class LdapServer(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* LDAP
    Server Configuration.
    """
    def __init__(self, undef_enabled=True):
        super(LdapServer, self).__init__()
        self._type = ("LdapServer", True)
        self._host = (self.__undef__, True)
        self._use_ssl = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._auth_method = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(LdapServer, cls).from_dict(data, dirty, undef_enabled)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "host", None, None)
        if "useSSL" not in data:
            raise ValueError("Missing required property \"useSSL\".")
        obj._use_ssl = (data.get("useSSL", obj.__undef__), dirty)
        if obj._use_ssl[0] is not None and obj._use_ssl[0] is not obj.__undef__:
            assert isinstance(obj._use_ssl[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._use_ssl[0]))
            common.validate_format(obj._use_ssl[0], "None", None, None)
        if "port" not in data:
            raise ValueError("Missing required property \"port\".")
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        if "authMethod" not in data:
            raise ValueError("Missing required property \"authMethod\".")
        obj._auth_method = (data.get("authMethod", obj.__undef__), dirty)
        if obj._auth_method[0] is not None and obj._auth_method[0] is not obj.__undef__:
            assert isinstance(obj._auth_method[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._auth_method[0]))
            assert obj._auth_method[0] in [u'SIMPLE', u'DIGEST_MD5'], "Expected enum [u'SIMPLE', u'DIGEST_MD5'] but got %s" % obj._auth_method[0]
            common.validate_format(obj._auth_method[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(LdapServer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "use_ssl" == "type" or (self.use_ssl is not self.__undef__ and not (dirty and not self._use_ssl[1])):
            dct["useSSL"] = dictify(self.use_ssl)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "auth_method" == "type" or (self.auth_method is not self.__undef__ and not (dirty and not self._auth_method[1])):
            dct["authMethod"] = dictify(self.auth_method)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)
        self._use_ssl = (self._use_ssl[0], True)
        self._port = (self._port[0], True)
        self._auth_method = (self._auth_method[0], True)

    def is_dirty(self):
        return any([self._host[1], self._use_ssl[1], self._port[1], self._auth_method[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, LdapServer):
            return False
        return super(LdapServer, self).__eq__(other) and \
               self.host == other.host and \
               self.use_ssl == other.use_ssl and \
               self.port == other.port and \
               self.auth_method == other.auth_method

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        LDAP server host name.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def use_ssl(self):
        """
        Authenticate using SSL.

        :rtype: ``bool``
        """
        return self._use_ssl[0]

    @use_ssl.setter
    def use_ssl(self, value):
        self._use_ssl = (value, True)

    @property
    def port(self):
        """
        LDAP server port.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def auth_method(self):
        """
        LDAP authentication method. *(permitted values: SIMPLE, DIGEST_MD5)*

        :rtype: ``basestring``
        """
        return self._auth_method[0]

    @auth_method.setter
    def auth_method(self, value):
        self._auth_method = (value, True)

class StorageTest(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Test the
    performance of storage devices.
    """
    def __init__(self, undef_enabled=True):
        super(StorageTest, self).__init__()
        self._type = ("StorageTest", True)
        self._state = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._test_results = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageTest, cls).from_dict(data, dirty, undef_enabled)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'WAITING', u'RUNNING', u'COMPLETED', u'FAILED', u'CANCELED'], "Expected enum [u'WAITING', u'RUNNING', u'COMPLETED', u'FAILED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (factory.create_object(data["parameters"], "StorageTestParameters"), dirty)
            factory.validate_type(obj._parameters[0], "StorageTestParameters")
        else:
            obj._parameters = (obj.__undef__, dirty)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._test_results = []
        for item in data.get("testResults") or []:
            obj._test_results.append(factory.create_object(item))
            factory.validate_type(obj._test_results[-1], "StorageTestResult")
        obj._test_results = (obj._test_results, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageTest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "test_results" == "type" or (self.test_results is not self.__undef__ and not (dirty and not self._test_results[1])):
            dct["testResults"] = dictify(self.test_results)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._state = (self._state[0], True)
        self._end_time = (self._end_time[0], True)
        self._parameters = (self._parameters[0], True)
        self._start_time = (self._start_time[0], True)
        self._test_results = (self._test_results[0], True)

    def is_dirty(self):
        return any([self._state[1], self._end_time[1], self._parameters[1], self._start_time[1], self._test_results[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageTest):
            return False
        return super(StorageTest, self).__eq__(other) and \
               self.state == other.state and \
               self.end_time == other.end_time and \
               self.parameters == other.parameters and \
               self.start_time == other.start_time and \
               self.test_results == other.test_results

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def state(self):
        """
        The state of the test. *(permitted values: WAITING, RUNNING, COMPLETED,
        FAILED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def end_time(self):
        """
        Time when the test ended.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def parameters(self):
        """
        The parameters used to execute the test.

        :rtype: :py:class:`v1_8_1.web.vo.StorageTestParameters`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def start_time(self):
        """
        Time when the test was started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def test_results(self):
        """
        The results assigned to various tests.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.StorageTestResult`
        """
        return self._test_results[0]

    @test_results.setter
    def test_results(self, value):
        self._test_results = (value, True)

class Host(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* The
    representation of a host object.
    """
    def __init__(self, undef_enabled=True):
        super(Host, self).__init__()
        self._type = ("Host", True)
        self._host_configuration = (self.__undef__, True)
        self._date_added = (self.__undef__, True)
        self._privilege_elevation_profile = (self.__undef__, True)
        self._host_runtime = (self.__undef__, True)
        self._address = (self.__undef__, True)
        self._ssh_port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Host, cls).from_dict(data, dirty, undef_enabled)
        if "hostConfiguration" in data and data["hostConfiguration"] is not None:
            obj._host_configuration = (factory.create_object(data["hostConfiguration"], "HostConfiguration"), dirty)
            factory.validate_type(obj._host_configuration[0], "HostConfiguration")
        else:
            obj._host_configuration = (obj.__undef__, dirty)
        obj._date_added = (data.get("dateAdded", obj.__undef__), dirty)
        if obj._date_added[0] is not None and obj._date_added[0] is not obj.__undef__:
            assert isinstance(obj._date_added[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._date_added[0]))
            common.validate_format(obj._date_added[0], "None", None, None)
        obj._privilege_elevation_profile = (data.get("privilegeElevationProfile", obj.__undef__), dirty)
        if obj._privilege_elevation_profile[0] is not None and obj._privilege_elevation_profile[0] is not obj.__undef__:
            assert isinstance(obj._privilege_elevation_profile[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._privilege_elevation_profile[0]))
            common.validate_format(obj._privilege_elevation_profile[0], "objectReference", None, None)
        if "hostRuntime" in data and data["hostRuntime"] is not None:
            obj._host_runtime = (factory.create_object(data["hostRuntime"], "HostRuntime"), dirty)
            factory.validate_type(obj._host_runtime[0], "HostRuntime")
        else:
            obj._host_runtime = (obj.__undef__, dirty)
        obj._address = (data.get("address", obj.__undef__), dirty)
        if obj._address[0] is not None and obj._address[0] is not obj.__undef__:
            assert isinstance(obj._address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._address[0]))
            common.validate_format(obj._address[0], "host", None, None)
        obj._ssh_port = (data.get("sshPort", obj.__undef__), dirty)
        if obj._ssh_port[0] is not None and obj._ssh_port[0] is not obj.__undef__:
            assert isinstance(obj._ssh_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._ssh_port[0]))
            common.validate_format(obj._ssh_port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Host, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_configuration" == "type" or (self.host_configuration is not self.__undef__ and not (dirty and not self._host_configuration[1])):
            dct["hostConfiguration"] = dictify(self.host_configuration)
        if "date_added" == "type" or (self.date_added is not self.__undef__ and not (dirty and not self._date_added[1])):
            dct["dateAdded"] = dictify(self.date_added)
        if "privilege_elevation_profile" == "type" or (self.privilege_elevation_profile is not self.__undef__ and not (dirty and not self._privilege_elevation_profile[1])):
            dct["privilegeElevationProfile"] = dictify(self.privilege_elevation_profile)
        if "host_runtime" == "type" or (self.host_runtime is not self.__undef__ and not (dirty and not self._host_runtime[1])):
            dct["hostRuntime"] = dictify(self.host_runtime)
        if "address" == "type" or (self.address is not self.__undef__ and not (dirty and not self._address[1])):
            dct["address"] = dictify(self.address)
        if "ssh_port" == "type" or (self.ssh_port is not self.__undef__ and not (dirty and not self._ssh_port[1])):
            dct["sshPort"] = dictify(self.ssh_port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_configuration = (self._host_configuration[0], True)
        self._date_added = (self._date_added[0], True)
        self._privilege_elevation_profile = (self._privilege_elevation_profile[0], True)
        self._host_runtime = (self._host_runtime[0], True)
        self._address = (self._address[0], True)
        self._ssh_port = (self._ssh_port[0], True)

    def is_dirty(self):
        return any([self._host_configuration[1], self._date_added[1], self._privilege_elevation_profile[1], self._host_runtime[1], self._address[1], self._ssh_port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Host):
            return False
        return super(Host, self).__eq__(other) and \
               self.host_configuration == other.host_configuration and \
               self.date_added == other.date_added and \
               self.privilege_elevation_profile == other.privilege_elevation_profile and \
               self.host_runtime == other.host_runtime and \
               self.address == other.address and \
               self.ssh_port == other.ssh_port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_configuration(self):
        """
        The host configuration object associated with the host.

        :rtype: :py:class:`v1_8_1.web.vo.HostConfiguration`
        """
        return self._host_configuration[0]

    @host_configuration.setter
    def host_configuration(self, value):
        self._host_configuration = (value, True)

    @property
    def date_added(self):
        """
        The date the host was added.

        :rtype: ``basestring``
        """
        return self._date_added[0]

    @date_added.setter
    def date_added(self, value):
        self._date_added = (value, True)

    @property
    def privilege_elevation_profile(self):
        """
        Profile for escalating user privileges.

        :rtype: ``basestring``
        """
        return self._privilege_elevation_profile[0]

    @privilege_elevation_profile.setter
    def privilege_elevation_profile(self, value):
        self._privilege_elevation_profile = (value, True)

    @property
    def host_runtime(self):
        """
        Runtime properties for this host.

        :rtype: :py:class:`v1_8_1.web.vo.HostRuntime`
        """
        return self._host_runtime[0]

    @host_runtime.setter
    def host_runtime(self, value):
        self._host_runtime = (value, True)

    @property
    def address(self):
        """
        The address associated with the host.

        :rtype: ``basestring``
        """
        return self._address[0]

    @address.setter
    def address(self, value):
        self._address = (value, True)

    @property
    def ssh_port(self):
        """
        *(default value: 22)* The port number used to connect to the host via
        SSH.

        :rtype: ``int``
        """
        return self._ssh_port[0]

    @ssh_port.setter
    def ssh_port(self, value):
        self._ssh_port = (value, True)

class Authorization(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Describes
    a role as applied to a user on an object.
    """
    def __init__(self, undef_enabled=True):
        super(Authorization, self).__init__()
        self._type = ("Authorization", True)
        self._role = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Authorization, cls).from_dict(data, dirty, undef_enabled)
        obj._role = (data.get("role", obj.__undef__), dirty)
        if obj._role[0] is not None and obj._role[0] is not obj.__undef__:
            assert isinstance(obj._role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._role[0]))
            common.validate_format(obj._role[0], "objectReference", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Authorization, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "role" == "type" or (self.role is not self.__undef__ and not (dirty and not self._role[1])):
            dct["role"] = dictify(self.role)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._role = (self._role[0], True)
        self._target = (self._target[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._role[1], self._target[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Authorization):
            return False
        return super(Authorization, self).__eq__(other) and \
               self.role == other.role and \
               self.target == other.target and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def role(self):
        """
        Applied role.

        :rtype: ``basestring``
        """
        return self._role[0]

    @role.setter
    def role(self, value):
        self._role = (value, True)

    @property
    def target(self):
        """
        Reference to the object that the authorization applies to.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def user(self):
        """
        Reference to the user that the authorization applies to.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class SourceRepository(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* A source
    repository represents a container for the source config.
    """
    def __init__(self, undef_enabled=True):
        super(SourceRepository, self).__init__()
        self._type = ("SourceRepository", True)
        self._environment = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._staging = (self.__undef__, True)
        self._linking_enabled = (self.__undef__, True)
        self._provisioning_enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._staging = (data.get("staging", obj.__undef__), dirty)
        if obj._staging[0] is not None and obj._staging[0] is not obj.__undef__:
            assert isinstance(obj._staging[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._staging[0]))
            common.validate_format(obj._staging[0], "None", None, None)
        obj._linking_enabled = (data.get("linkingEnabled", obj.__undef__), dirty)
        if obj._linking_enabled[0] is not None and obj._linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._linking_enabled[0]))
            common.validate_format(obj._linking_enabled[0], "None", None, None)
        obj._provisioning_enabled = (data.get("provisioningEnabled", obj.__undef__), dirty)
        if obj._provisioning_enabled[0] is not None and obj._provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._provisioning_enabled[0]))
            common.validate_format(obj._provisioning_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "staging" == "type" or (self.staging is not self.__undef__ and not (dirty and not self._staging[1])):
            dct["staging"] = dictify(self.staging)
        if "linking_enabled" == "type" or (self.linking_enabled is not self.__undef__ and not (dirty and not self._linking_enabled[1])):
            dct["linkingEnabled"] = dictify(self.linking_enabled)
        if "provisioning_enabled" == "type" or (self.provisioning_enabled is not self.__undef__ and not (dirty and not self._provisioning_enabled[1])):
            dct["provisioningEnabled"] = dictify(self.provisioning_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._version = (self._version[0], True)
        self._staging = (self._staging[0], True)
        self._linking_enabled = (self._linking_enabled[0], True)
        self._provisioning_enabled = (self._provisioning_enabled[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._version[1], self._staging[1], self._linking_enabled[1], self._provisioning_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceRepository):
            return False
        return super(SourceRepository, self).__eq__(other) and \
               self.environment == other.environment and \
               self.version == other.version and \
               self.staging == other.staging and \
               self.linking_enabled == other.linking_enabled and \
               self.provisioning_enabled == other.provisioning_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        Reference to the environment containing this repository.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def version(self):
        """
        Version of the repository.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def staging(self):
        """
        Flag indicating whether this repository can be used by the Delphix
        Engine for internal processing.

        :rtype: ``bool``
        """
        return self._staging[0]

    @staging.setter
    def staging(self, value):
        self._staging = (value, True)

    @property
    def linking_enabled(self):
        """
        *(default value: True)* Flag indicating whether the repository should
        be used for linking.

        :rtype: ``bool``
        """
        return self._linking_enabled[0]

    @linking_enabled.setter
    def linking_enabled(self, value):
        self._linking_enabled = (value, True)

    @property
    def provisioning_enabled(self):
        """
        *(default value: True)* Flag indicating whether the repository should
        be used for provisioning.

        :rtype: ``bool``
        """
        return self._provisioning_enabled[0]

    @provisioning_enabled.setter
    def provisioning_enabled(self, value):
        self._provisioning_enabled = (value, True)

class SamlServiceProvider(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* SAML
    service provider configuration.
    """
    def __init__(self, undef_enabled=True):
        super(SamlServiceProvider, self).__init__()
        self._type = ("SamlServiceProvider", True)
        self._signing_key = (self.__undef__, True)
        self._issuer_id = (self.__undef__, True)
        self._destination = (self.__undef__, True)
        self._base_url = (self.__undef__, True)
        self._decrypting_key = (self.__undef__, True)
        self._entity_id = (self.__undef__, True)
        self._hash_alg_url = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SamlServiceProvider, cls).from_dict(data, dirty, undef_enabled)
        obj._signing_key = (data.get("signingKey", obj.__undef__), dirty)
        if obj._signing_key[0] is not None and obj._signing_key[0] is not obj.__undef__:
            assert isinstance(obj._signing_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._signing_key[0]))
            common.validate_format(obj._signing_key[0], "None", None, None)
        if "issuerId" not in data:
            raise ValueError("Missing required property \"issuerId\".")
        obj._issuer_id = (data.get("issuerId", obj.__undef__), dirty)
        if obj._issuer_id[0] is not None and obj._issuer_id[0] is not obj.__undef__:
            assert isinstance(obj._issuer_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._issuer_id[0]))
            common.validate_format(obj._issuer_id[0], "None", None, None)
        if "destination" not in data:
            raise ValueError("Missing required property \"destination\".")
        obj._destination = (data.get("destination", obj.__undef__), dirty)
        if obj._destination[0] is not None and obj._destination[0] is not obj.__undef__:
            assert isinstance(obj._destination[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination[0]))
            common.validate_format(obj._destination[0], "None", None, None)
        if "baseUrl" not in data:
            raise ValueError("Missing required property \"baseUrl\".")
        obj._base_url = (data.get("baseUrl", obj.__undef__), dirty)
        if obj._base_url[0] is not None and obj._base_url[0] is not obj.__undef__:
            assert isinstance(obj._base_url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._base_url[0]))
            common.validate_format(obj._base_url[0], "None", None, None)
        obj._decrypting_key = (data.get("decryptingKey", obj.__undef__), dirty)
        if obj._decrypting_key[0] is not None and obj._decrypting_key[0] is not obj.__undef__:
            assert isinstance(obj._decrypting_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._decrypting_key[0]))
            common.validate_format(obj._decrypting_key[0], "None", None, None)
        if "entityId" not in data:
            raise ValueError("Missing required property \"entityId\".")
        obj._entity_id = (data.get("entityId", obj.__undef__), dirty)
        if obj._entity_id[0] is not None and obj._entity_id[0] is not obj.__undef__:
            assert isinstance(obj._entity_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._entity_id[0]))
            common.validate_format(obj._entity_id[0], "None", None, None)
        if "hashAlgUrl" not in data:
            raise ValueError("Missing required property \"hashAlgUrl\".")
        obj._hash_alg_url = (data.get("hashAlgUrl", obj.__undef__), dirty)
        if obj._hash_alg_url[0] is not None and obj._hash_alg_url[0] is not obj.__undef__:
            assert isinstance(obj._hash_alg_url[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._hash_alg_url[0]))
            common.validate_format(obj._hash_alg_url[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SamlServiceProvider, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "signing_key" == "type" or (self.signing_key is not self.__undef__ and not (dirty and not self._signing_key[1])):
            dct["signingKey"] = dictify(self.signing_key)
        if "issuer_id" == "type" or (self.issuer_id is not self.__undef__ and not (dirty and not self._issuer_id[1])):
            dct["issuerId"] = dictify(self.issuer_id)
        if "destination" == "type" or (self.destination is not self.__undef__ and not (dirty and not self._destination[1])):
            dct["destination"] = dictify(self.destination)
        if "base_url" == "type" or (self.base_url is not self.__undef__ and not (dirty and not self._base_url[1])):
            dct["baseUrl"] = dictify(self.base_url)
        if "decrypting_key" == "type" or (self.decrypting_key is not self.__undef__ and not (dirty and not self._decrypting_key[1])):
            dct["decryptingKey"] = dictify(self.decrypting_key)
        if "entity_id" == "type" or (self.entity_id is not self.__undef__ and not (dirty and not self._entity_id[1])):
            dct["entityId"] = dictify(self.entity_id)
        if "hash_alg_url" == "type" or (self.hash_alg_url is not self.__undef__ and not (dirty and not self._hash_alg_url[1])):
            dct["hashAlgUrl"] = dictify(self.hash_alg_url)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._signing_key = (self._signing_key[0], True)
        self._issuer_id = (self._issuer_id[0], True)
        self._destination = (self._destination[0], True)
        self._base_url = (self._base_url[0], True)
        self._decrypting_key = (self._decrypting_key[0], True)
        self._entity_id = (self._entity_id[0], True)
        self._hash_alg_url = (self._hash_alg_url[0], True)

    def is_dirty(self):
        return any([self._signing_key[1], self._issuer_id[1], self._destination[1], self._base_url[1], self._decrypting_key[1], self._entity_id[1], self._hash_alg_url[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SamlServiceProvider):
            return False
        return super(SamlServiceProvider, self).__eq__(other) and \
               self.signing_key == other.signing_key and \
               self.issuer_id == other.issuer_id and \
               self.destination == other.destination and \
               self.base_url == other.base_url and \
               self.decrypting_key == other.decrypting_key and \
               self.entity_id == other.entity_id and \
               self.hash_alg_url == other.hash_alg_url

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def signing_key(self):
        """
        The signing (public) key that will be used to verify SAML signatures.
        Leave empty if responses will not be signed.

        :rtype: ``basestring``
        """
        return self._signing_key[0]

    @signing_key.setter
    def signing_key(self, value):
        self._signing_key = (value, True)

    @property
    def issuer_id(self):
        """
        A unique identifier that is provided by the identity provider to ensure
        we are a valid service provider.

        :rtype: ``basestring``
        """
        return self._issuer_id[0]

    @issuer_id.setter
    def issuer_id(self, value):
        self._issuer_id = (value, True)

    @property
    def destination(self):
        """
        URL to which the SAML authentication request will be sent.

        :rtype: ``basestring``
        """
        return self._destination[0]

    @destination.setter
    def destination(self, value):
        self._destination = (value, True)

    @property
    def base_url(self):
        """
        The public URL the Delphix Engine will be accessed at.

        :rtype: ``basestring``
        """
        return self._base_url[0]

    @base_url.setter
    def base_url(self, value):
        self._base_url = (value, True)

    @property
    def decrypting_key(self):
        """
        The decryption (private) key that will be used to decrypt SAML
        assertions. Leave empty if response will not be encrypted. This key
        MUST be a PKCS8 key.

        :rtype: ``basestring``
        """
        return self._decrypting_key[0]

    @decrypting_key.setter
    def decrypting_key(self, value):
        self._decrypting_key = (value, True)

    @property
    def entity_id(self):
        """
        Unique name of service provider.

        :rtype: ``basestring``
        """
        return self._entity_id[0]

    @entity_id.setter
    def entity_id(self, value):
        self._entity_id = (value, True)

    @property
    def hash_alg_url(self):
        """
        Algorithm used for creation of digital signature on metadata.

        :rtype: ``basestring``
        """
        return self._hash_alg_url[0]

    @hash_alg_url.setter
    def hash_alg_url(self, value):
        self._hash_alg_url = (value, True)

class TimeflowSnapshot(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Snapshot
    of a point within a TimeFlow that is used as the basis for provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowSnapshot, self).__init__()
        self._type = ("TimeflowSnapshot", True)
        self._missing_non_logged_data = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._creation_time = (self.__undef__, True)
        self._temporary = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._first_change_point = (self.__undef__, True)
        self._consistency = (self.__undef__, True)
        self._timezone = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._retention = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowSnapshot, cls).from_dict(data, dirty, undef_enabled)
        obj._missing_non_logged_data = (data.get("missingNonLoggedData", obj.__undef__), dirty)
        if obj._missing_non_logged_data[0] is not None and obj._missing_non_logged_data[0] is not obj.__undef__:
            assert isinstance(obj._missing_non_logged_data[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._missing_non_logged_data[0]))
            common.validate_format(obj._missing_non_logged_data[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._creation_time = (data.get("creationTime", obj.__undef__), dirty)
        if obj._creation_time[0] is not None and obj._creation_time[0] is not obj.__undef__:
            assert isinstance(obj._creation_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._creation_time[0]))
            common.validate_format(obj._creation_time[0], "date", None, None)
        obj._temporary = (data.get("temporary", obj.__undef__), dirty)
        if obj._temporary[0] is not None and obj._temporary[0] is not obj.__undef__:
            assert isinstance(obj._temporary[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._temporary[0]))
            common.validate_format(obj._temporary[0], "None", None, None)
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "TimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "TimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        obj._consistency = (data.get("consistency", obj.__undef__), dirty)
        if obj._consistency[0] is not None and obj._consistency[0] is not obj.__undef__:
            assert isinstance(obj._consistency[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._consistency[0]))
            common.validate_format(obj._consistency[0], "None", None, None)
        obj._timezone = (data.get("timezone", obj.__undef__), dirty)
        if obj._timezone[0] is not None and obj._timezone[0] is not obj.__undef__:
            assert isinstance(obj._timezone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timezone[0]))
            common.validate_format(obj._timezone[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "SnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._retention = (data.get("retention", obj.__undef__), dirty)
        if obj._retention[0] is not None and obj._retention[0] is not obj.__undef__:
            assert isinstance(obj._retention[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._retention[0]))
            common.validate_format(obj._retention[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "missing_non_logged_data" == "type" or (self.missing_non_logged_data is not self.__undef__ and not (dirty and not self._missing_non_logged_data[1])):
            dct["missingNonLoggedData"] = dictify(self.missing_non_logged_data)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "creation_time" == "type" or (self.creation_time is not self.__undef__ and not (dirty and not self._creation_time[1])):
            dct["creationTime"] = dictify(self.creation_time)
        if "temporary" == "type" or (self.temporary is not self.__undef__ and not (dirty and not self._temporary[1])):
            dct["temporary"] = dictify(self.temporary)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "consistency" == "type" or (self.consistency is not self.__undef__ and not (dirty and not self._consistency[1])):
            dct["consistency"] = dictify(self.consistency)
        if "timezone" == "type" or (self.timezone is not self.__undef__ and not (dirty and not self._timezone[1])):
            dct["timezone"] = dictify(self.timezone)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "retention" == "type" or (self.retention is not self.__undef__ and not (dirty and not self._retention[1])):
            dct["retention"] = dictify(self.retention)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._missing_non_logged_data = (self._missing_non_logged_data[0], True)
        self._container = (self._container[0], True)
        self._creation_time = (self._creation_time[0], True)
        self._temporary = (self._temporary[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._version = (self._version[0], True)
        self._first_change_point = (self._first_change_point[0], True)
        self._consistency = (self._consistency[0], True)
        self._timezone = (self._timezone[0], True)
        self._runtime = (self._runtime[0], True)
        self._retention = (self._retention[0], True)

    def is_dirty(self):
        return any([self._missing_non_logged_data[1], self._container[1], self._creation_time[1], self._temporary[1], self._timeflow[1], self._latest_change_point[1], self._version[1], self._first_change_point[1], self._consistency[1], self._timezone[1], self._runtime[1], self._retention[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowSnapshot):
            return False
        return super(TimeflowSnapshot, self).__eq__(other) and \
               self.missing_non_logged_data == other.missing_non_logged_data and \
               self.container == other.container and \
               self.creation_time == other.creation_time and \
               self.temporary == other.temporary and \
               self.timeflow == other.timeflow and \
               self.latest_change_point == other.latest_change_point and \
               self.version == other.version and \
               self.first_change_point == other.first_change_point and \
               self.consistency == other.consistency and \
               self.timezone == other.timezone and \
               self.runtime == other.runtime and \
               self.retention == other.retention

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def missing_non_logged_data(self):
        """
        Boolean value indicating if a virtual database provisioned from this
        snapshot will be missing nologging changes.

        :rtype: ``bool``
        """
        return self._missing_non_logged_data[0]

    @missing_non_logged_data.setter
    def missing_non_logged_data(self, value):
        self._missing_non_logged_data = (value, True)

    @property
    def container(self):
        """
        Reference to the database of which this TimeFlow is a part.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def creation_time(self):
        """
        Point in time at which this snapshot was created. This may be different
        from the time corresponding to the TimeFlow.

        :rtype: ``basestring``
        """
        return self._creation_time[0]

    @creation_time.setter
    def creation_time(self, value):
        self._creation_time = (value, True)

    @property
    def temporary(self):
        """
        Boolean value indicating that this snapshot is in a transient state and
        should not be user visible.

        :rtype: ``bool``
        """
        return self._temporary[0]

    @temporary.setter
    def temporary(self, value):
        self._temporary = (value, True)

    @property
    def timeflow(self):
        """
        TimeFlow of which this snapshot is a part.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def version(self):
        """
        Version of database source repository at the time the snapshot was
        taken.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated. No recovery earlier than this point needs to be applied in
        order to provision a database from this snapshot. If "firstChangePoint"
        equals "latestChangePoint", then no recovery needs to be applied in
        order to provision a database.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def consistency(self):
        """
        A value in the set {CONSISTENT, INCONSISTENT, CRASH_CONSISTENT}
        indicating what type of recovery strategies must be invoked when
        provisioning from this snapshot.

        :rtype: ``basestring``
        """
        return self._consistency[0]

    @consistency.setter
    def consistency(self, value):
        self._consistency = (value, True)

    @property
    def timezone(self):
        """
        Time zone of the source database at the time the snapshot was taken.

        :rtype: ``basestring``
        """
        return self._timezone[0]

    @timezone.setter
    def timezone(self, value):
        self._timezone = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.SnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def retention(self):
        """
        Retention policy, in days. A value of -1 indicates the snapshot should
        be kept forever.

        :rtype: ``int``
        """
        return self._retention[0]

    @retention.setter
    def retention(self, value):
        self._retention = (value, True)

class NetworkTest(ReadonlyNamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReadonlyNamedUserObject` *)* Base type
    for all network test objects.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkTest, self).__init__()
        self._type = ("NetworkTest", True)
        self._state = (self.__undef__, True)
        self._end_time = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._remote_address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkTest, cls).from_dict(data, dirty, undef_enabled)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'RUNNING', u'COMPLETED', u'FAILED', u'CANCELED'], "Expected enum [u'RUNNING', u'COMPLETED', u'FAILED', u'CANCELED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._remote_address = (data.get("remoteAddress", obj.__undef__), dirty)
        if obj._remote_address[0] is not None and obj._remote_address[0] is not obj.__undef__:
            assert isinstance(obj._remote_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_address[0]))
            common.validate_format(obj._remote_address[0], "ipAddress", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkTest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "remote_address" == "type" or (self.remote_address is not self.__undef__ and not (dirty and not self._remote_address[1])):
            dct["remoteAddress"] = dictify(self.remote_address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._state = (self._state[0], True)
        self._end_time = (self._end_time[0], True)
        self._start_time = (self._start_time[0], True)
        self._remote_address = (self._remote_address[0], True)

    def is_dirty(self):
        return any([self._state[1], self._end_time[1], self._start_time[1], self._remote_address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkTest):
            return False
        return super(NetworkTest, self).__eq__(other) and \
               self.state == other.state and \
               self.end_time == other.end_time and \
               self.start_time == other.start_time and \
               self.remote_address == other.remote_address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def state(self):
        """
        The state of the test. *(permitted values: RUNNING, COMPLETED, FAILED,
        CANCELED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def end_time(self):
        """
        Time when the test ended.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

    @property
    def start_time(self):
        """
        Time when the test was started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def remote_address(self):
        """
        The remote IP address used for the test.

        :rtype: ``basestring``
        """
        return self._remote_address[0]

    @remote_address.setter
    def remote_address(self, value):
        self._remote_address = (value, True)

class NetworkThroughputTestBase(NetworkTest):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkTest` *)* The base type for all
    throughput tests.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkThroughputTestBase, self).__init__()
        self._type = ("NetworkThroughputTestBase", True)
        self._throughput = (self.__undef__, True)
        self._num_connections = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkThroughputTestBase, cls).from_dict(data, dirty, undef_enabled)
        obj._throughput = (data.get("throughput", obj.__undef__), dirty)
        if obj._throughput[0] is not None and obj._throughput[0] is not obj.__undef__:
            assert isinstance(obj._throughput[0], float), ("Expected one of [u'number'], but got %s" % type(obj._throughput[0]))
            common.validate_format(obj._throughput[0], "None", None, None)
        obj._num_connections = (data.get("numConnections", obj.__undef__), dirty)
        if obj._num_connections[0] is not None and obj._num_connections[0] is not obj.__undef__:
            assert isinstance(obj._num_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_connections[0]))
            common.validate_format(obj._num_connections[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkThroughputTestBase, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "throughput" == "type" or (self.throughput is not self.__undef__ and not (dirty and not self._throughput[1])):
            dct["throughput"] = dictify(self.throughput)
        if "num_connections" == "type" or (self.num_connections is not self.__undef__ and not (dirty and not self._num_connections[1])):
            dct["numConnections"] = dictify(self.num_connections)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._throughput = (self._throughput[0], True)
        self._num_connections = (self._num_connections[0], True)

    def is_dirty(self):
        return any([self._throughput[1], self._num_connections[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkThroughputTestBase):
            return False
        return super(NetworkThroughputTestBase, self).__eq__(other) and \
               self.throughput == other.throughput and \
               self.num_connections == other.num_connections

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def throughput(self):
        """
        Average throughput measured.

        :rtype: ``float``
        """
        return self._throughput[0]

    @throughput.setter
    def throughput(self, value):
        self._throughput = (value, True)

    @property
    def num_connections(self):
        """
        Number of connections used to achieve maximum sustained throughput.

        :rtype: ``int``
        """
        return self._num_connections[0]

    @num_connections.setter
    def num_connections(self, value):
        self._num_connections = (value, True)

class NetworkLatencyTest(NetworkTest):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkTest` *)* Round-trip latency
    tests to a target system.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkLatencyTest, self).__init__()
        self._type = ("NetworkLatencyTest", True)
        self._loss = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._average = (self.__undef__, True)
        self._maximum = (self.__undef__, True)
        self._minimum = (self.__undef__, True)
        self._stddev = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkLatencyTest, cls).from_dict(data, dirty, undef_enabled)
        obj._loss = (data.get("loss", obj.__undef__), dirty)
        if obj._loss[0] is not None and obj._loss[0] is not obj.__undef__:
            assert isinstance(obj._loss[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._loss[0]))
            common.validate_format(obj._loss[0], "None", None, None)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (factory.create_object(data["parameters"], "NetworkLatencyTestParameters"), dirty)
            factory.validate_type(obj._parameters[0], "NetworkLatencyTestParameters")
        else:
            obj._parameters = (obj.__undef__, dirty)
        obj._average = (data.get("average", obj.__undef__), dirty)
        if obj._average[0] is not None and obj._average[0] is not obj.__undef__:
            assert isinstance(obj._average[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._average[0]))
            common.validate_format(obj._average[0], "None", None, None)
        obj._maximum = (data.get("maximum", obj.__undef__), dirty)
        if obj._maximum[0] is not None and obj._maximum[0] is not obj.__undef__:
            assert isinstance(obj._maximum[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._maximum[0]))
            common.validate_format(obj._maximum[0], "None", None, None)
        obj._minimum = (data.get("minimum", obj.__undef__), dirty)
        if obj._minimum[0] is not None and obj._minimum[0] is not obj.__undef__:
            assert isinstance(obj._minimum[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._minimum[0]))
            common.validate_format(obj._minimum[0], "None", None, None)
        obj._stddev = (data.get("stddev", obj.__undef__), dirty)
        if obj._stddev[0] is not None and obj._stddev[0] is not obj.__undef__:
            assert isinstance(obj._stddev[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._stddev[0]))
            common.validate_format(obj._stddev[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkLatencyTest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "loss" == "type" or (self.loss is not self.__undef__ and not (dirty and not self._loss[1])):
            dct["loss"] = dictify(self.loss)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "average" == "type" or (self.average is not self.__undef__ and not (dirty and not self._average[1])):
            dct["average"] = dictify(self.average)
        if "maximum" == "type" or (self.maximum is not self.__undef__ and not (dirty and not self._maximum[1])):
            dct["maximum"] = dictify(self.maximum)
        if "minimum" == "type" or (self.minimum is not self.__undef__ and not (dirty and not self._minimum[1])):
            dct["minimum"] = dictify(self.minimum)
        if "stddev" == "type" or (self.stddev is not self.__undef__ and not (dirty and not self._stddev[1])):
            dct["stddev"] = dictify(self.stddev)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._loss = (self._loss[0], True)
        self._parameters = (self._parameters[0], True)
        self._average = (self._average[0], True)
        self._maximum = (self._maximum[0], True)
        self._minimum = (self._minimum[0], True)
        self._stddev = (self._stddev[0], True)

    def is_dirty(self):
        return any([self._loss[1], self._parameters[1], self._average[1], self._maximum[1], self._minimum[1], self._stddev[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkLatencyTest):
            return False
        return super(NetworkLatencyTest, self).__eq__(other) and \
               self.loss == other.loss and \
               self.parameters == other.parameters and \
               self.average == other.average and \
               self.maximum == other.maximum and \
               self.minimum == other.minimum and \
               self.stddev == other.stddev

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def loss(self):
        """
        Percentage of requests or replies lost.

        :rtype: ``int``
        """
        return self._loss[0]

    @loss.setter
    def loss(self, value):
        self._loss = (value, True)

    @property
    def parameters(self):
        """
        The parameters used to execute the test.

        :rtype: :py:class:`v1_8_1.web.vo.NetworkLatencyTestParameters`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def average(self):
        """
        Average measured round-trip time (usec).

        :rtype: ``int``
        """
        return self._average[0]

    @average.setter
    def average(self, value):
        self._average = (value, True)

    @property
    def maximum(self):
        """
        Maximum measured round-trip time (usec).

        :rtype: ``int``
        """
        return self._maximum[0]

    @maximum.setter
    def maximum(self, value):
        self._maximum = (value, True)

    @property
    def minimum(self):
        """
        Minimum measured round-trip time (usec).

        :rtype: ``int``
        """
        return self._minimum[0]

    @minimum.setter
    def minimum(self, value):
        self._minimum = (value, True)

    @property
    def stddev(self):
        """
        Standard deviation (usec).

        :rtype: ``int``
        """
        return self._stddev[0]

    @stddev.setter
    def stddev(self, value):
        self._stddev = (value, True)

class NetworkThroughputTest(NetworkThroughputTestBase):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkThroughputTestBase` *)* Bi-
    directional throughput tests to a target system.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkThroughputTest, self).__init__()
        self._type = ("NetworkThroughputTest", True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkThroughputTest, cls).from_dict(data, dirty, undef_enabled)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (factory.create_object(data["parameters"], "NetworkThroughputTestParameters"), dirty)
            factory.validate_type(obj._parameters[0], "NetworkThroughputTestParameters")
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkThroughputTest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkThroughputTest):
            return False
        return super(NetworkThroughputTest, self).__eq__(other) and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parameters(self):
        """
        The parameters used to execute the test.

        :rtype: :py:class:`v1_8_1.web.vo.NetworkThroughputTestParameters`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class NetworkDSPTest(NetworkThroughputTestBase):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkThroughputTestBase` *)* DSP
    throughput tests to a target system.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkDSPTest, self).__init__()
        self._type = ("NetworkDSPTest", True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkDSPTest, cls).from_dict(data, dirty, undef_enabled)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (factory.create_object(data["parameters"], "NetworkDSPTestParameters"), dirty)
            factory.validate_type(obj._parameters[0], "NetworkDSPTestParameters")
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkDSPTest, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkDSPTest):
            return False
        return super(NetworkDSPTest, self).__eq__(other) and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parameters(self):
        """
        The parameters used to execute the test.

        :rtype: :py:class:`v1_8_1.web.vo.NetworkDSPTestParameters`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class PgSQLSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a PostgreSQL TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSnapshot, self).__init__()
        self._type = ("PgSQLSnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "PgSQLTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "PgSQLTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "PgSQLTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "PgSQLTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._latest_change_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSnapshot):
            return False
        return super(PgSQLSnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.latest_change_point == other.latest_change_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

class AppDataSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Snapshot of an
    AppData TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSnapshot, self).__init__()
        self._type = ("AppDataSnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._metadata = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "AppDataTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "AppDataTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "AppDataSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "AppDataSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "AppDataTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "AppDataTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        if "metadata" in data and data["metadata"] is not None:
            obj._metadata = (data["metadata"], dirty)
        else:
            obj._metadata = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "metadata" == "type" or (self.metadata is not self.__undef__ and not (dirty and not self._metadata[1])):
            dct["metadata"] = dictify(self.metadata)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._runtime = (self._runtime[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._metadata = (self._metadata[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._runtime[1], self._latest_change_point[1], self._metadata[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSnapshot):
            return False
        return super(AppDataSnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.runtime == other.runtime and \
               self.latest_change_point == other.latest_change_point and \
               self.metadata == other.metadata

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def metadata(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._metadata[0]

    @metadata.setter
    def metadata(self, value):
        self._metadata = (value, True)

class MSSqlSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a MSSQL TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSnapshot, self).__init__()
        self._type = ("MSSqlSnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._backup_set_uuid = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "MSSqlTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "MSSqlTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MSSqlSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MSSqlSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "MSSqlTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "MSSqlTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        obj._backup_set_uuid = (data.get("backupSetUUID", obj.__undef__), dirty)
        if obj._backup_set_uuid[0] is not None and obj._backup_set_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_set_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_set_uuid[0]))
            common.validate_format(obj._backup_set_uuid[0], "None", None, None)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "backup_set_uuid" == "type" or (self.backup_set_uuid is not self.__undef__ and not (dirty and not self._backup_set_uuid[1])):
            dct["backupSetUUID"] = dictify(self.backup_set_uuid)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._runtime = (self._runtime[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._backup_set_uuid = (self._backup_set_uuid[0], True)
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._runtime[1], self._latest_change_point[1], self._backup_set_uuid[1], self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSnapshot):
            return False
        return super(MSSqlSnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.runtime == other.runtime and \
               self.latest_change_point == other.latest_change_point and \
               self.backup_set_uuid == other.backup_set_uuid and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def backup_set_uuid(self):
        """
        UUID of the source database backup that was restored for this snapshot.

        :rtype: ``basestring``
        """
        return self._backup_set_uuid[0]

    @backup_set_uuid.setter
    def backup_set_uuid(self, value):
        self._backup_set_uuid = (value, True)

    @property
    def internal_version(self):
        """
        Internal version of the source database at the time the snapshot was
        taken.

        :rtype: ``int``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class MySQLSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a MySQL TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSnapshot, self).__init__()
        self._type = ("MySQLSnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "MySQLTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "MySQLTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MySQLSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MySQLSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "MySQLTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "MySQLTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        if "internalVersion" in data and data["internalVersion"] is not None:
            obj._internal_version = (factory.create_object(data["internalVersion"], "MySQLVersion"), dirty)
            factory.validate_type(obj._internal_version[0], "MySQLVersion")
        else:
            obj._internal_version = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._runtime = (self._runtime[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._runtime[1], self._latest_change_point[1], self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSnapshot):
            return False
        return super(MySQLSnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.runtime == other.runtime and \
               self.latest_change_point == other.latest_change_point and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def internal_version(self):
        """
        Version of the source database at the time the snapshot was taken.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLVersion`
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class OracleSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of an Oracle TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSnapshot, self).__init__()
        self._type = ("OracleSnapshot", True)
        self._from_physical_standby_vdb = (self.__undef__, True)
        self._redo_log_size_in_bytes = (self.__undef__, True)
        self._fraction_timeflows = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._first_change_point = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSnapshot, cls).from_dict(data, dirty, undef_enabled)
        obj._from_physical_standby_vdb = (data.get("fromPhysicalStandbyVdb", obj.__undef__), dirty)
        if obj._from_physical_standby_vdb[0] is not None and obj._from_physical_standby_vdb[0] is not obj.__undef__:
            assert isinstance(obj._from_physical_standby_vdb[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._from_physical_standby_vdb[0]))
            common.validate_format(obj._from_physical_standby_vdb[0], "None", None, None)
        obj._redo_log_size_in_bytes = (data.get("redoLogSizeInBytes", obj.__undef__), dirty)
        if obj._redo_log_size_in_bytes[0] is not None and obj._redo_log_size_in_bytes[0] is not obj.__undef__:
            assert isinstance(obj._redo_log_size_in_bytes[0], float), ("Expected one of [u'number'], but got %s" % type(obj._redo_log_size_in_bytes[0]))
            common.validate_format(obj._redo_log_size_in_bytes[0], "None", None, None)
        obj._fraction_timeflows = []
        for item in data.get("fractionTimeflows") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._fraction_timeflows.append(item)
        obj._fraction_timeflows = (obj._fraction_timeflows, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "OracleTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "OracleTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "OracleTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "OracleTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleSnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleSnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "from_physical_standby_vdb" == "type" or (self.from_physical_standby_vdb is not self.__undef__ and not (dirty and not self._from_physical_standby_vdb[1])):
            dct["fromPhysicalStandbyVdb"] = dictify(self.from_physical_standby_vdb)
        if "redo_log_size_in_bytes" == "type" or (self.redo_log_size_in_bytes is not self.__undef__ and not (dirty and not self._redo_log_size_in_bytes[1])):
            dct["redoLogSizeInBytes"] = dictify(self.redo_log_size_in_bytes)
        if "fraction_timeflows" == "type" or (self.fraction_timeflows is not self.__undef__ and not (dirty and not self._fraction_timeflows[1])):
            dct["fractionTimeflows"] = dictify(self.fraction_timeflows)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._from_physical_standby_vdb = (self._from_physical_standby_vdb[0], True)
        self._redo_log_size_in_bytes = (self._redo_log_size_in_bytes[0], True)
        self._fraction_timeflows = (self._fraction_timeflows[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._first_change_point = (self._first_change_point[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._from_physical_standby_vdb[1], self._redo_log_size_in_bytes[1], self._fraction_timeflows[1], self._latest_change_point[1], self._first_change_point[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSnapshot):
            return False
        return super(OracleSnapshot, self).__eq__(other) and \
               self.from_physical_standby_vdb == other.from_physical_standby_vdb and \
               self.redo_log_size_in_bytes == other.redo_log_size_in_bytes and \
               self.fraction_timeflows == other.fraction_timeflows and \
               self.latest_change_point == other.latest_change_point and \
               self.first_change_point == other.first_change_point and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def from_physical_standby_vdb(self):
        """
        True if this snapshot was taken of a standby database.

        :rtype: ``bool``
        """
        return self._from_physical_standby_vdb[0]

    @from_physical_standby_vdb.setter
    def from_physical_standby_vdb(self, value):
        self._from_physical_standby_vdb = (value, True)

    @property
    def redo_log_size_in_bytes(self):
        """
        Online redo log size in bytes when this snapshot was taken.

        :rtype: ``float``
        """
        return self._redo_log_size_in_bytes[0]

    @redo_log_size_in_bytes.setter
    def redo_log_size_in_bytes(self, value):
        self._redo_log_size_in_bytes = (value, True)

    @property
    def fraction_timeflows(self):
        """
        Auxiliary TimeFlows with snapshots controlled by this master snapshot.

        :rtype: ``list`` of ``basestring``
        """
        return self._fraction_timeflows[0]

    @fraction_timeflows.setter
    def fraction_timeflows(self, value):
        self._fraction_timeflows = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.OracleTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.OracleTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.OracleSnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class VMwareSnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Snapshot of a
    VMware TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareSnapshot, self).__init__()
        self._type = ("VMwareSnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "VMwareTimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "VMwareTimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "VMwareTimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "VMwareTimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._latest_change_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareSnapshot):
            return False
        return super(VMwareSnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.latest_change_point == other.latest_change_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareTimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareTimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

class ASESnapshot(TimeflowSnapshot):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowSnapshot` *)* Provisionable
    snapshot of a SAP ASE TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(ASESnapshot, self).__init__()
        self._type = ("ASESnapshot", True)
        self._first_change_point = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._latest_change_point = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "firstChangePoint" in data and data["firstChangePoint"] is not None:
            obj._first_change_point = (factory.create_object(data["firstChangePoint"], "ASETimeflowPoint"), dirty)
            factory.validate_type(obj._first_change_point[0], "ASETimeflowPoint")
        else:
            obj._first_change_point = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ASESnapshotRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ASESnapshotRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        if "latestChangePoint" in data and data["latestChangePoint"] is not None:
            obj._latest_change_point = (factory.create_object(data["latestChangePoint"], "ASETimeflowPoint"), dirty)
            factory.validate_type(obj._latest_change_point[0], "ASETimeflowPoint")
        else:
            obj._latest_change_point = (obj.__undef__, dirty)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "first_change_point" == "type" or (self.first_change_point is not self.__undef__ and not (dirty and not self._first_change_point[1])):
            dct["firstChangePoint"] = dictify(self.first_change_point)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "latest_change_point" == "type" or (self.latest_change_point is not self.__undef__ and not (dirty and not self._latest_change_point[1])):
            dct["latestChangePoint"] = dictify(self.latest_change_point)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._first_change_point = (self._first_change_point[0], True)
        self._runtime = (self._runtime[0], True)
        self._latest_change_point = (self._latest_change_point[0], True)
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._first_change_point[1], self._runtime[1], self._latest_change_point[1], self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESnapshot):
            return False
        return super(ASESnapshot, self).__eq__(other) and \
               self.first_change_point == other.first_change_point and \
               self.runtime == other.runtime and \
               self.latest_change_point == other.latest_change_point and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def first_change_point(self):
        """
        The location within the parent TimeFlow at which this snapshot was
        initiated.

        :rtype: :py:class:`v1_8_1.web.vo.ASETimeflowPoint`
        """
        return self._first_change_point[0]

    @first_change_point.setter
    def first_change_point(self, value):
        self._first_change_point = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of the snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.ASESnapshotRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def latest_change_point(self):
        """
        The location of the snapshot within the parent TimeFlow represented by
        this snapshot.

        :rtype: :py:class:`v1_8_1.web.vo.ASETimeflowPoint`
        """
        return self._latest_change_point[0]

    @latest_change_point.setter
    def latest_change_point(self, value):
        self._latest_change_point = (value, True)

    @property
    def internal_version(self):
        """
        Internal version of the source database at the time the snapshot was
        taken.

        :rtype: ``basestring``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class MSSqlRepository(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* The SQL Server
    source repository.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlRepository, self).__init__()
        self._type = ("MSSqlRepository", True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlRepository):
            return False
        return super(MSSqlRepository, self).__eq__(other) and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def internal_version(self):
        """
        Internal version of the SQL Server instance.

        :rtype: ``int``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class AppDataRepository(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* An AppData
    repository.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataRepository, self).__init__()
        self._type = ("AppDataRepository", True)
        self._toolkit = (self.__undef__, True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._toolkit = (data.get("toolkit", obj.__undef__), dirty)
        if obj._toolkit[0] is not None and obj._toolkit[0] is not obj.__undef__:
            assert isinstance(obj._toolkit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit[0]))
            common.validate_format(obj._toolkit[0], "objectReference", None, None)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "toolkit" == "type" or (self.toolkit is not self.__undef__ and not (dirty and not self._toolkit[1])):
            dct["toolkit"] = dictify(self.toolkit)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._toolkit = (self._toolkit[0], True)
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._toolkit[1], self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataRepository):
            return False
        return super(AppDataRepository, self).__eq__(other) and \
               self.toolkit == other.toolkit and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def toolkit(self):
        """
        The toolkit associated with this repository.

        :rtype: ``basestring``
        """
        return self._toolkit[0]

    @toolkit.setter
    def toolkit(self, value):
        self._toolkit = (value, True)

    @property
    def parameters(self):
        """
        The list of parameters specified by the repository schema in the
        toolkit. If no schema is specified, this list is empty.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class PgSQLInstall(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* A PostgreSQL
    installation.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLInstall, self).__init__()
        self._type = ("PgSQLInstall", True)
        self._installation_path = (self.__undef__, True)
        self._segment_size = (self.__undef__, True)
        self._variant = (self.__undef__, True)
        self._discovered = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._bits = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLInstall, cls).from_dict(data, dirty, undef_enabled)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, 1024)
        obj._segment_size = (data.get("segmentSize", obj.__undef__), dirty)
        if obj._segment_size[0] is not None and obj._segment_size[0] is not obj.__undef__:
            assert isinstance(obj._segment_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._segment_size[0]))
            assert obj._segment_size[0] in [1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864], "Expected enum [1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864] but got %s" % obj._segment_size[0]
            common.validate_format(obj._segment_size[0], "None", None, None)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'PostgreSQL', u'EnterpriseDB'], "Expected enum [u'PostgreSQL', u'EnterpriseDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "pgsqlVersion", None, None)
        obj._bits = (data.get("bits", obj.__undef__), dirty)
        if obj._bits[0] is not None and obj._bits[0] is not obj.__undef__:
            assert isinstance(obj._bits[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bits[0]))
            assert obj._bits[0] in [32, 64], "Expected enum [32, 64] but got %s" % obj._bits[0]
            common.validate_format(obj._bits[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLInstall, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "segment_size" == "type" or (self.segment_size is not self.__undef__ and not (dirty and not self._segment_size[1])):
            dct["segmentSize"] = dictify(self.segment_size)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "bits" == "type" or (self.bits is not self.__undef__ and not (dirty and not self._bits[1])):
            dct["bits"] = dictify(self.bits)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._installation_path = (self._installation_path[0], True)
        self._segment_size = (self._segment_size[0], True)
        self._variant = (self._variant[0], True)
        self._discovered = (self._discovered[0], True)
        self._version = (self._version[0], True)
        self._bits = (self._bits[0], True)

    def is_dirty(self):
        return any([self._installation_path[1], self._segment_size[1], self._variant[1], self._discovered[1], self._version[1], self._bits[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLInstall):
            return False
        return super(PgSQLInstall, self).__eq__(other) and \
               self.installation_path == other.installation_path and \
               self.segment_size == other.segment_size and \
               self.variant == other.variant and \
               self.discovered == other.discovered and \
               self.version == other.version and \
               self.bits == other.bits

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def installation_path(self):
        """
        Directory path where the installation is located.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def segment_size(self):
        """
        Size of the WAL segments (in bytes) generated by PostgreSQL binaries.
        *(permitted values: 1048576, 2097152, 4194304, 8388608, 16777216,
        33554432, 67108864)*

        :rtype: ``int``
        """
        return self._segment_size[0]

    @segment_size.setter
    def segment_size(self, value):
        self._segment_size = (value, True)

    @property
    def variant(self):
        """
        Variant of the repository. *(permitted values: PostgreSQL,
        EnterpriseDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

    @property
    def discovered(self):
        """
        Flag indicating whether the installation was discovered or manually
        entered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def version(self):
        """
        Version of the repository.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def bits(self):
        """
        32 or 64 bit installation. *(permitted values: 32, 64)*

        :rtype: ``int``
        """
        return self._bits[0]

    @bits.setter
    def bits(self, value):
        self._bits = (value, True)

class OracleInstall(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* The Oracle source
    repository.
    """
    def __init__(self, undef_enabled=True):
        super(OracleInstall, self).__init__()
        self._type = ("OracleInstall", True)
        self._user_name = (self.__undef__, True)
        self._installation_home = (self.__undef__, True)
        self._user_id = (self.__undef__, True)
        self._logsync_possible = (self.__undef__, True)
        self._discovered = (self.__undef__, True)
        self._group_name = (self.__undef__, True)
        self._oracle_base = (self.__undef__, True)
        self._applied_patches = (self.__undef__, True)
        self._bits = (self.__undef__, True)
        self._group_id = (self.__undef__, True)
        self._rac = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleInstall, cls).from_dict(data, dirty, undef_enabled)
        obj._user_name = (data.get("userName", obj.__undef__), dirty)
        if obj._user_name[0] is not None and obj._user_name[0] is not obj.__undef__:
            assert isinstance(obj._user_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_name[0]))
            common.validate_format(obj._user_name[0], "None", None, None)
        obj._installation_home = (data.get("installationHome", obj.__undef__), dirty)
        if obj._installation_home[0] is not None and obj._installation_home[0] is not obj.__undef__:
            assert isinstance(obj._installation_home[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_home[0]))
            common.validate_format(obj._installation_home[0], "None", None, 256)
        obj._user_id = (data.get("userId", obj.__undef__), dirty)
        if obj._user_id[0] is not None and obj._user_id[0] is not obj.__undef__:
            assert isinstance(obj._user_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user_id[0]))
            common.validate_format(obj._user_id[0], "None", None, None)
        obj._logsync_possible = (data.get("logsyncPossible", obj.__undef__), dirty)
        if obj._logsync_possible[0] is not None and obj._logsync_possible[0] is not obj.__undef__:
            assert isinstance(obj._logsync_possible[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._logsync_possible[0]))
            common.validate_format(obj._logsync_possible[0], "None", None, None)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._group_name = (data.get("groupName", obj.__undef__), dirty)
        if obj._group_name[0] is not None and obj._group_name[0] is not obj.__undef__:
            assert isinstance(obj._group_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group_name[0]))
            common.validate_format(obj._group_name[0], "None", None, None)
        obj._oracle_base = (data.get("oracleBase", obj.__undef__), dirty)
        if obj._oracle_base[0] is not None and obj._oracle_base[0] is not obj.__undef__:
            assert isinstance(obj._oracle_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._oracle_base[0]))
            common.validate_format(obj._oracle_base[0], "None", None, None)
        obj._applied_patches = []
        for item in data.get("appliedPatches") or []:
            assert isinstance(item, int), ("Expected one of [u'integer'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._applied_patches.append(item)
        obj._applied_patches = (obj._applied_patches, dirty)
        obj._bits = (data.get("bits", obj.__undef__), dirty)
        if obj._bits[0] is not None and obj._bits[0] is not obj.__undef__:
            assert isinstance(obj._bits[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bits[0]))
            common.validate_format(obj._bits[0], "None", None, None)
        obj._group_id = (data.get("groupId", obj.__undef__), dirty)
        if obj._group_id[0] is not None and obj._group_id[0] is not obj.__undef__:
            assert isinstance(obj._group_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._group_id[0]))
            common.validate_format(obj._group_id[0], "None", None, None)
        obj._rac = (data.get("rac", obj.__undef__), dirty)
        if obj._rac[0] is not None and obj._rac[0] is not obj.__undef__:
            assert isinstance(obj._rac[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._rac[0]))
            common.validate_format(obj._rac[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleInstall, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "user_name" == "type" or (self.user_name is not self.__undef__ and not (dirty and not self._user_name[1])):
            dct["userName"] = dictify(self.user_name)
        if "installation_home" == "type" or (self.installation_home is not self.__undef__ and not (dirty and not self._installation_home[1])):
            dct["installationHome"] = dictify(self.installation_home)
        if "user_id" == "type" or (self.user_id is not self.__undef__ and not (dirty and not self._user_id[1])):
            dct["userId"] = dictify(self.user_id)
        if "logsync_possible" == "type" or (self.logsync_possible is not self.__undef__ and not (dirty and not self._logsync_possible[1])):
            dct["logsyncPossible"] = dictify(self.logsync_possible)
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "group_name" == "type" or (self.group_name is not self.__undef__ and not (dirty and not self._group_name[1])):
            dct["groupName"] = dictify(self.group_name)
        if "oracle_base" == "type" or (self.oracle_base is not self.__undef__ and not (dirty and not self._oracle_base[1])):
            dct["oracleBase"] = dictify(self.oracle_base)
        if "applied_patches" == "type" or (self.applied_patches is not self.__undef__ and not (dirty and not self._applied_patches[1])):
            dct["appliedPatches"] = dictify(self.applied_patches)
        if "bits" == "type" or (self.bits is not self.__undef__ and not (dirty and not self._bits[1])):
            dct["bits"] = dictify(self.bits)
        if "group_id" == "type" or (self.group_id is not self.__undef__ and not (dirty and not self._group_id[1])):
            dct["groupId"] = dictify(self.group_id)
        if "rac" == "type" or (self.rac is not self.__undef__ and not (dirty and not self._rac[1])):
            dct["rac"] = dictify(self.rac)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._user_name = (self._user_name[0], True)
        self._installation_home = (self._installation_home[0], True)
        self._user_id = (self._user_id[0], True)
        self._logsync_possible = (self._logsync_possible[0], True)
        self._discovered = (self._discovered[0], True)
        self._group_name = (self._group_name[0], True)
        self._oracle_base = (self._oracle_base[0], True)
        self._applied_patches = (self._applied_patches[0], True)
        self._bits = (self._bits[0], True)
        self._group_id = (self._group_id[0], True)
        self._rac = (self._rac[0], True)

    def is_dirty(self):
        return any([self._user_name[1], self._installation_home[1], self._user_id[1], self._logsync_possible[1], self._discovered[1], self._group_name[1], self._oracle_base[1], self._applied_patches[1], self._bits[1], self._group_id[1], self._rac[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleInstall):
            return False
        return super(OracleInstall, self).__eq__(other) and \
               self.user_name == other.user_name and \
               self.installation_home == other.installation_home and \
               self.user_id == other.user_id and \
               self.logsync_possible == other.logsync_possible and \
               self.discovered == other.discovered and \
               self.group_name == other.group_name and \
               self.oracle_base == other.oracle_base and \
               self.applied_patches == other.applied_patches and \
               self.bits == other.bits and \
               self.group_id == other.group_id and \
               self.rac == other.rac

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def user_name(self):
        """
        User name of the user that owns the install.

        :rtype: ``basestring``
        """
        return self._user_name[0]

    @user_name.setter
    def user_name(self, value):
        self._user_name = (value, True)

    @property
    def installation_home(self):
        """
        The Oracle install home.

        :rtype: ``basestring``
        """
        return self._installation_home[0]

    @installation_home.setter
    def installation_home(self, value):
        self._installation_home = (value, True)

    @property
    def user_id(self):
        """
        User ID of the user that owns the install.

        :rtype: ``int``
        """
        return self._user_id[0]

    @user_id.setter
    def user_id(self, value):
        self._user_id = (value, True)

    @property
    def logsync_possible(self):
        """
        Flag indicating whether this repository can use LogSync.

        :rtype: ``bool``
        """
        return self._logsync_possible[0]

    @logsync_possible.setter
    def logsync_possible(self, value):
        self._logsync_possible = (value, True)

    @property
    def discovered(self):
        """
        Flag indicating whether the install was discovered or manually entered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def group_name(self):
        """
        Group name of the user that owns the install.

        :rtype: ``basestring``
        """
        return self._group_name[0]

    @group_name.setter
    def group_name(self, value):
        self._group_name = (value, True)

    @property
    def oracle_base(self):
        """
        The Oracle base where database binaries are located.

        :rtype: ``basestring``
        """
        return self._oracle_base[0]

    @oracle_base.setter
    def oracle_base(self, value):
        self._oracle_base = (value, True)

    @property
    def applied_patches(self):
        """
        List of Oracle patches that have been applied to this Oracle Home.

        :rtype: ``list`` of ``int``
        """
        return self._applied_patches[0]

    @applied_patches.setter
    def applied_patches(self, value):
        self._applied_patches = (value, True)

    @property
    def bits(self):
        """
        32 or 64 bits.

        :rtype: ``int``
        """
        return self._bits[0]

    @bits.setter
    def bits(self, value):
        self._bits = (value, True)

    @property
    def group_id(self):
        """
        Group ID of the user that owns the install.

        :rtype: ``int``
        """
        return self._group_id[0]

    @group_id.setter
    def group_id(self, value):
        self._group_id = (value, True)

    @property
    def rac(self):
        """
        Flag indicating whether the install supports Oracle RAC.

        :rtype: ``bool``
        """
        return self._rac[0]

    @rac.setter
    def rac(self, value):
        self._rac = (value, True)

class MySQLInstall(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* A MySQL
    installation.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLInstall, self).__init__()
        self._type = ("MySQLInstall", True)
        self._discovered = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._installation_path = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLInstall, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, None)
        if "internalVersion" in data and data["internalVersion"] is not None:
            obj._internal_version = (factory.create_object(data["internalVersion"], "MySQLVersion"), dirty)
            factory.validate_type(obj._internal_version[0], "MySQLVersion")
        else:
            obj._internal_version = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLInstall, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if dirty and "version" in dct:
            del dct["version"]
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._version = (self._version[0], True)
        self._installation_path = (self._installation_path[0], True)
        self._internal_version = (self._internal_version[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._version[1], self._installation_path[1], self._internal_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLInstall):
            return False
        return super(MySQLInstall, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.version == other.version and \
               self.installation_path == other.installation_path and \
               self.internal_version == other.internal_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Flag indicating whether the MySQL installation was discovered or
        manually entered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def version(self):
        """
        Version string for the repository.

        :rtype: ``basestring``
        """
        return self._version[0]

    @property
    def installation_path(self):
        """
        Directory path where the MySQL installation is located.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def internal_version(self):
        """
        Version of the MySQL installation.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLVersion`
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

class ASEInstance(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* The SAP ASE
    source repository.
    """
    def __init__(self, undef_enabled=True):
        super(ASEInstance, self).__init__()
        self._type = ("ASEInstance", True)
        self._installation_path = (self.__undef__, True)
        self._internal_version = (self.__undef__, True)
        self._server_name = (self.__undef__, True)
        self._instance_owner = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._page_size = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)
        self._ports = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, None)
        obj._internal_version = (data.get("internalVersion", obj.__undef__), dirty)
        if obj._internal_version[0] is not None and obj._internal_version[0] is not obj.__undef__:
            assert isinstance(obj._internal_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._internal_version[0]))
            common.validate_format(obj._internal_version[0], "None", None, None)
        obj._server_name = (data.get("serverName", obj.__undef__), dirty)
        if obj._server_name[0] is not None and obj._server_name[0] is not obj.__undef__:
            assert isinstance(obj._server_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server_name[0]))
            common.validate_format(obj._server_name[0], "None", None, None)
        obj._instance_owner = (data.get("instanceOwner", obj.__undef__), dirty)
        if obj._instance_owner[0] is not None and obj._instance_owner[0] is not obj.__undef__:
            assert isinstance(obj._instance_owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_owner[0]))
            common.validate_format(obj._instance_owner[0], "None", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, 256)
        obj._page_size = (data.get("pageSize", obj.__undef__), dirty)
        if obj._page_size[0] is not None and obj._page_size[0] is not obj.__undef__:
            assert isinstance(obj._page_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._page_size[0]))
            common.validate_format(obj._page_size[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        obj._ports = []
        for item in data.get("ports") or []:
            assert isinstance(item, int), ("Expected one of [u'integer'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._ports.append(item)
        obj._ports = (obj._ports, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "internal_version" == "type" or (self.internal_version is not self.__undef__ and not (dirty and not self._internal_version[1])):
            dct["internalVersion"] = dictify(self.internal_version)
        if "server_name" == "type" or (self.server_name is not self.__undef__ and not (dirty and not self._server_name[1])):
            dct["serverName"] = dictify(self.server_name)
        if "instance_owner" == "type" or (self.instance_owner is not self.__undef__ and not (dirty and not self._instance_owner[1])):
            dct["instanceOwner"] = dictify(self.instance_owner)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "page_size" == "type" or (self.page_size is not self.__undef__ and not (dirty and not self._page_size[1])):
            dct["pageSize"] = dictify(self.page_size)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        if "ports" == "type" or (self.ports is not self.__undef__ and not (dirty and not self._ports[1])):
            dct["ports"] = dictify(self.ports)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._installation_path = (self._installation_path[0], True)
        self._internal_version = (self._internal_version[0], True)
        self._server_name = (self._server_name[0], True)
        self._instance_owner = (self._instance_owner[0], True)
        self._credentials = (self._credentials[0], True)
        self._db_user = (self._db_user[0], True)
        self._page_size = (self._page_size[0], True)
        self._instance_name = (self._instance_name[0], True)
        self._ports = (self._ports[0], True)

    def is_dirty(self):
        return any([self._installation_path[1], self._internal_version[1], self._server_name[1], self._instance_owner[1], self._credentials[1], self._db_user[1], self._page_size[1], self._instance_name[1], self._ports[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEInstance):
            return False
        return super(ASEInstance, self).__eq__(other) and \
               self.installation_path == other.installation_path and \
               self.internal_version == other.internal_version and \
               self.server_name == other.server_name and \
               self.instance_owner == other.instance_owner and \
               self.credentials == other.credentials and \
               self.db_user == other.db_user and \
               self.page_size == other.page_size and \
               self.instance_name == other.instance_name and \
               self.ports == other.ports

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def installation_path(self):
        """
        The SAP ASE instance home.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def internal_version(self):
        """
        Internal version of the SAP ASE instance.

        :rtype: ``basestring``
        """
        return self._internal_version[0]

    @internal_version.setter
    def internal_version(self, value):
        self._internal_version = (value, True)

    @property
    def server_name(self):
        """
        The server name of the SAP ASE instance.

        :rtype: ``basestring``
        """
        return self._server_name[0]

    @server_name.setter
    def server_name(self, value):
        self._server_name = (value, True)

    @property
    def instance_owner(self):
        """
        Account the SAP ASE instance is running as.

        :rtype: ``basestring``
        """
        return self._instance_owner[0]

    @instance_owner.setter
    def instance_owner(self, value):
        self._instance_owner = (value, True)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def db_user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def page_size(self):
        """
        Database page size for the SAP ASE instance.

        :rtype: ``int``
        """
        return self._page_size[0]

    @page_size.setter
    def page_size(self, value):
        self._page_size = (value, True)

    @property
    def instance_name(self):
        """
        The name of the SAP ASE instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

    @property
    def ports(self):
        """
        The network ports for connecting to the SAP ASE instance.

        :rtype: ``list`` of ``int``
        """
        return self._ports[0]

    @ports.setter
    def ports(self, value):
        self._ports = (value, True)

class VMwareComputeResource(SourceRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRepository` *)* A VMware Compute
    Resource object.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareComputeResource, self).__init__()
        self._type = ("VMwareComputeResource", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareComputeResource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareComputeResource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareComputeResource):
            return False
        return super(VMwareComputeResource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlInstance(MSSqlRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlRepository` *)* A SQL Server
    Instance.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlInstance, self).__init__()
        self._type = ("MSSqlInstance", True)
        self._installation_path = (self.__undef__, True)
        self._server_name = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._instance_owner = (self.__undef__, True)
        self._instance_name = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlInstance, cls).from_dict(data, dirty, undef_enabled)
        obj._installation_path = (data.get("installationPath", obj.__undef__), dirty)
        if obj._installation_path[0] is not None and obj._installation_path[0] is not obj.__undef__:
            assert isinstance(obj._installation_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_path[0]))
            common.validate_format(obj._installation_path[0], "None", None, None)
        obj._server_name = (data.get("serverName", obj.__undef__), dirty)
        if obj._server_name[0] is not None and obj._server_name[0] is not obj.__undef__:
            assert isinstance(obj._server_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._server_name[0]))
            common.validate_format(obj._server_name[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._instance_owner = (data.get("instanceOwner", obj.__undef__), dirty)
        if obj._instance_owner[0] is not None and obj._instance_owner[0] is not obj.__undef__:
            assert isinstance(obj._instance_owner[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_owner[0]))
            common.validate_format(obj._instance_owner[0], "None", None, None)
        obj._instance_name = (data.get("instanceName", obj.__undef__), dirty)
        if obj._instance_name[0] is not None and obj._instance_name[0] is not obj.__undef__:
            assert isinstance(obj._instance_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._instance_name[0]))
            common.validate_format(obj._instance_name[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "installation_path" == "type" or (self.installation_path is not self.__undef__ and not (dirty and not self._installation_path[1])):
            dct["installationPath"] = dictify(self.installation_path)
        if "server_name" == "type" or (self.server_name is not self.__undef__ and not (dirty and not self._server_name[1])):
            dct["serverName"] = dictify(self.server_name)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "instance_owner" == "type" or (self.instance_owner is not self.__undef__ and not (dirty and not self._instance_owner[1])):
            dct["instanceOwner"] = dictify(self.instance_owner)
        if "instance_name" == "type" or (self.instance_name is not self.__undef__ and not (dirty and not self._instance_name[1])):
            dct["instanceName"] = dictify(self.instance_name)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._installation_path = (self._installation_path[0], True)
        self._server_name = (self._server_name[0], True)
        self._version = (self._version[0], True)
        self._instance_owner = (self._instance_owner[0], True)
        self._instance_name = (self._instance_name[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._installation_path[1], self._server_name[1], self._version[1], self._instance_owner[1], self._instance_name[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlInstance):
            return False
        return super(MSSqlInstance, self).__eq__(other) and \
               self.installation_path == other.installation_path and \
               self.server_name == other.server_name and \
               self.version == other.version and \
               self.instance_owner == other.instance_owner and \
               self.instance_name == other.instance_name and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def installation_path(self):
        """
        The SQL Server instance home.

        :rtype: ``basestring``
        """
        return self._installation_path[0]

    @installation_path.setter
    def installation_path(self, value):
        self._installation_path = (value, True)

    @property
    def server_name(self):
        """
        The Servername of the SQL Server instance.

        :rtype: ``basestring``
        """
        return self._server_name[0]

    @server_name.setter
    def server_name(self, value):
        self._server_name = (value, True)

    @property
    def version(self):
        """
        The version of the SQL Server instance.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def instance_owner(self):
        """
        Account the SQL Server instance is running as.

        :rtype: ``basestring``
        """
        return self._instance_owner[0]

    @instance_owner.setter
    def instance_owner(self, value):
        self._instance_owner = (value, True)

    @property
    def instance_name(self):
        """
        The name of the SQL Server instance.

        :rtype: ``basestring``
        """
        return self._instance_name[0]

    @instance_name.setter
    def instance_name(self, value):
        self._instance_name = (value, True)

    @property
    def port(self):
        """
        The network port for connecting to the SQL Server instance.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class MSSqlBaseClusterRepository(MSSqlRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlRepository` *)* The representation
    of a SQL Server Cluster repository.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlBaseClusterRepository, self).__init__()
        self._type = ("MSSqlBaseClusterRepository", True)
        self._instances = (self.__undef__, True)
        self._listeners = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlBaseClusterRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._instances = []
        for item in data.get("instances") or []:
            obj._instances.append(factory.create_object(item))
            factory.validate_type(obj._instances[-1], "MSSqlBaseClusterInstance")
        obj._instances = (obj._instances, dirty)
        obj._listeners = []
        for item in data.get("listeners") or []:
            obj._listeners.append(factory.create_object(item))
            factory.validate_type(obj._listeners[-1], "MSSqlBaseClusterListener")
        obj._listeners = (obj._listeners, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlBaseClusterRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        if "listeners" == "type" or (self.listeners is not self.__undef__ and not (dirty and not self._listeners[1])):
            dct["listeners"] = dictify(self.listeners)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instances = (self._instances[0], True)
        self._listeners = (self._listeners[0], True)

    def is_dirty(self):
        return any([self._instances[1], self._listeners[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlBaseClusterRepository):
            return False
        return super(MSSqlBaseClusterRepository, self).__eq__(other) and \
               self.instances == other.instances and \
               self.listeners == other.listeners

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instances(self):
        """
        The list of MSSQL Cluster instances belonging to this repository.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.MSSqlBaseClusterInstance`
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

    @property
    def listeners(self):
        """
        The list of listeners belonging to this repository.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.MSSqlBaseClusterListener`
        """
        return self._listeners[0]

    @listeners.setter
    def listeners(self, value):
        self._listeners = (value, True)

class MSSqlFailoverClusterRepository(MSSqlBaseClusterRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterRepository` *)* The
    representation of a SQL Server Failover Cluster repository.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlFailoverClusterRepository, self).__init__()
        self._type = ("MSSqlFailoverClusterRepository", True)
        self._drives = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlFailoverClusterRepository, cls).from_dict(data, dirty, undef_enabled)
        obj._drives = []
        for item in data.get("drives") or []:
            obj._drives.append(factory.create_object(item))
            factory.validate_type(obj._drives[-1], "MSSqlFailoverClusterDriveLetter")
        obj._drives = (obj._drives, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlFailoverClusterRepository, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "drives" == "type" or (self.drives is not self.__undef__ and not (dirty and not self._drives[1])):
            dct["drives"] = dictify(self.drives)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._drives = (self._drives[0], True)

    def is_dirty(self):
        return any([self._drives[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlFailoverClusterRepository):
            return False
        return super(MSSqlFailoverClusterRepository, self).__eq__(other) and \
               self.drives == other.drives

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def drives(self):
        """
        The list of drive letters belonging to this Failover Cluster
        repository.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.MSSqlFailoverClusterDriveLetter`
        """
        return self._drives[0]

    @drives.setter
    def drives(self, value):
        self._drives = (value, True)

class MSSqlAvailabilityGroup(MSSqlBaseClusterRepository):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterRepository` *)* The
    representation of a SQL Server Availability Group.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlAvailabilityGroup, self).__init__()
        self._type = ("MSSqlAvailabilityGroup", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlAvailabilityGroup, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlAvailabilityGroup, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlAvailabilityGroup):
            return False
        return super(MSSqlAvailabilityGroup, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class VMwareHost(Host):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Host` *)* The representation of a
    VMware host object.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareHost, self).__init__()
        self._type = ("VMwareHost", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareHost, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareHost, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareHost):
            return False
        return super(VMwareHost, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class UnixHost(Host):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Host` *)* The representation of a Unix
    host object.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHost, self).__init__()
        self._type = ("UnixHost", True)
        self._toolkit_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHost, cls).from_dict(data, dirty, undef_enabled)
        obj._toolkit_path = (data.get("toolkitPath", obj.__undef__), dirty)
        if obj._toolkit_path[0] is not None and obj._toolkit_path[0] is not obj.__undef__:
            assert isinstance(obj._toolkit_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit_path[0]))
            common.validate_format(obj._toolkit_path[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHost, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "toolkit_path" == "type" or (self.toolkit_path is not self.__undef__ and not (dirty and not self._toolkit_path[1])):
            dct["toolkitPath"] = dictify(self.toolkit_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._toolkit_path = (self._toolkit_path[0], True)

    def is_dirty(self):
        return any([self._toolkit_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHost):
            return False
        return super(UnixHost, self).__eq__(other) and \
               self.toolkit_path == other.toolkit_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def toolkit_path(self):
        """
        The path for the toolkit that resides on the host.

        :rtype: ``basestring``
        """
        return self._toolkit_path[0]

    @toolkit_path.setter
    def toolkit_path(self, value):
        self._toolkit_path = (value, True)

class WindowsHost(Host):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Host` *)* The representation of a
    Windows host object.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHost, self).__init__()
        self._type = ("WindowsHost", True)
        self._connector_authentication_key = (self.__undef__, True)
        self._connector_port = (self.__undef__, True)
        self._toolkit_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHost, cls).from_dict(data, dirty, undef_enabled)
        obj._connector_authentication_key = (data.get("connectorAuthenticationKey", obj.__undef__), dirty)
        if obj._connector_authentication_key[0] is not None and obj._connector_authentication_key[0] is not obj.__undef__:
            assert isinstance(obj._connector_authentication_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_authentication_key[0]))
            common.validate_format(obj._connector_authentication_key[0], "None", None, None)
        obj._connector_port = (data.get("connectorPort", obj.__undef__), dirty)
        if obj._connector_port[0] is not None and obj._connector_port[0] is not obj.__undef__:
            assert isinstance(obj._connector_port[0], float), ("Expected one of [u'number'], but got %s" % type(obj._connector_port[0]))
            common.validate_format(obj._connector_port[0], "None", None, None)
        obj._toolkit_path = (data.get("toolkitPath", obj.__undef__), dirty)
        if obj._toolkit_path[0] is not None and obj._toolkit_path[0] is not obj.__undef__:
            assert isinstance(obj._toolkit_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit_path[0]))
            common.validate_format(obj._toolkit_path[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHost, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connector_authentication_key" == "type" or (self.connector_authentication_key is not self.__undef__ and not (dirty and not self._connector_authentication_key[1])):
            dct["connectorAuthenticationKey"] = dictify(self.connector_authentication_key)
        if "connector_port" == "type" or (self.connector_port is not self.__undef__ and not (dirty and not self._connector_port[1])):
            dct["connectorPort"] = dictify(self.connector_port)
        if "toolkit_path" == "type" or (self.toolkit_path is not self.__undef__ and not (dirty and not self._toolkit_path[1])):
            dct["toolkitPath"] = dictify(self.toolkit_path)
        if dirty and "toolkitPath" in dct:
            del dct["toolkitPath"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connector_authentication_key = (self._connector_authentication_key[0], True)
        self._connector_port = (self._connector_port[0], True)
        self._toolkit_path = (self._toolkit_path[0], True)

    def is_dirty(self):
        return any([self._connector_authentication_key[1], self._connector_port[1], self._toolkit_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHost):
            return False
        return super(WindowsHost, self).__eq__(other) and \
               self.connector_authentication_key == other.connector_authentication_key and \
               self.connector_port == other.connector_port and \
               self.toolkit_path == other.toolkit_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connector_authentication_key(self):
        """
        Unique per Delphix key used to authenticate with the remote Delphix
        Connector.

        :rtype: ``basestring``
        """
        return self._connector_authentication_key[0]

    @connector_authentication_key.setter
    def connector_authentication_key(self, value):
        self._connector_authentication_key = (value, True)

    @property
    def connector_port(self):
        """
        The port that the connector connects on.

        :rtype: ``float``
        """
        return self._connector_port[0]

    @connector_port.setter
    def connector_port(self, value):
        self._connector_port = (value, True)

    @property
    def toolkit_path(self):
        """
        The path for the toolkit that resides on the host.

        :rtype: ``basestring``
        """
        return self._toolkit_path[0]

class ASEDBConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* A SAP ASE Database
    Config.
    """
    def __init__(self, undef_enabled=True):
        super(ASEDBConfig, self).__init__()
        self._type = ("ASEDBConfig", True)
        self._credentials = (self.__undef__, True)
        self._database_name = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEDBConfig, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 30)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._database_name = (self._database_name[0], True)
        self._repository = (self._repository[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._database_name[1], self._repository[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEDBConfig):
            return False
        return super(ASEDBConfig, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.database_name == other.database_name and \
               self.repository == other.repository and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class PgSQLDBClusterConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* Configuration
    information for a PostgreSQL database cluster.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBClusterConfig, self).__init__()
        self._type = ("PgSQLDBClusterConfig", True)
        self._repository = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._cluster_data_directory = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBClusterConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._cluster_data_directory = (data.get("clusterDataDirectory", obj.__undef__), dirty)
        if obj._cluster_data_directory[0] is not None and obj._cluster_data_directory[0] is not obj.__undef__:
            assert isinstance(obj._cluster_data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster_data_directory[0]))
            common.validate_format(obj._cluster_data_directory[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBClusterConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "cluster_data_directory" == "type" or (self.cluster_data_directory is not self.__undef__ and not (dirty and not self._cluster_data_directory[1])):
            dct["clusterDataDirectory"] = dictify(self.cluster_data_directory)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._repository = (self._repository[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._credentials = (self._credentials[0], True)
        self._cluster_data_directory = (self._cluster_data_directory[0], True)
        self._port = (self._port[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._repository[1], self._connection_database[1], self._credentials[1], self._cluster_data_directory[1], self._port[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBClusterConfig):
            return False
        return super(PgSQLDBClusterConfig, self).__eq__(other) and \
               self.repository == other.repository and \
               self.connection_database == other.connection_database and \
               self.credentials == other.credentials and \
               self.cluster_data_directory == other.cluster_data_directory and \
               self.port == other.port and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def connection_database(self):
        """
        The database that must be used to run SQL queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def credentials(self):
        """
        The password of the database cluster user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def cluster_data_directory(self):
        """
        The data directory for the PostgreSQL cluster.

        :rtype: ``basestring``
        """
        return self._cluster_data_directory[0]

    @cluster_data_directory.setter
    def cluster_data_directory(self, value):
        self._cluster_data_directory = (value, True)

    @property
    def port(self):
        """
        The port on which the PostgresSQL server for the cluster is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class OracleBaseDBConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* The source config
    represents the dynamically discovered attributes of a base Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleBaseDBConfig, self).__init__()
        self._type = ("OracleBaseDBConfig", True)
        self._services = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleBaseDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._services = []
        for item in data.get("services") or []:
            obj._services.append(factory.create_object(item))
            factory.validate_type(obj._services[-1], "OracleService")
        obj._services = (obj._services, dirty)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 30)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleBaseDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "services" == "type" or (self.services is not self.__undef__ and not (dirty and not self._services[1])):
            dct["services"] = dictify(self.services)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._services = (self._services[0], True)
        self._credentials = (self._credentials[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._services[1], self._credentials[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleBaseDBConfig):
            return False
        return super(OracleBaseDBConfig, self).__eq__(other) and \
               self.services == other.services and \
               self.credentials == other.credentials and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def services(self):
        """
        The list of database services.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleService`
        """
        return self._services[0]

    @services.setter
    def services(self, value):
        self._services = (value, True)

    @property
    def credentials(self):
        """
        The password of the database user. This must be a PasswordCredential
        instance.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class MySQLServerConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* Configuration
    information for a MySQL server instance.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLServerConfig, self).__init__()
        self._type = ("MySQLServerConfig", True)
        self._credentials = (self.__undef__, True)
        self._data_directory = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLServerConfig, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credentials[0], "PasswordCredential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._data_directory = (data.get("dataDirectory", obj.__undef__), dirty)
        if obj._data_directory[0] is not None and obj._data_directory[0] is not obj.__undef__:
            assert isinstance(obj._data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_directory[0]))
            common.validate_format(obj._data_directory[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLServerConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "data_directory" == "type" or (self.data_directory is not self.__undef__ and not (dirty and not self._data_directory[1])):
            dct["dataDirectory"] = dictify(self.data_directory)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._data_directory = (self._data_directory[0], True)
        self._port = (self._port[0], True)
        self._repository = (self._repository[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._data_directory[1], self._port[1], self._repository[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLServerConfig):
            return False
        return super(MySQLServerConfig, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.data_directory == other.data_directory and \
               self.port == other.port and \
               self.repository == other.repository and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the server instance user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def data_directory(self):
        """
        The data directory for the MySQL server instance.

        :rtype: ``basestring``
        """
        return self._data_directory[0]

    @data_directory.setter
    def data_directory(self, value):
        self._data_directory = (value, True)

    @property
    def port(self):
        """
        The port on which the MySQL server instance is listening.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def user(self):
        """
        The username of the server instance user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class VMwareMachineConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* VM configuration for
    VMware virtual machines.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareMachineConfig, self).__init__()
        self._type = ("VMwareMachineConfig", True)
        self._name = (self.__undef__, True)
        self._repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareMachineConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareMachineConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._name = (self._name[0], True)
        self._repository = (self._repository[0], True)

    def is_dirty(self):
        return any([self._name[1], self._repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareMachineConfig):
            return False
        return super(VMwareMachineConfig, self).__eq__(other) and \
               self.name == other.name and \
               self.repository == other.repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def name(self):
        """
        The name of the config.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def repository(self):
        """
        The object reference of the compute resource.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

class AppDataSourceConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* Base Source config
    for AppDataToolkits.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceConfig, self).__init__()
        self._type = ("AppDataSourceConfig", True)
        self._parameters = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceConfig, cls).from_dict(data, dirty, undef_enabled)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parameters = (self._parameters[0], True)
        self._name = (self._name[0], True)
        self._repository = (self._repository[0], True)

    def is_dirty(self):
        return any([self._parameters[1], self._name[1], self._repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceConfig):
            return False
        return super(AppDataSourceConfig, self).__eq__(other) and \
               self.parameters == other.parameters and \
               self.name == other.name and \
               self.repository == other.repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parameters(self):
        """
        The list of parameters specified by the source config schema in the
        toolkit. If no schema is specified, this list is empty.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def name(self):
        """
        The name of the config.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

class MSSqlDBConfig(SourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfig` *)* Configuration
    information for a MSSQL Source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDBConfig, self).__init__()
        self._type = ("MSSqlDBConfig", True)
        self._credentials = (self.__undef__, True)
        self._database_name = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._recovery_model = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDBConfig, cls).from_dict(data, dirty, undef_enabled)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 128)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, 256)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._recovery_model = (data.get("recoveryModel", obj.__undef__), dirty)
        if obj._recovery_model[0] is not None and obj._recovery_model[0] is not obj.__undef__:
            assert isinstance(obj._recovery_model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._recovery_model[0]))
            assert obj._recovery_model[0] in [u'FULL', u'SIMPLE', u'BULK_LOGGED', u'UNKNOWN'], "Expected enum [u'FULL', u'SIMPLE', u'BULK_LOGGED', u'UNKNOWN'] but got %s" % obj._recovery_model[0]
            common.validate_format(obj._recovery_model[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "recovery_model" == "type" or (self.recovery_model is not self.__undef__ and not (dirty and not self._recovery_model[1])):
            dct["recoveryModel"] = dictify(self.recovery_model)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credentials = (self._credentials[0], True)
        self._database_name = (self._database_name[0], True)
        self._user = (self._user[0], True)
        self._repository = (self._repository[0], True)
        self._recovery_model = (self._recovery_model[0], True)

    def is_dirty(self):
        return any([self._credentials[1], self._database_name[1], self._user[1], self._repository[1], self._recovery_model[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDBConfig):
            return False
        return super(MSSqlDBConfig, self).__eq__(other) and \
               self.credentials == other.credentials and \
               self.database_name == other.database_name and \
               self.user == other.user and \
               self.repository == other.repository and \
               self.recovery_model == other.recovery_model

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credentials(self):
        """
        The password of the database user.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

    @property
    def user(self):
        """
        The username of the database user.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def recovery_model(self):
        """
        *(default value: SIMPLE)* Specifies the current recovery model of the
        source database. *(permitted values: FULL, SIMPLE, BULK_LOGGED,
        UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._recovery_model[0]

    @recovery_model.setter
    def recovery_model(self, value):
        self._recovery_model = (value, True)

class MSSqlSIConfig(MSSqlDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlDBConfig` *)* Configuration
    information for a single instance MSSQL Source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSIConfig, self).__init__()
        self._type = ("MSSqlSIConfig", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSIConfig, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSIConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSIConfig):
            return False
        return super(MSSqlSIConfig, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlFailoverClusterDBConfig(MSSqlDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlDBConfig` *)* Database for a SQL
    Server Failover Cluster.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlFailoverClusterDBConfig, self).__init__()
        self._type = ("MSSqlFailoverClusterDBConfig", True)
        self._drive_letter = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlFailoverClusterDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._drive_letter = (data.get("driveLetter", obj.__undef__), dirty)
        if obj._drive_letter[0] is not None and obj._drive_letter[0] is not obj.__undef__:
            assert isinstance(obj._drive_letter[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._drive_letter[0]))
            common.validate_format(obj._drive_letter[0], "None", 1, 1)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlFailoverClusterDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "drive_letter" == "type" or (self.drive_letter is not self.__undef__ and not (dirty and not self._drive_letter[1])):
            dct["driveLetter"] = dictify(self.drive_letter)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._drive_letter = (self._drive_letter[0], True)

    def is_dirty(self):
        return any([self._drive_letter[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlFailoverClusterDBConfig):
            return False
        return super(MSSqlFailoverClusterDBConfig, self).__eq__(other) and \
               self.drive_letter == other.drive_letter

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def drive_letter(self):
        """
        Base drive letter location for mount points.

        :rtype: ``basestring``
        """
        return self._drive_letter[0]

    @drive_letter.setter
    def drive_letter(self, value):
        self._drive_letter = (value, True)

class MSSqlAvailabilityGroupDBConfig(MSSqlDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlDBConfig` *)* Database for a SQL
    Server Availability Group.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlAvailabilityGroupDBConfig, self).__init__()
        self._type = ("MSSqlAvailabilityGroupDBConfig", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlAvailabilityGroupDBConfig, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlAvailabilityGroupDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlAvailabilityGroupDBConfig):
            return False
        return super(MSSqlAvailabilityGroupDBConfig, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataStagedSourceConfig(AppDataSourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataSourceConfig` *)* An AppData
    source config with a staging source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataStagedSourceConfig, self).__init__()
        self._type = ("AppDataStagedSourceConfig", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataStagedSourceConfig, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataStagedSourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataStagedSourceConfig):
            return False
        return super(AppDataStagedSourceConfig, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataDirectSourceConfig(AppDataSourceConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataSourceConfig` *)* Source config
    for directly linked AppData sources.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataDirectSourceConfig, self).__init__()
        self._type = ("AppDataDirectSourceConfig", True)
        self._path = (self.__undef__, True)
        self._restoration = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataDirectSourceConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._path = (data.get("path", obj.__undef__), dirty)
        if obj._path[0] is not None and obj._path[0] is not obj.__undef__:
            assert isinstance(obj._path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._path[0]))
            common.validate_format(obj._path[0], "None", None, 1024)
        obj._restoration = (data.get("restoration", obj.__undef__), dirty)
        if obj._restoration[0] is not None and obj._restoration[0] is not obj.__undef__:
            assert isinstance(obj._restoration[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._restoration[0]))
            common.validate_format(obj._restoration[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataDirectSourceConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "path" == "type" or (self.path is not self.__undef__ and not (dirty and not self._path[1])):
            dct["path"] = dictify(self.path)
        if "restoration" == "type" or (self.restoration is not self.__undef__ and not (dirty and not self._restoration[1])):
            dct["restoration"] = dictify(self.restoration)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._path = (self._path[0], True)
        self._restoration = (self._restoration[0], True)

    def is_dirty(self):
        return any([self._path[1], self._restoration[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataDirectSourceConfig):
            return False
        return super(AppDataDirectSourceConfig, self).__eq__(other) and \
               self.path == other.path and \
               self.restoration == other.restoration

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def path(self):
        """
        The path to the data to be synced.

        :rtype: ``basestring``
        """
        return self._path[0]

    @path.setter
    def path(self, value):
        self._path = (value, True)

    @property
    def restoration(self):
        """
        True if this source config is part of a restoration dataset.

        :rtype: ``bool``
        """
        return self._restoration[0]

    @restoration.setter
    def restoration(self, value):
        self._restoration = (value, True)

class OraclePDBConfig(OracleBaseDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseDBConfig` *)* Representation
    of properties for an Oracle pluggable database configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OraclePDBConfig, self).__init__()
        self._type = ("OraclePDBConfig", True)
        self._cdb_config = (self.__undef__, True)
        self._database_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OraclePDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._cdb_config = (data.get("cdbConfig", obj.__undef__), dirty)
        if obj._cdb_config[0] is not None and obj._cdb_config[0] is not obj.__undef__:
            assert isinstance(obj._cdb_config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cdb_config[0]))
            common.validate_format(obj._cdb_config[0], "objectReference", None, None)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 30)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OraclePDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cdb_config" == "type" or (self.cdb_config is not self.__undef__ and not (dirty and not self._cdb_config[1])):
            dct["cdbConfig"] = dictify(self.cdb_config)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cdb_config = (self._cdb_config[0], True)
        self._database_name = (self._database_name[0], True)

    def is_dirty(self):
        return any([self._cdb_config[1], self._database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OraclePDBConfig):
            return False
        return super(OraclePDBConfig, self).__eq__(other) and \
               self.cdb_config == other.cdb_config and \
               self.database_name == other.database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cdb_config(self):
        """
        The DB config of an Oracle multitenant database this pluggable database
        belongs to.

        :rtype: ``basestring``
        """
        return self._cdb_config[0]

    @cdb_config.setter
    def cdb_config(self, value):
        self._cdb_config = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

class OracleDBConfig(OracleBaseDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseDBConfig` *)* The source
    config represents the dynamically discovered attributes of an Oracle
    source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDBConfig, self).__init__()
        self._type = ("OracleDBConfig", True)
        self._unique_name = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._non_sys_credentials = (self.__undef__, True)
        self._non_sys_user = (self.__undef__, True)
        self._database_name = (self.__undef__, True)
        self._cdb_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDBConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._unique_name = (data.get("uniqueName", obj.__undef__), dirty)
        if obj._unique_name[0] is not None and obj._unique_name[0] is not obj.__undef__:
            assert isinstance(obj._unique_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._unique_name[0]))
            common.validate_format(obj._unique_name[0], "None", None, 30)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        if "nonSysCredentials" in data and data["nonSysCredentials"] is not None:
            obj._non_sys_credentials = (factory.create_object(data["nonSysCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._non_sys_credentials[0], "PasswordCredential")
        else:
            obj._non_sys_credentials = (obj.__undef__, dirty)
        obj._non_sys_user = (data.get("nonSysUser", obj.__undef__), dirty)
        if obj._non_sys_user[0] is not None and obj._non_sys_user[0] is not obj.__undef__:
            assert isinstance(obj._non_sys_user[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._non_sys_user[0]))
            common.validate_format(obj._non_sys_user[0], "None", None, 30)
        obj._database_name = (data.get("databaseName", obj.__undef__), dirty)
        if obj._database_name[0] is not None and obj._database_name[0] is not obj.__undef__:
            assert isinstance(obj._database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_name[0]))
            common.validate_format(obj._database_name[0], "None", None, 8)
        obj._cdb_type = (data.get("cdbType", obj.__undef__), dirty)
        if obj._cdb_type[0] is not None and obj._cdb_type[0] is not obj.__undef__:
            assert isinstance(obj._cdb_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cdb_type[0]))
            assert obj._cdb_type[0] in [u'UNKNOWN', u'ROOT_CDB', u'NON_CDB', u'AUX_CDB'], "Expected enum [u'UNKNOWN', u'ROOT_CDB', u'NON_CDB', u'AUX_CDB'] but got %s" % obj._cdb_type[0]
            common.validate_format(obj._cdb_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDBConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "unique_name" == "type" or (self.unique_name is not self.__undef__ and not (dirty and not self._unique_name[1])):
            dct["uniqueName"] = dictify(self.unique_name)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "non_sys_credentials" == "type" or (self.non_sys_credentials is not self.__undef__ and not (dirty and not self._non_sys_credentials[1])):
            dct["nonSysCredentials"] = dictify(self.non_sys_credentials)
        if "non_sys_user" == "type" or (self.non_sys_user is not self.__undef__ and not (dirty and not self._non_sys_user[1])):
            dct["nonSysUser"] = dictify(self.non_sys_user)
        if "database_name" == "type" or (self.database_name is not self.__undef__ and not (dirty and not self._database_name[1])):
            dct["databaseName"] = dictify(self.database_name)
        if "cdb_type" == "type" or (self.cdb_type is not self.__undef__ and not (dirty and not self._cdb_type[1])):
            dct["cdbType"] = dictify(self.cdb_type)
        if dirty and "cdbType" in dct:
            del dct["cdbType"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._unique_name = (self._unique_name[0], True)
        self._repository = (self._repository[0], True)
        self._non_sys_credentials = (self._non_sys_credentials[0], True)
        self._non_sys_user = (self._non_sys_user[0], True)
        self._database_name = (self._database_name[0], True)
        self._cdb_type = (self._cdb_type[0], True)

    def is_dirty(self):
        return any([self._unique_name[1], self._repository[1], self._non_sys_credentials[1], self._non_sys_user[1], self._database_name[1], self._cdb_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDBConfig):
            return False
        return super(OracleDBConfig, self).__eq__(other) and \
               self.unique_name == other.unique_name and \
               self.repository == other.repository and \
               self.non_sys_credentials == other.non_sys_credentials and \
               self.non_sys_user == other.non_sys_user and \
               self.database_name == other.database_name and \
               self.cdb_type == other.cdb_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def unique_name(self):
        """
        The unique name.

        :rtype: ``basestring``
        """
        return self._unique_name[0]

    @unique_name.setter
    def unique_name(self, value):
        self._unique_name = (value, True)

    @property
    def repository(self):
        """
        The object reference of the source repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def non_sys_credentials(self):
        """
        The password of a database user that does not have administrative
        privileges.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._non_sys_credentials[0]

    @non_sys_credentials.setter
    def non_sys_credentials(self, value):
        self._non_sys_credentials = (value, True)

    @property
    def non_sys_user(self):
        """
        The username of a database user that does not have administrative
        privileges.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._non_sys_user[0]

    @non_sys_user.setter
    def non_sys_user(self, value):
        self._non_sys_user = (value, True)

    @property
    def database_name(self):
        """
        The name of the database.

        :rtype: ``basestring``
        """
        return self._database_name[0]

    @database_name.setter
    def database_name(self, value):
        self._database_name = (value, True)

    @property
    def cdb_type(self):
        """
        The container type of this database. *(permitted values: UNKNOWN,
        ROOT_CDB, NON_CDB, AUX_CDB)*

        :rtype: ``basestring``
        """
        return self._cdb_type[0]

class OracleSIConfig(OracleDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDBConfig` *)* The representation
    of a single-instance Oracle DB configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSIConfig, self).__init__()
        self._type = ("OracleSIConfig", True)
        self._instance = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSIConfig, cls).from_dict(data, dirty, undef_enabled)
        if "instance" in data and data["instance"] is not None:
            obj._instance = (factory.create_object(data["instance"], "OracleInstance"), dirty)
            factory.validate_type(obj._instance[0], "OracleInstance")
        else:
            obj._instance = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSIConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance" == "type" or (self.instance is not self.__undef__ and not (dirty and not self._instance[1])):
            dct["instance"] = dictify(self.instance)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance = (self._instance[0], True)

    def is_dirty(self):
        return any([self._instance[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSIConfig):
            return False
        return super(OracleSIConfig, self).__eq__(other) and \
               self.instance == other.instance

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance(self):
        """
        The Oracle instance.

        :rtype: :py:class:`v1_8_1.web.vo.OracleInstance`
        """
        return self._instance[0]

    @instance.setter
    def instance(self, value):
        self._instance = (value, True)

class OracleRACConfig(OracleDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDBConfig` *)* Representation of
    the properties specific to a RAC Oracle DB configuration.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRACConfig, self).__init__()
        self._type = ("OracleRACConfig", True)
        self._instances = (self.__undef__, True)
        self._crs_database_name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRACConfig, cls).from_dict(data, dirty, undef_enabled)
        obj._instances = []
        for item in data.get("instances") or []:
            obj._instances.append(factory.create_object(item))
            factory.validate_type(obj._instances[-1], "OracleRACInstance")
        obj._instances = (obj._instances, dirty)
        obj._crs_database_name = (data.get("crsDatabaseName", obj.__undef__), dirty)
        if obj._crs_database_name[0] is not None and obj._crs_database_name[0] is not obj.__undef__:
            assert isinstance(obj._crs_database_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crs_database_name[0]))
            common.validate_format(obj._crs_database_name[0], "None", None, 30)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRACConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instances" == "type" or (self.instances is not self.__undef__ and not (dirty and not self._instances[1])):
            dct["instances"] = dictify(self.instances)
        if "crs_database_name" == "type" or (self.crs_database_name is not self.__undef__ and not (dirty and not self._crs_database_name[1])):
            dct["crsDatabaseName"] = dictify(self.crs_database_name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instances = (self._instances[0], True)
        self._crs_database_name = (self._crs_database_name[0], True)

    def is_dirty(self):
        return any([self._instances[1], self._crs_database_name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRACConfig):
            return False
        return super(OracleRACConfig, self).__eq__(other) and \
               self.instances == other.instances and \
               self.crs_database_name == other.crs_database_name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instances(self):
        """
        The list of RAC instances for this RAC configuration.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleRACInstance`
        """
        return self._instances[0]

    @instances.setter
    def instances(self, value):
        self._instances = (value, True)

    @property
    def crs_database_name(self):
        """
        The Oracle Clusterware database name.

        :rtype: ``basestring``
        """
        return self._crs_database_name[0]

    @crs_database_name.setter
    def crs_database_name(self, value):
        self._crs_database_name = (value, True)

class ASESIConfig(ASEDBConfig):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASEDBConfig` *)* A SAP ASE single
    instance database config.
    """
    def __init__(self, undef_enabled=True):
        super(ASESIConfig, self).__init__()
        self._type = ("ASESIConfig", True)
        self._instance = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESIConfig, cls).from_dict(data, dirty, undef_enabled)
        if "instance" in data and data["instance"] is not None:
            obj._instance = (factory.create_object(data["instance"], "ASEInstanceConfig"), dirty)
            factory.validate_type(obj._instance[0], "ASEInstanceConfig")
        else:
            obj._instance = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESIConfig, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "instance" == "type" or (self.instance is not self.__undef__ and not (dirty and not self._instance[1])):
            dct["instance"] = dictify(self.instance)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._instance = (self._instance[0], True)

    def is_dirty(self):
        return any([self._instance[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESIConfig):
            return False
        return super(ASESIConfig, self).__eq__(other) and \
               self.instance == other.instance

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def instance(self):
        """
        The SAP ASE instance.

        :rtype: :py:class:`v1_8_1.web.vo.ASEInstanceConfig`
        """
        return self._instance[0]

    @instance.setter
    def instance(self, value):
        self._instance = (value, True)

class PgSQLSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* A PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSource, self).__init__()
        self._type = ("PgSQLSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "PgSQLSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "PgSQLSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSource):
            return False
        return super(PgSQLSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class OracleSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* An Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSource, self).__init__()
        self._type = ("OracleSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleBaseSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleBaseSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSource):
            return False
        return super(OracleSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties for this Oracle source.

        :rtype: :py:class:`v1_8_1.web.vo.OracleBaseSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class MSSqlSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* A MSSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSource, self).__init__()
        self._type = ("MSSqlSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MSSqlSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MSSqlSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSource):
            return False
        return super(MSSqlSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class ASESource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* A SAP ASE source.
    """
    def __init__(self, undef_enabled=True):
        super(ASESource, self).__init__()
        self._type = ("ASESource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ASESourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ASESourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESource):
            return False
        return super(ASESource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.ASESourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class MySQLSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* A MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSource, self).__init__()
        self._type = ("MySQLSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MySQLSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MySQLSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSource):
            return False
        return super(MySQLSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class VMwareSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* A VMware source.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareSource, self).__init__()
        self._type = ("VMwareSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "VMwareSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "VMwareSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareSource):
            return False
        return super(VMwareSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class AppDataSource(Source):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Source` *)* An AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSource, self).__init__()
        self._type = ("AppDataSource", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSource, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "AppDataSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "AppDataSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSource):
            return False
        return super(AppDataSource, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class AppDataLinkedSource(AppDataSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataSource` *)* Base AppData linked
    source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkedSource, self).__init__()
        self._type = ("AppDataLinkedSource", True)
        self._operations = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._config = (self._config[0], True)
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._config[1], self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkedSource):
            return False
        return super(AppDataLinkedSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.config == other.config and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def parameters(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class AppDataManagedSource(AppDataSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataSource` *)* An AppData source
    managed by Delphix.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataManagedSource, self).__init__()
        self._type = ("AppDataManagedSource", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataManagedSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataManagedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataManagedSource):
            return False
        return super(AppDataManagedSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataRestorationSource(AppDataManagedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataManagedSource` *)* A restoration
    AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataRestorationSource, self).__init__()
        self._type = ("AppDataRestorationSource", True)
        self._additional_mount_points = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataRestorationSource, cls).from_dict(data, dirty, undef_enabled)
        obj._additional_mount_points = []
        for item in data.get("additionalMountPoints") or []:
            obj._additional_mount_points.append(factory.create_object(item))
            factory.validate_type(obj._additional_mount_points[-1], "AppDataAdditionalMountPoint")
        obj._additional_mount_points = (obj._additional_mount_points, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataRestorationSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "additional_mount_points" == "type" or (self.additional_mount_points is not self.__undef__ and not (dirty and not self._additional_mount_points[1])):
            dct["additionalMountPoints"] = dictify(self.additional_mount_points)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._additional_mount_points = (self._additional_mount_points[0], True)

    def is_dirty(self):
        return any([self._additional_mount_points[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataRestorationSource):
            return False
        return super(AppDataRestorationSource, self).__eq__(other) and \
               self.additional_mount_points == other.additional_mount_points

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def additional_mount_points(self):
        """
        Locations to mount subdirectories of the dataset in addition to the
        normal target mount point. These paths will be mounted and unmounted as
        part of enabling and disabling this source.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.AppDataAdditionalMountPoint`
        """
        return self._additional_mount_points[0]

    @additional_mount_points.setter
    def additional_mount_points(self, value):
        self._additional_mount_points = (value, True)

class AppDataVirtualSource(AppDataManagedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataManagedSource` *)* A virtual
    AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataVirtualSource, self).__init__()
        self._type = ("AppDataVirtualSource", True)
        self._operations = (self.__undef__, True)
        self._additional_mount_points = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._additional_mount_points = []
        for item in data.get("additionalMountPoints") or []:
            obj._additional_mount_points.append(factory.create_object(item))
            factory.validate_type(obj._additional_mount_points[-1], "AppDataAdditionalMountPoint")
        obj._additional_mount_points = (obj._additional_mount_points, dirty)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        if "parameters" in data and data["parameters"] is not None:
            obj._parameters = (data["parameters"], dirty)
        else:
            obj._parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "additional_mount_points" == "type" or (self.additional_mount_points is not self.__undef__ and not (dirty and not self._additional_mount_points[1])):
            dct["additionalMountPoints"] = dictify(self.additional_mount_points)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._additional_mount_points = (self._additional_mount_points[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._parameters = (self._parameters[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._additional_mount_points[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataVirtualSource):
            return False
        return super(AppDataVirtualSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.additional_mount_points == other.additional_mount_points and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.parameters == other.parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def additional_mount_points(self):
        """
        Locations to mount subdirectories of the AppData in addition to the
        normal target mount point. These paths will be mounted and unmounted as
        part of enabling and disabling this source.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.AppDataAdditionalMountPoint`
        """
        return self._additional_mount_points[0]

    @additional_mount_points.setter
    def additional_mount_points(self, value):
        self._additional_mount_points = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def parameters(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

class AppDataLinkedDirectSource(AppDataLinkedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataLinkedSource` *)* An AppData
    linked source directly replicated into the Delphix Engine.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkedDirectSource, self).__init__()
        self._type = ("AppDataLinkedDirectSource", True)
        self._excludes = (self.__undef__, True)
        self._follow_symlinks = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkedDirectSource, cls).from_dict(data, dirty, undef_enabled)
        obj._excludes = []
        for item in data.get("excludes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._excludes.append(item)
        obj._excludes = (obj._excludes, dirty)
        obj._follow_symlinks = []
        for item in data.get("followSymlinks") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._follow_symlinks.append(item)
        obj._follow_symlinks = (obj._follow_symlinks, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkedDirectSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "excludes" == "type" or (self.excludes is not self.__undef__ and not (dirty and not self._excludes[1])):
            dct["excludes"] = dictify(self.excludes)
        if "follow_symlinks" == "type" or (self.follow_symlinks is not self.__undef__ and not (dirty and not self._follow_symlinks[1])):
            dct["followSymlinks"] = dictify(self.follow_symlinks)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._excludes = (self._excludes[0], True)
        self._follow_symlinks = (self._follow_symlinks[0], True)

    def is_dirty(self):
        return any([self._excludes[1], self._follow_symlinks[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkedDirectSource):
            return False
        return super(AppDataLinkedDirectSource, self).__eq__(other) and \
               self.excludes == other.excludes and \
               self.follow_symlinks == other.follow_symlinks

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def excludes(self):
        """
        List of subdirectories in the source to exclude when syncing data.
        These paths are relative to the root of the source directory.

        :rtype: ``list`` of ``basestring``
        """
        return self._excludes[0]

    @excludes.setter
    def excludes(self, value):
        self._excludes = (value, True)

    @property
    def follow_symlinks(self):
        """
        List of symlinks in the source to follow when syncing data. These paths
        are relative to the root of the source directory. All other symlinks
        are preserved.

        :rtype: ``list`` of ``basestring``
        """
        return self._follow_symlinks[0]

    @follow_symlinks.setter
    def follow_symlinks(self, value):
        self._follow_symlinks = (value, True)

class AppDataLinkedStagedSource(AppDataLinkedSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataLinkedSource` *)* An AppData
    linked source with a staging source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataLinkedStagedSource, self).__init__()
        self._type = ("AppDataLinkedStagedSource", True)
        self._staging_environment = (self.__undef__, True)
        self._staging_mount_base = (self.__undef__, True)
        self._staging_environment_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataLinkedStagedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._staging_environment = (data.get("stagingEnvironment", obj.__undef__), dirty)
        if obj._staging_environment[0] is not None and obj._staging_environment[0] is not obj.__undef__:
            assert isinstance(obj._staging_environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_environment[0]))
            common.validate_format(obj._staging_environment[0], "objectReference", None, None)
        obj._staging_mount_base = (data.get("stagingMountBase", obj.__undef__), dirty)
        if obj._staging_mount_base[0] is not None and obj._staging_mount_base[0] is not obj.__undef__:
            assert isinstance(obj._staging_mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_mount_base[0]))
            common.validate_format(obj._staging_mount_base[0], "None", None, 256)
        obj._staging_environment_user = (data.get("stagingEnvironmentUser", obj.__undef__), dirty)
        if obj._staging_environment_user[0] is not None and obj._staging_environment_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_environment_user[0]))
            common.validate_format(obj._staging_environment_user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataLinkedStagedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "staging_environment" == "type" or (self.staging_environment is not self.__undef__ and not (dirty and not self._staging_environment[1])):
            dct["stagingEnvironment"] = dictify(self.staging_environment)
        if "staging_mount_base" == "type" or (self.staging_mount_base is not self.__undef__ and not (dirty and not self._staging_mount_base[1])):
            dct["stagingMountBase"] = dictify(self.staging_mount_base)
        if "staging_environment_user" == "type" or (self.staging_environment_user is not self.__undef__ and not (dirty and not self._staging_environment_user[1])):
            dct["stagingEnvironmentUser"] = dictify(self.staging_environment_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._staging_environment = (self._staging_environment[0], True)
        self._staging_mount_base = (self._staging_mount_base[0], True)
        self._staging_environment_user = (self._staging_environment_user[0], True)

    def is_dirty(self):
        return any([self._staging_environment[1], self._staging_mount_base[1], self._staging_environment_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataLinkedStagedSource):
            return False
        return super(AppDataLinkedStagedSource, self).__eq__(other) and \
               self.staging_environment == other.staging_environment and \
               self.staging_mount_base == other.staging_mount_base and \
               self.staging_environment_user == other.staging_environment_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def staging_environment(self):
        """
        The environment used as an intermediate stage to pull data into
        Delphix.

        :rtype: ``basestring``
        """
        return self._staging_environment[0]

    @staging_environment.setter
    def staging_environment(self, value):
        self._staging_environment = (value, True)

    @property
    def staging_mount_base(self):
        """
        The base mount point for the NFS mount on the staging environment.

        :rtype: ``basestring``
        """
        return self._staging_mount_base[0]

    @staging_mount_base.setter
    def staging_mount_base(self, value):
        self._staging_mount_base = (value, True)

    @property
    def staging_environment_user(self):
        """
        The environment user used to access the staging environment.

        :rtype: ``basestring``
        """
        return self._staging_environment_user[0]

    @staging_environment_user.setter
    def staging_environment_user(self, value):
        self._staging_environment_user = (value, True)

class VMwareVirtualSource(VMwareSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.VMwareSource` *)* A virtual VMware
    source.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareVirtualSource, self).__init__()
        self._type = ("VMwareVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "VMwareSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "VMwareSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareVirtualSource):
            return False
        return super(VMwareVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        VMX configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class VMwareLinkedSource(VMwareSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.VMwareSource` *)* A VMware linked
    source.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareLinkedSource, self).__init__()
        self._type = ("VMwareLinkedSource", True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareLinkedSource):
            return False
        return super(VMwareLinkedSource, self).__eq__(other) and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class MySQLVirtualSource(MySQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLSource` *)* A virtual MySQL
    source.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLVirtualSource, self).__init__()
        self._type = ("MySQLVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._operations = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._operations = (self._operations[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._mount_base[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._file_mapping_rules[1], self._operations[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLVirtualSource):
            return False
        return super(MySQLVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.mount_base == other.mount_base and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.operations == other.operations

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MySQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def mount_base(self):
        """
        The base mount point for the NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

class MySQLLinkedSource(MySQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLSource` *)* A linked MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLLinkedSource, self).__init__()
        self._type = ("MySQLLinkedSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MySQLSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MySQLSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._runtime = (self._runtime[0], True)
        self._config = (self._config[0], True)
        self._staging_source = (self._staging_source[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._runtime[1], self._config[1], self._staging_source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLLinkedSource):
            return False
        return super(MySQLLinkedSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.runtime == other.runtime and \
               self.config == other.config and \
               self.staging_source == other.staging_source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MySQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for validated sync of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

class MySQLStagingSource(MySQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLSource` *)* A MySQL staging source
    used for validated sync.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLStagingSource, self).__init__()
        self._type = ("MySQLStagingSource", True)
        self._mount_base = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._post_script = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, None)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MySQLSourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MySQLSourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._post_script = (self._post_script[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._mount_base[1], self._pre_script[1], self._post_script[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLStagingSource):
            return False
        return super(MySQLStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base and \
               self.pre_script == other.pre_script and \
               self.post_script == other.post_script and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mount point for the NFS mounts on the staging host.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided script to run prior to taking a snapshot.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def post_script(self):
        """
        A user-provided script to run after taking a snapshot.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLSourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class ASEVirtualSource(ASESource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESource` *)* A virtual SAP ASE
    source.
    """
    def __init__(self, undef_enabled=True):
        super(ASEVirtualSource, self).__init__()
        self._type = ("ASEVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, 4096)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ASESourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ASESourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._file_mapping_rules[1], self._mount_base[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEVirtualSource):
            return False
        return super(ASEVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        SAP ASE database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mount point for the NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.ASESourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class ASELinkedSource(ASESource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESource` *)* A linked SAP ASE source.
    """
    def __init__(self, undef_enabled=True):
        super(ASELinkedSource, self).__init__()
        self._type = ("ASELinkedSource", True)
        self._operations = (self.__undef__, True)
        self._load_backup_path = (self.__undef__, True)
        self._load_location = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._dump_credentials = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASELinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._load_backup_path = (data.get("loadBackupPath", obj.__undef__), dirty)
        if obj._load_backup_path[0] is not None and obj._load_backup_path[0] is not obj.__undef__:
            assert isinstance(obj._load_backup_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._load_backup_path[0]))
            common.validate_format(obj._load_backup_path[0], "None", None, 1024)
        if "loadLocation" in data and data["loadLocation"] is not None:
            obj._load_location = (factory.create_object(data["loadLocation"], "ASEBackupLocation"), dirty)
            factory.validate_type(obj._load_location[0], "ASEBackupLocation")
        else:
            obj._load_location = (obj.__undef__, dirty)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'ENABLED', u'DISABLED'], "Expected enum [u'ENABLED', u'DISABLED'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ASESourceRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ASESourceRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "dumpCredentials" in data and data["dumpCredentials"] is not None:
            obj._dump_credentials = (factory.create_object(data["dumpCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._dump_credentials[0], "PasswordCredential")
        else:
            obj._dump_credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASELinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "load_backup_path" == "type" or (self.load_backup_path is not self.__undef__ and not (dirty and not self._load_backup_path[1])):
            dct["loadBackupPath"] = dictify(self.load_backup_path)
        if "load_location" == "type" or (self.load_location is not self.__undef__ and not (dirty and not self._load_location[1])):
            dct["loadLocation"] = dictify(self.load_location)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "dump_credentials" == "type" or (self.dump_credentials is not self.__undef__ and not (dirty and not self._dump_credentials[1])):
            dct["dumpCredentials"] = dictify(self.dump_credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._load_backup_path = (self._load_backup_path[0], True)
        self._load_location = (self._load_location[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._staging_source = (self._staging_source[0], True)
        self._runtime = (self._runtime[0], True)
        self._config = (self._config[0], True)
        self._dump_credentials = (self._dump_credentials[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._load_backup_path[1], self._load_location[1], self._external_file_path[1], self._validated_sync_mode[1], self._staging_source[1], self._runtime[1], self._config[1], self._dump_credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASELinkedSource):
            return False
        return super(ASELinkedSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.load_backup_path == other.load_backup_path and \
               self.load_location == other.load_location and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.staging_source == other.staging_source and \
               self.runtime == other.runtime and \
               self.config == other.config and \
               self.dump_credentials == other.dump_credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def load_backup_path(self):
        """
        Source database backup location.

        :rtype: ``basestring``
        """
        return self._load_backup_path[0]

    @load_backup_path.setter
    def load_backup_path(self, value):
        self._load_backup_path = (value, True)

    @property
    def load_location(self):
        """
        Backup location to use for loading backups from the source.

        :rtype: :py:class:`v1_8_1.web.vo.ASEBackupLocation`
        """
        return self._load_location[0]

    @load_location.setter
    def load_location(self, value):
        self._load_location = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: ENABLED)* Specifies the validated sync mode to
        synchronize the dSource with the source database. *(permitted values:
        ENABLED, DISABLED)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for validated sync of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this source.

        :rtype: :py:class:`v1_8_1.web.vo.ASESourceRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def dump_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._dump_credentials[0]

    @dump_credentials.setter
    def dump_credentials(self, value):
        self._dump_credentials = (value, True)

class ASEStagingSource(ASESource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESource` *)* An SAP ASE staging
    source used for validated sync..
    """
    def __init__(self, undef_enabled=True):
        super(ASEStagingSource, self).__init__()
        self._type = ("ASEStagingSource", True)
        self._mount_base = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._post_script = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, None)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._post_script = (self._post_script[0], True)

    def is_dirty(self):
        return any([self._mount_base[1], self._pre_script[1], self._post_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEStagingSource):
            return False
        return super(ASEStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base and \
               self.pre_script == other.pre_script and \
               self.post_script == other.post_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mount point for the NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def pre_script(self):
        """
        The path to a user-provided script or executable to run on the staging
        host prior to restoring from a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def post_script(self):
        """
        The path to a user-provided shell script or executable to run on the
        staging host after restoring from a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

class MSSqlVirtualSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlSource` *)* A virtual MSSQL
    source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlVirtualSource, self).__init__()
        self._type = ("MSSqlVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._post_script = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 256)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._post_script = (self._post_script[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._file_mapping_rules[1], self._mount_base[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._pre_script[1], self._post_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlVirtualSource):
            return False
        return super(MSSqlVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.pre_script == other.pre_script and \
               self.post_script == other.post_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MSSQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mount point for the iSCSI LUN mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided PowerShell script or executable to run prior to
        provisioning.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def post_script(self):
        """
        A user-provided PowerShell script or executable to run after
        provisioning.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

class MSSqlLinkedSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlSource` *)* A linked MSSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlLinkedSource, self).__init__()
        self._type = ("MSSqlLinkedSource", True)
        self._operations = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)
        self._backup_location_credentials = (self.__undef__, True)
        self._backup_location_user = (self.__undef__, True)
        self._shared_backup_location = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._encryption_key = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'], "Expected enum [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        if "backupLocationCredentials" in data and data["backupLocationCredentials"] is not None:
            obj._backup_location_credentials = (factory.create_object(data["backupLocationCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._backup_location_credentials[0], "PasswordCredential")
        else:
            obj._backup_location_credentials = (obj.__undef__, dirty)
        obj._backup_location_user = (data.get("backupLocationUser", obj.__undef__), dirty)
        if obj._backup_location_user[0] is not None and obj._backup_location_user[0] is not obj.__undef__:
            assert isinstance(obj._backup_location_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_location_user[0]))
            common.validate_format(obj._backup_location_user[0], "None", None, 256)
        obj._shared_backup_location = (data.get("sharedBackupLocation", obj.__undef__), dirty)
        if obj._shared_backup_location[0] is not None and obj._shared_backup_location[0] is not obj.__undef__:
            assert isinstance(obj._shared_backup_location[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._shared_backup_location[0]))
            common.validate_format(obj._shared_backup_location[0], "None", None, 260)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._encryption_key = (data.get("encryptionKey", obj.__undef__), dirty)
        if obj._encryption_key[0] is not None and obj._encryption_key[0] is not obj.__undef__:
            assert isinstance(obj._encryption_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._encryption_key[0]))
            common.validate_format(obj._encryption_key[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        if "backup_location_credentials" == "type" or (self.backup_location_credentials is not self.__undef__ and not (dirty and not self._backup_location_credentials[1])):
            dct["backupLocationCredentials"] = dictify(self.backup_location_credentials)
        if "backup_location_user" == "type" or (self.backup_location_user is not self.__undef__ and not (dirty and not self._backup_location_user[1])):
            dct["backupLocationUser"] = dictify(self.backup_location_user)
        if "shared_backup_location" == "type" or (self.shared_backup_location is not self.__undef__ and not (dirty and not self._shared_backup_location[1])):
            dct["sharedBackupLocation"] = dictify(self.shared_backup_location)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "encryption_key" == "type" or (self.encryption_key is not self.__undef__ and not (dirty and not self._encryption_key[1])):
            dct["encryptionKey"] = dictify(self.encryption_key)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._staging_source = (self._staging_source[0], True)
        self._backup_location_credentials = (self._backup_location_credentials[0], True)
        self._backup_location_user = (self._backup_location_user[0], True)
        self._shared_backup_location = (self._shared_backup_location[0], True)
        self._config = (self._config[0], True)
        self._encryption_key = (self._encryption_key[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._external_file_path[1], self._validated_sync_mode[1], self._staging_source[1], self._backup_location_credentials[1], self._backup_location_user[1], self._shared_backup_location[1], self._config[1], self._encryption_key[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlLinkedSource):
            return False
        return super(MSSqlLinkedSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.staging_source == other.staging_source and \
               self.backup_location_credentials == other.backup_location_credentials and \
               self.backup_location_user == other.backup_location_user and \
               self.shared_backup_location == other.shared_backup_location and \
               self.config == other.config and \
               self.encryption_key == other.encryption_key

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: TRANSACTION_LOG)* Specifies the backup types validated
        sync will use to synchronize the dSource with the source database.
        *(permitted values: TRANSACTION_LOG, FULL_OR_DIFFERENTIAL, FULL, NONE)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for pre-provisioning of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

    @property
    def backup_location_credentials(self):
        """
        The password for accessing the shared backup location.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._backup_location_credentials[0]

    @backup_location_credentials.setter
    def backup_location_credentials(self, value):
        self._backup_location_credentials = (value, True)

    @property
    def backup_location_user(self):
        """
        The user for accessing the shared backup location.

        :rtype: ``basestring``
        """
        return self._backup_location_user[0]

    @backup_location_user.setter
    def backup_location_user(self, value):
        self._backup_location_user = (value, True)

    @property
    def shared_backup_location(self):
        """
        Shared source database backup location.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._shared_backup_location[0]

    @shared_backup_location.setter
    def shared_backup_location(self, value):
        self._shared_backup_location = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def encryption_key(self):
        """
        The encryption key to use when restoring encrypted backups.

        :rtype: ``basestring``
        """
        return self._encryption_key[0]

    @encryption_key.setter
    def encryption_key(self, value):
        self._encryption_key = (value, True)

class MSSqlStagingSource(MSSqlSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlSource` *)* An MSSQL staging
    source used for pre-provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlStagingSource, self).__init__()
        self._type = ("MSSqlStagingSource", True)
        self._mount_base = (self.__undef__, True)
        self._pre_script = (self.__undef__, True)
        self._post_script = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, None)
        obj._pre_script = (data.get("preScript", obj.__undef__), dirty)
        if obj._pre_script[0] is not None and obj._pre_script[0] is not obj.__undef__:
            assert isinstance(obj._pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pre_script[0]))
            common.validate_format(obj._pre_script[0], "None", None, 1024)
        obj._post_script = (data.get("postScript", obj.__undef__), dirty)
        if obj._post_script[0] is not None and obj._post_script[0] is not obj.__undef__:
            assert isinstance(obj._post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._post_script[0]))
            common.validate_format(obj._post_script[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "pre_script" == "type" or (self.pre_script is not self.__undef__ and not (dirty and not self._pre_script[1])):
            dct["preScript"] = dictify(self.pre_script)
        if "post_script" == "type" or (self.post_script is not self.__undef__ and not (dirty and not self._post_script[1])):
            dct["postScript"] = dictify(self.post_script)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)
        self._pre_script = (self._pre_script[0], True)
        self._post_script = (self._post_script[0], True)

    def is_dirty(self):
        return any([self._mount_base[1], self._pre_script[1], self._post_script[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlStagingSource):
            return False
        return super(MSSqlStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base and \
               self.pre_script == other.pre_script and \
               self.post_script == other.post_script

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mount point for the iSCSI LUN mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def pre_script(self):
        """
        A user-provided PowerShell script or executable to run prior to
        restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._pre_script[0]

    @pre_script.setter
    def pre_script(self, value):
        self._pre_script = (value, True)

    @property
    def post_script(self):
        """
        A user-provided PowerShell script or executable to run after restoring
        from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._post_script[0]

    @post_script.setter
    def post_script(self, value):
        self._post_script = (value, True)

class OracleVirtualSource(OracleSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleSource` *)* A virtual Oracle
    source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleVirtualSource, self).__init__()
        self._type = ("OracleVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._redo_log_groups = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._node_listener_list = (self.__undef__, True)
        self._manual_provisioning = (self.__undef__, True)
        self._archivelog_mode = (self.__undef__, True)
        self._custom_env_vars = (self.__undef__, True)
        self._redo_log_size_in_mb = (self.__undef__, True)
        self._config_template = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._redo_log_groups = (data.get("redoLogGroups", obj.__undef__), dirty)
        if obj._redo_log_groups[0] is not None and obj._redo_log_groups[0] is not obj.__undef__:
            assert isinstance(obj._redo_log_groups[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._redo_log_groups[0]))
            common.validate_format(obj._redo_log_groups[0], "None", None, None)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        obj._node_listener_list = []
        for item in data.get("nodeListenerList") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._node_listener_list.append(item)
        obj._node_listener_list = (obj._node_listener_list, dirty)
        obj._manual_provisioning = (data.get("manualProvisioning", obj.__undef__), dirty)
        if obj._manual_provisioning[0] is not None and obj._manual_provisioning[0] is not obj.__undef__:
            assert isinstance(obj._manual_provisioning[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._manual_provisioning[0]))
            common.validate_format(obj._manual_provisioning[0], "None", None, None)
        obj._archivelog_mode = (data.get("archivelogMode", obj.__undef__), dirty)
        if obj._archivelog_mode[0] is not None and obj._archivelog_mode[0] is not obj.__undef__:
            assert isinstance(obj._archivelog_mode[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._archivelog_mode[0]))
            common.validate_format(obj._archivelog_mode[0], "None", None, None)
        obj._custom_env_vars = []
        for item in data.get("customEnvVars") or []:
            obj._custom_env_vars.append(factory.create_object(item))
            factory.validate_type(obj._custom_env_vars[-1], "OracleCustomEnvVar")
        obj._custom_env_vars = (obj._custom_env_vars, dirty)
        obj._redo_log_size_in_mb = (data.get("redoLogSizeInMB", obj.__undef__), dirty)
        if obj._redo_log_size_in_mb[0] is not None and obj._redo_log_size_in_mb[0] is not obj.__undef__:
            assert isinstance(obj._redo_log_size_in_mb[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._redo_log_size_in_mb[0]))
            common.validate_format(obj._redo_log_size_in_mb[0], "None", None, None)
        obj._config_template = (data.get("configTemplate", obj.__undef__), dirty)
        if obj._config_template[0] is not None and obj._config_template[0] is not obj.__undef__:
            assert isinstance(obj._config_template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config_template[0]))
            common.validate_format(obj._config_template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "redo_log_groups" == "type" or (self.redo_log_groups is not self.__undef__ and not (dirty and not self._redo_log_groups[1])):
            dct["redoLogGroups"] = dictify(self.redo_log_groups)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "node_listener_list" == "type" or (self.node_listener_list is not self.__undef__ and not (dirty and not self._node_listener_list[1])):
            dct["nodeListenerList"] = dictify(self.node_listener_list)
        if "manual_provisioning" == "type" or (self.manual_provisioning is not self.__undef__ and not (dirty and not self._manual_provisioning[1])):
            dct["manualProvisioning"] = dictify(self.manual_provisioning)
        if "archivelog_mode" == "type" or (self.archivelog_mode is not self.__undef__ and not (dirty and not self._archivelog_mode[1])):
            dct["archivelogMode"] = dictify(self.archivelog_mode)
        if "custom_env_vars" == "type" or (self.custom_env_vars is not self.__undef__ and not (dirty and not self._custom_env_vars[1])):
            dct["customEnvVars"] = dictify(self.custom_env_vars)
        if "redo_log_size_in_mb" == "type" or (self.redo_log_size_in_mb is not self.__undef__ and not (dirty and not self._redo_log_size_in_mb[1])):
            dct["redoLogSizeInMB"] = dictify(self.redo_log_size_in_mb)
        if "config_template" == "type" or (self.config_template is not self.__undef__ and not (dirty and not self._config_template[1])):
            dct["configTemplate"] = dictify(self.config_template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._redo_log_groups = (self._redo_log_groups[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._node_listener_list = (self._node_listener_list[0], True)
        self._manual_provisioning = (self._manual_provisioning[0], True)
        self._archivelog_mode = (self._archivelog_mode[0], True)
        self._custom_env_vars = (self._custom_env_vars[0], True)
        self._redo_log_size_in_mb = (self._redo_log_size_in_mb[0], True)
        self._config_template = (self._config_template[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._redo_log_groups[1], self._file_mapping_rules[1], self._mount_base[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._node_listener_list[1], self._manual_provisioning[1], self._archivelog_mode[1], self._custom_env_vars[1], self._redo_log_size_in_mb[1], self._config_template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleVirtualSource):
            return False
        return super(OracleVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.redo_log_groups == other.redo_log_groups and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.node_listener_list == other.node_listener_list and \
               self.manual_provisioning == other.manual_provisioning and \
               self.archivelog_mode == other.archivelog_mode and \
               self.custom_env_vars == other.custom_env_vars and \
               self.redo_log_size_in_mb == other.redo_log_size_in_mb and \
               self.config_template == other.config_template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        Oracle database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def redo_log_groups(self):
        """
        *(default value: 3)* Number of Online Redo Log Groups.

        :rtype: ``int``
        """
        return self._redo_log_groups[0]

    @redo_log_groups.setter
    def redo_log_groups(self, value):
        self._redo_log_groups = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mount point to use for the NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def node_listener_list(self):
        """
        A list of object references of Oracle Node Listeners selected for this
        Virtual Database. Delphix picks one default listener from the target
        environment if this list is empty at virtual database provision time.

        :rtype: ``list`` of ``basestring``
        """
        return self._node_listener_list[0]

    @node_listener_list.setter
    def node_listener_list(self, value):
        self._node_listener_list = (value, True)

    @property
    def manual_provisioning(self):
        """
        Flag indicating whether the database should be provisioned in manual
        mode.

        :rtype: ``bool``
        """
        return self._manual_provisioning[0]

    @manual_provisioning.setter
    def manual_provisioning(self, value):
        self._manual_provisioning = (value, True)

    @property
    def archivelog_mode(self):
        """
        *(default value: True)* Archive Log Mode of the Oracle virtual
        database.

        :rtype: ``bool``
        """
        return self._archivelog_mode[0]

    @archivelog_mode.setter
    def archivelog_mode(self, value):
        self._archivelog_mode = (value, True)

    @property
    def custom_env_vars(self):
        """
        Custom environment variables for Oracle databases.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleCustomEnvVar`
        """
        return self._custom_env_vars[0]

    @custom_env_vars.setter
    def custom_env_vars(self, value):
        self._custom_env_vars = (value, True)

    @property
    def redo_log_size_in_mb(self):
        """
        Online Redo Log size in MB.

        :rtype: ``int``
        """
        return self._redo_log_size_in_mb[0]

    @redo_log_size_in_mb.setter
    def redo_log_size_in_mb(self, value):
        self._redo_log_size_in_mb = (value, True)

    @property
    def config_template(self):
        """
        Optional database template to use for provisioning and refresh. If set,
        configParams will be ignored on provision or refresh.

        :rtype: ``basestring``
        """
        return self._config_template[0]

    @config_template.setter
    def config_template(self, value):
        self._config_template = (value, True)

class OracleLinkedSource(OracleSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleSource` *)* A linked Oracle
    source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLinkedSource, self).__init__()
        self._type = ("OracleLinkedSource", True)
        self._operations = (self.__undef__, True)
        self._number_of_connections = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._files_per_set = (self.__undef__, True)
        self._backup_level_enabled = (self.__undef__, True)
        self._rman_channels = (self.__undef__, True)
        self._encrypted_linking_enabled = (self.__undef__, True)
        self._compressed_linking_enabled = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._check_logical = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._number_of_connections = (data.get("numberOfConnections", obj.__undef__), dirty)
        if obj._number_of_connections[0] is not None and obj._number_of_connections[0] is not obj.__undef__:
            assert isinstance(obj._number_of_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._number_of_connections[0]))
            common.validate_format(obj._number_of_connections[0], "None", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._files_per_set = (data.get("filesPerSet", obj.__undef__), dirty)
        if obj._files_per_set[0] is not None and obj._files_per_set[0] is not obj.__undef__:
            assert isinstance(obj._files_per_set[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._files_per_set[0]))
            common.validate_format(obj._files_per_set[0], "None", None, None)
        obj._backup_level_enabled = (data.get("backupLevelEnabled", obj.__undef__), dirty)
        if obj._backup_level_enabled[0] is not None and obj._backup_level_enabled[0] is not obj.__undef__:
            assert isinstance(obj._backup_level_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._backup_level_enabled[0]))
            common.validate_format(obj._backup_level_enabled[0], "None", None, None)
        obj._rman_channels = (data.get("rmanChannels", obj.__undef__), dirty)
        if obj._rman_channels[0] is not None and obj._rman_channels[0] is not obj.__undef__:
            assert isinstance(obj._rman_channels[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._rman_channels[0]))
            common.validate_format(obj._rman_channels[0], "None", None, None)
        obj._encrypted_linking_enabled = (data.get("encryptedLinkingEnabled", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled[0] is not None and obj._encrypted_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled[0]))
            common.validate_format(obj._encrypted_linking_enabled[0], "None", None, None)
        obj._compressed_linking_enabled = (data.get("compressedLinkingEnabled", obj.__undef__), dirty)
        if obj._compressed_linking_enabled[0] is not None and obj._compressed_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._compressed_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compressed_linking_enabled[0]))
            common.validate_format(obj._compressed_linking_enabled[0], "None", None, None)
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._check_logical = (data.get("checkLogical", obj.__undef__), dirty)
        if obj._check_logical[0] is not None and obj._check_logical[0] is not obj.__undef__:
            assert isinstance(obj._check_logical[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._check_logical[0]))
            common.validate_format(obj._check_logical[0], "None", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "number_of_connections" == "type" or (self.number_of_connections is not self.__undef__ and not (dirty and not self._number_of_connections[1])):
            dct["numberOfConnections"] = dictify(self.number_of_connections)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "files_per_set" == "type" or (self.files_per_set is not self.__undef__ and not (dirty and not self._files_per_set[1])):
            dct["filesPerSet"] = dictify(self.files_per_set)
        if "backup_level_enabled" == "type" or (self.backup_level_enabled is not self.__undef__ and not (dirty and not self._backup_level_enabled[1])):
            dct["backupLevelEnabled"] = dictify(self.backup_level_enabled)
        if "rman_channels" == "type" or (self.rman_channels is not self.__undef__ and not (dirty and not self._rman_channels[1])):
            dct["rmanChannels"] = dictify(self.rman_channels)
        if "encrypted_linking_enabled" == "type" or (self.encrypted_linking_enabled is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled[1])):
            dct["encryptedLinkingEnabled"] = dictify(self.encrypted_linking_enabled)
        if "compressed_linking_enabled" == "type" or (self.compressed_linking_enabled is not self.__undef__ and not (dirty and not self._compressed_linking_enabled[1])):
            dct["compressedLinkingEnabled"] = dictify(self.compressed_linking_enabled)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "check_logical" == "type" or (self.check_logical is not self.__undef__ and not (dirty and not self._check_logical[1])):
            dct["checkLogical"] = dictify(self.check_logical)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._number_of_connections = (self._number_of_connections[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._files_per_set = (self._files_per_set[0], True)
        self._backup_level_enabled = (self._backup_level_enabled[0], True)
        self._rman_channels = (self._rman_channels[0], True)
        self._encrypted_linking_enabled = (self._encrypted_linking_enabled[0], True)
        self._compressed_linking_enabled = (self._compressed_linking_enabled[0], True)
        self._config = (self._config[0], True)
        self._check_logical = (self._check_logical[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._number_of_connections[1], self._external_file_path[1], self._files_per_set[1], self._backup_level_enabled[1], self._rman_channels[1], self._encrypted_linking_enabled[1], self._compressed_linking_enabled[1], self._config[1], self._check_logical[1], self._bandwidth_limit[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLinkedSource):
            return False
        return super(OracleLinkedSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.number_of_connections == other.number_of_connections and \
               self.external_file_path == other.external_file_path and \
               self.files_per_set == other.files_per_set and \
               self.backup_level_enabled == other.backup_level_enabled and \
               self.rman_channels == other.rman_channels and \
               self.encrypted_linking_enabled == other.encrypted_linking_enabled and \
               self.compressed_linking_enabled == other.compressed_linking_enabled and \
               self.config == other.config and \
               self.check_logical == other.check_logical and \
               self.bandwidth_limit == other.bandwidth_limit

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def number_of_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use
        during SnapSync.

        :rtype: ``int``
        """
        return self._number_of_connections[0]

    @number_of_connections.setter
    def number_of_connections(self, value):
        self._number_of_connections = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def files_per_set(self):
        """
        *(default value: 5)* Number of data files to include in each RMAN
        backup set.

        :rtype: ``int``
        """
        return self._files_per_set[0]

    @files_per_set.setter
    def files_per_set(self, value):
        self._files_per_set = (value, True)

    @property
    def backup_level_enabled(self):
        """
        Defines whether backup level is enabled.

        :rtype: ``bool``
        """
        return self._backup_level_enabled[0]

    @backup_level_enabled.setter
    def backup_level_enabled(self, value):
        self._backup_level_enabled = (value, True)

    @property
    def rman_channels(self):
        """
        *(default value: 2)* Number of parallel channels to use.

        :rtype: ``int``
        """
        return self._rman_channels[0]

    @rman_channels.setter
    def rman_channels(self, value):
        self._rman_channels = (value, True)

    @property
    def encrypted_linking_enabled(self):
        """
        True if SnapSync data from the source should be retrieved through an
        encrypted connection. Enabling this feature can decrease the
        performance of SnapSync from the source but has no impact on the
        performance of VDBs created from the retrieved data.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled[0]

    @encrypted_linking_enabled.setter
    def encrypted_linking_enabled(self, value):
        self._encrypted_linking_enabled = (value, True)

    @property
    def compressed_linking_enabled(self):
        """
        *(default value: True)* True if SnapSync data from the source should be
        compressed over the network. Enabling this feature will reduce network
        bandwidth consumption and may significantly improve throughput,
        especially over slow network.

        :rtype: ``bool``
        """
        return self._compressed_linking_enabled[0]

    @compressed_linking_enabled.setter
    def compressed_linking_enabled(self, value):
        self._compressed_linking_enabled = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def check_logical(self):
        """
        True if extended block checking should be used for this linked
        database.

        :rtype: ``bool``
        """
        return self._check_logical[0]

    @check_logical.setter
    def check_logical(self, value):
        self._check_logical = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for SnapSync and LogSync network traffic. A
        value of 0 means no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

class OracleLiveSource(OracleVirtualSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleVirtualSource` *)* An Oracle
    LiveSource.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLiveSource, self).__init__()
        self._type = ("OracleLiveSource", True)
        self._resync_status = (self.__undef__, True)
        self._data_age_warning_threshold = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLiveSource, cls).from_dict(data, dirty, undef_enabled)
        obj._resync_status = (data.get("resyncStatus", obj.__undef__), dirty)
        if obj._resync_status[0] is not None and obj._resync_status[0] is not obj.__undef__:
            assert isinstance(obj._resync_status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._resync_status[0]))
            assert obj._resync_status[0] in [u'RESYNC_NOT_REQUIRED', u'RESYNC_NEEDED', u'RESYNC_IN_PROGRESS', u'APPLY_READY', u'APPLY_IN_PROGRESS', u'APPLY_FAILED'], "Expected enum [u'RESYNC_NOT_REQUIRED', u'RESYNC_NEEDED', u'RESYNC_IN_PROGRESS', u'APPLY_READY', u'APPLY_IN_PROGRESS', u'APPLY_FAILED'] but got %s" % obj._resync_status[0]
            common.validate_format(obj._resync_status[0], "None", None, None)
        obj._data_age_warning_threshold = (data.get("dataAgeWarningThreshold", obj.__undef__), dirty)
        if obj._data_age_warning_threshold[0] is not None and obj._data_age_warning_threshold[0] is not obj.__undef__:
            assert isinstance(obj._data_age_warning_threshold[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._data_age_warning_threshold[0]))
            common.validate_format(obj._data_age_warning_threshold[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLiveSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "resync_status" == "type" or (self.resync_status is not self.__undef__ and not (dirty and not self._resync_status[1])):
            dct["resyncStatus"] = dictify(self.resync_status)
        if "data_age_warning_threshold" == "type" or (self.data_age_warning_threshold is not self.__undef__ and not (dirty and not self._data_age_warning_threshold[1])):
            dct["dataAgeWarningThreshold"] = dictify(self.data_age_warning_threshold)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._resync_status = (self._resync_status[0], True)
        self._data_age_warning_threshold = (self._data_age_warning_threshold[0], True)

    def is_dirty(self):
        return any([self._resync_status[1], self._data_age_warning_threshold[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLiveSource):
            return False
        return super(OracleLiveSource, self).__eq__(other) and \
               self.resync_status == other.resync_status and \
               self.data_age_warning_threshold == other.data_age_warning_threshold

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def resync_status(self):
        """
        Resync status for this Oracle LiveSource. *(permitted values:
        RESYNC_NOT_REQUIRED, RESYNC_NEEDED, RESYNC_IN_PROGRESS, APPLY_READY,
        APPLY_IN_PROGRESS, APPLY_FAILED)*

        :rtype: ``basestring``
        """
        return self._resync_status[0]

    @resync_status.setter
    def resync_status(self, value):
        self._resync_status = (value, True)

    @property
    def data_age_warning_threshold(self):
        """
        *(default value: 900)* Amount of tolerable delay for this Oracle
        LiveSource in seconds.

        :rtype: ``int``
        """
        return self._data_age_warning_threshold[0]

    @data_age_warning_threshold.setter
    def data_age_warning_threshold(self, value):
        self._data_age_warning_threshold = (value, True)

class OracleWarehouseSource(OracleVirtualSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleVirtualSource` *)* A warehouse
    represents a housing that accepts databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleWarehouseSource, self).__init__()
        self._type = ("OracleWarehouseSource", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleWarehouseSource, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleWarehouseSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleWarehouseSource):
            return False
        return super(OracleWarehouseSource, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PgSQLStagingSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PgSQLSource` *)* A PostgreSQL staging
    source used for pre-provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLStagingSource, self).__init__()
        self._type = ("PgSQLStagingSource", True)
        self._mount_base = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLStagingSource, cls).from_dict(data, dirty, undef_enabled)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLStagingSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._mount_base = (self._mount_base[0], True)

    def is_dirty(self):
        return any([self._mount_base[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLStagingSource):
            return False
        return super(PgSQLStagingSource, self).__eq__(other) and \
               self.mount_base == other.mount_base

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def mount_base(self):
        """
        The base mount point for the NFS mounts on the pre-provisioning host.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

class PgSQLVirtualSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PgSQLSource` *)* A virtual PostgreSQL
    source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLVirtualSource, self).__init__()
        self._type = ("PgSQLVirtualSource", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._file_mapping_rules = (self.__undef__, True)
        self._mount_base = (self.__undef__, True)
        self._allow_auto_vdb_restart_on_host_reboot = (self.__undef__, True)
        self._ident_entries = (self.__undef__, True)
        self._hba_entries = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLVirtualSource, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "VirtualSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "VirtualSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._file_mapping_rules = (data.get("fileMappingRules", obj.__undef__), dirty)
        if obj._file_mapping_rules[0] is not None and obj._file_mapping_rules[0] is not obj.__undef__:
            assert isinstance(obj._file_mapping_rules[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._file_mapping_rules[0]))
            common.validate_format(obj._file_mapping_rules[0], "None", None, None)
        obj._mount_base = (data.get("mountBase", obj.__undef__), dirty)
        if obj._mount_base[0] is not None and obj._mount_base[0] is not obj.__undef__:
            assert isinstance(obj._mount_base[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mount_base[0]))
            common.validate_format(obj._mount_base[0], "None", None, 256)
        obj._allow_auto_vdb_restart_on_host_reboot = (data.get("allowAutoVDBRestartOnHostReboot", obj.__undef__), dirty)
        if obj._allow_auto_vdb_restart_on_host_reboot[0] is not None and obj._allow_auto_vdb_restart_on_host_reboot[0] is not obj.__undef__:
            assert isinstance(obj._allow_auto_vdb_restart_on_host_reboot[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_auto_vdb_restart_on_host_reboot[0]))
            common.validate_format(obj._allow_auto_vdb_restart_on_host_reboot[0], "None", None, None)
        obj._ident_entries = []
        for item in data.get("identEntries") or []:
            obj._ident_entries.append(factory.create_object(item))
            factory.validate_type(obj._ident_entries[-1], "PgSQLIdentEntry")
        obj._ident_entries = (obj._ident_entries, dirty)
        obj._hba_entries = []
        for item in data.get("hbaEntries") or []:
            obj._hba_entries.append(factory.create_object(item))
            factory.validate_type(obj._hba_entries[-1], "PgSQLHBAEntry")
        obj._hba_entries = (obj._hba_entries, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLVirtualSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "file_mapping_rules" == "type" or (self.file_mapping_rules is not self.__undef__ and not (dirty and not self._file_mapping_rules[1])):
            dct["fileMappingRules"] = dictify(self.file_mapping_rules)
        if "mount_base" == "type" or (self.mount_base is not self.__undef__ and not (dirty and not self._mount_base[1])):
            dct["mountBase"] = dictify(self.mount_base)
        if "allow_auto_vdb_restart_on_host_reboot" == "type" or (self.allow_auto_vdb_restart_on_host_reboot is not self.__undef__ and not (dirty and not self._allow_auto_vdb_restart_on_host_reboot[1])):
            dct["allowAutoVDBRestartOnHostReboot"] = dictify(self.allow_auto_vdb_restart_on_host_reboot)
        if "ident_entries" == "type" or (self.ident_entries is not self.__undef__ and not (dirty and not self._ident_entries[1])):
            dct["identEntries"] = dictify(self.ident_entries)
        if "hba_entries" == "type" or (self.hba_entries is not self.__undef__ and not (dirty and not self._hba_entries[1])):
            dct["hbaEntries"] = dictify(self.hba_entries)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._file_mapping_rules = (self._file_mapping_rules[0], True)
        self._mount_base = (self._mount_base[0], True)
        self._allow_auto_vdb_restart_on_host_reboot = (self._allow_auto_vdb_restart_on_host_reboot[0], True)
        self._ident_entries = (self._ident_entries[0], True)
        self._hba_entries = (self._hba_entries[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._file_mapping_rules[1], self._mount_base[1], self._allow_auto_vdb_restart_on_host_reboot[1], self._ident_entries[1], self._hba_entries[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLVirtualSource):
            return False
        return super(PgSQLVirtualSource, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.file_mapping_rules == other.file_mapping_rules and \
               self.mount_base == other.mount_base and \
               self.allow_auto_vdb_restart_on_host_reboot == other.allow_auto_vdb_restart_on_host_reboot and \
               self.ident_entries == other.ident_entries and \
               self.hba_entries == other.hba_entries

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        PostgreSQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.VirtualSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def file_mapping_rules(self):
        """
        Database file mapping rules.

        :rtype: ``basestring``
        """
        return self._file_mapping_rules[0]

    @file_mapping_rules.setter
    def file_mapping_rules(self, value):
        self._file_mapping_rules = (value, True)

    @property
    def mount_base(self):
        """
        The base mount point to use for the NFS mounts.

        :rtype: ``basestring``
        """
        return self._mount_base[0]

    @mount_base.setter
    def mount_base(self, value):
        self._mount_base = (value, True)

    @property
    def allow_auto_vdb_restart_on_host_reboot(self):
        """
        Indicates whether Delphix should automatically restart this virtual
        source when target host reboot is detected.

        :rtype: ``bool``
        """
        return self._allow_auto_vdb_restart_on_host_reboot[0]

    @allow_auto_vdb_restart_on_host_reboot.setter
    def allow_auto_vdb_restart_on_host_reboot(self, value):
        self._allow_auto_vdb_restart_on_host_reboot = (value, True)

    @property
    def ident_entries(self):
        """
        Entries in the PostgreSQL username map file (pg_ident.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLIdentEntry`
        """
        return self._ident_entries[0]

    @ident_entries.setter
    def ident_entries(self, value):
        self._ident_entries = (value, True)

    @property
    def hba_entries(self):
        """
        Entries in the PostgreSQL host-based authentication file (pg_hba.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLHBAEntry`
        """
        return self._hba_entries[0]

    @hba_entries.setter
    def hba_entries(self, value):
        self._hba_entries = (value, True)

class PgSQLLinkedSource(PgSQLSource):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PgSQLSource` *)* A linked PostgreSQL
    source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLLinkedSource, self).__init__()
        self._type = ("PgSQLLinkedSource", True)
        self._operations = (self.__undef__, True)
        self._staging_source = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLLinkedSource, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._staging_source = (data.get("stagingSource", obj.__undef__), dirty)
        if obj._staging_source[0] is not None and obj._staging_source[0] is not obj.__undef__:
            assert isinstance(obj._staging_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_source[0]))
            common.validate_format(obj._staging_source[0], "objectReference", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLLinkedSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "staging_source" == "type" or (self.staging_source is not self.__undef__ and not (dirty and not self._staging_source[1])):
            dct["stagingSource"] = dictify(self.staging_source)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._staging_source = (self._staging_source[0], True)
        self._external_file_path = (self._external_file_path[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._staging_source[1], self._external_file_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLLinkedSource):
            return False
        return super(PgSQLLinkedSource, self).__eq__(other) and \
               self.operations == other.operations and \
               self.staging_source == other.staging_source and \
               self.external_file_path == other.external_file_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def staging_source(self):
        """
        The staging source for pre-provisioning of the database.

        :rtype: ``basestring``
        """
        return self._staging_source[0]

    @staging_source.setter
    def staging_source(self, value):
        self._staging_source = (value, True)

    @property
    def external_file_path(self):
        """
        The external file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

class JSDataLayout(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A Jet Stream data
    layout comprised of a set of data sources and configuration information.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataLayout, self).__init__()
        self._type = ("JSDataLayout", True)
        self._notes = (self.__undef__, True)
        self._last_updated = (self.__undef__, True)
        self._first_operation = (self.__undef__, True)
        self._active_branch = (self.__undef__, True)
        self._properties = (self.__undef__, True)
        self._last_operation = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataLayout, cls).from_dict(data, dirty, undef_enabled)
        obj._notes = (data.get("notes", obj.__undef__), dirty)
        if obj._notes[0] is not None and obj._notes[0] is not obj.__undef__:
            assert isinstance(obj._notes[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._notes[0]))
            common.validate_format(obj._notes[0], "None", None, 4096)
        obj._last_updated = (data.get("lastUpdated", obj.__undef__), dirty)
        if obj._last_updated[0] is not None and obj._last_updated[0] is not obj.__undef__:
            assert isinstance(obj._last_updated[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_updated[0]))
            common.validate_format(obj._last_updated[0], "date", None, None)
        obj._first_operation = (data.get("firstOperation", obj.__undef__), dirty)
        if obj._first_operation[0] is not None and obj._first_operation[0] is not obj.__undef__:
            assert isinstance(obj._first_operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._first_operation[0]))
            common.validate_format(obj._first_operation[0], "objectReference", None, None)
        obj._active_branch = (data.get("activeBranch", obj.__undef__), dirty)
        if obj._active_branch[0] is not None and obj._active_branch[0] is not obj.__undef__:
            assert isinstance(obj._active_branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._active_branch[0]))
            common.validate_format(obj._active_branch[0], "objectReference", None, None)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        obj._last_operation = (data.get("lastOperation", obj.__undef__), dirty)
        if obj._last_operation[0] is not None and obj._last_operation[0] is not obj.__undef__:
            assert isinstance(obj._last_operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_operation[0]))
            common.validate_format(obj._last_operation[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "notes" == "type" or (self.notes is not self.__undef__ and not (dirty and not self._notes[1])):
            dct["notes"] = dictify(self.notes)
        if "last_updated" == "type" or (self.last_updated is not self.__undef__ and not (dirty and not self._last_updated[1])):
            dct["lastUpdated"] = dictify(self.last_updated)
        if "first_operation" == "type" or (self.first_operation is not self.__undef__ and not (dirty and not self._first_operation[1])):
            dct["firstOperation"] = dictify(self.first_operation)
        if "active_branch" == "type" or (self.active_branch is not self.__undef__ and not (dirty and not self._active_branch[1])):
            dct["activeBranch"] = dictify(self.active_branch)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        if "last_operation" == "type" or (self.last_operation is not self.__undef__ and not (dirty and not self._last_operation[1])):
            dct["lastOperation"] = dictify(self.last_operation)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._notes = (self._notes[0], True)
        self._last_updated = (self._last_updated[0], True)
        self._first_operation = (self._first_operation[0], True)
        self._active_branch = (self._active_branch[0], True)
        self._properties = (self._properties[0], True)
        self._last_operation = (self._last_operation[0], True)

    def is_dirty(self):
        return any([self._notes[1], self._last_updated[1], self._first_operation[1], self._active_branch[1], self._properties[1], self._last_operation[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataLayout):
            return False
        return super(JSDataLayout, self).__eq__(other) and \
               self.notes == other.notes and \
               self.last_updated == other.last_updated and \
               self.first_operation == other.first_operation and \
               self.active_branch == other.active_branch and \
               self.properties == other.properties and \
               self.last_operation == other.last_operation

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def notes(self):
        """
        Notes for this data layout.

        :rtype: ``basestring``
        """
        return self._notes[0]

    @notes.setter
    def notes(self, value):
        self._notes = (value, True)

    @property
    def last_updated(self):
        """
        Timestamp of the last update to the application.

        :rtype: ``basestring``
        """
        return self._last_updated[0]

    @last_updated.setter
    def last_updated(self, value):
        self._last_updated = (value, True)

    @property
    def first_operation(self):
        """
        The first JSOperation on this data layout by data time.

        :rtype: ``basestring``
        """
        return self._first_operation[0]

    @first_operation.setter
    def first_operation(self, value):
        self._first_operation = (value, True)

    @property
    def active_branch(self):
        """
        The active branch of the data layout.

        :rtype: ``basestring``
        """
        return self._active_branch[0]

    @active_branch.setter
    def active_branch(self, value):
        self._active_branch = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this data layout.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

    @property
    def last_operation(self):
        """
        The last JSOperation on this data layout by data time.

        :rtype: ``basestring``
        """
        return self._last_operation[0]

    @last_operation.setter
    def last_operation(self, value):
        self._last_operation = (value, True)

class Toolkit(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* An installed
    toolkit.
    """
    def __init__(self, undef_enabled=True):
        super(Toolkit, self).__init__()
        self._type = ("Toolkit", True)
        self._discovery_definition = (self.__undef__, True)
        self._pretty_name = (self.__undef__, True)
        self._name = (self.__undef__, True)
        self._build_api = (self.__undef__, True)
        self._virtual_source_definition = (self.__undef__, True)
        self._messages = (self.__undef__, True)
        self._host_types = (self.__undef__, True)
        self._linked_source_definition = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._default_locale = (self.__undef__, True)
        self._snapshot_schema = (self.__undef__, True)
        self._resources = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Toolkit, cls).from_dict(data, dirty, undef_enabled)
        if "discoveryDefinition" in data and data["discoveryDefinition"] is not None:
            obj._discovery_definition = (factory.create_object(data["discoveryDefinition"], "ToolkitDiscoveryDefinition"), dirty)
            factory.validate_type(obj._discovery_definition[0], "ToolkitDiscoveryDefinition")
        else:
            obj._discovery_definition = (obj.__undef__, dirty)
        if "prettyName" not in data:
            raise ValueError("Missing required property \"prettyName\".")
        obj._pretty_name = (data.get("prettyName", obj.__undef__), dirty)
        if obj._pretty_name[0] is not None and obj._pretty_name[0] is not obj.__undef__:
            assert isinstance(obj._pretty_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._pretty_name[0]))
            common.validate_format(obj._pretty_name[0], "None", None, 256)
        if "name" not in data:
            raise ValueError("Missing required property \"name\".")
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, 256)
        if "buildApi" not in data:
            raise ValueError("Missing required property \"buildApi\".")
        if "buildApi" in data and data["buildApi"] is not None:
            obj._build_api = (factory.create_object(data["buildApi"], "APIVersion"), dirty)
            factory.validate_type(obj._build_api[0], "APIVersion")
        else:
            obj._build_api = (obj.__undef__, dirty)
        if "virtualSourceDefinition" not in data:
            raise ValueError("Missing required property \"virtualSourceDefinition\".")
        if "virtualSourceDefinition" in data and data["virtualSourceDefinition"] is not None:
            obj._virtual_source_definition = (factory.create_object(data["virtualSourceDefinition"], "ToolkitVirtualSource"), dirty)
            factory.validate_type(obj._virtual_source_definition[0], "ToolkitVirtualSource")
        else:
            obj._virtual_source_definition = (obj.__undef__, dirty)
        obj._messages = []
        for item in data.get("messages") or []:
            obj._messages.append(factory.create_object(item))
            factory.validate_type(obj._messages[-1], "ToolkitLocale")
        obj._messages = (obj._messages, dirty)
        if "hostTypes" not in data:
            raise ValueError("Missing required property \"hostTypes\".")
        obj._host_types = []
        for item in data.get("hostTypes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            assert item in [u'UNIX', u'WINDOWS'], "Expected enum [u'UNIX', u'WINDOWS'] but got %s" % item
            common.validate_format(item, "None", None, None)
            obj._host_types.append(item)
        obj._host_types = (obj._host_types, dirty)
        if "linkedSourceDefinition" not in data:
            raise ValueError("Missing required property \"linkedSourceDefinition\".")
        if "linkedSourceDefinition" in data and data["linkedSourceDefinition"] is not None:
            obj._linked_source_definition = (factory.create_object(data["linkedSourceDefinition"], "ToolkitLinkedSource"), dirty)
            factory.validate_type(obj._linked_source_definition[0], "ToolkitLinkedSource")
        else:
            obj._linked_source_definition = (obj.__undef__, dirty)
        if "version" not in data:
            raise ValueError("Missing required property \"version\".")
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "toolkitVersion", None, None)
        if "defaultLocale" not in data:
            raise ValueError("Missing required property \"defaultLocale\".")
        obj._default_locale = (data.get("defaultLocale", obj.__undef__), dirty)
        if obj._default_locale[0] is not None and obj._default_locale[0] is not obj.__undef__:
            assert isinstance(obj._default_locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_locale[0]))
            common.validate_format(obj._default_locale[0], "locale", None, None)
        if "snapshotSchema" not in data:
            raise ValueError("Missing required property \"snapshotSchema\".")
        if "snapshotSchema" in data and data["snapshotSchema"] is not None:
            obj._snapshot_schema = (data["snapshotSchema"], dirty)
        else:
            obj._snapshot_schema = (obj.__undef__, dirty)
        if "resources" not in data:
            raise ValueError("Missing required property \"resources\".")
        obj._resources = (data.get("resources", obj.__undef__), dirty)
        if obj._resources[0] is not None and obj._resources[0] is not obj.__undef__:
            assert isinstance(obj._resources[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._resources[0]))
            common.validate_format(obj._resources[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Toolkit, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovery_definition" == "type" or (self.discovery_definition is not self.__undef__ and not (dirty and not self._discovery_definition[1])):
            dct["discoveryDefinition"] = dictify(self.discovery_definition)
        if "pretty_name" == "type" or (self.pretty_name is not self.__undef__ and not (dirty and not self._pretty_name[1])):
            dct["prettyName"] = dictify(self.pretty_name)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        if "build_api" == "type" or (self.build_api is not self.__undef__ and not (dirty and not self._build_api[1])):
            dct["buildApi"] = dictify(self.build_api)
        if "virtual_source_definition" == "type" or (self.virtual_source_definition is not self.__undef__ and not (dirty and not self._virtual_source_definition[1])):
            dct["virtualSourceDefinition"] = dictify(self.virtual_source_definition)
        if "messages" == "type" or (self.messages is not self.__undef__ and not (dirty and not self._messages[1])):
            dct["messages"] = dictify(self.messages)
        if "host_types" == "type" or (self.host_types is not self.__undef__ and not (dirty and not self._host_types[1])):
            dct["hostTypes"] = dictify(self.host_types)
        if "linked_source_definition" == "type" or (self.linked_source_definition is not self.__undef__ and not (dirty and not self._linked_source_definition[1])):
            dct["linkedSourceDefinition"] = dictify(self.linked_source_definition)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "default_locale" == "type" or (self.default_locale is not self.__undef__ and not (dirty and not self._default_locale[1])):
            dct["defaultLocale"] = dictify(self.default_locale)
        if "snapshot_schema" == "type" or (self.snapshot_schema is not self.__undef__ and not (dirty and not self._snapshot_schema[1])):
            dct["snapshotSchema"] = dictify(self.snapshot_schema)
        if "resources" == "type" or (self.resources is not self.__undef__ and not (dirty and not self._resources[1])):
            dct["resources"] = dictify(self.resources)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovery_definition = (self._discovery_definition[0], True)
        self._pretty_name = (self._pretty_name[0], True)
        self._name = (self._name[0], True)
        self._build_api = (self._build_api[0], True)
        self._virtual_source_definition = (self._virtual_source_definition[0], True)
        self._messages = (self._messages[0], True)
        self._host_types = (self._host_types[0], True)
        self._linked_source_definition = (self._linked_source_definition[0], True)
        self._version = (self._version[0], True)
        self._default_locale = (self._default_locale[0], True)
        self._snapshot_schema = (self._snapshot_schema[0], True)
        self._resources = (self._resources[0], True)

    def is_dirty(self):
        return any([self._discovery_definition[1], self._pretty_name[1], self._name[1], self._build_api[1], self._virtual_source_definition[1], self._messages[1], self._host_types[1], self._linked_source_definition[1], self._version[1], self._default_locale[1], self._snapshot_schema[1], self._resources[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Toolkit):
            return False
        return super(Toolkit, self).__eq__(other) and \
               self.discovery_definition == other.discovery_definition and \
               self.pretty_name == other.pretty_name and \
               self.name == other.name and \
               self.build_api == other.build_api and \
               self.virtual_source_definition == other.virtual_source_definition and \
               self.messages == other.messages and \
               self.host_types == other.host_types and \
               self.linked_source_definition == other.linked_source_definition and \
               self.version == other.version and \
               self.default_locale == other.default_locale and \
               self.snapshot_schema == other.snapshot_schema and \
               self.resources == other.resources

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovery_definition(self):
        """
        Definition of how to discover sources of this type.

        :rtype: :py:class:`v1_8_1.web.vo.ToolkitDiscoveryDefinition`
        """
        return self._discovery_definition[0]

    @discovery_definition.setter
    def discovery_definition(self, value):
        self._discovery_definition = (value, True)

    @property
    def pretty_name(self):
        """
        A human readable name for the toolkit.

        :rtype: ``basestring``
        """
        return self._pretty_name[0]

    @pretty_name.setter
    def pretty_name(self, value):
        self._pretty_name = (value, True)

    @property
    def name(self):
        """
        A unique and descriptive name for the toolkit.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

    @property
    def build_api(self):
        """
        The Delphix API version that the toolkit was built against.

        :rtype: :py:class:`v1_8_1.web.vo.APIVersion`
        """
        return self._build_api[0]

    @build_api.setter
    def build_api(self, value):
        self._build_api = (value, True)

    @property
    def virtual_source_definition(self):
        """
        Definition of how to provision virtual sources of this type.

        :rtype: :py:class:`v1_8_1.web.vo.ToolkitVirtualSource`
        """
        return self._virtual_source_definition[0]

    @virtual_source_definition.setter
    def virtual_source_definition(self, value):
        self._virtual_source_definition = (value, True)

    @property
    def messages(self):
        """
        The set of localizable messages for this toolkit.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.ToolkitLocale`
        """
        return self._messages[0]

    @messages.setter
    def messages(self, value):
        self._messages = (value, True)

    @property
    def host_types(self):
        """
        A list of host types compatible with this toolkit.

        :rtype: ``list`` of ``basestring``
        """
        return self._host_types[0]

    @host_types.setter
    def host_types(self, value):
        self._host_types = (value, True)

    @property
    def linked_source_definition(self):
        """
        Definition of how to link sources of this type.

        :rtype: :py:class:`v1_8_1.web.vo.ToolkitLinkedSource`
        """
        return self._linked_source_definition[0]

    @linked_source_definition.setter
    def linked_source_definition(self, value):
        self._linked_source_definition = (value, True)

    @property
    def version(self):
        """
        The version of the toolkit that is of the form: 'major.minor.patch'.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def default_locale(self):
        """
        The default locale for this toolkit. This locale defines the set of all
        message IDs for the toolkit and serves as the fallback locale when
        messages cannot be localized in a particular locale. If no messages are
        specified for the toolkit, the defaultLocale may be any locale.

        :rtype: ``basestring``
        """
        return self._default_locale[0]

    @default_locale.setter
    def default_locale(self, value):
        self._default_locale = (value, True)

    @property
    def snapshot_schema(self):
        """
        Schema for metadata collected during snapshotting.

        :rtype: :py:class:`v1_8_1.web.vo.SchemaDraftV4`
        """
        return self._snapshot_schema[0]

    @snapshot_schema.setter
    def snapshot_schema(self, value):
        self._snapshot_schema = (value, True)

    @property
    def resources(self):
        """
        Resources for use by workflows in this toolkit.

        :rtype: ``dict``
        """
        return self._resources[0]

    @resources.setter
    def resources(self, value):
        self._resources = (value, True)

class SourceRepositoryTemplate(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* The representation
    of a repository template object.
    """
    def __init__(self, undef_enabled=True):
        super(SourceRepositoryTemplate, self).__init__()
        self._type = ("SourceRepositoryTemplate", True)
        self._container = (self.__undef__, True)
        self._repository = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SourceRepositoryTemplate, cls).from_dict(data, dirty, undef_enabled)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._repository = (data.get("repository", obj.__undef__), dirty)
        if obj._repository[0] is not None and obj._repository[0] is not obj.__undef__:
            assert isinstance(obj._repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._repository[0]))
            common.validate_format(obj._repository[0], "objectReference", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SourceRepositoryTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "repository" == "type" or (self.repository is not self.__undef__ and not (dirty and not self._repository[1])):
            dct["repository"] = dictify(self.repository)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._repository = (self._repository[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._container[1], self._repository[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SourceRepositoryTemplate):
            return False
        return super(SourceRepositoryTemplate, self).__eq__(other) and \
               self.container == other.container and \
               self.repository == other.repository and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The reference to the database container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def repository(self):
        """
        The reference to the target repository.

        :rtype: ``basestring``
        """
        return self._repository[0]

    @repository.setter
    def repository(self, value):
        self._repository = (value, True)

    @property
    def template(self):
        """
        The reference to the associated template.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class User(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Delphix users.
    """
    def __init__(self, undef_enabled=True):
        super(User, self).__init__()
        self._type = ("User", True)
        self._credential = (self.__undef__, True)
        self._authentication_type = (self.__undef__, True)
        self._first_name = (self.__undef__, True)
        self._public_key = (self.__undef__, True)
        self._locale = (self.__undef__, True)
        self._last_name = (self.__undef__, True)
        self._home_phone_number = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._user_type = (self.__undef__, True)
        self._session_timeout = (self.__undef__, True)
        self._email_address = (self.__undef__, True)
        self._password_update_requested = (self.__undef__, True)
        self._principal = (self.__undef__, True)
        self._mobile_phone_number = (self.__undef__, True)
        self._work_phone_number = (self.__undef__, True)
        self._is_default = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(User, cls).from_dict(data, dirty, undef_enabled)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "PasswordCredential"), dirty)
            factory.validate_type(obj._credential[0], "PasswordCredential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._authentication_type = (data.get("authenticationType", obj.__undef__), dirty)
        if obj._authentication_type[0] is not None and obj._authentication_type[0] is not obj.__undef__:
            assert isinstance(obj._authentication_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._authentication_type[0]))
            assert obj._authentication_type[0] in [u'LDAP', u'NATIVE', u'SAML'], "Expected enum [u'LDAP', u'NATIVE', u'SAML'] but got %s" % obj._authentication_type[0]
            common.validate_format(obj._authentication_type[0], "None", None, None)
        obj._first_name = (data.get("firstName", obj.__undef__), dirty)
        if obj._first_name[0] is not None and obj._first_name[0] is not obj.__undef__:
            assert isinstance(obj._first_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._first_name[0]))
            common.validate_format(obj._first_name[0], "None", None, 64)
        obj._public_key = (data.get("publicKey", obj.__undef__), dirty)
        if obj._public_key[0] is not None and obj._public_key[0] is not obj.__undef__:
            assert isinstance(obj._public_key[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._public_key[0]))
            common.validate_format(obj._public_key[0], "None", None, None)
        obj._locale = (data.get("locale", obj.__undef__), dirty)
        if obj._locale[0] is not None and obj._locale[0] is not obj.__undef__:
            assert isinstance(obj._locale[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._locale[0]))
            common.validate_format(obj._locale[0], "locale", None, 16)
        obj._last_name = (data.get("lastName", obj.__undef__), dirty)
        if obj._last_name[0] is not None and obj._last_name[0] is not obj.__undef__:
            assert isinstance(obj._last_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_name[0]))
            common.validate_format(obj._last_name[0], "None", None, 64)
        obj._home_phone_number = (data.get("homePhoneNumber", obj.__undef__), dirty)
        if obj._home_phone_number[0] is not None and obj._home_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._home_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._home_phone_number[0]))
            common.validate_format(obj._home_phone_number[0], "None", None, 32)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._user_type = (data.get("userType", obj.__undef__), dirty)
        if obj._user_type[0] is not None and obj._user_type[0] is not obj.__undef__:
            assert isinstance(obj._user_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user_type[0]))
            assert obj._user_type[0] in [u'SYSTEM', u'DOMAIN'], "Expected enum [u'SYSTEM', u'DOMAIN'] but got %s" % obj._user_type[0]
            common.validate_format(obj._user_type[0], "None", None, None)
        obj._session_timeout = (data.get("sessionTimeout", obj.__undef__), dirty)
        if obj._session_timeout[0] is not None and obj._session_timeout[0] is not obj.__undef__:
            assert isinstance(obj._session_timeout[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._session_timeout[0]))
            common.validate_format(obj._session_timeout[0], "None", None, None)
        obj._email_address = (data.get("emailAddress", obj.__undef__), dirty)
        if obj._email_address[0] is not None and obj._email_address[0] is not obj.__undef__:
            assert isinstance(obj._email_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._email_address[0]))
            common.validate_format(obj._email_address[0], "email", None, 256)
        obj._password_update_requested = (data.get("passwordUpdateRequested", obj.__undef__), dirty)
        if obj._password_update_requested[0] is not None and obj._password_update_requested[0] is not obj.__undef__:
            assert isinstance(obj._password_update_requested[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._password_update_requested[0]))
            common.validate_format(obj._password_update_requested[0], "None", None, None)
        obj._principal = (data.get("principal", obj.__undef__), dirty)
        if obj._principal[0] is not None and obj._principal[0] is not obj.__undef__:
            assert isinstance(obj._principal[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._principal[0]))
            common.validate_format(obj._principal[0], "None", None, None)
        obj._mobile_phone_number = (data.get("mobilePhoneNumber", obj.__undef__), dirty)
        if obj._mobile_phone_number[0] is not None and obj._mobile_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._mobile_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._mobile_phone_number[0]))
            common.validate_format(obj._mobile_phone_number[0], "None", None, 32)
        obj._work_phone_number = (data.get("workPhoneNumber", obj.__undef__), dirty)
        if obj._work_phone_number[0] is not None and obj._work_phone_number[0] is not obj.__undef__:
            assert isinstance(obj._work_phone_number[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._work_phone_number[0]))
            common.validate_format(obj._work_phone_number[0], "None", None, 32)
        obj._is_default = (data.get("isDefault", obj.__undef__), dirty)
        if obj._is_default[0] is not None and obj._is_default[0] is not obj.__undef__:
            assert isinstance(obj._is_default[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._is_default[0]))
            common.validate_format(obj._is_default[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(User, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "authentication_type" == "type" or (self.authentication_type is not self.__undef__ and not (dirty and not self._authentication_type[1])):
            dct["authenticationType"] = dictify(self.authentication_type)
        if "first_name" == "type" or (self.first_name is not self.__undef__ and not (dirty and not self._first_name[1])):
            dct["firstName"] = dictify(self.first_name)
        if "public_key" == "type" or (self.public_key is not self.__undef__ and not (dirty and not self._public_key[1])):
            dct["publicKey"] = dictify(self.public_key)
        if "locale" == "type" or (self.locale is not self.__undef__ and not (dirty and not self._locale[1])):
            dct["locale"] = dictify(self.locale)
        if "last_name" == "type" or (self.last_name is not self.__undef__ and not (dirty and not self._last_name[1])):
            dct["lastName"] = dictify(self.last_name)
        if "home_phone_number" == "type" or (self.home_phone_number is not self.__undef__ and not (dirty and not self._home_phone_number[1])):
            dct["homePhoneNumber"] = dictify(self.home_phone_number)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "user_type" == "type" or (self.user_type is not self.__undef__ and not (dirty and not self._user_type[1])):
            dct["userType"] = dictify(self.user_type)
        if "session_timeout" == "type" or (self.session_timeout is not self.__undef__ and not (dirty and not self._session_timeout[1])):
            dct["sessionTimeout"] = dictify(self.session_timeout)
        if "email_address" == "type" or (self.email_address is not self.__undef__ and not (dirty and not self._email_address[1])):
            dct["emailAddress"] = dictify(self.email_address)
        if "password_update_requested" == "type" or (self.password_update_requested is not self.__undef__ and not (dirty and not self._password_update_requested[1])):
            dct["passwordUpdateRequested"] = dictify(self.password_update_requested)
        if "principal" == "type" or (self.principal is not self.__undef__ and not (dirty and not self._principal[1])):
            dct["principal"] = dictify(self.principal)
        if "mobile_phone_number" == "type" or (self.mobile_phone_number is not self.__undef__ and not (dirty and not self._mobile_phone_number[1])):
            dct["mobilePhoneNumber"] = dictify(self.mobile_phone_number)
        if "work_phone_number" == "type" or (self.work_phone_number is not self.__undef__ and not (dirty and not self._work_phone_number[1])):
            dct["workPhoneNumber"] = dictify(self.work_phone_number)
        if "is_default" == "type" or (self.is_default is not self.__undef__ and not (dirty and not self._is_default[1])):
            dct["isDefault"] = dictify(self.is_default)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._credential = (self._credential[0], True)
        self._authentication_type = (self._authentication_type[0], True)
        self._first_name = (self._first_name[0], True)
        self._public_key = (self._public_key[0], True)
        self._locale = (self._locale[0], True)
        self._last_name = (self._last_name[0], True)
        self._home_phone_number = (self._home_phone_number[0], True)
        self._enabled = (self._enabled[0], True)
        self._user_type = (self._user_type[0], True)
        self._session_timeout = (self._session_timeout[0], True)
        self._email_address = (self._email_address[0], True)
        self._password_update_requested = (self._password_update_requested[0], True)
        self._principal = (self._principal[0], True)
        self._mobile_phone_number = (self._mobile_phone_number[0], True)
        self._work_phone_number = (self._work_phone_number[0], True)
        self._is_default = (self._is_default[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._credential[1], self._authentication_type[1], self._first_name[1], self._public_key[1], self._locale[1], self._last_name[1], self._home_phone_number[1], self._enabled[1], self._user_type[1], self._session_timeout[1], self._email_address[1], self._password_update_requested[1], self._principal[1], self._mobile_phone_number[1], self._work_phone_number[1], self._is_default[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, User):
            return False
        return super(User, self).__eq__(other) and \
               self.credential == other.credential and \
               self.authentication_type == other.authentication_type and \
               self.first_name == other.first_name and \
               self.public_key == other.public_key and \
               self.locale == other.locale and \
               self.last_name == other.last_name and \
               self.home_phone_number == other.home_phone_number and \
               self.enabled == other.enabled and \
               self.user_type == other.user_type and \
               self.session_timeout == other.session_timeout and \
               self.email_address == other.email_address and \
               self.password_update_requested == other.password_update_requested and \
               self.principal == other.principal and \
               self.mobile_phone_number == other.mobile_phone_number and \
               self.work_phone_number == other.work_phone_number and \
               self.is_default == other.is_default and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def credential(self):
        """
        Credential used for authentication.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def authentication_type(self):
        """
        User authentication type. *(permitted values: LDAP, NATIVE, SAML)*

        :rtype: ``basestring``
        """
        return self._authentication_type[0]

    @authentication_type.setter
    def authentication_type(self, value):
        self._authentication_type = (value, True)

    @property
    def first_name(self):
        """
        First name of user.

        :rtype: ``basestring``
        """
        return self._first_name[0]

    @first_name.setter
    def first_name(self, value):
        self._first_name = (value, True)

    @property
    def public_key(self):
        """
        Public key used for authentication.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._public_key[0]

    @public_key.setter
    def public_key(self, value):
        self._public_key = (value, True)

    @property
    def locale(self):
        """
        *(default value: en-US)* Preferred locale as an IETF BCP 47 language
        tag, defaults to 'en-US'.

        :rtype: ``basestring``
        """
        return self._locale[0]

    @locale.setter
    def locale(self, value):
        self._locale = (value, True)

    @property
    def last_name(self):
        """
        Last name of user.

        :rtype: ``basestring``
        """
        return self._last_name[0]

    @last_name.setter
    def last_name(self, value):
        self._last_name = (value, True)

    @property
    def home_phone_number(self):
        """
        Home phone number of user.

        :rtype: ``basestring``
        """
        return self._home_phone_number[0]

    @home_phone_number.setter
    def home_phone_number(self, value):
        self._home_phone_number = (value, True)

    @property
    def enabled(self):
        """
        *(default value: True)* True if the user is currently enabled and can
        log into the system.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def user_type(self):
        """
        *(default value: DOMAIN)* Type of user. *(permitted values: SYSTEM,
        DOMAIN)*

        :rtype: ``basestring``
        """
        return self._user_type[0]

    @user_type.setter
    def user_type(self, value):
        self._user_type = (value, True)

    @property
    def session_timeout(self):
        """
        *(default value: 30)* Session timeout in minutes.

        :rtype: ``int``
        """
        return self._session_timeout[0]

    @session_timeout.setter
    def session_timeout(self, value):
        self._session_timeout = (value, True)

    @property
    def email_address(self):
        """
        Email address for the user.

        :rtype: ``basestring``
        """
        return self._email_address[0]

    @email_address.setter
    def email_address(self, value):
        self._email_address = (value, True)

    @property
    def password_update_requested(self):
        """
        True if the user's password should be updated.

        :rtype: ``bool``
        """
        return self._password_update_requested[0]

    @password_update_requested.setter
    def password_update_requested(self, value):
        self._password_update_requested = (value, True)

    @property
    def principal(self):
        """
        Principal name used for authentication.

        :rtype: ``basestring``
        """
        return self._principal[0]

    @principal.setter
    def principal(self, value):
        self._principal = (value, True)

    @property
    def mobile_phone_number(self):
        """
        Mobile phone number of user.

        :rtype: ``basestring``
        """
        return self._mobile_phone_number[0]

    @mobile_phone_number.setter
    def mobile_phone_number(self, value):
        self._mobile_phone_number = (value, True)

    @property
    def work_phone_number(self):
        """
        Work phone number of user.

        :rtype: ``basestring``
        """
        return self._work_phone_number[0]

    @work_phone_number.setter
    def work_phone_number(self, value):
        self._work_phone_number = (value, True)

    @property
    def is_default(self):
        """
        True if this is the default user and cannot be deleted.

        :rtype: ``bool``
        """
        return self._is_default[0]

    @is_default.setter
    def is_default(self, value):
        self._is_default = (value, True)

    @property
    def name(self):
        """
        Name of user.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class Namespace(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Object namespace
    for target-side replication.
    """
    def __init__(self, undef_enabled=True):
        super(Namespace, self).__init__()
        self._type = ("Namespace", True)
        self._failover_report = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._failed_over = (self.__undef__, True)
        self._namespace_type = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._secure_namespace = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Namespace, cls).from_dict(data, dirty, undef_enabled)
        obj._failover_report = (data.get("failoverReport", obj.__undef__), dirty)
        if obj._failover_report[0] is not None and obj._failover_report[0] is not obj.__undef__:
            assert isinstance(obj._failover_report[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._failover_report[0]))
            common.validate_format(obj._failover_report[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._failed_over = (data.get("failedOver", obj.__undef__), dirty)
        if obj._failed_over[0] is not None and obj._failed_over[0] is not obj.__undef__:
            assert isinstance(obj._failed_over[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._failed_over[0]))
            common.validate_format(obj._failed_over[0], "None", None, None)
        obj._namespace_type = (data.get("namespaceType", obj.__undef__), dirty)
        if obj._namespace_type[0] is not None and obj._namespace_type[0] is not obj.__undef__:
            assert isinstance(obj._namespace_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._namespace_type[0]))
            assert obj._namespace_type[0] in [u'REPLICATION'], "Expected enum [u'REPLICATION'] but got %s" % obj._namespace_type[0]
            common.validate_format(obj._namespace_type[0], "None", None, None)
        obj._source = (data.get("source", obj.__undef__), dirty)
        if obj._source[0] is not None and obj._source[0] is not obj.__undef__:
            assert isinstance(obj._source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source[0]))
            common.validate_format(obj._source[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, None)
        obj._secure_namespace = (data.get("secureNamespace", obj.__undef__), dirty)
        if obj._secure_namespace[0] is not None and obj._secure_namespace[0] is not obj.__undef__:
            assert isinstance(obj._secure_namespace[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._secure_namespace[0]))
            common.validate_format(obj._secure_namespace[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Namespace, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "failover_report" == "type" or (self.failover_report is not self.__undef__ and not (dirty and not self._failover_report[1])):
            dct["failoverReport"] = dictify(self.failover_report)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "failed_over" == "type" or (self.failed_over is not self.__undef__ and not (dirty and not self._failed_over[1])):
            dct["failedOver"] = dictify(self.failed_over)
        if "namespace_type" == "type" or (self.namespace_type is not self.__undef__ and not (dirty and not self._namespace_type[1])):
            dct["namespaceType"] = dictify(self.namespace_type)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "secure_namespace" == "type" or (self.secure_namespace is not self.__undef__ and not (dirty and not self._secure_namespace[1])):
            dct["secureNamespace"] = dictify(self.secure_namespace)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._failover_report = (self._failover_report[0], True)
        self._description = (self._description[0], True)
        self._failed_over = (self._failed_over[0], True)
        self._namespace_type = (self._namespace_type[0], True)
        self._source = (self._source[0], True)
        self._tag = (self._tag[0], True)
        self._secure_namespace = (self._secure_namespace[0], True)

    def is_dirty(self):
        return any([self._failover_report[1], self._description[1], self._failed_over[1], self._namespace_type[1], self._source[1], self._tag[1], self._secure_namespace[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Namespace):
            return False
        return super(Namespace, self).__eq__(other) and \
               self.failover_report == other.failover_report and \
               self.description == other.description and \
               self.failed_over == other.failed_over and \
               self.namespace_type == other.namespace_type and \
               self.source == other.source and \
               self.tag == other.tag and \
               self.secure_namespace == other.secure_namespace

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def failover_report(self):
        """
        If failedOver is true, contains a report concern objects affected
        during failover.

        :rtype: ``basestring``
        """
        return self._failover_report[0]

    @failover_report.setter
    def failover_report(self, value):
        self._failover_report = (value, True)

    @property
    def description(self):
        """
        Description of this namespace.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def failed_over(self):
        """
        Indicates the namespace has been failed over into the live environment.

        :rtype: ``bool``
        """
        return self._failed_over[0]

    @failed_over.setter
    def failed_over(self, value):
        self._failed_over = (value, True)

    @property
    def namespace_type(self):
        """
        Type of object namespace. *(permitted values: REPLICATION)*

        :rtype: ``basestring``
        """
        return self._namespace_type[0]

    @namespace_type.setter
    def namespace_type(self, value):
        self._namespace_type = (value, True)

    @property
    def source(self):
        """
        For replication, the source host IP address.

        :rtype: ``basestring``
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def tag(self):
        """
        A unique identifier for the source data stream.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def secure_namespace(self):
        """
        True if the source data stream was generated from a secure replication
        spec.

        :rtype: ``bool``
        """
        return self._secure_namespace[0]

    @secure_namespace.setter
    def secure_namespace(self, value):
        self._secure_namespace = (value, True)

class OperationTemplate(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Template for
    commonly used operations.
    """
    def __init__(self, undef_enabled=True):
        super(OperationTemplate, self).__init__()
        self._type = ("OperationTemplate", True)
        self._operation = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._last_updated = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OperationTemplate, cls).from_dict(data, dirty, undef_enabled)
        if "operation" in data and data["operation"] is not None:
            obj._operation = (factory.create_object(data["operation"], "SourceOperation"), dirty)
            factory.validate_type(obj._operation[0], "SourceOperation")
        else:
            obj._operation = (obj.__undef__, dirty)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._last_updated = (data.get("lastUpdated", obj.__undef__), dirty)
        if obj._last_updated[0] is not None and obj._last_updated[0] is not obj.__undef__:
            assert isinstance(obj._last_updated[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_updated[0]))
            common.validate_format(obj._last_updated[0], "date", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", 1, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OperationTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "last_updated" == "type" or (self.last_updated is not self.__undef__ and not (dirty and not self._last_updated[1])):
            dct["lastUpdated"] = dictify(self.last_updated)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operation = (self._operation[0], True)
        self._description = (self._description[0], True)
        self._last_updated = (self._last_updated[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._operation[1], self._description[1], self._last_updated[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OperationTemplate):
            return False
        return super(OperationTemplate, self).__eq__(other) and \
               self.operation == other.operation and \
               self.description == other.description and \
               self.last_updated == other.last_updated and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operation(self):
        """
        Template contents.

        :rtype: :py:class:`v1_8_1.web.vo.SourceOperation`
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

    @property
    def description(self):
        """
        User provided description for this template.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def last_updated(self):
        """
        Most recently modified time.

        :rtype: ``basestring``
        """
        return self._last_updated[0]

    @last_updated.setter
    def last_updated(self, value):
        self._last_updated = (value, True)

    @property
    def name(self):
        """
        The name clients should use when setting the parameter's value.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class JSBookmark(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A named entity
    that represents a point in time for all of the data sources in a data
    layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSBookmark, self).__init__()
        self._type = ("JSBookmark", True)
        self._container_name = (self.__undef__, True)
        self._usable = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._tags = (self.__undef__, True)
        self._creation_time = (self.__undef__, True)
        self._template_name = (self.__undef__, True)
        self._checkout_count = (self.__undef__, True)
        self._bookmark_type = (self.__undef__, True)
        self._expiration = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._timestamp = (self.__undef__, True)
        self._shared = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBookmark, cls).from_dict(data, dirty, undef_enabled)
        obj._container_name = (data.get("containerName", obj.__undef__), dirty)
        if obj._container_name[0] is not None and obj._container_name[0] is not obj.__undef__:
            assert isinstance(obj._container_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container_name[0]))
            common.validate_format(obj._container_name[0], "None", None, None)
        obj._usable = (data.get("usable", obj.__undef__), dirty)
        if obj._usable[0] is not None and obj._usable[0] is not obj.__undef__:
            assert isinstance(obj._usable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._usable[0]))
            common.validate_format(obj._usable[0], "None", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._tags = []
        for item in data.get("tags") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._tags.append(item)
        obj._tags = (obj._tags, dirty)
        obj._creation_time = (data.get("creationTime", obj.__undef__), dirty)
        if obj._creation_time[0] is not None and obj._creation_time[0] is not obj.__undef__:
            assert isinstance(obj._creation_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._creation_time[0]))
            common.validate_format(obj._creation_time[0], "date", None, None)
        obj._template_name = (data.get("templateName", obj.__undef__), dirty)
        if obj._template_name[0] is not None and obj._template_name[0] is not obj.__undef__:
            assert isinstance(obj._template_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template_name[0]))
            common.validate_format(obj._template_name[0], "None", None, None)
        obj._checkout_count = (data.get("checkoutCount", obj.__undef__), dirty)
        if obj._checkout_count[0] is not None and obj._checkout_count[0] is not obj.__undef__:
            assert isinstance(obj._checkout_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._checkout_count[0]))
            common.validate_format(obj._checkout_count[0], "None", None, None)
        obj._bookmark_type = (data.get("bookmarkType", obj.__undef__), dirty)
        if obj._bookmark_type[0] is not None and obj._bookmark_type[0] is not obj.__undef__:
            assert isinstance(obj._bookmark_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark_type[0]))
            assert obj._bookmark_type[0] in [u'DATA_CONTAINER', u'DATA_TEMPLATE'], "Expected enum [u'DATA_CONTAINER', u'DATA_TEMPLATE'] but got %s" % obj._bookmark_type[0]
            common.validate_format(obj._bookmark_type[0], "None", None, None)
        obj._expiration = (data.get("expiration", obj.__undef__), dirty)
        if obj._expiration[0] is not None and obj._expiration[0] is not obj.__undef__:
            assert isinstance(obj._expiration[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._expiration[0]))
            common.validate_format(obj._expiration[0], "date", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._shared = (data.get("shared", obj.__undef__), dirty)
        if obj._shared[0] is not None and obj._shared[0] is not obj.__undef__:
            assert isinstance(obj._shared[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._shared[0]))
            common.validate_format(obj._shared[0], "None", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container_name" == "type" or (self.container_name is not self.__undef__ and not (dirty and not self._container_name[1])):
            dct["containerName"] = dictify(self.container_name)
        if "usable" == "type" or (self.usable is not self.__undef__ and not (dirty and not self._usable[1])):
            dct["usable"] = dictify(self.usable)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "tags" == "type" or (self.tags is not self.__undef__ and not (dirty and not self._tags[1])):
            dct["tags"] = dictify(self.tags)
        if "creation_time" == "type" or (self.creation_time is not self.__undef__ and not (dirty and not self._creation_time[1])):
            dct["creationTime"] = dictify(self.creation_time)
        if "template_name" == "type" or (self.template_name is not self.__undef__ and not (dirty and not self._template_name[1])):
            dct["templateName"] = dictify(self.template_name)
        if "checkout_count" == "type" or (self.checkout_count is not self.__undef__ and not (dirty and not self._checkout_count[1])):
            dct["checkoutCount"] = dictify(self.checkout_count)
        if "bookmark_type" == "type" or (self.bookmark_type is not self.__undef__ and not (dirty and not self._bookmark_type[1])):
            dct["bookmarkType"] = dictify(self.bookmark_type)
        if "expiration" == "type" or (self.expiration is not self.__undef__ and not (dirty and not self._expiration[1])):
            dct["expiration"] = dictify(self.expiration)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "shared" == "type" or (self.shared is not self.__undef__ and not (dirty and not self._shared[1])):
            dct["shared"] = dictify(self.shared)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container_name = (self._container_name[0], True)
        self._usable = (self._usable[0], True)
        self._container = (self._container[0], True)
        self._description = (self._description[0], True)
        self._tags = (self._tags[0], True)
        self._creation_time = (self._creation_time[0], True)
        self._template_name = (self._template_name[0], True)
        self._checkout_count = (self._checkout_count[0], True)
        self._bookmark_type = (self._bookmark_type[0], True)
        self._expiration = (self._expiration[0], True)
        self._branch = (self._branch[0], True)
        self._timestamp = (self._timestamp[0], True)
        self._shared = (self._shared[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._container_name[1], self._usable[1], self._container[1], self._description[1], self._tags[1], self._creation_time[1], self._template_name[1], self._checkout_count[1], self._bookmark_type[1], self._expiration[1], self._branch[1], self._timestamp[1], self._shared[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBookmark):
            return False
        return super(JSBookmark, self).__eq__(other) and \
               self.container_name == other.container_name and \
               self.usable == other.usable and \
               self.container == other.container and \
               self.description == other.description and \
               self.tags == other.tags and \
               self.creation_time == other.creation_time and \
               self.template_name == other.template_name and \
               self.checkout_count == other.checkout_count and \
               self.bookmark_type == other.bookmark_type and \
               self.expiration == other.expiration and \
               self.branch == other.branch and \
               self.timestamp == other.timestamp and \
               self.shared == other.shared and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container_name(self):
        """
        The name of the data container this bookmark was created on. This will
        be null if the bookmark was created on a data template.

        :rtype: ``basestring``
        """
        return self._container_name[0]

    @container_name.setter
    def container_name(self, value):
        self._container_name = (value, True)

    @property
    def usable(self):
        """
        True if this bookmark is usable as input to a data operation (e.g.,
        CREATE_BRANCH or RESTORE).

        :rtype: ``bool``
        """
        return self._usable[0]

    @usable.setter
    def usable(self, value):
        self._usable = (value, True)

    @property
    def container(self):
        """
        The data container this bookmark was created on. This will be null if
        the bookmark was created on a data template.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def description(self):
        """
        Description of this bookmark.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def tags(self):
        """
        A set of user-defined labels for this bookmark.

        :rtype: ``list`` of ``basestring``
        """
        return self._tags[0]

    @tags.setter
    def tags(self, value):
        self._tags = (value, True)

    @property
    def creation_time(self):
        """
        The time at which the bookmark was created.

        :rtype: ``basestring``
        """
        return self._creation_time[0]

    @creation_time.setter
    def creation_time(self, value):
        self._creation_time = (value, True)

    @property
    def template_name(self):
        """
        The name of the data template this bookmark was created on or the
        template of the data container this bookmark was created on.

        :rtype: ``basestring``
        """
        return self._template_name[0]

    @template_name.setter
    def template_name(self, value):
        self._template_name = (value, True)

    @property
    def checkout_count(self):
        """
        The number of times this bookmark has been checked out. This means it
        was used as input to a RESTORE, CREATE_BRANCH, or RESET operation.

        :rtype: ``int``
        """
        return self._checkout_count[0]

    @checkout_count.setter
    def checkout_count(self, value):
        self._checkout_count = (value, True)

    @property
    def bookmark_type(self):
        """
        Denotes whether or not this bookmark was created on a data container or
        a data template. *(permitted values: DATA_CONTAINER, DATA_TEMPLATE)*

        :rtype: ``basestring``
        """
        return self._bookmark_type[0]

    @bookmark_type.setter
    def bookmark_type(self, value):
        self._bookmark_type = (value, True)

    @property
    def expiration(self):
        """
        A policy will automatically delete this bookmark at this time. If the
        value is null, then the bookmark will be kept until manually deleted.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._expiration[0]

    @expiration.setter
    def expiration(self, value):
        self._expiration = (value, True)

    @property
    def branch(self):
        """
        A reference to the branch this bookmark applies to.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def timestamp(self):
        """
        The timestamp for the data that the bookmark refers to.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def shared(self):
        """
        True if this bookmark is shared.

        :rtype: ``bool``
        """
        return self._shared[0]

    @shared.setter
    def shared(self, value):
        self._shared = (value, True)

    @property
    def template(self):
        """
        The data template this bookmark was created on or the template of the
        data container this bookmark was created on.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class EnvironmentUser(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* The representation
    of an environment user object.
    """
    def __init__(self, undef_enabled=True):
        super(EnvironmentUser, self).__init__()
        self._type = ("EnvironmentUser", True)
        self._environment = (self.__undef__, True)
        self._credential = (self.__undef__, True)
        self._user_id = (self.__undef__, True)
        self._group_id = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnvironmentUser, cls).from_dict(data, dirty, undef_enabled)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        obj._user_id = (data.get("userId", obj.__undef__), dirty)
        if obj._user_id[0] is not None and obj._user_id[0] is not obj.__undef__:
            assert isinstance(obj._user_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user_id[0]))
            common.validate_format(obj._user_id[0], "None", None, None)
        obj._group_id = (data.get("groupId", obj.__undef__), dirty)
        if obj._group_id[0] is not None and obj._group_id[0] is not obj.__undef__:
            assert isinstance(obj._group_id[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._group_id[0]))
            common.validate_format(obj._group_id[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnvironmentUser, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        if "user_id" == "type" or (self.user_id is not self.__undef__ and not (dirty and not self._user_id[1])):
            dct["userId"] = dictify(self.user_id)
        if "group_id" == "type" or (self.group_id is not self.__undef__ and not (dirty and not self._group_id[1])):
            dct["groupId"] = dictify(self.group_id)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._environment = (self._environment[0], True)
        self._credential = (self._credential[0], True)
        self._user_id = (self._user_id[0], True)
        self._group_id = (self._group_id[0], True)

    def is_dirty(self):
        return any([self._environment[1], self._credential[1], self._user_id[1], self._group_id[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnvironmentUser):
            return False
        return super(EnvironmentUser, self).__eq__(other) and \
               self.environment == other.environment and \
               self.credential == other.credential and \
               self.user_id == other.user_id and \
               self.group_id == other.group_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def environment(self):
        """
        A reference to the associated environment.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def credential(self):
        """
        The credential for the environment user.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

    @property
    def user_id(self):
        """
        User ID of the user.

        :rtype: ``int``
        """
        return self._user_id[0]

    @user_id.setter
    def user_id(self, value):
        self._user_id = (value, True)

    @property
    def group_id(self):
        """
        Group ID of the user.

        :rtype: ``int``
        """
        return self._group_id[0]

    @group_id.setter
    def group_id(self, value):
        self._group_id = (value, True)

class Job(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Represents a job
    object.
    """
    def __init__(self, undef_enabled=True):
        super(Job, self).__init__()
        self._type = ("Job", True)
        self._update_time = (self.__undef__, True)
        self._job_state = (self.__undef__, True)
        self._target = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._suspendable = (self.__undef__, True)
        self._parent_action = (self.__undef__, True)
        self._events = (self.__undef__, True)
        self._cancelable = (self.__undef__, True)
        self._target_object_type = (self.__undef__, True)
        self._action_type = (self.__undef__, True)
        self._percent_complete = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._parent_action_state = (self.__undef__, True)
        self._email_addresses = (self.__undef__, True)
        self._target_name = (self.__undef__, True)
        self._queued = (self.__undef__, True)
        self._user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Job, cls).from_dict(data, dirty, undef_enabled)
        obj._update_time = (data.get("updateTime", obj.__undef__), dirty)
        if obj._update_time[0] is not None and obj._update_time[0] is not obj.__undef__:
            assert isinstance(obj._update_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._update_time[0]))
            common.validate_format(obj._update_time[0], "date", None, None)
        obj._job_state = (data.get("jobState", obj.__undef__), dirty)
        if obj._job_state[0] is not None and obj._job_state[0] is not obj.__undef__:
            assert isinstance(obj._job_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._job_state[0]))
            assert obj._job_state[0] in [u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED'], "Expected enum [u'RUNNING', u'SUSPENDED', u'CANCELED', u'COMPLETED', u'FAILED'] but got %s" % obj._job_state[0]
            common.validate_format(obj._job_state[0], "None", None, None)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "objectReference", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._suspendable = (data.get("suspendable", obj.__undef__), dirty)
        if obj._suspendable[0] is not None and obj._suspendable[0] is not obj.__undef__:
            assert isinstance(obj._suspendable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._suspendable[0]))
            common.validate_format(obj._suspendable[0], "None", None, None)
        obj._parent_action = (data.get("parentAction", obj.__undef__), dirty)
        if obj._parent_action[0] is not None and obj._parent_action[0] is not obj.__undef__:
            assert isinstance(obj._parent_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_action[0]))
            common.validate_format(obj._parent_action[0], "objectReference", None, None)
        obj._events = []
        for item in data.get("events") or []:
            obj._events.append(factory.create_object(item))
            factory.validate_type(obj._events[-1], "JobEvent")
        obj._events = (obj._events, dirty)
        obj._cancelable = (data.get("cancelable", obj.__undef__), dirty)
        if obj._cancelable[0] is not None and obj._cancelable[0] is not obj.__undef__:
            assert isinstance(obj._cancelable[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cancelable[0]))
            common.validate_format(obj._cancelable[0], "None", None, None)
        obj._target_object_type = (data.get("targetObjectType", obj.__undef__), dirty)
        if obj._target_object_type[0] is not None and obj._target_object_type[0] is not obj.__undef__:
            assert isinstance(obj._target_object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_object_type[0]))
            common.validate_format(obj._target_object_type[0], "type", None, None)
        obj._action_type = (data.get("actionType", obj.__undef__), dirty)
        if obj._action_type[0] is not None and obj._action_type[0] is not obj.__undef__:
            assert isinstance(obj._action_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action_type[0]))
            common.validate_format(obj._action_type[0], "None", None, None)
        obj._percent_complete = (data.get("percentComplete", obj.__undef__), dirty)
        if obj._percent_complete[0] is not None and obj._percent_complete[0] is not obj.__undef__:
            assert isinstance(obj._percent_complete[0], float), ("Expected one of [u'number'], but got %s" % type(obj._percent_complete[0]))
            common.validate_format(obj._percent_complete[0], "None", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._parent_action_state = (data.get("parentActionState", obj.__undef__), dirty)
        if obj._parent_action_state[0] is not None and obj._parent_action_state[0] is not obj.__undef__:
            assert isinstance(obj._parent_action_state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_action_state[0]))
            assert obj._parent_action_state[0] in [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'], "Expected enum [u'EXECUTING', u'WAITING', u'COMPLETED', u'FAILED', u'CANCELED'] but got %s" % obj._parent_action_state[0]
            common.validate_format(obj._parent_action_state[0], "None", None, None)
        obj._email_addresses = []
        for item in data.get("emailAddresses") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "email", None, None)
            obj._email_addresses.append(item)
        obj._email_addresses = (obj._email_addresses, dirty)
        obj._target_name = (data.get("targetName", obj.__undef__), dirty)
        if obj._target_name[0] is not None and obj._target_name[0] is not obj.__undef__:
            assert isinstance(obj._target_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_name[0]))
            common.validate_format(obj._target_name[0], "None", None, None)
        obj._queued = (data.get("queued", obj.__undef__), dirty)
        if obj._queued[0] is not None and obj._queued[0] is not obj.__undef__:
            assert isinstance(obj._queued[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._queued[0]))
            common.validate_format(obj._queued[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Job, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "update_time" == "type" or (self.update_time is not self.__undef__ and not (dirty and not self._update_time[1])):
            dct["updateTime"] = dictify(self.update_time)
        if "job_state" == "type" or (self.job_state is not self.__undef__ and not (dirty and not self._job_state[1])):
            dct["jobState"] = dictify(self.job_state)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if "suspendable" == "type" or (self.suspendable is not self.__undef__ and not (dirty and not self._suspendable[1])):
            dct["suspendable"] = dictify(self.suspendable)
        if "parent_action" == "type" or (self.parent_action is not self.__undef__ and not (dirty and not self._parent_action[1])):
            dct["parentAction"] = dictify(self.parent_action)
        if "events" == "type" or (self.events is not self.__undef__ and not (dirty and not self._events[1])):
            dct["events"] = dictify(self.events)
        if "cancelable" == "type" or (self.cancelable is not self.__undef__ and not (dirty and not self._cancelable[1])):
            dct["cancelable"] = dictify(self.cancelable)
        if "target_object_type" == "type" or (self.target_object_type is not self.__undef__ and not (dirty and not self._target_object_type[1])):
            dct["targetObjectType"] = dictify(self.target_object_type)
        if "action_type" == "type" or (self.action_type is not self.__undef__ and not (dirty and not self._action_type[1])):
            dct["actionType"] = dictify(self.action_type)
        if "percent_complete" == "type" or (self.percent_complete is not self.__undef__ and not (dirty and not self._percent_complete[1])):
            dct["percentComplete"] = dictify(self.percent_complete)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "parent_action_state" == "type" or (self.parent_action_state is not self.__undef__ and not (dirty and not self._parent_action_state[1])):
            dct["parentActionState"] = dictify(self.parent_action_state)
        if "email_addresses" == "type" or (self.email_addresses is not self.__undef__ and not (dirty and not self._email_addresses[1])):
            dct["emailAddresses"] = dictify(self.email_addresses)
        if "target_name" == "type" or (self.target_name is not self.__undef__ and not (dirty and not self._target_name[1])):
            dct["targetName"] = dictify(self.target_name)
        if "queued" == "type" or (self.queued is not self.__undef__ and not (dirty and not self._queued[1])):
            dct["queued"] = dictify(self.queued)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._update_time = (self._update_time[0], True)
        self._job_state = (self._job_state[0], True)
        self._target = (self._target[0], True)
        self._title = (self._title[0], True)
        self._suspendable = (self._suspendable[0], True)
        self._parent_action = (self._parent_action[0], True)
        self._events = (self._events[0], True)
        self._cancelable = (self._cancelable[0], True)
        self._target_object_type = (self._target_object_type[0], True)
        self._action_type = (self._action_type[0], True)
        self._percent_complete = (self._percent_complete[0], True)
        self._start_time = (self._start_time[0], True)
        self._parent_action_state = (self._parent_action_state[0], True)
        self._email_addresses = (self._email_addresses[0], True)
        self._target_name = (self._target_name[0], True)
        self._queued = (self._queued[0], True)
        self._user = (self._user[0], True)

    def is_dirty(self):
        return any([self._update_time[1], self._job_state[1], self._target[1], self._title[1], self._suspendable[1], self._parent_action[1], self._events[1], self._cancelable[1], self._target_object_type[1], self._action_type[1], self._percent_complete[1], self._start_time[1], self._parent_action_state[1], self._email_addresses[1], self._target_name[1], self._queued[1], self._user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Job):
            return False
        return super(Job, self).__eq__(other) and \
               self.update_time == other.update_time and \
               self.job_state == other.job_state and \
               self.target == other.target and \
               self.title == other.title and \
               self.suspendable == other.suspendable and \
               self.parent_action == other.parent_action and \
               self.events == other.events and \
               self.cancelable == other.cancelable and \
               self.target_object_type == other.target_object_type and \
               self.action_type == other.action_type and \
               self.percent_complete == other.percent_complete and \
               self.start_time == other.start_time and \
               self.parent_action_state == other.parent_action_state and \
               self.email_addresses == other.email_addresses and \
               self.target_name == other.target_name and \
               self.queued == other.queued and \
               self.user == other.user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def update_time(self):
        """
        Time the job was last updated.

        :rtype: ``basestring``
        """
        return self._update_time[0]

    @update_time.setter
    def update_time(self, value):
        self._update_time = (value, True)

    @property
    def job_state(self):
        """
        State of the job. *(permitted values: RUNNING, SUSPENDED, CANCELED,
        COMPLETED, FAILED)*

        :rtype: ``basestring``
        """
        return self._job_state[0]

    @job_state.setter
    def job_state(self, value):
        self._job_state = (value, True)

    @property
    def target(self):
        """
        Object reference of the target.

        :rtype: ``basestring``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

    @property
    def title(self):
        """
        Title of the job.

        :rtype: ``basestring``
        """
        return self._title[0]

    @title.setter
    def title(self, value):
        self._title = (value, True)

    @property
    def suspendable(self):
        """
        Whether this job can be suspended.

        :rtype: ``bool``
        """
        return self._suspendable[0]

    @suspendable.setter
    def suspendable(self, value):
        self._suspendable = (value, True)

    @property
    def parent_action(self):
        """
        This job's parent action.

        :rtype: ``basestring``
        """
        return self._parent_action[0]

    @parent_action.setter
    def parent_action(self, value):
        self._parent_action = (value, True)

    @property
    def events(self):
        """
        A list of time-sorted past JobEvent objects associated with this job.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.JobEvent`
        """
        return self._events[0]

    @events.setter
    def events(self, value):
        self._events = (value, True)

    @property
    def cancelable(self):
        """
        Whether this job can be canceled.

        :rtype: ``bool``
        """
        return self._cancelable[0]

    @cancelable.setter
    def cancelable(self, value):
        self._cancelable = (value, True)

    @property
    def target_object_type(self):
        """
        Object type of the target.

        :rtype: ``basestring``
        """
        return self._target_object_type[0]

    @target_object_type.setter
    def target_object_type(self, value):
        self._target_object_type = (value, True)

    @property
    def action_type(self):
        """
        Action type of the Job.

        :rtype: ``basestring``
        """
        return self._action_type[0]

    @action_type.setter
    def action_type(self, value):
        self._action_type = (value, True)

    @property
    def percent_complete(self):
        """
        Completion percentage. This value is a copy of the last event's
        percentComplete. It will be 0 if there are no job events or if the
        events field is not populated while fetching the job.

        :rtype: ``float``
        """
        return self._percent_complete[0]

    @percent_complete.setter
    def percent_complete(self, value):
        self._percent_complete = (value, True)

    @property
    def start_time(self):
        """
        Time the job was created. Note that this is not the time when the job
        started executing.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def parent_action_state(self):
        """
        State of this job's parent action. This value is populated only if the
        job is fetched via the plain get API call. *(permitted values:
        EXECUTING, WAITING, COMPLETED, FAILED, CANCELED)*

        :rtype: ``basestring``
        """
        return self._parent_action_state[0]

    @parent_action_state.setter
    def parent_action_state(self, value):
        self._parent_action_state = (value, True)

    @property
    def email_addresses(self):
        """
        Email addresses to be notified on job notification alerts.

        :rtype: ``list`` of ``basestring``
        """
        return self._email_addresses[0]

    @email_addresses.setter
    def email_addresses(self, value):
        self._email_addresses = (value, True)

    @property
    def target_name(self):
        """
        A cached copy of the target object name.

        :rtype: ``basestring``
        """
        return self._target_name[0]

    @target_name.setter
    def target_name(self, value):
        self._target_name = (value, True)

    @property
    def queued(self):
        """
        Whether this job is waiting for resources to be available for its
        execution.

        :rtype: ``bool``
        """
        return self._queued[0]

    @queued.setter
    def queued(self, value):
        self._queued = (value, True)

    @property
    def user(self):
        """
        User that initiated the action.

        :rtype: ``basestring``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

class WindowsClusterNode(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A node in a
    Windows Cluster.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsClusterNode, self).__init__()
        self._type = ("WindowsClusterNode", True)
        self._discovered = (self.__undef__, True)
        self._cluster = (self.__undef__, True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsClusterNode, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._cluster = (data.get("cluster", obj.__undef__), dirty)
        if obj._cluster[0] is not None and obj._cluster[0] is not obj.__undef__:
            assert isinstance(obj._cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster[0]))
            common.validate_format(obj._cluster[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsClusterNode, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._cluster = (self._cluster[0], True)
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._cluster[1], self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsClusterNode):
            return False
        return super(WindowsClusterNode, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.cluster == other.cluster and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Indicates whether the node is discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def cluster(self):
        """
        A reference to the Windows cluster environment this node belongs to.

        :rtype: ``basestring``
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def host(self):
        """
        A reference to the physical host.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class SystemVersion(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Describes a
    Delphix software revision.
    """
    def __init__(self, undef_enabled=True):
        super(SystemVersion, self).__init__()
        self._type = ("SystemVersion", True)
        self._status = (self.__undef__, True)
        self._verify_date = (self.__undef__, True)
        self._build_date = (self.__undef__, True)
        self._install_date = (self.__undef__, True)
        self._os_running = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._min_os_version = (self.__undef__, True)
        self._os_version = (self.__undef__, True)
        self._min_version = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemVersion, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            common.validate_format(obj._status[0], "None", None, None)
        obj._verify_date = (data.get("verifyDate", obj.__undef__), dirty)
        if obj._verify_date[0] is not None and obj._verify_date[0] is not obj.__undef__:
            assert isinstance(obj._verify_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._verify_date[0]))
            common.validate_format(obj._verify_date[0], "date", None, None)
        obj._build_date = (data.get("buildDate", obj.__undef__), dirty)
        if obj._build_date[0] is not None and obj._build_date[0] is not obj.__undef__:
            assert isinstance(obj._build_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._build_date[0]))
            common.validate_format(obj._build_date[0], "date", None, None)
        obj._install_date = (data.get("installDate", obj.__undef__), dirty)
        if obj._install_date[0] is not None and obj._install_date[0] is not obj.__undef__:
            assert isinstance(obj._install_date[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._install_date[0]))
            common.validate_format(obj._install_date[0], "date", None, None)
        obj._os_running = (data.get("osRunning", obj.__undef__), dirty)
        if obj._os_running[0] is not None and obj._os_running[0] is not obj.__undef__:
            assert isinstance(obj._os_running[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._os_running[0]))
            common.validate_format(obj._os_running[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "None", None, None)
        obj._min_os_version = (data.get("minOsVersion", obj.__undef__), dirty)
        if obj._min_os_version[0] is not None and obj._min_os_version[0] is not obj.__undef__:
            assert isinstance(obj._min_os_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._min_os_version[0]))
            common.validate_format(obj._min_os_version[0], "None", None, None)
        obj._os_version = (data.get("osVersion", obj.__undef__), dirty)
        if obj._os_version[0] is not None and obj._os_version[0] is not obj.__undef__:
            assert isinstance(obj._os_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os_version[0]))
            common.validate_format(obj._os_version[0], "None", None, None)
        obj._min_version = (data.get("minVersion", obj.__undef__), dirty)
        if obj._min_version[0] is not None and obj._min_version[0] is not obj.__undef__:
            assert isinstance(obj._min_version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._min_version[0]))
            common.validate_format(obj._min_version[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemVersion, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "verify_date" == "type" or (self.verify_date is not self.__undef__ and not (dirty and not self._verify_date[1])):
            dct["verifyDate"] = dictify(self.verify_date)
        if "build_date" == "type" or (self.build_date is not self.__undef__ and not (dirty and not self._build_date[1])):
            dct["buildDate"] = dictify(self.build_date)
        if "install_date" == "type" or (self.install_date is not self.__undef__ and not (dirty and not self._install_date[1])):
            dct["installDate"] = dictify(self.install_date)
        if "os_running" == "type" or (self.os_running is not self.__undef__ and not (dirty and not self._os_running[1])):
            dct["osRunning"] = dictify(self.os_running)
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if "min_os_version" == "type" or (self.min_os_version is not self.__undef__ and not (dirty and not self._min_os_version[1])):
            dct["minOsVersion"] = dictify(self.min_os_version)
        if "os_version" == "type" or (self.os_version is not self.__undef__ and not (dirty and not self._os_version[1])):
            dct["osVersion"] = dictify(self.os_version)
        if "min_version" == "type" or (self.min_version is not self.__undef__ and not (dirty and not self._min_version[1])):
            dct["minVersion"] = dictify(self.min_version)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._verify_date = (self._verify_date[0], True)
        self._build_date = (self._build_date[0], True)
        self._install_date = (self._install_date[0], True)
        self._os_running = (self._os_running[0], True)
        self._version = (self._version[0], True)
        self._min_os_version = (self._min_os_version[0], True)
        self._os_version = (self._os_version[0], True)
        self._min_version = (self._min_version[0], True)

    def is_dirty(self):
        return any([self._status[1], self._verify_date[1], self._build_date[1], self._install_date[1], self._os_running[1], self._version[1], self._min_os_version[1], self._os_version[1], self._min_version[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemVersion):
            return False
        return super(SystemVersion, self).__eq__(other) and \
               self.status == other.status and \
               self.verify_date == other.verify_date and \
               self.build_date == other.build_date and \
               self.install_date == other.install_date and \
               self.os_running == other.os_running and \
               self.version == other.version and \
               self.min_os_version == other.min_os_version and \
               self.os_version == other.os_version and \
               self.min_version == other.min_version

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The state of the version.

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def verify_date(self):
        """
        Date on which this version was last verified.

        :rtype: ``basestring``
        """
        return self._verify_date[0]

    @verify_date.setter
    def verify_date(self, value):
        self._verify_date = (value, True)

    @property
    def build_date(self):
        """
        Date on which the version was built.

        :rtype: ``basestring``
        """
        return self._build_date[0]

    @build_date.setter
    def build_date(self, value):
        self._build_date = (value, True)

    @property
    def install_date(self):
        """
        Date on which this version was installed.

        :rtype: ``basestring``
        """
        return self._install_date[0]

    @install_date.setter
    def install_date(self, value):
        self._install_date = (value, True)

    @property
    def os_running(self):
        """
        DelphixOS is running from this version.

        :rtype: ``bool``
        """
        return self._os_running[0]

    @os_running.setter
    def os_running(self, value):
        self._os_running = (value, True)

    @property
    def version(self):
        """
        The Delphix version number.

        :rtype: ``basestring``
        """
        return self._version[0]

    @version.setter
    def version(self, value):
        self._version = (value, True)

    @property
    def min_os_version(self):
        """
        The minimum DelphixOS version supported by this Delphix version.

        :rtype: ``basestring``
        """
        return self._min_os_version[0]

    @min_os_version.setter
    def min_os_version(self, value):
        self._min_os_version = (value, True)

    @property
    def os_version(self):
        """
        The DelphixOS version number.

        :rtype: ``basestring``
        """
        return self._os_version[0]

    @os_version.setter
    def os_version(self, value):
        self._os_version = (value, True)

    @property
    def min_version(self):
        """
        The minimum required Delphix version in order to upgrade.

        :rtype: ``basestring``
        """
        return self._min_version[0]

    @min_version.setter
    def min_version(self, value):
        self._min_version = (value, True)

class Container(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A container
    holding data.
    """
    def __init__(self, undef_enabled=True):
        super(Container, self).__init__()
        self._type = ("Container", True)
        self._group = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._current_timeflow = (self.__undef__, True)
        self._creation_time = (self.__undef__, True)
        self._restoration = (self.__undef__, True)
        self._previous_timeflow = (self.__undef__, True)
        self._masked = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._provision_container = (self.__undef__, True)
        self._transformation = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Container, cls).from_dict(data, dirty, undef_enabled)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        obj._current_timeflow = (data.get("currentTimeflow", obj.__undef__), dirty)
        if obj._current_timeflow[0] is not None and obj._current_timeflow[0] is not obj.__undef__:
            assert isinstance(obj._current_timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._current_timeflow[0]))
            common.validate_format(obj._current_timeflow[0], "objectReference", None, None)
        obj._creation_time = (data.get("creationTime", obj.__undef__), dirty)
        if obj._creation_time[0] is not None and obj._creation_time[0] is not obj.__undef__:
            assert isinstance(obj._creation_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._creation_time[0]))
            common.validate_format(obj._creation_time[0], "date", None, None)
        obj._restoration = (data.get("restoration", obj.__undef__), dirty)
        if obj._restoration[0] is not None and obj._restoration[0] is not obj.__undef__:
            assert isinstance(obj._restoration[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._restoration[0]))
            common.validate_format(obj._restoration[0], "None", None, None)
        obj._previous_timeflow = (data.get("previousTimeflow", obj.__undef__), dirty)
        if obj._previous_timeflow[0] is not None and obj._previous_timeflow[0] is not obj.__undef__:
            assert isinstance(obj._previous_timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._previous_timeflow[0]))
            common.validate_format(obj._previous_timeflow[0], "objectReference", None, None)
        obj._masked = (data.get("masked", obj.__undef__), dirty)
        if obj._masked[0] is not None and obj._masked[0] is not obj.__undef__:
            assert isinstance(obj._masked[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._masked[0]))
            common.validate_format(obj._masked[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "DBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "DBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._provision_container = (data.get("provisionContainer", obj.__undef__), dirty)
        if obj._provision_container[0] is not None and obj._provision_container[0] is not obj.__undef__:
            assert isinstance(obj._provision_container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._provision_container[0]))
            common.validate_format(obj._provision_container[0], "objectReference", None, None)
        obj._transformation = (data.get("transformation", obj.__undef__), dirty)
        if obj._transformation[0] is not None and obj._transformation[0] is not obj.__undef__:
            assert isinstance(obj._transformation[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._transformation[0]))
            common.validate_format(obj._transformation[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Container, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "current_timeflow" == "type" or (self.current_timeflow is not self.__undef__ and not (dirty and not self._current_timeflow[1])):
            dct["currentTimeflow"] = dictify(self.current_timeflow)
        if "creation_time" == "type" or (self.creation_time is not self.__undef__ and not (dirty and not self._creation_time[1])):
            dct["creationTime"] = dictify(self.creation_time)
        if "restoration" == "type" or (self.restoration is not self.__undef__ and not (dirty and not self._restoration[1])):
            dct["restoration"] = dictify(self.restoration)
        if "previous_timeflow" == "type" or (self.previous_timeflow is not self.__undef__ and not (dirty and not self._previous_timeflow[1])):
            dct["previousTimeflow"] = dictify(self.previous_timeflow)
        if "masked" == "type" or (self.masked is not self.__undef__ and not (dirty and not self._masked[1])):
            dct["masked"] = dictify(self.masked)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "provision_container" == "type" or (self.provision_container is not self.__undef__ and not (dirty and not self._provision_container[1])):
            dct["provisionContainer"] = dictify(self.provision_container)
        if "transformation" == "type" or (self.transformation is not self.__undef__ and not (dirty and not self._transformation[1])):
            dct["transformation"] = dictify(self.transformation)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._group = (self._group[0], True)
        self._description = (self._description[0], True)
        self._current_timeflow = (self._current_timeflow[0], True)
        self._creation_time = (self._creation_time[0], True)
        self._restoration = (self._restoration[0], True)
        self._previous_timeflow = (self._previous_timeflow[0], True)
        self._masked = (self._masked[0], True)
        self._runtime = (self._runtime[0], True)
        self._provision_container = (self._provision_container[0], True)
        self._transformation = (self._transformation[0], True)

    def is_dirty(self):
        return any([self._group[1], self._description[1], self._current_timeflow[1], self._creation_time[1], self._restoration[1], self._previous_timeflow[1], self._masked[1], self._runtime[1], self._provision_container[1], self._transformation[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Container):
            return False
        return super(Container, self).__eq__(other) and \
               self.group == other.group and \
               self.description == other.description and \
               self.current_timeflow == other.current_timeflow and \
               self.creation_time == other.creation_time and \
               self.restoration == other.restoration and \
               self.previous_timeflow == other.previous_timeflow and \
               self.masked == other.masked and \
               self.runtime == other.runtime and \
               self.provision_container == other.provision_container and \
               self.transformation == other.transformation

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def group(self):
        """
        A reference to the group containing this container.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

    @property
    def description(self):
        """
        Optional user-provided description for the container.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def current_timeflow(self):
        """
        A reference to the currently active TimeFlow for this container.

        :rtype: ``basestring``
        """
        return self._current_timeflow[0]

    @current_timeflow.setter
    def current_timeflow(self, value):
        self._current_timeflow = (value, True)

    @property
    def creation_time(self):
        """
        The date this container was created.

        :rtype: ``basestring``
        """
        return self._creation_time[0]

    @creation_time.setter
    def creation_time(self, value):
        self._creation_time = (value, True)

    @property
    def restoration(self):
        """
        True if this container is part of a restoration dataset.

        :rtype: ``bool``
        """
        return self._restoration[0]

    @restoration.setter
    def restoration(self, value):
        self._restoration = (value, True)

    @property
    def previous_timeflow(self):
        """
        A reference to the previous TimeFlow for this container.

        :rtype: ``basestring``
        """
        return self._previous_timeflow[0]

    @previous_timeflow.setter
    def previous_timeflow(self, value):
        self._previous_timeflow = (value, True)

    @property
    def masked(self):
        """
        True if this container is a masked container.

        :rtype: ``bool``
        """
        return self._masked[0]

    @masked.setter
    def masked(self, value):
        self._masked = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.DBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def provision_container(self):
        """
        A reference to the container this container was provisioned from.

        :rtype: ``basestring``
        """
        return self._provision_container[0]

    @provision_container.setter
    def provision_container(self, value):
        self._provision_container = (value, True)

    @property
    def transformation(self):
        """
        True if this container is a transformation container.

        :rtype: ``bool``
        """
        return self._transformation[0]

    @transformation.setter
    def transformation(self, value):
        self._transformation = (value, True)

class JSBranch(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A branch
    represents a distinct timeline for data sources in a data layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSBranch, self).__init__()
        self._type = ("JSBranch", True)
        self._data_layout = (self.__undef__, True)
        self._last_operation = (self.__undef__, True)
        self._first_operation = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSBranch, cls).from_dict(data, dirty, undef_enabled)
        obj._data_layout = (data.get("dataLayout", obj.__undef__), dirty)
        if obj._data_layout[0] is not None and obj._data_layout[0] is not obj.__undef__:
            assert isinstance(obj._data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_layout[0]))
            common.validate_format(obj._data_layout[0], "objectReference", None, None)
        obj._last_operation = (data.get("lastOperation", obj.__undef__), dirty)
        if obj._last_operation[0] is not None and obj._last_operation[0] is not obj.__undef__:
            assert isinstance(obj._last_operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_operation[0]))
            common.validate_format(obj._last_operation[0], "objectReference", None, None)
        obj._first_operation = (data.get("firstOperation", obj.__undef__), dirty)
        if obj._first_operation[0] is not None and obj._first_operation[0] is not obj.__undef__:
            assert isinstance(obj._first_operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._first_operation[0]))
            common.validate_format(obj._first_operation[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSBranch, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_layout" == "type" or (self.data_layout is not self.__undef__ and not (dirty and not self._data_layout[1])):
            dct["dataLayout"] = dictify(self.data_layout)
        if "last_operation" == "type" or (self.last_operation is not self.__undef__ and not (dirty and not self._last_operation[1])):
            dct["lastOperation"] = dictify(self.last_operation)
        if "first_operation" == "type" or (self.first_operation is not self.__undef__ and not (dirty and not self._first_operation[1])):
            dct["firstOperation"] = dictify(self.first_operation)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_layout = (self._data_layout[0], True)
        self._last_operation = (self._last_operation[0], True)
        self._first_operation = (self._first_operation[0], True)

    def is_dirty(self):
        return any([self._data_layout[1], self._last_operation[1], self._first_operation[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSBranch):
            return False
        return super(JSBranch, self).__eq__(other) and \
               self.data_layout == other.data_layout and \
               self.last_operation == other.last_operation and \
               self.first_operation == other.first_operation

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_layout(self):
        """
        A reference to the data layout this branch was created on.

        :rtype: ``basestring``
        """
        return self._data_layout[0]

    @data_layout.setter
    def data_layout(self, value):
        self._data_layout = (value, True)

    @property
    def last_operation(self):
        """
        The last JSOperation on this branch by data time.

        :rtype: ``basestring``
        """
        return self._last_operation[0]

    @last_operation.setter
    def last_operation(self, value):
        self._last_operation = (value, True)

    @property
    def first_operation(self):
        """
        The first JSOperation on this branch by data time.

        :rtype: ``basestring``
        """
        return self._first_operation[0]

    @first_operation.setter
    def first_operation(self, value):
        self._first_operation = (value, True)

class DatabaseTemplate(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Parameter
    configuration for virtual databases.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseTemplate, self).__init__()
        self._type = ("DatabaseTemplate", True)
        self._description = (self.__undef__, True)
        self._parameters = (self.__undef__, True)
        self._source_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseTemplate, cls).from_dict(data, dirty, undef_enabled)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._parameters = (data.get("parameters", obj.__undef__), dirty)
        if obj._parameters[0] is not None and obj._parameters[0] is not obj.__undef__:
            assert isinstance(obj._parameters[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._parameters[0]))
            common.validate_format(obj._parameters[0], "None", None, None)
        obj._source_type = (data.get("sourceType", obj.__undef__), dirty)
        if obj._source_type[0] is not None and obj._source_type[0] is not obj.__undef__:
            assert isinstance(obj._source_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_type[0]))
            assert obj._source_type[0] in [u'OracleVirtualSource', u'MSSqlVirtualSource', u'PgSQLVirtualSource'], "Expected enum [u'OracleVirtualSource', u'MSSqlVirtualSource', u'PgSQLVirtualSource'] but got %s" % obj._source_type[0]
            common.validate_format(obj._source_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "parameters" == "type" or (self.parameters is not self.__undef__ and not (dirty and not self._parameters[1])):
            dct["parameters"] = dictify(self.parameters)
        if "source_type" == "type" or (self.source_type is not self.__undef__ and not (dirty and not self._source_type[1])):
            dct["sourceType"] = dictify(self.source_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._description = (self._description[0], True)
        self._parameters = (self._parameters[0], True)
        self._source_type = (self._source_type[0], True)

    def is_dirty(self):
        return any([self._description[1], self._parameters[1], self._source_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseTemplate):
            return False
        return super(DatabaseTemplate, self).__eq__(other) and \
               self.description == other.description and \
               self.parameters == other.parameters and \
               self.source_type == other.source_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def description(self):
        """
        User provided description for this template.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def parameters(self):
        """
        A name/value map of string configuration parameters.

        :rtype: ``dict``
        """
        return self._parameters[0]

    @parameters.setter
    def parameters(self, value):
        self._parameters = (value, True)

    @property
    def source_type(self):
        """
        The type of the source associated with the template. *(permitted
        values: OracleVirtualSource, MSSqlVirtualSource, PgSQLVirtualSource)*

        :rtype: ``basestring``
        """
        return self._source_type[0]

    @source_type.setter
    def source_type(self, value):
        self._source_type = (value, True)

class StatisticSlice(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Collects a slice
    of a multidimensional analytics statistic.
    """
    def __init__(self, undef_enabled=True):
        super(StatisticSlice, self).__init__()
        self._type = ("StatisticSlice", True)
        self._axis_constraints = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._statistic_type = (self.__undef__, True)
        self._data_node = (self.__undef__, True)
        self._collection_axes = (self.__undef__, True)
        self._collection_interval = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StatisticSlice, cls).from_dict(data, dirty, undef_enabled)
        obj._axis_constraints = []
        for item in data.get("axisConstraints") or []:
            obj._axis_constraints.append(factory.create_object(item))
            factory.validate_type(obj._axis_constraints[-1], "AxisConstraint")
        obj._axis_constraints = (obj._axis_constraints, dirty)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'INITIALIZED', u'RUNNING', u'PAUSED', u'FAILED'], "Expected enum [u'INITIALIZED', u'RUNNING', u'PAUSED', u'FAILED'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._statistic_type = (data.get("statisticType", obj.__undef__), dirty)
        if obj._statistic_type[0] is not None and obj._statistic_type[0] is not obj.__undef__:
            assert isinstance(obj._statistic_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._statistic_type[0]))
            common.validate_format(obj._statistic_type[0], "None", None, None)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        obj._collection_axes = []
        for item in data.get("collectionAxes") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._collection_axes.append(item)
        obj._collection_axes = (obj._collection_axes, dirty)
        obj._collection_interval = (data.get("collectionInterval", obj.__undef__), dirty)
        if obj._collection_interval[0] is not None and obj._collection_interval[0] is not obj.__undef__:
            assert isinstance(obj._collection_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._collection_interval[0]))
            common.validate_format(obj._collection_interval[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StatisticSlice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "axis_constraints" == "type" or (self.axis_constraints is not self.__undef__ and not (dirty and not self._axis_constraints[1])):
            dct["axisConstraints"] = dictify(self.axis_constraints)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "statistic_type" == "type" or (self.statistic_type is not self.__undef__ and not (dirty and not self._statistic_type[1])):
            dct["statisticType"] = dictify(self.statistic_type)
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        if "collection_axes" == "type" or (self.collection_axes is not self.__undef__ and not (dirty and not self._collection_axes[1])):
            dct["collectionAxes"] = dictify(self.collection_axes)
        if "collection_interval" == "type" or (self.collection_interval is not self.__undef__ and not (dirty and not self._collection_interval[1])):
            dct["collectionInterval"] = dictify(self.collection_interval)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._axis_constraints = (self._axis_constraints[0], True)
        self._state = (self._state[0], True)
        self._statistic_type = (self._statistic_type[0], True)
        self._data_node = (self._data_node[0], True)
        self._collection_axes = (self._collection_axes[0], True)
        self._collection_interval = (self._collection_interval[0], True)

    def is_dirty(self):
        return any([self._axis_constraints[1], self._state[1], self._statistic_type[1], self._data_node[1], self._collection_axes[1], self._collection_interval[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StatisticSlice):
            return False
        return super(StatisticSlice, self).__eq__(other) and \
               self.axis_constraints == other.axis_constraints and \
               self.state == other.state and \
               self.statistic_type == other.statistic_type and \
               self.data_node == other.data_node and \
               self.collection_axes == other.collection_axes and \
               self.collection_interval == other.collection_interval

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def axis_constraints(self):
        """
        Axis constraints act as per-axis filters on data that is being
        collected.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.AxisConstraint`
        """
        return self._axis_constraints[0]

    @axis_constraints.setter
    def axis_constraints(self, value):
        self._axis_constraints = (value, True)

    @property
    def state(self):
        """
        Collection state of the slice. *(permitted values: INITIALIZED,
        RUNNING, PAUSED, FAILED)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def statistic_type(self):
        """
        The type name for the data this can collect.

        :rtype: ``basestring``
        """
        return self._statistic_type[0]

    @statistic_type.setter
    def statistic_type(self, value):
        self._statistic_type = (value, True)

    @property
    def data_node(self):
        """
        The data node for which to collect analytics statistic.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

    @property
    def collection_axes(self):
        """
        The set of axes to collect (usually these are not constrained axes).

        :rtype: ``list`` of ``basestring``
        """
        return self._collection_axes[0]

    @collection_axes.setter
    def collection_axes(self, value):
        self._collection_axes = (value, True)

    @property
    def collection_interval(self):
        """
        The minimum interval between each reading for this statistic.

        :rtype: ``int``
        """
        return self._collection_interval[0]

    @collection_interval.setter
    def collection_interval(self, value):
        self._collection_interval = (value, True)

class StorageDevice(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A storage device
    on the system.
    """
    def __init__(self, undef_enabled=True):
        super(StorageDevice, self).__init__()
        self._type = ("StorageDevice", True)
        self._vendor = (self.__undef__, True)
        self._configured = (self.__undef__, True)
        self._data_node = (self.__undef__, True)
        self._model = (self.__undef__, True)
        self._serial = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StorageDevice, cls).from_dict(data, dirty, undef_enabled)
        obj._vendor = (data.get("vendor", obj.__undef__), dirty)
        if obj._vendor[0] is not None and obj._vendor[0] is not obj.__undef__:
            assert isinstance(obj._vendor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._vendor[0]))
            common.validate_format(obj._vendor[0], "None", None, None)
        obj._configured = (data.get("configured", obj.__undef__), dirty)
        if obj._configured[0] is not None and obj._configured[0] is not obj.__undef__:
            assert isinstance(obj._configured[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._configured[0]))
            common.validate_format(obj._configured[0], "None", None, None)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        obj._model = (data.get("model", obj.__undef__), dirty)
        if obj._model[0] is not None and obj._model[0] is not obj.__undef__:
            assert isinstance(obj._model[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._model[0]))
            common.validate_format(obj._model[0], "None", None, None)
        obj._serial = (data.get("serial", obj.__undef__), dirty)
        if obj._serial[0] is not None and obj._serial[0] is not obj.__undef__:
            assert isinstance(obj._serial[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._serial[0]))
            common.validate_format(obj._serial[0], "None", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StorageDevice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "vendor" == "type" or (self.vendor is not self.__undef__ and not (dirty and not self._vendor[1])):
            dct["vendor"] = dictify(self.vendor)
        if "configured" == "type" or (self.configured is not self.__undef__ and not (dirty and not self._configured[1])):
            dct["configured"] = dictify(self.configured)
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        if "model" == "type" or (self.model is not self.__undef__ and not (dirty and not self._model[1])):
            dct["model"] = dictify(self.model)
        if "serial" == "type" or (self.serial is not self.__undef__ and not (dirty and not self._serial[1])):
            dct["serial"] = dictify(self.serial)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._vendor = (self._vendor[0], True)
        self._configured = (self._configured[0], True)
        self._data_node = (self._data_node[0], True)
        self._model = (self._model[0], True)
        self._serial = (self._serial[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._vendor[1], self._configured[1], self._data_node[1], self._model[1], self._serial[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StorageDevice):
            return False
        return super(StorageDevice, self).__eq__(other) and \
               self.vendor == other.vendor and \
               self.configured == other.configured and \
               self.data_node == other.data_node and \
               self.model == other.model and \
               self.serial == other.serial and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def vendor(self):
        """
        Vendor ID of the device.

        :rtype: ``basestring``
        """
        return self._vendor[0]

    @vendor.setter
    def vendor(self, value):
        self._vendor = (value, True)

    @property
    def configured(self):
        """
        True if the device is currently configured in the system.

        :rtype: ``bool``
        """
        return self._configured[0]

    @configured.setter
    def configured(self, value):
        self._configured = (value, True)

    @property
    def data_node(self):
        """
        The data node to which the storage device is attached.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

    @property
    def model(self):
        """
        Model ID of the device.

        :rtype: ``basestring``
        """
        return self._model[0]

    @model.setter
    def model(self, value):
        self._model = (value, True)

    @property
    def serial(self):
        """
        Serial number of the device.

        :rtype: ``basestring``
        """
        return self._serial[0]

    @serial.setter
    def serial(self, value):
        self._serial = (value, True)

    @property
    def size(self):
        """
        Physical size of the device, in bytes.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class DataNode(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Server holding
    applications and databases data in a grid deployment model.
    """
    def __init__(self, undef_enabled=True):
        super(DataNode, self).__init__()
        self._type = ("DataNode", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DataNode, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DataNode, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DataNode):
            return False
        return super(DataNode, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class UpgradeCheckResult(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Describes
    unsatisfied upgrade requirements.
    """
    def __init__(self, undef_enabled=True):
        super(UpgradeCheckResult, self).__init__()
        self._type = ("UpgradeCheckResult", True)
        self._status = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._title = (self.__undef__, True)
        self._version = (self.__undef__, True)
        self._action = (self.__undef__, True)
        self._severity = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UpgradeCheckResult, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'ACTIVE', u'IGNORED', u'RESOLVED'], "Expected enum [u'ACTIVE', u'IGNORED', u'RESOLVED'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._title = (data.get("title", obj.__undef__), dirty)
        if obj._title[0] is not None and obj._title[0] is not obj.__undef__:
            assert isinstance(obj._title[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._title[0]))
            common.validate_format(obj._title[0], "None", None, None)
        obj._version = (data.get("version", obj.__undef__), dirty)
        if obj._version[0] is not None and obj._version[0] is not obj.__undef__:
            assert isinstance(obj._version[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._version[0]))
            common.validate_format(obj._version[0], "objectReference", None, None)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "None", None, None)
        obj._severity = (data.get("severity", obj.__undef__), dirty)
        if obj._severity[0] is not None and obj._severity[0] is not obj.__undef__:
            assert isinstance(obj._severity[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._severity[0]))
            assert obj._severity[0] in [u'WARNING', u'CRITICAL'], "Expected enum [u'WARNING', u'CRITICAL'] but got %s" % obj._severity[0]
            common.validate_format(obj._severity[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UpgradeCheckResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if dirty and "status" in dct:
            del dct["status"]
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if dirty and "description" in dct:
            del dct["description"]
        if "title" == "type" or (self.title is not self.__undef__ and not (dirty and not self._title[1])):
            dct["title"] = dictify(self.title)
        if dirty and "title" in dct:
            del dct["title"]
        if "version" == "type" or (self.version is not self.__undef__ and not (dirty and not self._version[1])):
            dct["version"] = dictify(self.version)
        if dirty and "version" in dct:
            del dct["version"]
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if dirty and "action" in dct:
            del dct["action"]
        if "severity" == "type" or (self.severity is not self.__undef__ and not (dirty and not self._severity[1])):
            dct["severity"] = dictify(self.severity)
        if dirty and "severity" in dct:
            del dct["severity"]
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._description = (self._description[0], True)
        self._title = (self._title[0], True)
        self._version = (self._version[0], True)
        self._action = (self._action[0], True)
        self._severity = (self._severity[0], True)

    def is_dirty(self):
        return any([self._status[1], self._description[1], self._title[1], self._version[1], self._action[1], self._severity[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UpgradeCheckResult):
            return False
        return super(UpgradeCheckResult, self).__eq__(other) and \
               self.status == other.status and \
               self.description == other.description and \
               self.title == other.title and \
               self.version == other.version and \
               self.action == other.action and \
               self.severity == other.severity

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        The status of the upgrade check result. *(permitted values: ACTIVE,
        IGNORED, RESOLVED)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @property
    def description(self):
        """
        A localized, textual description of the error.

        :rtype: ``basestring``
        """
        return self._description[0]

    @property
    def title(self):
        """
        A localized string that is the broad category of this check.

        :rtype: ``basestring``
        """
        return self._title[0]

    @property
    def version(self):
        """
        A reference to the upgrade version that generated this check result.

        :rtype: ``basestring``
        """
        return self._version[0]

    @property
    def action(self):
        """
        A localized, textual description of the action the user should take to
        overcome the error.

        :rtype: ``basestring``
        """
        return self._action[0]

    @property
    def severity(self):
        """
        The severity of the missing upgrade requirement. CRITICAL check results
        block the upgrade. *(permitted values: WARNING, CRITICAL)*

        :rtype: ``basestring``
        """
        return self._severity[0]

class JSOperation(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* An operation that
    occurred on a Jet Stream data layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSOperation, self).__init__()
        self._type = ("JSOperation", True)
        self._data_layout = (self.__undef__, True)
        self._data_parent = (self.__undef__, True)
        self._data_time = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._bookmark = (self.__undef__, True)
        self._root_action = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._start_time = (self.__undef__, True)
        self._branch = (self.__undef__, True)
        self._operation = (self.__undef__, True)
        self._end_time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSOperation, cls).from_dict(data, dirty, undef_enabled)
        obj._data_layout = (data.get("dataLayout", obj.__undef__), dirty)
        if obj._data_layout[0] is not None and obj._data_layout[0] is not obj.__undef__:
            assert isinstance(obj._data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_layout[0]))
            common.validate_format(obj._data_layout[0], "objectReference", None, None)
        if "dataParent" in data and data["dataParent"] is not None:
            obj._data_parent = (factory.create_object(data["dataParent"], "JSDataParent"), dirty)
            factory.validate_type(obj._data_parent[0], "JSDataParent")
        else:
            obj._data_parent = (obj.__undef__, dirty)
        obj._data_time = (data.get("dataTime", obj.__undef__), dirty)
        if obj._data_time[0] is not None and obj._data_time[0] is not obj.__undef__:
            assert isinstance(obj._data_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_time[0]))
            common.validate_format(obj._data_time[0], "date", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        obj._root_action = (data.get("rootAction", obj.__undef__), dirty)
        if obj._root_action[0] is not None and obj._root_action[0] is not obj.__undef__:
            assert isinstance(obj._root_action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._root_action[0]))
            common.validate_format(obj._root_action[0], "objectReference", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "objectReference", None, None)
        obj._start_time = (data.get("startTime", obj.__undef__), dirty)
        if obj._start_time[0] is not None and obj._start_time[0] is not obj.__undef__:
            assert isinstance(obj._start_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_time[0]))
            common.validate_format(obj._start_time[0], "date", None, None)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        obj._operation = (data.get("operation", obj.__undef__), dirty)
        if obj._operation[0] is not None and obj._operation[0] is not obj.__undef__:
            assert isinstance(obj._operation[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._operation[0]))
            assert obj._operation[0] in [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'DELETE_BRANCH', u'CREATE_BOOKMARK', u'DELETE_BOOKMARK', u'ENABLE', u'DISABLE', u'ACTIVATE', u'DEACTIVATE', u'RECOVER', u'RESTORE', u'UNDO'], "Expected enum [u'REFRESH', u'RESET', u'CREATE_BRANCH', u'DELETE_BRANCH', u'CREATE_BOOKMARK', u'DELETE_BOOKMARK', u'ENABLE', u'DISABLE', u'ACTIVATE', u'DEACTIVATE', u'RECOVER', u'RESTORE', u'UNDO'] but got %s" % obj._operation[0]
            common.validate_format(obj._operation[0], "None", None, None)
        obj._end_time = (data.get("endTime", obj.__undef__), dirty)
        if obj._end_time[0] is not None and obj._end_time[0] is not obj.__undef__:
            assert isinstance(obj._end_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_time[0]))
            common.validate_format(obj._end_time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSOperation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_layout" == "type" or (self.data_layout is not self.__undef__ and not (dirty and not self._data_layout[1])):
            dct["dataLayout"] = dictify(self.data_layout)
        if "data_parent" == "type" or (self.data_parent is not self.__undef__ and not (dirty and not self._data_parent[1])):
            dct["dataParent"] = dictify(self.data_parent)
        if "data_time" == "type" or (self.data_time is not self.__undef__ and not (dirty and not self._data_time[1])):
            dct["dataTime"] = dictify(self.data_time)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        if "root_action" == "type" or (self.root_action is not self.__undef__ and not (dirty and not self._root_action[1])):
            dct["rootAction"] = dictify(self.root_action)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "start_time" == "type" or (self.start_time is not self.__undef__ and not (dirty and not self._start_time[1])):
            dct["startTime"] = dictify(self.start_time)
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "operation" == "type" or (self.operation is not self.__undef__ and not (dirty and not self._operation[1])):
            dct["operation"] = dictify(self.operation)
        if "end_time" == "type" or (self.end_time is not self.__undef__ and not (dirty and not self._end_time[1])):
            dct["endTime"] = dictify(self.end_time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_layout = (self._data_layout[0], True)
        self._data_parent = (self._data_parent[0], True)
        self._data_time = (self._data_time[0], True)
        self._description = (self._description[0], True)
        self._bookmark = (self._bookmark[0], True)
        self._root_action = (self._root_action[0], True)
        self._user = (self._user[0], True)
        self._start_time = (self._start_time[0], True)
        self._branch = (self._branch[0], True)
        self._operation = (self._operation[0], True)
        self._end_time = (self._end_time[0], True)

    def is_dirty(self):
        return any([self._data_layout[1], self._data_parent[1], self._data_time[1], self._description[1], self._bookmark[1], self._root_action[1], self._user[1], self._start_time[1], self._branch[1], self._operation[1], self._end_time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSOperation):
            return False
        return super(JSOperation, self).__eq__(other) and \
               self.data_layout == other.data_layout and \
               self.data_parent == other.data_parent and \
               self.data_time == other.data_time and \
               self.description == other.description and \
               self.bookmark == other.bookmark and \
               self.root_action == other.root_action and \
               self.user == other.user and \
               self.start_time == other.start_time and \
               self.branch == other.branch and \
               self.operation == other.operation and \
               self.end_time == other.end_time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_layout(self):
        """
        The data layout that this operation was performed on.

        :rtype: ``basestring``
        """
        return self._data_layout[0]

    @data_layout.setter
    def data_layout(self, value):
        self._data_layout = (value, True)

    @property
    def data_parent(self):
        """
        The data parent of the operation.

        :rtype: :py:class:`v1_8_1.web.vo.JSDataParent`
        """
        return self._data_parent[0]

    @data_parent.setter
    def data_parent(self, value):
        self._data_parent = (value, True)

    @property
    def data_time(self):
        """
        The time that the data represented by this operation was active. It
        will be null if the operation is in progress.

        :rtype: ``basestring``
        """
        return self._data_time[0]

    @data_time.setter
    def data_time(self, value):
        self._data_time = (value, True)

    @property
    def description(self):
        """
        Plain text description of the operation.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def bookmark(self):
        """
        The bookmark that was created.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

    @property
    def root_action(self):
        """
        The root action that spawned this operation.

        :rtype: ``basestring``
        """
        return self._root_action[0]

    @root_action.setter
    def root_action(self, value):
        self._root_action = (value, True)

    @property
    def user(self):
        """
        The user who performed the operation.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def start_time(self):
        """
        The time the operation started.

        :rtype: ``basestring``
        """
        return self._start_time[0]

    @start_time.setter
    def start_time(self, value):
        self._start_time = (value, True)

    @property
    def branch(self):
        """
        The branch that this operation was performed on.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def operation(self):
        """
        The operation performed. *(permitted values: REFRESH, RESET,
        CREATE_BRANCH, DELETE_BRANCH, CREATE_BOOKMARK, DELETE_BOOKMARK, ENABLE,
        DISABLE, ACTIVATE, DEACTIVATE, RECOVER, RESTORE, UNDO)*

        :rtype: ``basestring``
        """
        return self._operation[0]

    @operation.setter
    def operation(self, value):
        self._operation = (value, True)

    @property
    def end_time(self):
        """
        The time the operation finished. It will be null if the operation is in
        progress.

        :rtype: ``basestring``
        """
        return self._end_time[0]

    @end_time.setter
    def end_time(self, value):
        self._end_time = (value, True)

class Group(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Database group.
    """
    def __init__(self, undef_enabled=True):
        super(Group, self).__init__()
        self._type = ("Group", True)
        self._data_node = (self.__undef__, True)
        self._description = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Group, cls).from_dict(data, dirty, undef_enabled)
        obj._data_node = (data.get("dataNode", obj.__undef__), dirty)
        if obj._data_node[0] is not None and obj._data_node[0] is not obj.__undef__:
            assert isinstance(obj._data_node[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_node[0]))
            common.validate_format(obj._data_node[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Group, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_node" == "type" or (self.data_node is not self.__undef__ and not (dirty and not self._data_node[1])):
            dct["dataNode"] = dictify(self.data_node)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_node = (self._data_node[0], True)
        self._description = (self._description[0], True)

    def is_dirty(self):
        return any([self._data_node[1], self._description[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Group):
            return False
        return super(Group, self).__eq__(other) and \
               self.data_node == other.data_node and \
               self.description == other.description

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_node(self):
        """
        The data node where databases of this group will be located.

        :rtype: ``basestring``
        """
        return self._data_node[0]

    @data_node.setter
    def data_node(self, value):
        self._data_node = (value, True)

    @property
    def description(self):
        """
        Optional description for the group.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

class JSDataSource(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* The data source
    used for Jet Stream data layouts.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataSource, self).__init__()
        self._type = ("JSDataSource", True)
        self._data_layout = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._enabled = (self.__undef__, True)
        self._priority = (self.__undef__, True)
        self._masked = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._properties = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataSource, cls).from_dict(data, dirty, undef_enabled)
        obj._data_layout = (data.get("dataLayout", obj.__undef__), dirty)
        if obj._data_layout[0] is not None and obj._data_layout[0] is not obj.__undef__:
            assert isinstance(obj._data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_layout[0]))
            common.validate_format(obj._data_layout[0], "objectReference", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, 4096)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        obj._priority = (data.get("priority", obj.__undef__), dirty)
        if obj._priority[0] is not None and obj._priority[0] is not obj.__undef__:
            assert isinstance(obj._priority[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._priority[0]))
            common.validate_format(obj._priority[0], "None", None, None)
        obj._masked = (data.get("masked", obj.__undef__), dirty)
        if obj._masked[0] is not None and obj._masked[0] is not obj.__undef__:
            assert isinstance(obj._masked[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._masked[0]))
            common.validate_format(obj._masked[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "SourceConnectionInfo"), dirty)
            factory.validate_type(obj._runtime[0], "SourceConnectionInfo")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._properties = (data.get("properties", obj.__undef__), dirty)
        if obj._properties[0] is not None and obj._properties[0] is not obj.__undef__:
            assert isinstance(obj._properties[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._properties[0]))
            common.validate_format(obj._properties[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataSource, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_layout" == "type" or (self.data_layout is not self.__undef__ and not (dirty and not self._data_layout[1])):
            dct["dataLayout"] = dictify(self.data_layout)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        if "priority" == "type" or (self.priority is not self.__undef__ and not (dirty and not self._priority[1])):
            dct["priority"] = dictify(self.priority)
        if "masked" == "type" or (self.masked is not self.__undef__ and not (dirty and not self._masked[1])):
            dct["masked"] = dictify(self.masked)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "properties" == "type" or (self.properties is not self.__undef__ and not (dirty and not self._properties[1])):
            dct["properties"] = dictify(self.properties)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_layout = (self._data_layout[0], True)
        self._container = (self._container[0], True)
        self._description = (self._description[0], True)
        self._enabled = (self._enabled[0], True)
        self._priority = (self._priority[0], True)
        self._masked = (self._masked[0], True)
        self._runtime = (self._runtime[0], True)
        self._properties = (self._properties[0], True)

    def is_dirty(self):
        return any([self._data_layout[1], self._container[1], self._description[1], self._enabled[1], self._priority[1], self._masked[1], self._runtime[1], self._properties[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataSource):
            return False
        return super(JSDataSource, self).__eq__(other) and \
               self.data_layout == other.data_layout and \
               self.container == other.container and \
               self.description == other.description and \
               self.enabled == other.enabled and \
               self.priority == other.priority and \
               self.masked == other.masked and \
               self.runtime == other.runtime and \
               self.properties == other.properties

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_layout(self):
        """
        A reference to the Jet Stream data layout to which this source belongs.

        :rtype: ``basestring``
        """
        return self._data_layout[0]

    @data_layout.setter
    def data_layout(self, value):
        self._data_layout = (value, True)

    @property
    def container(self):
        """
        A reference to the underlying container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def description(self):
        """
        A description of this data source.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def enabled(self):
        """
        Flag indicating whether the source is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

    @property
    def priority(self):
        """
        *(default value: 1)* Dictates order of operations on data sources.
        Operations can be performed in parallel for all sources or
        sequentially. Below are possible valid and invalid orderings given an
        example data template with 3 sources (A, B, and C).<br>Valid:<br>A B
        C<br>1 1 1 (parallel)<br>1 2 3 (sequential)<br>Invalid:<br>A B C<br>2 2
        2<br>0 1 2<br>2 3 4<br>1 2 2<br>In the sequential case the data source
        with priority 1 is the first to be started and the last to be stopped.
        This value is set on creation of the template's data sources and copied
        to the data container's data sources.

        :rtype: ``int``
        """
        return self._priority[0]

    @priority.setter
    def priority(self, value):
        self._priority = (value, True)

    @property
    def masked(self):
        """
        Flag indicating whether the source is masked.

        :rtype: ``bool``
        """
        return self._masked[0]

    @masked.setter
    def masked(self, value):
        self._masked = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this data source.

        :rtype: :py:class:`v1_8_1.web.vo.SourceConnectionInfo`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def properties(self):
        """
        Key/value pairs used to specify attributes for this data source.

        :rtype: ``dict``
        """
        return self._properties[0]

    @properties.setter
    def properties(self, value):
        self._properties = (value, True)

class Timeflow(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* Data for a
    particular historical timeline within a database.
    """
    def __init__(self, undef_enabled=True):
        super(Timeflow, self).__init__()
        self._type = ("Timeflow", True)
        self._parent_point = (self.__undef__, True)
        self._parent_snapshot = (self.__undef__, True)
        self._container = (self.__undef__, True)
        self._creation_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(Timeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "TimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "TimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        obj._parent_snapshot = (data.get("parentSnapshot", obj.__undef__), dirty)
        if obj._parent_snapshot[0] is not None and obj._parent_snapshot[0] is not obj.__undef__:
            assert isinstance(obj._parent_snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._parent_snapshot[0]))
            common.validate_format(obj._parent_snapshot[0], "objectReference", None, None)
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._creation_type = (data.get("creationType", obj.__undef__), dirty)
        if obj._creation_type[0] is not None and obj._creation_type[0] is not obj.__undef__:
            assert isinstance(obj._creation_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._creation_type[0]))
            assert obj._creation_type[0] in [u'INITIAL', u'INDETERMINATE', u'REFRESH', u'ROLLBACK', u'TEMPORARY', u'TRANSFORMATION', u'V2P', u'PDB_PLUG', u'WAREHOUSE', u'ORACLE_LIVE_SOURCE_RESYNC'], "Expected enum [u'INITIAL', u'INDETERMINATE', u'REFRESH', u'ROLLBACK', u'TEMPORARY', u'TRANSFORMATION', u'V2P', u'PDB_PLUG', u'WAREHOUSE', u'ORACLE_LIVE_SOURCE_RESYNC'] but got %s" % obj._creation_type[0]
            common.validate_format(obj._creation_type[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(Timeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        if "parent_snapshot" == "type" or (self.parent_snapshot is not self.__undef__ and not (dirty and not self._parent_snapshot[1])):
            dct["parentSnapshot"] = dictify(self.parent_snapshot)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "creation_type" == "type" or (self.creation_type is not self.__undef__ and not (dirty and not self._creation_type[1])):
            dct["creationType"] = dictify(self.creation_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)
        self._parent_snapshot = (self._parent_snapshot[0], True)
        self._container = (self._container[0], True)
        self._creation_type = (self._creation_type[0], True)

    def is_dirty(self):
        return any([self._parent_point[1], self._parent_snapshot[1], self._container[1], self._creation_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, Timeflow):
            return False
        return super(Timeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point and \
               self.parent_snapshot == other.parent_snapshot and \
               self.container == other.container and \
               self.creation_type == other.creation_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

    @property
    def parent_snapshot(self):
        """
        Reference to the parent snapshot that serves as the provisioning base
        for this object. This may be different from the snapshot within the
        parent point, and is only present for virtual TimeFlows.

        :rtype: ``basestring``
        """
        return self._parent_snapshot[0]

    @parent_snapshot.setter
    def parent_snapshot(self, value):
        self._parent_snapshot = (value, True)

    @property
    def container(self):
        """
        Reference to the data container (database) for this TimeFlow.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def creation_type(self):
        """
        The source action that created the TimeFlow. *(permitted values:
        INITIAL, INDETERMINATE, REFRESH, ROLLBACK, TEMPORARY, TRANSFORMATION,
        V2P, PDB_PLUG, WAREHOUSE, ORACLE_LIVE_SOURCE_RESYNC)*

        :rtype: ``basestring``
        """
        return self._creation_type[0]

    @creation_type.setter
    def creation_type(self, value):
        self._creation_type = (value, True)

class TimeflowBookmark(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* A TimeFlow
    bookmark is a user defined name for a TimeFlow point (location or timestamp
    within a TimeFlow).
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowBookmark, self).__init__()
        self._type = ("TimeflowBookmark", True)
        self._timestamp = (self.__undef__, True)
        self._retention_proof = (self.__undef__, True)
        self._tag = (self.__undef__, True)
        self._location = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowBookmark, cls).from_dict(data, dirty, undef_enabled)
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        obj._retention_proof = (data.get("retentionProof", obj.__undef__), dirty)
        if obj._retention_proof[0] is not None and obj._retention_proof[0] is not obj.__undef__:
            assert isinstance(obj._retention_proof[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._retention_proof[0]))
            common.validate_format(obj._retention_proof[0], "None", None, None)
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, 64)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "retention_proof" == "type" or (self.retention_proof is not self.__undef__ and not (dirty and not self._retention_proof[1])):
            dct["retentionProof"] = dictify(self.retention_proof)
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._retention_proof = (self._retention_proof[0], True)
        self._tag = (self._tag[0], True)
        self._location = (self._location[0], True)
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._retention_proof[1], self._tag[1], self._location[1], self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowBookmark):
            return False
        return super(TimeflowBookmark, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.retention_proof == other.retention_proof and \
               self.tag == other.tag and \
               self.location == other.location and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the TimeFlow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def retention_proof(self):
        """
        Indicates whether retention should be allowed to clean up the TimeFlow
        bookmark and associated data.

        :rtype: ``bool``
        """
        return self._retention_proof[0]

    @retention_proof.setter
    def retention_proof(self, value):
        self._retention_proof = (value, True)

    @property
    def tag(self):
        """
        A tag for the bookmark that can be used to group TimeFlow bookmarks
        together or qualify the type of the bookmark.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def location(self):
        """
        The TimeFlow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

    @property
    def timeflow(self):
        """
        Reference to the TimeFlow for this bookmark.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class OracleListener(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* An Oracle
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleListener, self).__init__()
        self._type = ("OracleListener", True)
        self._discovered = (self.__undef__, True)
        self._environment = (self.__undef__, True)
        self._end_points = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleListener, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._environment = (data.get("environment", obj.__undef__), dirty)
        if obj._environment[0] is not None and obj._environment[0] is not obj.__undef__:
            assert isinstance(obj._environment[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment[0]))
            common.validate_format(obj._environment[0], "objectReference", None, None)
        obj._end_points = []
        for item in data.get("endPoints") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "hostnameAndPort", None, None)
            obj._end_points.append(item)
        obj._end_points = (obj._end_points, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "environment" == "type" or (self.environment is not self.__undef__ and not (dirty and not self._environment[1])):
            dct["environment"] = dictify(self.environment)
        if "end_points" == "type" or (self.end_points is not self.__undef__ and not (dirty and not self._end_points[1])):
            dct["endPoints"] = dictify(self.end_points)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._environment = (self._environment[0], True)
        self._end_points = (self._end_points[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._environment[1], self._end_points[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleListener):
            return False
        return super(OracleListener, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.environment == other.environment and \
               self.end_points == other.end_points

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Whether this listener was automatically discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def environment(self):
        """
        Reference to the environment this listener is associated with.

        :rtype: ``basestring``
        """
        return self._environment[0]

    @environment.setter
    def environment(self, value):
        self._environment = (value, True)

    @property
    def end_points(self):
        """
        The list of end points for this listener.

        :rtype: ``list`` of ``basestring``
        """
        return self._end_points[0]

    @end_points.setter
    def end_points(self, value):
        self._end_points = (value, True)

class OracleClusterNode(NamedUserObject):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NamedUserObject` *)* The representation
    of an oracle cluster node object.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterNode, self).__init__()
        self._type = ("OracleClusterNode", True)
        self._discovered = (self.__undef__, True)
        self._cluster = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._virtual_i_ps = (self.__undef__, True)
        self._enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterNode, cls).from_dict(data, dirty, undef_enabled)
        obj._discovered = (data.get("discovered", obj.__undef__), dirty)
        if obj._discovered[0] is not None and obj._discovered[0] is not obj.__undef__:
            assert isinstance(obj._discovered[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._discovered[0]))
            common.validate_format(obj._discovered[0], "None", None, None)
        obj._cluster = (data.get("cluster", obj.__undef__), dirty)
        if obj._cluster[0] is not None and obj._cluster[0] is not obj.__undef__:
            assert isinstance(obj._cluster[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cluster[0]))
            common.validate_format(obj._cluster[0], "objectReference", None, None)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        obj._virtual_i_ps = []
        for item in data.get("virtualIPs") or []:
            obj._virtual_i_ps.append(factory.create_object(item))
            factory.validate_type(obj._virtual_i_ps[-1], "OracleVirtualIP")
        obj._virtual_i_ps = (obj._virtual_i_ps, dirty)
        obj._enabled = (data.get("enabled", obj.__undef__), dirty)
        if obj._enabled[0] is not None and obj._enabled[0] is not obj.__undef__:
            assert isinstance(obj._enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._enabled[0]))
            common.validate_format(obj._enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterNode, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "discovered" == "type" or (self.discovered is not self.__undef__ and not (dirty and not self._discovered[1])):
            dct["discovered"] = dictify(self.discovered)
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "virtual_i_ps" == "type" or (self.virtual_i_ps is not self.__undef__ and not (dirty and not self._virtual_i_ps[1])):
            dct["virtualIPs"] = dictify(self.virtual_i_ps)
        if "enabled" == "type" or (self.enabled is not self.__undef__ and not (dirty and not self._enabled[1])):
            dct["enabled"] = dictify(self.enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._discovered = (self._discovered[0], True)
        self._cluster = (self._cluster[0], True)
        self._host = (self._host[0], True)
        self._virtual_i_ps = (self._virtual_i_ps[0], True)
        self._enabled = (self._enabled[0], True)

    def is_dirty(self):
        return any([self._discovered[1], self._cluster[1], self._host[1], self._virtual_i_ps[1], self._enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterNode):
            return False
        return super(OracleClusterNode, self).__eq__(other) and \
               self.discovered == other.discovered and \
               self.cluster == other.cluster and \
               self.host == other.host and \
               self.virtual_i_ps == other.virtual_i_ps and \
               self.enabled == other.enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def discovered(self):
        """
        Indicates whether the node is discovered.

        :rtype: ``bool``
        """
        return self._discovered[0]

    @discovered.setter
    def discovered(self, value):
        self._discovered = (value, True)

    @property
    def cluster(self):
        """
        The reference to the parent cluster environment.

        :rtype: ``basestring``
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def host(self):
        """
        The reference to the associated host object.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def virtual_i_ps(self):
        """
        The list of virtual IPs belonging to this node.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleVirtualIP`
        """
        return self._virtual_i_ps[0]

    @virtual_i_ps.setter
    def virtual_i_ps(self, value):
        self._virtual_i_ps = (value, True)

    @property
    def enabled(self):
        """
        Indicates whether the node is enabled.

        :rtype: ``bool``
        """
        return self._enabled[0]

    @enabled.setter
    def enabled(self, value):
        self._enabled = (value, True)

class OracleScanListener(OracleListener):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleListener` *)* An Oracle scan
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleScanListener, self).__init__()
        self._type = ("OracleScanListener", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleScanListener, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleScanListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleScanListener):
            return False
        return super(OracleScanListener, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleNodeListener(OracleListener):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleListener` *)* An Oracle node
    listener.
    """
    def __init__(self, undef_enabled=True):
        super(OracleNodeListener, self).__init__()
        self._type = ("OracleNodeListener", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleNodeListener, cls).from_dict(data, dirty, undef_enabled)
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleNodeListener, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleNodeListener):
            return False
        return super(OracleNodeListener, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        Reference to the host this listener is associated with.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class VMwareTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareTimeflow, self).__init__()
        self._type = ("VMwareTimeflow", True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareTimeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "VMwareTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "VMwareTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareTimeflow):
            return False
        return super(VMwareTimeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class PgSQLTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a PostgreSQL container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLTimeflow, self).__init__()
        self._type = ("PgSQLTimeflow", True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLTimeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "PgSQLTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "PgSQLTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLTimeflow):
            return False
        return super(PgSQLTimeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class ASETimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a SAP ASE data container.
    """
    def __init__(self, undef_enabled=True):
        super(ASETimeflow, self).__init__()
        self._type = ("ASETimeflow", True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASETimeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "ASETimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "ASETimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASETimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASETimeflow):
            return False
        return super(ASETimeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.ASETimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class AppDataBaseTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataBaseTimeflow, self).__init__()
        self._type = ("AppDataBaseTimeflow", True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataBaseTimeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "AppDataTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "AppDataTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataBaseTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataBaseTimeflow):
            return False
        return super(AppDataBaseTimeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class MySQLTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a MySQL container.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLTimeflow, self).__init__()
        self._type = ("MySQLTimeflow", True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLTimeflow, cls).from_dict(data, dirty, undef_enabled)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "MySQLTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "MySQLTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLTimeflow):
            return False
        return super(MySQLTimeflow, self).__eq__(other) and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class OracleTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleTimeflow, self).__init__()
        self._type = ("OracleTimeflow", True)
        self._warehouse = (self.__undef__, True)
        self._parent_point = (self.__undef__, True)
        self._incarnation_id = (self.__undef__, True)
        self._warehouse_timeflow = (self.__undef__, True)
        self._cdb_timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTimeflow, cls).from_dict(data, dirty, undef_enabled)
        obj._warehouse = (data.get("warehouse", obj.__undef__), dirty)
        if obj._warehouse[0] is not None and obj._warehouse[0] is not obj.__undef__:
            assert isinstance(obj._warehouse[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._warehouse[0]))
            common.validate_format(obj._warehouse[0], "None", None, None)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "OracleTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "OracleTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        obj._incarnation_id = (data.get("incarnationID", obj.__undef__), dirty)
        if obj._incarnation_id[0] is not None and obj._incarnation_id[0] is not obj.__undef__:
            assert isinstance(obj._incarnation_id[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._incarnation_id[0]))
            common.validate_format(obj._incarnation_id[0], "None", None, None)
        obj._warehouse_timeflow = (data.get("warehouseTimeflow", obj.__undef__), dirty)
        if obj._warehouse_timeflow[0] is not None and obj._warehouse_timeflow[0] is not obj.__undef__:
            assert isinstance(obj._warehouse_timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._warehouse_timeflow[0]))
            common.validate_format(obj._warehouse_timeflow[0], "objectReference", None, None)
        obj._cdb_timeflow = (data.get("cdbTimeflow", obj.__undef__), dirty)
        if obj._cdb_timeflow[0] is not None and obj._cdb_timeflow[0] is not obj.__undef__:
            assert isinstance(obj._cdb_timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._cdb_timeflow[0]))
            common.validate_format(obj._cdb_timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "warehouse" == "type" or (self.warehouse is not self.__undef__ and not (dirty and not self._warehouse[1])):
            dct["warehouse"] = dictify(self.warehouse)
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        if "incarnation_id" == "type" or (self.incarnation_id is not self.__undef__ and not (dirty and not self._incarnation_id[1])):
            dct["incarnationID"] = dictify(self.incarnation_id)
        if "warehouse_timeflow" == "type" or (self.warehouse_timeflow is not self.__undef__ and not (dirty and not self._warehouse_timeflow[1])):
            dct["warehouseTimeflow"] = dictify(self.warehouse_timeflow)
        if "cdb_timeflow" == "type" or (self.cdb_timeflow is not self.__undef__ and not (dirty and not self._cdb_timeflow[1])):
            dct["cdbTimeflow"] = dictify(self.cdb_timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._warehouse = (self._warehouse[0], True)
        self._parent_point = (self._parent_point[0], True)
        self._incarnation_id = (self._incarnation_id[0], True)
        self._warehouse_timeflow = (self._warehouse_timeflow[0], True)
        self._cdb_timeflow = (self._cdb_timeflow[0], True)

    def is_dirty(self):
        return any([self._warehouse[1], self._parent_point[1], self._incarnation_id[1], self._warehouse_timeflow[1], self._cdb_timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTimeflow):
            return False
        return super(OracleTimeflow, self).__eq__(other) and \
               self.warehouse == other.warehouse and \
               self.parent_point == other.parent_point and \
               self.incarnation_id == other.incarnation_id and \
               self.warehouse_timeflow == other.warehouse_timeflow and \
               self.cdb_timeflow == other.cdb_timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def warehouse(self):
        """
        Set to true if the TimeFlow represents a warehouse.

        :rtype: ``bool``
        """
        return self._warehouse[0]

    @warehouse.setter
    def warehouse(self, value):
        self._warehouse = (value, True)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.OracleTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

    @property
    def incarnation_id(self):
        """
        Oracle-specific incarnation identifier for this TimeFlow.

        :rtype: ``basestring``
        """
        return self._incarnation_id[0]

    @incarnation_id.setter
    def incarnation_id(self, value):
        self._incarnation_id = (value, True)

    @property
    def warehouse_timeflow(self):
        """
        Reference to the TimeFlow of the warehouse that this TimeFlow is a part
        of.

        :rtype: ``basestring``
        """
        return self._warehouse_timeflow[0]

    @warehouse_timeflow.setter
    def warehouse_timeflow(self, value):
        self._warehouse_timeflow = (value, True)

    @property
    def cdb_timeflow(self):
        """
        Reference to the mirror CDB TimeFlow if this is a PDB TimeFlow.

        :rtype: ``basestring``
        """
        return self._cdb_timeflow[0]

    @cdb_timeflow.setter
    def cdb_timeflow(self, value):
        self._cdb_timeflow = (value, True)

class MSSqlTimeflow(Timeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Timeflow` *)* TimeFlow representing
    historical data for a particular timeline within a data container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlTimeflow, self).__init__()
        self._type = ("MSSqlTimeflow", True)
        self._database_guid = (self.__undef__, True)
        self._parent_point = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlTimeflow, cls).from_dict(data, dirty, undef_enabled)
        obj._database_guid = (data.get("databaseGuid", obj.__undef__), dirty)
        if obj._database_guid[0] is not None and obj._database_guid[0] is not obj.__undef__:
            assert isinstance(obj._database_guid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_guid[0]))
            common.validate_format(obj._database_guid[0], "None", None, None)
        if "parentPoint" in data and data["parentPoint"] is not None:
            obj._parent_point = (factory.create_object(data["parentPoint"], "MSSqlTimeflowPoint"), dirty)
            factory.validate_type(obj._parent_point[0], "MSSqlTimeflowPoint")
        else:
            obj._parent_point = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "database_guid" == "type" or (self.database_guid is not self.__undef__ and not (dirty and not self._database_guid[1])):
            dct["databaseGuid"] = dictify(self.database_guid)
        if "parent_point" == "type" or (self.parent_point is not self.__undef__ and not (dirty and not self._parent_point[1])):
            dct["parentPoint"] = dictify(self.parent_point)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._database_guid = (self._database_guid[0], True)
        self._parent_point = (self._parent_point[0], True)

    def is_dirty(self):
        return any([self._database_guid[1], self._parent_point[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlTimeflow):
            return False
        return super(MSSqlTimeflow, self).__eq__(other) and \
               self.database_guid == other.database_guid and \
               self.parent_point == other.parent_point

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def database_guid(self):
        """
        MSSQL-specific recovery branch identifier for this TimeFlow.

        :rtype: ``basestring``
        """
        return self._database_guid[0]

    @database_guid.setter
    def database_guid(self, value):
        self._database_guid = (value, True)

    @property
    def parent_point(self):
        """
        The origin point on the parent TimeFlow from which this TimeFlow was
        provisioned. This will not be present for TimeFlows derived from linked
        sources.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlTimeflowPoint`
        """
        return self._parent_point[0]

    @parent_point.setter
    def parent_point(self, value):
        self._parent_point = (value, True)

class AppDataTimeflow(AppDataBaseTimeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataBaseTimeflow` *)* TimeFlow
    representing historical data for a particular timeline within a data
    container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataTimeflow, self).__init__()
        self._type = ("AppDataTimeflow", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataTimeflow, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataTimeflow):
            return False
        return super(AppDataTimeflow, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataWindowsTimeflow(AppDataBaseTimeflow):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AppDataBaseTimeflow` *)* TimeFlow
    representing historical data for a particular timeline within a data
    container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataWindowsTimeflow, self).__init__()
        self._type = ("AppDataWindowsTimeflow", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataWindowsTimeflow, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataWindowsTimeflow, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataWindowsTimeflow):
            return False
        return super(AppDataWindowsTimeflow, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ConfiguredStorageDevice(StorageDevice):
    """
    *(extends* :py:class:`v1_8_1.web.vo.StorageDevice` *)* A storage device
    configured as usable storage.
    """
    def __init__(self, undef_enabled=True):
        super(ConfiguredStorageDevice, self).__init__()
        self._type = ("ConfiguredStorageDevice", True)
        self._boot_device = (self.__undef__, True)
        self._used_size = (self.__undef__, True)
        self._expandable_size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ConfiguredStorageDevice, cls).from_dict(data, dirty, undef_enabled)
        obj._boot_device = (data.get("bootDevice", obj.__undef__), dirty)
        if obj._boot_device[0] is not None and obj._boot_device[0] is not obj.__undef__:
            assert isinstance(obj._boot_device[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._boot_device[0]))
            common.validate_format(obj._boot_device[0], "None", None, None)
        obj._used_size = (data.get("usedSize", obj.__undef__), dirty)
        if obj._used_size[0] is not None and obj._used_size[0] is not obj.__undef__:
            assert isinstance(obj._used_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._used_size[0]))
            common.validate_format(obj._used_size[0], "None", None, None)
        obj._expandable_size = (data.get("expandableSize", obj.__undef__), dirty)
        if obj._expandable_size[0] is not None and obj._expandable_size[0] is not obj.__undef__:
            assert isinstance(obj._expandable_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._expandable_size[0]))
            common.validate_format(obj._expandable_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ConfiguredStorageDevice, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "boot_device" == "type" or (self.boot_device is not self.__undef__ and not (dirty and not self._boot_device[1])):
            dct["bootDevice"] = dictify(self.boot_device)
        if "used_size" == "type" or (self.used_size is not self.__undef__ and not (dirty and not self._used_size[1])):
            dct["usedSize"] = dictify(self.used_size)
        if "expandable_size" == "type" or (self.expandable_size is not self.__undef__ and not (dirty and not self._expandable_size[1])):
            dct["expandableSize"] = dictify(self.expandable_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._boot_device = (self._boot_device[0], True)
        self._used_size = (self._used_size[0], True)
        self._expandable_size = (self._expandable_size[0], True)

    def is_dirty(self):
        return any([self._boot_device[1], self._used_size[1], self._expandable_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ConfiguredStorageDevice):
            return False
        return super(ConfiguredStorageDevice, self).__eq__(other) and \
               self.boot_device == other.boot_device and \
               self.used_size == other.used_size and \
               self.expandable_size == other.expandable_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def boot_device(self):
        """
        Boolean value indicating if this is a boot device.

        :rtype: ``bool``
        """
        return self._boot_device[0]

    @boot_device.setter
    def boot_device(self, value):
        self._boot_device = (value, True)

    @property
    def used_size(self):
        """
        Size of allocated space on the device.

        :rtype: ``float``
        """
        return self._used_size[0]

    @used_size.setter
    def used_size(self, value):
        self._used_size = (value, True)

    @property
    def expandable_size(self):
        """
        Amount of additional space that would be made available, if the device
        is expanded.

        :rtype: ``float``
        """
        return self._expandable_size[0]

    @expandable_size.setter
    def expandable_size(self, value):
        self._expandable_size = (value, True)

class PgSQLDatabaseTemplate(DatabaseTemplate):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseTemplate` *)* Configuration for
    PostgreSQL virtual databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDatabaseTemplate, self).__init__()
        self._type = ("PgSQLDatabaseTemplate", True)
        self._ident_entries = (self.__undef__, True)
        self._hba_entries = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDatabaseTemplate, cls).from_dict(data, dirty, undef_enabled)
        obj._ident_entries = []
        for item in data.get("identEntries") or []:
            obj._ident_entries.append(factory.create_object(item))
            factory.validate_type(obj._ident_entries[-1], "PgSQLIdentEntry")
        obj._ident_entries = (obj._ident_entries, dirty)
        obj._hba_entries = []
        for item in data.get("hbaEntries") or []:
            obj._hba_entries.append(factory.create_object(item))
            factory.validate_type(obj._hba_entries[-1], "PgSQLHBAEntry")
        obj._hba_entries = (obj._hba_entries, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDatabaseTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "ident_entries" == "type" or (self.ident_entries is not self.__undef__ and not (dirty and not self._ident_entries[1])):
            dct["identEntries"] = dictify(self.ident_entries)
        if "hba_entries" == "type" or (self.hba_entries is not self.__undef__ and not (dirty and not self._hba_entries[1])):
            dct["hbaEntries"] = dictify(self.hba_entries)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._ident_entries = (self._ident_entries[0], True)
        self._hba_entries = (self._hba_entries[0], True)

    def is_dirty(self):
        return any([self._ident_entries[1], self._hba_entries[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDatabaseTemplate):
            return False
        return super(PgSQLDatabaseTemplate, self).__eq__(other) and \
               self.ident_entries == other.ident_entries and \
               self.hba_entries == other.hba_entries

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def ident_entries(self):
        """
        Entries in the PostgreSQL username map file (pg_ident.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLIdentEntry`
        """
        return self._ident_entries[0]

    @ident_entries.setter
    def ident_entries(self, value):
        self._ident_entries = (value, True)

    @property
    def hba_entries(self):
        """
        Entries in the PostgreSQL host-based authentication file (pg_hba.conf).

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.PgSQLHBAEntry`
        """
        return self._hba_entries[0]

    @hba_entries.setter
    def hba_entries(self, value):
        self._hba_entries = (value, True)

class VMwareContainer(Container):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Container` *)* Data container for
    VMware virtual machines.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareContainer, self).__init__()
        self._type = ("VMwareContainer", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "VMwareContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "VMwareContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareContainer):
            return False
        return super(VMwareContainer, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class DatabaseContainer(Container):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Container` *)* A container holding
    database data.
    """
    def __init__(self, undef_enabled=True):
        super(DatabaseContainer, self).__init__()
        self._type = ("DatabaseContainer", True)
        self._performance_mode = (self.__undef__, True)
        self._os = (self.__undef__, True)
        self._processor = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._performance_mode = (data.get("performanceMode", obj.__undef__), dirty)
        if obj._performance_mode[0] is not None and obj._performance_mode[0] is not obj.__undef__:
            assert isinstance(obj._performance_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._performance_mode[0]))
            assert obj._performance_mode[0] in [u'ENABLED', u'DISABLED'], "Expected enum [u'ENABLED', u'DISABLED'] but got %s" % obj._performance_mode[0]
            common.validate_format(obj._performance_mode[0], "None", None, None)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            common.validate_format(obj._os[0], "None", None, None)
        obj._processor = (data.get("processor", obj.__undef__), dirty)
        if obj._processor[0] is not None and obj._processor[0] is not obj.__undef__:
            assert isinstance(obj._processor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._processor[0]))
            common.validate_format(obj._processor[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "SourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "SourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "performance_mode" == "type" or (self.performance_mode is not self.__undef__ and not (dirty and not self._performance_mode[1])):
            dct["performanceMode"] = dictify(self.performance_mode)
        if dirty and "performanceMode" in dct:
            del dct["performanceMode"]
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        if "processor" == "type" or (self.processor is not self.__undef__ and not (dirty and not self._processor[1])):
            dct["processor"] = dictify(self.processor)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._performance_mode = (self._performance_mode[0], True)
        self._os = (self._os[0], True)
        self._processor = (self._processor[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)

    def is_dirty(self):
        return any([self._performance_mode[1], self._os[1], self._processor[1], self._sourcing_policy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DatabaseContainer):
            return False
        return super(DatabaseContainer, self).__eq__(other) and \
               self.performance_mode == other.performance_mode and \
               self.os == other.os and \
               self.processor == other.processor and \
               self.sourcing_policy == other.sourcing_policy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def performance_mode(self):
        """
        *(default value: DISABLED)* Whether to enable high performance mode.
        *(permitted values: ENABLED, DISABLED)*

        :rtype: ``basestring``
        """
        return self._performance_mode[0]

    @property
    def os(self):
        """
        Native operating system of the original database source system.

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

    @property
    def processor(self):
        """
        Native processor type of the original database source system.

        :rtype: ``basestring``
        """
        return self._processor[0]

    @processor.setter
    def processor(self, value):
        self._processor = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing LogSync and SnapSync across sources.

        :rtype: :py:class:`v1_8_1.web.vo.SourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

class MSSqlDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* A MSSQL Database
    Container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlDatabaseContainer, self).__init__()
        self._type = ("MSSqlDatabaseContainer", True)
        self._delphix_managed = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._delphix_managed = (data.get("delphixManaged", obj.__undef__), dirty)
        if obj._delphix_managed[0] is not None and obj._delphix_managed[0] is not obj.__undef__:
            assert isinstance(obj._delphix_managed[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._delphix_managed[0]))
            common.validate_format(obj._delphix_managed[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MSSqlDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MSSqlDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "delphix_managed" == "type" or (self.delphix_managed is not self.__undef__ and not (dirty and not self._delphix_managed[1])):
            dct["delphixManaged"] = dictify(self.delphix_managed)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._delphix_managed = (self._delphix_managed[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._delphix_managed[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlDatabaseContainer):
            return False
        return super(MSSqlDatabaseContainer, self).__eq__(other) and \
               self.delphix_managed == other.delphix_managed and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def delphix_managed(self):
        """
        Specifies whether Delphix should managed the backups for this
        container.

        :rtype: ``bool``
        """
        return self._delphix_managed[0]

    @delphix_managed.setter
    def delphix_managed(self, value):
        self._delphix_managed = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class MySQLDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* A MySQL Database
    Container.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLDatabaseContainer, self).__init__()
        self._type = ("MySQLDatabaseContainer", True)
        self._runtime = (self.__undef__, True)
        self._variant = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "MySQLDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "MySQLDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._variant = (data.get("variant", obj.__undef__), dirty)
        if obj._variant[0] is not None and obj._variant[0] is not obj.__undef__:
            assert isinstance(obj._variant[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._variant[0]))
            assert obj._variant[0] in [u'CommunityServer', u'MariaDB'], "Expected enum [u'CommunityServer', u'MariaDB'] but got %s" % obj._variant[0]
            common.validate_format(obj._variant[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "variant" == "type" or (self.variant is not self.__undef__ and not (dirty and not self._variant[1])):
            dct["variant"] = dictify(self.variant)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)
        self._variant = (self._variant[0], True)

    def is_dirty(self):
        return any([self._runtime[1], self._variant[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLDatabaseContainer):
            return False
        return super(MySQLDatabaseContainer, self).__eq__(other) and \
               self.runtime == other.runtime and \
               self.variant == other.variant

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def variant(self):
        """
        Variant of the MySQL installation. *(permitted values: CommunityServer,
        MariaDB)*

        :rtype: ``basestring``
        """
        return self._variant[0]

    @variant.setter
    def variant(self, value):
        self._variant = (value, True)

class PgSQLDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* A PostgreSQL
    Database Container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDatabaseContainer, self).__init__()
        self._type = ("PgSQLDatabaseContainer", True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "PgSQLDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "PgSQLDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDatabaseContainer):
            return False
        return super(PgSQLDatabaseContainer, self).__eq__(other) and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class OracleDatabaseContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* Data container
    for Oracle databases, both linked and virtual.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatabaseContainer, self).__init__()
        self._type = ("OracleDatabaseContainer", True)
        self._content_type = (self.__undef__, True)
        self._physical_standby = (self.__undef__, True)
        self._diagnose_no_logging_faults = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)
        self._performance_mode = (self.__undef__, True)
        self._endianness = (self.__undef__, True)
        self._database_fraction = (self.__undef__, True)
        self._pre_provisioning_enabled = (self.__undef__, True)
        self._runtime = (self.__undef__, True)
        self._cross_platform_ready = (self.__undef__, True)
        self._live_source = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatabaseContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._content_type = (data.get("contentType", obj.__undef__), dirty)
        if obj._content_type[0] is not None and obj._content_type[0] is not obj.__undef__:
            assert isinstance(obj._content_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._content_type[0]))
            assert obj._content_type[0] in [u'PDB', u'ROOT_CDB', u'AUX_CDB', u'NON_CDB'], "Expected enum [u'PDB', u'ROOT_CDB', u'AUX_CDB', u'NON_CDB'] but got %s" % obj._content_type[0]
            common.validate_format(obj._content_type[0], "None", None, None)
        obj._physical_standby = (data.get("physicalStandby", obj.__undef__), dirty)
        if obj._physical_standby[0] is not None and obj._physical_standby[0] is not obj.__undef__:
            assert isinstance(obj._physical_standby[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._physical_standby[0]))
            common.validate_format(obj._physical_standby[0], "None", None, None)
        obj._diagnose_no_logging_faults = (data.get("diagnoseNoLoggingFaults", obj.__undef__), dirty)
        if obj._diagnose_no_logging_faults[0] is not None and obj._diagnose_no_logging_faults[0] is not obj.__undef__:
            assert isinstance(obj._diagnose_no_logging_faults[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._diagnose_no_logging_faults[0]))
            common.validate_format(obj._diagnose_no_logging_faults[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "OracleSourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "OracleSourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        obj._performance_mode = (data.get("performanceMode", obj.__undef__), dirty)
        if obj._performance_mode[0] is not None and obj._performance_mode[0] is not obj.__undef__:
            assert isinstance(obj._performance_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._performance_mode[0]))
            assert obj._performance_mode[0] in [u'ENABLED', u'DISABLED'], "Expected enum [u'ENABLED', u'DISABLED'] but got %s" % obj._performance_mode[0]
            common.validate_format(obj._performance_mode[0], "None", None, None)
        obj._endianness = (data.get("endianness", obj.__undef__), dirty)
        if obj._endianness[0] is not None and obj._endianness[0] is not obj.__undef__:
            assert isinstance(obj._endianness[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._endianness[0]))
            assert obj._endianness[0] in [u'BIG_ENDIAN', u'LITTLE_ENDIAN'], "Expected enum [u'BIG_ENDIAN', u'LITTLE_ENDIAN'] but got %s" % obj._endianness[0]
            common.validate_format(obj._endianness[0], "None", None, None)
        obj._database_fraction = (data.get("databaseFraction", obj.__undef__), dirty)
        if obj._database_fraction[0] is not None and obj._database_fraction[0] is not obj.__undef__:
            assert isinstance(obj._database_fraction[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._database_fraction[0]))
            common.validate_format(obj._database_fraction[0], "None", None, None)
        obj._pre_provisioning_enabled = (data.get("preProvisioningEnabled", obj.__undef__), dirty)
        if obj._pre_provisioning_enabled[0] is not None and obj._pre_provisioning_enabled[0] is not obj.__undef__:
            assert isinstance(obj._pre_provisioning_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._pre_provisioning_enabled[0]))
            common.validate_format(obj._pre_provisioning_enabled[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "OracleDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "OracleDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._cross_platform_ready = (data.get("crossPlatformReady", obj.__undef__), dirty)
        if obj._cross_platform_ready[0] is not None and obj._cross_platform_ready[0] is not obj.__undef__:
            assert isinstance(obj._cross_platform_ready[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._cross_platform_ready[0]))
            common.validate_format(obj._cross_platform_ready[0], "None", None, None)
        obj._live_source = (data.get("liveSource", obj.__undef__), dirty)
        if obj._live_source[0] is not None and obj._live_source[0] is not obj.__undef__:
            assert isinstance(obj._live_source[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._live_source[0]))
            common.validate_format(obj._live_source[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatabaseContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "content_type" == "type" or (self.content_type is not self.__undef__ and not (dirty and not self._content_type[1])):
            dct["contentType"] = dictify(self.content_type)
        if "physical_standby" == "type" or (self.physical_standby is not self.__undef__ and not (dirty and not self._physical_standby[1])):
            dct["physicalStandby"] = dictify(self.physical_standby)
        if "diagnose_no_logging_faults" == "type" or (self.diagnose_no_logging_faults is not self.__undef__ and not (dirty and not self._diagnose_no_logging_faults[1])):
            dct["diagnoseNoLoggingFaults"] = dictify(self.diagnose_no_logging_faults)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        if "performance_mode" == "type" or (self.performance_mode is not self.__undef__ and not (dirty and not self._performance_mode[1])):
            dct["performanceMode"] = dictify(self.performance_mode)
        if "endianness" == "type" or (self.endianness is not self.__undef__ and not (dirty and not self._endianness[1])):
            dct["endianness"] = dictify(self.endianness)
        if "database_fraction" == "type" or (self.database_fraction is not self.__undef__ and not (dirty and not self._database_fraction[1])):
            dct["databaseFraction"] = dictify(self.database_fraction)
        if "pre_provisioning_enabled" == "type" or (self.pre_provisioning_enabled is not self.__undef__ and not (dirty and not self._pre_provisioning_enabled[1])):
            dct["preProvisioningEnabled"] = dictify(self.pre_provisioning_enabled)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "cross_platform_ready" == "type" or (self.cross_platform_ready is not self.__undef__ and not (dirty and not self._cross_platform_ready[1])):
            dct["crossPlatformReady"] = dictify(self.cross_platform_ready)
        if "live_source" == "type" or (self.live_source is not self.__undef__ and not (dirty and not self._live_source[1])):
            dct["liveSource"] = dictify(self.live_source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._content_type = (self._content_type[0], True)
        self._physical_standby = (self._physical_standby[0], True)
        self._diagnose_no_logging_faults = (self._diagnose_no_logging_faults[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)
        self._performance_mode = (self._performance_mode[0], True)
        self._endianness = (self._endianness[0], True)
        self._database_fraction = (self._database_fraction[0], True)
        self._pre_provisioning_enabled = (self._pre_provisioning_enabled[0], True)
        self._runtime = (self._runtime[0], True)
        self._cross_platform_ready = (self._cross_platform_ready[0], True)
        self._live_source = (self._live_source[0], True)

    def is_dirty(self):
        return any([self._content_type[1], self._physical_standby[1], self._diagnose_no_logging_faults[1], self._sourcing_policy[1], self._performance_mode[1], self._endianness[1], self._database_fraction[1], self._pre_provisioning_enabled[1], self._runtime[1], self._cross_platform_ready[1], self._live_source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatabaseContainer):
            return False
        return super(OracleDatabaseContainer, self).__eq__(other) and \
               self.content_type == other.content_type and \
               self.physical_standby == other.physical_standby and \
               self.diagnose_no_logging_faults == other.diagnose_no_logging_faults and \
               self.sourcing_policy == other.sourcing_policy and \
               self.performance_mode == other.performance_mode and \
               self.endianness == other.endianness and \
               self.database_fraction == other.database_fraction and \
               self.pre_provisioning_enabled == other.pre_provisioning_enabled and \
               self.runtime == other.runtime and \
               self.cross_platform_ready == other.cross_platform_ready and \
               self.live_source == other.live_source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def content_type(self):
        """
        Indicates whether this container is for a PDB, CDB root, auxiliary CDB,
        or non-CDB. *(permitted values: PDB, ROOT_CDB, AUX_CDB, NON_CDB)*

        :rtype: ``basestring``
        """
        return self._content_type[0]

    @content_type.setter
    def content_type(self, value):
        self._content_type = (value, True)

    @property
    def physical_standby(self):
        """
        Indicates whether or not the database in this container is a physical
        standby.

        :rtype: ``bool``
        """
        return self._physical_standby[0]

    @physical_standby.setter
    def physical_standby(self, value):
        self._physical_standby = (value, True)

    @property
    def diagnose_no_logging_faults(self):
        """
        *(default value: True)* If true, NOLOGGING operations on this container
        are treated as faults and cannot be resolved manually. Otherwise, these
        operations are ignored.

        :rtype: ``bool``
        """
        return self._diagnose_no_logging_faults[0]

    @diagnose_no_logging_faults.setter
    def diagnose_no_logging_faults(self, value):
        self._diagnose_no_logging_faults = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing LogSync and SnapSync across sources.

        :rtype: :py:class:`v1_8_1.web.vo.OracleSourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

    @property
    def performance_mode(self):
        """
        *(default value: DISABLED)* Whether to enable high performance mode.
        *(permitted values: ENABLED, DISABLED)*

        :rtype: ``basestring``
        """
        return self._performance_mode[0]

    @performance_mode.setter
    def performance_mode(self, value):
        self._performance_mode = (value, True)

    @property
    def endianness(self):
        """
        Native endianness of the original database source system. *(permitted
        values: BIG_ENDIAN, LITTLE_ENDIAN)*

        :rtype: ``basestring``
        """
        return self._endianness[0]

    @endianness.setter
    def endianness(self, value):
        self._endianness = (value, True)

    @property
    def database_fraction(self):
        """
        Indicates whether or not the database in this container consists only
        of transportable tablespaces.

        :rtype: ``bool``
        """
        return self._database_fraction[0]

    @database_fraction.setter
    def database_fraction(self, value):
        self._database_fraction = (value, True)

    @property
    def pre_provisioning_enabled(self):
        """
        If true, pre-provisioning will be performed after every sync.

        :rtype: ``bool``
        """
        return self._pre_provisioning_enabled[0]

    @pre_provisioning_enabled.setter
    def pre_provisioning_enabled(self, value):
        self._pre_provisioning_enabled = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.OracleDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def cross_platform_ready(self):
        """
        Indicates whether or not this container is ready for cross-platform
        provisioning.

        :rtype: ``bool``
        """
        return self._cross_platform_ready[0]

    @cross_platform_ready.setter
    def cross_platform_ready(self, value):
        self._cross_platform_ready = (value, True)

    @property
    def live_source(self):
        """
        Indicates whether or not this container has an associated LiveSource.

        :rtype: ``bool``
        """
        return self._live_source[0]

    @live_source.setter
    def live_source(self, value):
        self._live_source = (value, True)

class AppDataContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* Data container
    for AppData.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataContainer, self).__init__()
        self._type = ("AppDataContainer", True)
        self._guid = (self.__undef__, True)
        self._toolkit = (self.__undef__, True)
        self._restoration = (self.__undef__, True)
        self._runtime = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._guid = (data.get("guid", obj.__undef__), dirty)
        if obj._guid[0] is not None and obj._guid[0] is not obj.__undef__:
            assert isinstance(obj._guid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._guid[0]))
            common.validate_format(obj._guid[0], "None", None, None)
        obj._toolkit = (data.get("toolkit", obj.__undef__), dirty)
        if obj._toolkit[0] is not None and obj._toolkit[0] is not obj.__undef__:
            assert isinstance(obj._toolkit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._toolkit[0]))
            common.validate_format(obj._toolkit[0], "None", None, None)
        obj._restoration = (data.get("restoration", obj.__undef__), dirty)
        if obj._restoration[0] is not None and obj._restoration[0] is not obj.__undef__:
            assert isinstance(obj._restoration[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._restoration[0]))
            common.validate_format(obj._restoration[0], "None", None, None)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "AppDataContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "AppDataContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "guid" == "type" or (self.guid is not self.__undef__ and not (dirty and not self._guid[1])):
            dct["guid"] = dictify(self.guid)
        if "toolkit" == "type" or (self.toolkit is not self.__undef__ and not (dirty and not self._toolkit[1])):
            dct["toolkit"] = dictify(self.toolkit)
        if "restoration" == "type" or (self.restoration is not self.__undef__ and not (dirty and not self._restoration[1])):
            dct["restoration"] = dictify(self.restoration)
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._guid = (self._guid[0], True)
        self._toolkit = (self._toolkit[0], True)
        self._restoration = (self._restoration[0], True)
        self._runtime = (self._runtime[0], True)

    def is_dirty(self):
        return any([self._guid[1], self._toolkit[1], self._restoration[1], self._runtime[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataContainer):
            return False
        return super(AppDataContainer, self).__eq__(other) and \
               self.guid == other.guid and \
               self.toolkit == other.toolkit and \
               self.restoration == other.restoration and \
               self.runtime == other.runtime

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def guid(self):
        """
        A global identifier for this container, including across Delphix
        Engines.

        :rtype: ``basestring``
        """
        return self._guid[0]

    @guid.setter
    def guid(self, value):
        self._guid = (value, True)

    @property
    def toolkit(self):
        """
        The toolkit managing the data in the container.

        :rtype: ``basestring``
        """
        return self._toolkit[0]

    @toolkit.setter
    def toolkit(self, value):
        self._toolkit = (value, True)

    @property
    def restoration(self):
        """
        True if this container is part of a restoration dataset.

        :rtype: ``bool``
        """
        return self._restoration[0]

    @restoration.setter
    def restoration(self, value):
        self._restoration = (value, True)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.AppDataContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

class ASEDBContainer(DatabaseContainer):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DatabaseContainer` *)* An SAP ASE
    Database Container.
    """
    def __init__(self, undef_enabled=True):
        super(ASEDBContainer, self).__init__()
        self._type = ("ASEDBContainer", True)
        self._runtime = (self.__undef__, True)
        self._os = (self.__undef__, True)
        self._processor = (self.__undef__, True)
        self._sourcing_policy = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEDBContainer, cls).from_dict(data, dirty, undef_enabled)
        if "runtime" in data and data["runtime"] is not None:
            obj._runtime = (factory.create_object(data["runtime"], "ASEDBContainerRuntime"), dirty)
            factory.validate_type(obj._runtime[0], "ASEDBContainerRuntime")
        else:
            obj._runtime = (obj.__undef__, dirty)
        obj._os = (data.get("os", obj.__undef__), dirty)
        if obj._os[0] is not None and obj._os[0] is not obj.__undef__:
            assert isinstance(obj._os[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._os[0]))
            common.validate_format(obj._os[0], "None", None, None)
        obj._processor = (data.get("processor", obj.__undef__), dirty)
        if obj._processor[0] is not None and obj._processor[0] is not obj.__undef__:
            assert isinstance(obj._processor[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._processor[0]))
            common.validate_format(obj._processor[0], "None", None, None)
        if "sourcingPolicy" in data and data["sourcingPolicy"] is not None:
            obj._sourcing_policy = (factory.create_object(data["sourcingPolicy"], "SourcingPolicy"), dirty)
            factory.validate_type(obj._sourcing_policy[0], "SourcingPolicy")
        else:
            obj._sourcing_policy = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEDBContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "runtime" == "type" or (self.runtime is not self.__undef__ and not (dirty and not self._runtime[1])):
            dct["runtime"] = dictify(self.runtime)
        if "os" == "type" or (self.os is not self.__undef__ and not (dirty and not self._os[1])):
            dct["os"] = dictify(self.os)
        if "processor" == "type" or (self.processor is not self.__undef__ and not (dirty and not self._processor[1])):
            dct["processor"] = dictify(self.processor)
        if "sourcing_policy" == "type" or (self.sourcing_policy is not self.__undef__ and not (dirty and not self._sourcing_policy[1])):
            dct["sourcingPolicy"] = dictify(self.sourcing_policy)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._runtime = (self._runtime[0], True)
        self._os = (self._os[0], True)
        self._processor = (self._processor[0], True)
        self._sourcing_policy = (self._sourcing_policy[0], True)

    def is_dirty(self):
        return any([self._runtime[1], self._os[1], self._processor[1], self._sourcing_policy[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEDBContainer):
            return False
        return super(ASEDBContainer, self).__eq__(other) and \
               self.runtime == other.runtime and \
               self.os == other.os and \
               self.processor == other.processor and \
               self.sourcing_policy == other.sourcing_policy

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def runtime(self):
        """
        Runtime properties of this container.

        :rtype: :py:class:`v1_8_1.web.vo.ASEDBContainerRuntime`
        """
        return self._runtime[0]

    @runtime.setter
    def runtime(self, value):
        self._runtime = (value, True)

    @property
    def os(self):
        """
        The operating system for the source database.

        :rtype: ``basestring``
        """
        return self._os[0]

    @os.setter
    def os(self, value):
        self._os = (value, True)

    @property
    def processor(self):
        """
        The processor type for the source database.

        :rtype: ``basestring``
        """
        return self._processor[0]

    @processor.setter
    def processor(self, value):
        self._processor = (value, True)

    @property
    def sourcing_policy(self):
        """
        Policies for managing LogSync and SnapSync across sources for an SAP
        ASE container.

        :rtype: :py:class:`v1_8_1.web.vo.SourcingPolicy`
        """
        return self._sourcing_policy[0]

    @sourcing_policy.setter
    def sourcing_policy(self, value):
        self._sourcing_policy = (value, True)

class JSDataContainer(JSDataLayout):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataLayout` *)* A container
    represents a data template provisioned for a specific user.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataContainer, self).__init__()
        self._type = ("JSDataContainer", True)
        self._owner = (self.__undef__, True)
        self._state = (self.__undef__, True)
        self._operation_count = (self.__undef__, True)
        self._template = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataContainer, cls).from_dict(data, dirty, undef_enabled)
        obj._owner = (data.get("owner", obj.__undef__), dirty)
        if obj._owner[0] is not None and obj._owner[0] is not obj.__undef__:
            assert isinstance(obj._owner[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._owner[0]))
            common.validate_format(obj._owner[0], "objectReference", None, None)
        obj._state = (data.get("state", obj.__undef__), dirty)
        if obj._state[0] is not None and obj._state[0] is not obj.__undef__:
            assert isinstance(obj._state[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._state[0]))
            assert obj._state[0] in [u'ONLINE', u'OFFLINE', u'INCONSISTENT'], "Expected enum [u'ONLINE', u'OFFLINE', u'INCONSISTENT'] but got %s" % obj._state[0]
            common.validate_format(obj._state[0], "None", None, None)
        obj._operation_count = (data.get("operationCount", obj.__undef__), dirty)
        if obj._operation_count[0] is not None and obj._operation_count[0] is not obj.__undef__:
            assert isinstance(obj._operation_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._operation_count[0]))
            common.validate_format(obj._operation_count[0], "None", None, None)
        obj._template = (data.get("template", obj.__undef__), dirty)
        if obj._template[0] is not None and obj._template[0] is not obj.__undef__:
            assert isinstance(obj._template[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._template[0]))
            common.validate_format(obj._template[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataContainer, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "owner" == "type" or (self.owner is not self.__undef__ and not (dirty and not self._owner[1])):
            dct["owner"] = dictify(self.owner)
        if "state" == "type" or (self.state is not self.__undef__ and not (dirty and not self._state[1])):
            dct["state"] = dictify(self.state)
        if "operation_count" == "type" or (self.operation_count is not self.__undef__ and not (dirty and not self._operation_count[1])):
            dct["operationCount"] = dictify(self.operation_count)
        if "template" == "type" or (self.template is not self.__undef__ and not (dirty and not self._template[1])):
            dct["template"] = dictify(self.template)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._owner = (self._owner[0], True)
        self._state = (self._state[0], True)
        self._operation_count = (self._operation_count[0], True)
        self._template = (self._template[0], True)

    def is_dirty(self):
        return any([self._owner[1], self._state[1], self._operation_count[1], self._template[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataContainer):
            return False
        return super(JSDataContainer, self).__eq__(other) and \
               self.owner == other.owner and \
               self.state == other.state and \
               self.operation_count == other.operation_count and \
               self.template == other.template

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def owner(self):
        """
        For backward compatibility. The owner of the data container.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._owner[0]

    @owner.setter
    def owner(self, value):
        self._owner = (value, True)

    @property
    def state(self):
        """
        The state of the data container. *(permitted values: ONLINE, OFFLINE,
        INCONSISTENT)*

        :rtype: ``basestring``
        """
        return self._state[0]

    @state.setter
    def state(self, value):
        self._state = (value, True)

    @property
    def operation_count(self):
        """
        The number of operations performed on this data container.

        :rtype: ``int``
        """
        return self._operation_count[0]

    @operation_count.setter
    def operation_count(self, value):
        self._operation_count = (value, True)

    @property
    def template(self):
        """
        The data template that this data container was provisioned from.

        :rtype: ``basestring``
        """
        return self._template[0]

    @template.setter
    def template(self, value):
        self._template = (value, True)

class JSDataTemplate(JSDataLayout):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSDataLayout` *)* A data template is a
    collection of data sources and configuration representing a data layout
    that can be provisioned to Jet Stream users.
    """
    def __init__(self, undef_enabled=True):
        super(JSDataTemplate, self).__init__()
        self._type = ("JSDataTemplate", True)
        self._confirm_time_consuming_operations = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSDataTemplate, cls).from_dict(data, dirty, undef_enabled)
        obj._confirm_time_consuming_operations = (data.get("confirmTimeConsumingOperations", obj.__undef__), dirty)
        if obj._confirm_time_consuming_operations[0] is not None and obj._confirm_time_consuming_operations[0] is not obj.__undef__:
            assert isinstance(obj._confirm_time_consuming_operations[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._confirm_time_consuming_operations[0]))
            common.validate_format(obj._confirm_time_consuming_operations[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSDataTemplate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "confirm_time_consuming_operations" == "type" or (self.confirm_time_consuming_operations is not self.__undef__ and not (dirty and not self._confirm_time_consuming_operations[1])):
            dct["confirmTimeConsumingOperations"] = dictify(self.confirm_time_consuming_operations)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._confirm_time_consuming_operations = (self._confirm_time_consuming_operations[0], True)

    def is_dirty(self):
        return any([self._confirm_time_consuming_operations[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSDataTemplate):
            return False
        return super(JSDataTemplate, self).__eq__(other) and \
               self.confirm_time_consuming_operations == other.confirm_time_consuming_operations

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def confirm_time_consuming_operations(self):
        """
        *(default value: True)* A client should consider warning the user
        before performing an operation which may take a long time, if this is
        true.

        :rtype: ``bool``
        """
        return self._confirm_time_consuming_operations[0]

    @confirm_time_consuming_operations.setter
    def confirm_time_consuming_operations(self, value):
        self._confirm_time_consuming_operations = (value, True)

class SchedulePolicy(Policy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Policy` *)* The base type for all
    schedule policies.
    """
    def __init__(self, undef_enabled=True):
        super(SchedulePolicy, self).__init__()
        self._type = ("SchedulePolicy", True)
        self._timezone = (self.__undef__, True)
        self._schedule_list = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SchedulePolicy, cls).from_dict(data, dirty, undef_enabled)
        if "timezone" in data and data["timezone"] is not None:
            obj._timezone = (factory.create_object(data["timezone"], "TimeZone"), dirty)
            factory.validate_type(obj._timezone[0], "TimeZone")
        else:
            obj._timezone = (obj.__undef__, dirty)
        obj._schedule_list = []
        for item in data.get("scheduleList") or []:
            obj._schedule_list.append(factory.create_object(item))
            factory.validate_type(obj._schedule_list[-1], "Schedule")
        obj._schedule_list = (obj._schedule_list, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SchedulePolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timezone" == "type" or (self.timezone is not self.__undef__ and not (dirty and not self._timezone[1])):
            dct["timezone"] = dictify(self.timezone)
        if "schedule_list" == "type" or (self.schedule_list is not self.__undef__ and not (dirty and not self._schedule_list[1])):
            dct["scheduleList"] = dictify(self.schedule_list)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timezone = (self._timezone[0], True)
        self._schedule_list = (self._schedule_list[0], True)

    def is_dirty(self):
        return any([self._timezone[1], self._schedule_list[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SchedulePolicy):
            return False
        return super(SchedulePolicy, self).__eq__(other) and \
               self.timezone == other.timezone and \
               self.schedule_list == other.schedule_list

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timezone(self):
        """
        The timezone of this policy. If not specified, defaults to the Delphix
        Engine's timezone.

        :rtype: :py:class:`v1_8_1.web.vo.TimeZone`
        """
        return self._timezone[0]

    @timezone.setter
    def timezone(self, value):
        self._timezone = (value, True)

    @property
    def schedule_list(self):
        """
        List of Schedule objects representing when the policy will execute.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.Schedule`
        """
        return self._schedule_list[0]

    @schedule_list.setter
    def schedule_list(self, value):
        self._schedule_list = (value, True)

class QuotaPolicy(Policy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Policy` *)* This policy limits the
    maximum amount of space an object (group or database) can use.
    """
    def __init__(self, undef_enabled=True):
        super(QuotaPolicy, self).__init__()
        self._type = ("QuotaPolicy", True)
        self._crit_alert_time = (self.__undef__, True)
        self._warn_alert_time = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(QuotaPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._crit_alert_time = (data.get("critAlertTime", obj.__undef__), dirty)
        if obj._crit_alert_time[0] is not None and obj._crit_alert_time[0] is not obj.__undef__:
            assert isinstance(obj._crit_alert_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._crit_alert_time[0]))
            common.validate_format(obj._crit_alert_time[0], "date", None, None)
        obj._warn_alert_time = (data.get("warnAlertTime", obj.__undef__), dirty)
        if obj._warn_alert_time[0] is not None and obj._warn_alert_time[0] is not obj.__undef__:
            assert isinstance(obj._warn_alert_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._warn_alert_time[0]))
            common.validate_format(obj._warn_alert_time[0], "date", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(QuotaPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "crit_alert_time" == "type" or (self.crit_alert_time is not self.__undef__ and not (dirty and not self._crit_alert_time[1])):
            dct["critAlertTime"] = dictify(self.crit_alert_time)
        if "warn_alert_time" == "type" or (self.warn_alert_time is not self.__undef__ and not (dirty and not self._warn_alert_time[1])):
            dct["warnAlertTime"] = dictify(self.warn_alert_time)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._crit_alert_time = (self._crit_alert_time[0], True)
        self._warn_alert_time = (self._warn_alert_time[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._crit_alert_time[1], self._warn_alert_time[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, QuotaPolicy):
            return False
        return super(QuotaPolicy, self).__eq__(other) and \
               self.crit_alert_time == other.crit_alert_time and \
               self.warn_alert_time == other.warn_alert_time and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def crit_alert_time(self):
        """
        Last time a critical alert was generated.

        :rtype: ``basestring``
        """
        return self._crit_alert_time[0]

    @crit_alert_time.setter
    def crit_alert_time(self, value):
        self._crit_alert_time = (value, True)

    @property
    def warn_alert_time(self):
        """
        Last time a warning alert was generated.

        :rtype: ``basestring``
        """
        return self._warn_alert_time[0]

    @warn_alert_time.setter
    def warn_alert_time(self, value):
        self._warn_alert_time = (value, True)

    @property
    def size(self):
        """
        Size of the quota, in bytes.

        :rtype: ``float``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class RetentionPolicy(Policy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Policy` *)* This policy controls what
    data (log and snapshot) is kept.
    """
    def __init__(self, undef_enabled=True):
        super(RetentionPolicy, self).__init__()
        self._type = ("RetentionPolicy", True)
        self._day_of_week = (self.__undef__, True)
        self._log_duration = (self.__undef__, True)
        self._num_of_yearly = (self.__undef__, True)
        self._num_of_monthly = (self.__undef__, True)
        self._num_of_daily = (self.__undef__, True)
        self._day_of_year = (self.__undef__, True)
        self._data_duration = (self.__undef__, True)
        self._num_of_weekly = (self.__undef__, True)
        self._data_unit = (self.__undef__, True)
        self._log_unit = (self.__undef__, True)
        self._day_of_month = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RetentionPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._day_of_week = (data.get("dayOfWeek", obj.__undef__), dirty)
        if obj._day_of_week[0] is not None and obj._day_of_week[0] is not obj.__undef__:
            assert isinstance(obj._day_of_week[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._day_of_week[0]))
            assert obj._day_of_week[0] in [u'MONDAY', u'TUESDAY', u'WEDNESDAY', u'THURSDAY', u'FRIDAY', u'SATURDAY', u'SUNDAY'], "Expected enum [u'MONDAY', u'TUESDAY', u'WEDNESDAY', u'THURSDAY', u'FRIDAY', u'SATURDAY', u'SUNDAY'] but got %s" % obj._day_of_week[0]
            common.validate_format(obj._day_of_week[0], "None", None, None)
        obj._log_duration = (data.get("logDuration", obj.__undef__), dirty)
        if obj._log_duration[0] is not None and obj._log_duration[0] is not obj.__undef__:
            assert isinstance(obj._log_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._log_duration[0]))
            common.validate_format(obj._log_duration[0], "None", None, None)
        obj._num_of_yearly = (data.get("numOfYearly", obj.__undef__), dirty)
        if obj._num_of_yearly[0] is not None and obj._num_of_yearly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_yearly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_yearly[0]))
            common.validate_format(obj._num_of_yearly[0], "None", None, None)
        obj._num_of_monthly = (data.get("numOfMonthly", obj.__undef__), dirty)
        if obj._num_of_monthly[0] is not None and obj._num_of_monthly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_monthly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_monthly[0]))
            common.validate_format(obj._num_of_monthly[0], "None", None, None)
        obj._num_of_daily = (data.get("numOfDaily", obj.__undef__), dirty)
        if obj._num_of_daily[0] is not None and obj._num_of_daily[0] is not obj.__undef__:
            assert isinstance(obj._num_of_daily[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_daily[0]))
            common.validate_format(obj._num_of_daily[0], "None", None, None)
        obj._day_of_year = (data.get("dayOfYear", obj.__undef__), dirty)
        if obj._day_of_year[0] is not None and obj._day_of_year[0] is not obj.__undef__:
            assert isinstance(obj._day_of_year[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._day_of_year[0]))
            common.validate_format(obj._day_of_year[0], "None", None, 32)
        obj._data_duration = (data.get("dataDuration", obj.__undef__), dirty)
        if obj._data_duration[0] is not None and obj._data_duration[0] is not obj.__undef__:
            assert isinstance(obj._data_duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._data_duration[0]))
            common.validate_format(obj._data_duration[0], "None", None, None)
        obj._num_of_weekly = (data.get("numOfWeekly", obj.__undef__), dirty)
        if obj._num_of_weekly[0] is not None and obj._num_of_weekly[0] is not obj.__undef__:
            assert isinstance(obj._num_of_weekly[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_of_weekly[0]))
            common.validate_format(obj._num_of_weekly[0], "None", None, None)
        obj._data_unit = (data.get("dataUnit", obj.__undef__), dirty)
        if obj._data_unit[0] is not None and obj._data_unit[0] is not obj.__undef__:
            assert isinstance(obj._data_unit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_unit[0]))
            assert obj._data_unit[0] in [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'], "Expected enum [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'] but got %s" % obj._data_unit[0]
            common.validate_format(obj._data_unit[0], "None", None, None)
        obj._log_unit = (data.get("logUnit", obj.__undef__), dirty)
        if obj._log_unit[0] is not None and obj._log_unit[0] is not obj.__undef__:
            assert isinstance(obj._log_unit[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._log_unit[0]))
            assert obj._log_unit[0] in [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'], "Expected enum [u'DAY', u'WEEK', u'MONTH', u'QUARTER', u'YEAR'] but got %s" % obj._log_unit[0]
            common.validate_format(obj._log_unit[0], "None", None, None)
        obj._day_of_month = (data.get("dayOfMonth", obj.__undef__), dirty)
        if obj._day_of_month[0] is not None and obj._day_of_month[0] is not obj.__undef__:
            assert isinstance(obj._day_of_month[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._day_of_month[0]))
            common.validate_format(obj._day_of_month[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RetentionPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "day_of_week" == "type" or (self.day_of_week is not self.__undef__ and not (dirty and not self._day_of_week[1])):
            dct["dayOfWeek"] = dictify(self.day_of_week)
        if "log_duration" == "type" or (self.log_duration is not self.__undef__ and not (dirty and not self._log_duration[1])):
            dct["logDuration"] = dictify(self.log_duration)
        if "num_of_yearly" == "type" or (self.num_of_yearly is not self.__undef__ and not (dirty and not self._num_of_yearly[1])):
            dct["numOfYearly"] = dictify(self.num_of_yearly)
        if "num_of_monthly" == "type" or (self.num_of_monthly is not self.__undef__ and not (dirty and not self._num_of_monthly[1])):
            dct["numOfMonthly"] = dictify(self.num_of_monthly)
        if "num_of_daily" == "type" or (self.num_of_daily is not self.__undef__ and not (dirty and not self._num_of_daily[1])):
            dct["numOfDaily"] = dictify(self.num_of_daily)
        if "day_of_year" == "type" or (self.day_of_year is not self.__undef__ and not (dirty and not self._day_of_year[1])):
            dct["dayOfYear"] = dictify(self.day_of_year)
        if "data_duration" == "type" or (self.data_duration is not self.__undef__ and not (dirty and not self._data_duration[1])):
            dct["dataDuration"] = dictify(self.data_duration)
        if "num_of_weekly" == "type" or (self.num_of_weekly is not self.__undef__ and not (dirty and not self._num_of_weekly[1])):
            dct["numOfWeekly"] = dictify(self.num_of_weekly)
        if "data_unit" == "type" or (self.data_unit is not self.__undef__ and not (dirty and not self._data_unit[1])):
            dct["dataUnit"] = dictify(self.data_unit)
        if "log_unit" == "type" or (self.log_unit is not self.__undef__ and not (dirty and not self._log_unit[1])):
            dct["logUnit"] = dictify(self.log_unit)
        if "day_of_month" == "type" or (self.day_of_month is not self.__undef__ and not (dirty and not self._day_of_month[1])):
            dct["dayOfMonth"] = dictify(self.day_of_month)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._day_of_week = (self._day_of_week[0], True)
        self._log_duration = (self._log_duration[0], True)
        self._num_of_yearly = (self._num_of_yearly[0], True)
        self._num_of_monthly = (self._num_of_monthly[0], True)
        self._num_of_daily = (self._num_of_daily[0], True)
        self._day_of_year = (self._day_of_year[0], True)
        self._data_duration = (self._data_duration[0], True)
        self._num_of_weekly = (self._num_of_weekly[0], True)
        self._data_unit = (self._data_unit[0], True)
        self._log_unit = (self._log_unit[0], True)
        self._day_of_month = (self._day_of_month[0], True)

    def is_dirty(self):
        return any([self._day_of_week[1], self._log_duration[1], self._num_of_yearly[1], self._num_of_monthly[1], self._num_of_daily[1], self._day_of_year[1], self._data_duration[1], self._num_of_weekly[1], self._data_unit[1], self._log_unit[1], self._day_of_month[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RetentionPolicy):
            return False
        return super(RetentionPolicy, self).__eq__(other) and \
               self.day_of_week == other.day_of_week and \
               self.log_duration == other.log_duration and \
               self.num_of_yearly == other.num_of_yearly and \
               self.num_of_monthly == other.num_of_monthly and \
               self.num_of_daily == other.num_of_daily and \
               self.day_of_year == other.day_of_year and \
               self.data_duration == other.data_duration and \
               self.num_of_weekly == other.num_of_weekly and \
               self.data_unit == other.data_unit and \
               self.log_unit == other.log_unit and \
               self.day_of_month == other.day_of_month

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def day_of_week(self):
        """
        Day of week upon which to enforce weekly snapshot retention.
        *(permitted values: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
        SATURDAY, SUNDAY)*

        :rtype: ``basestring``
        """
        return self._day_of_week[0]

    @day_of_week.setter
    def day_of_week(self, value):
        self._day_of_week = (value, True)

    @property
    def log_duration(self):
        """
        Amount of time (in logUnit units) to keep log data.

        :rtype: ``int``
        """
        return self._log_duration[0]

    @log_duration.setter
    def log_duration(self, value):
        self._log_duration = (value, True)

    @property
    def num_of_yearly(self):
        """
        Number of yearly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_yearly[0]

    @num_of_yearly.setter
    def num_of_yearly(self, value):
        self._num_of_yearly = (value, True)

    @property
    def num_of_monthly(self):
        """
        Number of monthly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_monthly[0]

    @num_of_monthly.setter
    def num_of_monthly(self, value):
        self._num_of_monthly = (value, True)

    @property
    def num_of_daily(self):
        """
        Number of daily snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_daily[0]

    @num_of_daily.setter
    def num_of_daily(self, value):
        self._num_of_daily = (value, True)

    @property
    def day_of_year(self):
        """
        Day of year upon which to enforce yearly snapshot retention, expressed
        a month / day string (e.g., "Jan 1").

        :rtype: ``basestring``
        """
        return self._day_of_year[0]

    @day_of_year.setter
    def day_of_year(self, value):
        self._day_of_year = (value, True)

    @property
    def data_duration(self):
        """
        Amount of time (in dataUnit units) to keep source data.

        :rtype: ``int``
        """
        return self._data_duration[0]

    @data_duration.setter
    def data_duration(self, value):
        self._data_duration = (value, True)

    @property
    def num_of_weekly(self):
        """
        Number of weekly snapshots to keep.

        :rtype: ``int``
        """
        return self._num_of_weekly[0]

    @num_of_weekly.setter
    def num_of_weekly(self, value):
        self._num_of_weekly = (value, True)

    @property
    def data_unit(self):
        """
        Time unit for dataDuration. *(permitted values: DAY, WEEK, MONTH,
        QUARTER, YEAR)*

        :rtype: ``basestring``
        """
        return self._data_unit[0]

    @data_unit.setter
    def data_unit(self, value):
        self._data_unit = (value, True)

    @property
    def log_unit(self):
        """
        Time unit for logDuration. *(permitted values: DAY, WEEK, MONTH,
        QUARTER, YEAR)*

        :rtype: ``basestring``
        """
        return self._log_unit[0]

    @log_unit.setter
    def log_unit(self, value):
        self._log_unit = (value, True)

    @property
    def day_of_month(self):
        """
        Day of month upon which to enforce monthly snapshot retention.

        :rtype: ``int``
        """
        return self._day_of_month[0]

    @day_of_month.setter
    def day_of_month(self, value):
        self._day_of_month = (value, True)

class RefreshPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SchedulePolicy` *)* This policy
    refreshes a container according to a schedule.
    """
    def __init__(self, undef_enabled=True):
        super(RefreshPolicy, self).__init__()
        self._type = ("RefreshPolicy", True)
        self._provision_source = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(RefreshPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._provision_source = (data.get("provisionSource", obj.__undef__), dirty)
        if obj._provision_source[0] is not None and obj._provision_source[0] is not obj.__undef__:
            assert isinstance(obj._provision_source[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._provision_source[0]))
            assert obj._provision_source[0] in [u'LATEST_SNAPSHOT', u'LATEST_TIME_FLOW_LOG'], "Expected enum [u'LATEST_SNAPSHOT', u'LATEST_TIME_FLOW_LOG'] but got %s" % obj._provision_source[0]
            common.validate_format(obj._provision_source[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(RefreshPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "provision_source" == "type" or (self.provision_source is not self.__undef__ and not (dirty and not self._provision_source[1])):
            dct["provisionSource"] = dictify(self.provision_source)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._provision_source = (self._provision_source[0], True)

    def is_dirty(self):
        return any([self._provision_source[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, RefreshPolicy):
            return False
        return super(RefreshPolicy, self).__eq__(other) and \
               self.provision_source == other.provision_source

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def provision_source(self):
        """
        Provision source, either the latest time or latest snapshot.
        *(permitted values: LATEST_SNAPSHOT, LATEST_TIME_FLOW_LOG)*

        :rtype: ``basestring``
        """
        return self._provision_source[0]

    @provision_source.setter
    def provision_source(self, value):
        self._provision_source = (value, True)

class SyncPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SchedulePolicy` *)* This policy syncs a
    container (runs SnapSync) according to the given schedule.
    """
    def __init__(self, undef_enabled=True):
        super(SyncPolicy, self).__init__()
        self._type = ("SyncPolicy", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SyncPolicy, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SyncPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SyncPolicy):
            return False
        return super(SyncPolicy, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SnapshotPolicy(SchedulePolicy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SchedulePolicy` *)* This policy creates
    snapshots of a container with externally managed sources (virtual
    databases) according to a schedule.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotPolicy, self).__init__()
        self._type = ("SnapshotPolicy", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotPolicy, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotPolicy):
            return False
        return super(SnapshotPolicy, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ReplicationList(ReplicationObjectSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReplicationObjectSpecification` *)*
    List of objects that are to be replicated.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationList, self).__init__()
        self._type = ("ReplicationList", True)
        self._objects = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationList, cls).from_dict(data, dirty, undef_enabled)
        obj._objects = []
        for item in data.get("objects") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._objects.append(item)
        obj._objects = (obj._objects, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationList, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "objects" == "type" or (self.objects is not self.__undef__ and not (dirty and not self._objects[1])):
            dct["objects"] = dictify(self.objects)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._objects = (self._objects[0], True)

    def is_dirty(self):
        return any([self._objects[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationList):
            return False
        return super(ReplicationList, self).__eq__(other) and \
               self.objects == other.objects

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def objects(self):
        """
        Objects to replicate, in canonical object reference form.

        :rtype: ``list`` of ``basestring``
        """
        return self._objects[0]

    @objects.setter
    def objects(self, value):
        self._objects = (value, True)

class ReplicationSecureList(ReplicationObjectSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ReplicationObjectSpecification` *)*
    List of containers that are to be securely replicated.
    """
    def __init__(self, undef_enabled=True):
        super(ReplicationSecureList, self).__init__()
        self._type = ("ReplicationSecureList", True)
        self._containers = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ReplicationSecureList, cls).from_dict(data, dirty, undef_enabled)
        obj._containers = []
        for item in data.get("containers") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._containers.append(item)
        obj._containers = (obj._containers, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ReplicationSecureList, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "containers" == "type" or (self.containers is not self.__undef__ and not (dirty and not self._containers[1])):
            dct["containers"] = dictify(self.containers)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._containers = (self._containers[0], True)

    def is_dirty(self):
        return any([self._containers[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ReplicationSecureList):
            return False
        return super(ReplicationSecureList, self).__eq__(other) and \
               self.containers == other.containers

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def containers(self):
        """
        Containers to replicate, in canonical object reference form.

        :rtype: ``list`` of ``basestring``
        """
        return self._containers[0]

    @containers.setter
    def containers(self, value):
        self._containers = (value, True)

class BaseGroupCapacityData(AggregateCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AggregateCapacityData` *)* Capacity
    data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(BaseGroupCapacityData, self).__init__()
        self._type = ("BaseGroupCapacityData", True)
        self._group = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._group = (data.get("group", obj.__undef__), dirty)
        if obj._group[0] is not None and obj._group[0] is not obj.__undef__:
            assert isinstance(obj._group[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._group[0]))
            common.validate_format(obj._group[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "group" == "type" or (self.group is not self.__undef__ and not (dirty and not self._group[1])):
            dct["group"] = dictify(self.group)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._group = (self._group[0], True)

    def is_dirty(self):
        return any([self._group[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseGroupCapacityData):
            return False
        return super(BaseGroupCapacityData, self).__eq__(other) and \
               self.group == other.group

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def group(self):
        """
        Which group these stats represent.

        :rtype: ``basestring``
        """
        return self._group[0]

    @group.setter
    def group(self, value):
        self._group = (value, True)

class BaseSystemCapacityData(AggregateCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AggregateCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(BaseSystemCapacityData, self).__init__()
        self._type = ("BaseSystemCapacityData", True)
        self._total_space = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BaseSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        obj._total_space = (data.get("totalSpace", obj.__undef__), dirty)
        if obj._total_space[0] is not None and obj._total_space[0] is not obj.__undef__:
            assert isinstance(obj._total_space[0], float), ("Expected one of [u'number'], but got %s" % type(obj._total_space[0]))
            common.validate_format(obj._total_space[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BaseSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "total_space" == "type" or (self.total_space is not self.__undef__ and not (dirty and not self._total_space[1])):
            dct["totalSpace"] = dictify(self.total_space)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._total_space = (self._total_space[0], True)

    def is_dirty(self):
        return any([self._total_space[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BaseSystemCapacityData):
            return False
        return super(BaseSystemCapacityData, self).__eq__(other) and \
               self.total_space == other.total_space

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def total_space(self):
        """
        Total storage space (used and unused).

        :rtype: ``float``
        """
        return self._total_space[0]

    @total_space.setter
    def total_space(self, value):
        self._total_space = (value, True)

class HistoricalSystemCapacityData(BaseSystemCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseSystemCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalSystemCapacityData, self).__init__()
        self._type = ("HistoricalSystemCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalSystemCapacityData):
            return False
        return super(HistoricalSystemCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class CurrentSystemCapacityData(BaseSystemCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseSystemCapacityData` *)* Capacity
    data for the entire system.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentSystemCapacityData, self).__init__()
        self._type = ("CurrentSystemCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentSystemCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentSystemCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentSystemCapacityData):
            return False
        return super(CurrentSystemCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class CurrentGroupCapacityData(BaseGroupCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseGroupCapacityData` *)* Capacity
    data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(CurrentGroupCapacityData, self).__init__()
        self._type = ("CurrentGroupCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CurrentGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CurrentGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CurrentGroupCapacityData):
            return False
        return super(CurrentGroupCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class HistoricalGroupCapacityData(BaseGroupCapacityData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BaseGroupCapacityData` *)* Historical
    capacity data aggregated over a group.
    """
    def __init__(self, undef_enabled=True):
        super(HistoricalGroupCapacityData, self).__init__()
        self._type = ("HistoricalGroupCapacityData", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HistoricalGroupCapacityData, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HistoricalGroupCapacityData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HistoricalGroupCapacityData):
            return False
        return super(HistoricalGroupCapacityData, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OKResult(CallResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CallResult` *)* Result of a successful
    API call.
    """
    def __init__(self, undef_enabled=True):
        super(OKResult, self).__init__()
        self._type = ("OKResult", True)
        self._action = (self.__undef__, True)
        self._job = (self.__undef__, True)
        self._result = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OKResult, cls).from_dict(data, dirty, undef_enabled)
        obj._action = (data.get("action", obj.__undef__), dirty)
        if obj._action[0] is not None and obj._action[0] is not obj.__undef__:
            assert isinstance(obj._action[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._action[0]))
            common.validate_format(obj._action[0], "objectReference", None, None)
        obj._job = (data.get("job", obj.__undef__), dirty)
        if obj._job[0] is not None and obj._job[0] is not obj.__undef__:
            assert isinstance(obj._job[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._job[0]))
            common.validate_format(obj._job[0], "objectReference", None, None)
        obj._result = (data.get("result", obj.__undef__), dirty)
        if obj._result[0] is not None and obj._result[0] is not obj.__undef__:
            assert isinstance(obj._result[0], dict) or isinstance(obj._result[0], list) or isinstance(obj._result[0], basestring) or isinstance(obj._result[0], int), ("Expected one of [u'object', u'array', u'string', u'integer'], but got %s" % type(obj._result[0]))
            common.validate_format(obj._result[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OKResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "action" == "type" or (self.action is not self.__undef__ and not (dirty and not self._action[1])):
            dct["action"] = dictify(self.action)
        if "job" == "type" or (self.job is not self.__undef__ and not (dirty and not self._job[1])):
            dct["job"] = dictify(self.job)
        if "result" == "type" or (self.result is not self.__undef__ and not (dirty and not self._result[1])):
            dct["result"] = dictify(self.result)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._action = (self._action[0], True)
        self._job = (self._job[0], True)
        self._result = (self._result[0], True)

    def is_dirty(self):
        return any([self._action[1], self._job[1], self._result[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OKResult):
            return False
        return super(OKResult, self).__eq__(other) and \
               self.action == other.action and \
               self.job == other.job and \
               self.result == other.result

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def action(self):
        """
        Reference to the action associated with the operation, if any.

        :rtype: ``basestring``
        """
        return self._action[0]

    @action.setter
    def action(self, value):
        self._action = (value, True)

    @property
    def job(self):
        """
        Reference to the job started by the operation, if any.

        :rtype: ``basestring``
        """
        return self._job[0]

    @job.setter
    def job(self, value):
        self._job = (value, True)

    @property
    def result(self):
        """
        Result of the operation. This will be specific to the API being
        invoked.

        :rtype: ``dict`` *or* ``list`` *or* ``basestring`` *or* ``int``
        """
        return self._result[0]

    @result.setter
    def result(self, value):
        self._result = (value, True)

class ErrorResult(CallResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CallResult` *)* Result of a failed API
    call.
    """
    def __init__(self, undef_enabled=True):
        super(ErrorResult, self).__init__()
        self._type = ("ErrorResult", True)
        self._error = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ErrorResult, cls).from_dict(data, dirty, undef_enabled)
        if "error" in data and data["error"] is not None:
            obj._error = (factory.create_object(data["error"], "APIError"), dirty)
            factory.validate_type(obj._error[0], "APIError")
        else:
            obj._error = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ErrorResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "error" == "type" or (self.error is not self.__undef__ and not (dirty and not self._error[1])):
            dct["error"] = dictify(self.error)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._error = (self._error[0], True)

    def is_dirty(self):
        return any([self._error[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ErrorResult):
            return False
        return super(ErrorResult, self).__eq__(other) and \
               self.error == other.error

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def error(self):
        """
        Specifics of the error that occurred during API call execution.

        :rtype: :py:class:`v1_8_1.web.vo.APIError`
        """
        return self._error[0]

    @error.setter
    def error(self, value):
        self._error = (value, True)

class DataResult(OKResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OKResult` *)* Result of a successful
    API call containing a reference to a downloadable resource.
    """
    def __init__(self, undef_enabled=True):
        super(DataResult, self).__init__()
        self._type = ("DataResult", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DataResult, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DataResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DataResult):
            return False
        return super(DataResult, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ListResult(OKResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OKResult` *)* Result of a successful
    API call returning a list.
    """
    def __init__(self, undef_enabled=True):
        super(ListResult, self).__init__()
        self._type = ("ListResult", True)
        self._overflow = (self.__undef__, True)
        self._total = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ListResult, cls).from_dict(data, dirty, undef_enabled)
        obj._overflow = (data.get("overflow", obj.__undef__), dirty)
        if obj._overflow[0] is not None and obj._overflow[0] is not obj.__undef__:
            assert isinstance(obj._overflow[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._overflow[0]))
            common.validate_format(obj._overflow[0], "None", None, None)
        obj._total = (data.get("total", obj.__undef__), dirty)
        if obj._total[0] is not None and obj._total[0] is not obj.__undef__:
            assert isinstance(obj._total[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._total[0]))
            common.validate_format(obj._total[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ListResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "overflow" == "type" or (self.overflow is not self.__undef__ and not (dirty and not self._overflow[1])):
            dct["overflow"] = dictify(self.overflow)
        if "total" == "type" or (self.total is not self.__undef__ and not (dirty and not self._total[1])):
            dct["total"] = dictify(self.total)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._overflow = (self._overflow[0], True)
        self._total = (self._total[0], True)

    def is_dirty(self):
        return any([self._overflow[1], self._total[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ListResult):
            return False
        return super(ListResult, self).__eq__(other) and \
               self.overflow == other.overflow and \
               self.total == other.total

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def overflow(self):
        """
        True if the total number of matching items is too large to be
        calculated.

        :rtype: ``bool``
        """
        return self._overflow[0]

    @overflow.setter
    def overflow(self, value):
        self._overflow = (value, True)

    @property
    def total(self):
        """
        The number of items in the entire result set, regardless of the
        requested page size. For some operations, this value is null.

        :rtype: ``int``
        """
        return self._total[0]

    @total.setter
    def total(self, value):
        self._total = (value, True)

class JSTimelinePointBookmarkInput(JSTimelinePointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSTimelinePointParameters` *)*
    Specifies the Jet Stream timeline point using a reference to the Jet Stream
    bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimelinePointBookmarkInput, self).__init__()
        self._type = ("JSTimelinePointBookmarkInput", True)
        self._bookmark = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimelinePointBookmarkInput, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" not in data:
            raise ValueError("Missing required property \"bookmark\".")
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimelinePointBookmarkInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)

    def is_dirty(self):
        return any([self._bookmark[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimelinePointBookmarkInput):
            return False
        return super(JSTimelinePointBookmarkInput, self).__eq__(other) and \
               self.bookmark == other.bookmark

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        The Jet Stream bookmark.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

class JSTimelinePointTimeParameters(JSTimelinePointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSTimelinePointParameters` *)*
    Specifies time related timeline parameters such as time input and latest
    time input.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimelinePointTimeParameters, self).__init__()
        self._type = ("JSTimelinePointTimeParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimelinePointTimeParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimelinePointTimeParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimelinePointTimeParameters):
            return False
        return super(JSTimelinePointTimeParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class JSTimelinePointLatestTimeInput(JSTimelinePointTimeParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSTimelinePointTimeParameters` *)*
    Specifies the use of the latest available data from the given data layout.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimelinePointLatestTimeInput, self).__init__()
        self._type = ("JSTimelinePointLatestTimeInput", True)
        self._source_data_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimelinePointLatestTimeInput, cls).from_dict(data, dirty, undef_enabled)
        if "sourceDataLayout" not in data:
            raise ValueError("Missing required property \"sourceDataLayout\".")
        obj._source_data_layout = (data.get("sourceDataLayout", obj.__undef__), dirty)
        if obj._source_data_layout[0] is not None and obj._source_data_layout[0] is not obj.__undef__:
            assert isinstance(obj._source_data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_data_layout[0]))
            common.validate_format(obj._source_data_layout[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimelinePointLatestTimeInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_data_layout" == "type" or (self.source_data_layout is not self.__undef__ and not (dirty and not self._source_data_layout[1])):
            dct["sourceDataLayout"] = dictify(self.source_data_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_data_layout = (self._source_data_layout[0], True)

    def is_dirty(self):
        return any([self._source_data_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimelinePointLatestTimeInput):
            return False
        return super(JSTimelinePointLatestTimeInput, self).__eq__(other) and \
               self.source_data_layout == other.source_data_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_data_layout(self):
        """
        The reference to the data layout used for this operation.

        :rtype: ``basestring``
        """
        return self._source_data_layout[0]

    @source_data_layout.setter
    def source_data_layout(self, value):
        self._source_data_layout = (value, True)

class JSTimelinePointTimeInput(JSTimelinePointTimeParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSTimelinePointTimeParameters` *)*
    Specifies a point in time on the Jet Stream timeline for a specific branch.
    Latest provisionable points before the specified time will be used.
    """
    def __init__(self, undef_enabled=True):
        super(JSTimelinePointTimeInput, self).__init__()
        self._type = ("JSTimelinePointTimeInput", True)
        self._branch = (self.__undef__, True)
        self._time = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSTimelinePointTimeInput, cls).from_dict(data, dirty, undef_enabled)
        if "branch" not in data:
            raise ValueError("Missing required property \"branch\".")
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        if "time" not in data:
            raise ValueError("Missing required property \"time\".")
        obj._time = (data.get("time", obj.__undef__), dirty)
        if obj._time[0] is not None and obj._time[0] is not obj.__undef__:
            assert isinstance(obj._time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._time[0]))
            common.validate_format(obj._time[0], "date", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSTimelinePointTimeInput, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        if "time" == "type" or (self.time is not self.__undef__ and not (dirty and not self._time[1])):
            dct["time"] = dictify(self.time)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._branch = (self._branch[0], True)
        self._time = (self._time[0], True)

    def is_dirty(self):
        return any([self._branch[1], self._time[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSTimelinePointTimeInput):
            return False
        return super(JSTimelinePointTimeInput, self).__eq__(other) and \
               self.branch == other.branch and \
               self.time == other.time

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def branch(self):
        """
        The reference to the branch used for this operation.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

    @property
    def time(self):
        """
        A point in time on the given branch.

        :rtype: ``basestring``
        """
        return self._time[0]

    @time.setter
    def time(self, value):
        self._time = (value, True)

class PublicKeyCredential(Credential):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Credential` *)* The public key based
    security credential.
    """
    def __init__(self, undef_enabled=True):
        super(PublicKeyCredential, self).__init__()
        self._type = ("PublicKeyCredential", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PublicKeyCredential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PublicKeyCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PublicKeyCredential):
            return False
        return super(PublicKeyCredential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PasswordCredential(Credential):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Credential` *)* The password based
    security credential.
    """
    def __init__(self, undef_enabled=True):
        super(PasswordCredential, self).__init__()
        self._type = ("PasswordCredential", True)
        self._password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PasswordCredential, cls).from_dict(data, dirty, undef_enabled)
        if "password" not in data:
            raise ValueError("Missing required property \"password\".")
        obj._password = (data.get("password", obj.__undef__), dirty)
        if obj._password[0] is not None and obj._password[0] is not obj.__undef__:
            assert isinstance(obj._password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._password[0]))
            common.validate_format(obj._password[0], "password", 1, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PasswordCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "password" == "type" or (self.password is not self.__undef__ and not (dirty and not self._password[1])):
            dct["password"] = dictify(self.password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._password = (self._password[0], True)

    def is_dirty(self):
        return any([self._password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PasswordCredential):
            return False
        return super(PasswordCredential, self).__eq__(other) and \
               self.password == other.password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def password(self):
        """
        The password.

        :rtype: ``basestring``
        """
        return self._password[0]

    @password.setter
    def password(self, value):
        self._password = (value, True)

class SystemKeyCredential(PublicKeyCredential):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PublicKeyCredential` *)* The system
    public key based security credential.
    """
    def __init__(self, undef_enabled=True):
        super(SystemKeyCredential, self).__init__()
        self._type = ("SystemKeyCredential", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemKeyCredential, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemKeyCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemKeyCredential):
            return False
        return super(SystemKeyCredential, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class KeyPairCredential(PublicKeyCredential):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PublicKeyCredential` *)* The public key
    based security credential consisting of a user specified key pair.
    """
    def __init__(self, undef_enabled=True):
        super(KeyPairCredential, self).__init__()
        self._type = ("KeyPairCredential", True)
        self._public_key = (self.__undef__, True)
        self._private_key = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(KeyPairCredential, cls).from_dict(data, dirty, undef_enabled)
        if "publicKey" not in data:
            raise ValueError("Missing required property \"publicKey\".")
        obj._public_key = (data.get("publicKey", obj.__undef__), dirty)
        if obj._public_key[0] is not None and obj._public_key[0] is not obj.__undef__:
            assert isinstance(obj._public_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._public_key[0]))
            common.validate_format(obj._public_key[0], "password", None, None)
        if "privateKey" not in data:
            raise ValueError("Missing required property \"privateKey\".")
        obj._private_key = (data.get("privateKey", obj.__undef__), dirty)
        if obj._private_key[0] is not None and obj._private_key[0] is not obj.__undef__:
            assert isinstance(obj._private_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._private_key[0]))
            common.validate_format(obj._private_key[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(KeyPairCredential, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "public_key" == "type" or (self.public_key is not self.__undef__ and not (dirty and not self._public_key[1])):
            dct["publicKey"] = dictify(self.public_key)
        if "private_key" == "type" or (self.private_key is not self.__undef__ and not (dirty and not self._private_key[1])):
            dct["privateKey"] = dictify(self.private_key)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._public_key = (self._public_key[0], True)
        self._private_key = (self._private_key[0], True)

    def is_dirty(self):
        return any([self._public_key[1], self._private_key[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, KeyPairCredential):
            return False
        return super(KeyPairCredential, self).__eq__(other) and \
               self.public_key == other.public_key and \
               self.private_key == other.private_key

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def public_key(self):
        """
        The public key in the key pair.

        :rtype: ``basestring``
        """
        return self._public_key[0]

    @public_key.setter
    def public_key(self, value):
        self._public_key = (value, True)

    @property
    def private_key(self):
        """
        The private key in the key pair.

        :rtype: ``basestring``
        """
        return self._private_key[0]

    @private_key.setter
    def private_key(self, value):
        self._private_key = (value, True)

class ControlNodeInitializationParameters(SystemInitializationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SystemInitializationParameters` *)*
    Parameters used for initializing a control node.
    """
    def __init__(self, undef_enabled=True):
        super(ControlNodeInitializationParameters, self).__init__()
        self._type = ("ControlNodeInitializationParameters", True)
        self._grid = (self.__undef__, True)
        self._default_user = (self.__undef__, True)
        self._devices = (self.__undef__, True)
        self._default_password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ControlNodeInitializationParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._grid = (data.get("grid", obj.__undef__), dirty)
        if obj._grid[0] is not None and obj._grid[0] is not obj.__undef__:
            assert isinstance(obj._grid[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._grid[0]))
            common.validate_format(obj._grid[0], "None", None, None)
        obj._default_user = (data.get("defaultUser", obj.__undef__), dirty)
        if obj._default_user[0] is not None and obj._default_user[0] is not obj.__undef__:
            assert isinstance(obj._default_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_user[0]))
            common.validate_format(obj._default_user[0], "None", 1, 256)
        obj._devices = []
        for item in data.get("devices") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "objectReference", None, None)
            obj._devices.append(item)
        obj._devices = (obj._devices, dirty)
        obj._default_password = (data.get("defaultPassword", obj.__undef__), dirty)
        if obj._default_password[0] is not None and obj._default_password[0] is not obj.__undef__:
            assert isinstance(obj._default_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._default_password[0]))
            common.validate_format(obj._default_password[0], "password", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ControlNodeInitializationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "grid" == "type" or (self.grid is not self.__undef__ and not (dirty and not self._grid[1])):
            dct["grid"] = dictify(self.grid)
        if "default_user" == "type" or (self.default_user is not self.__undef__ and not (dirty and not self._default_user[1])):
            dct["defaultUser"] = dictify(self.default_user)
        if "devices" == "type" or (self.devices is not self.__undef__ and not (dirty and not self._devices[1])):
            dct["devices"] = dictify(self.devices)
        if "default_password" == "type" or (self.default_password is not self.__undef__ and not (dirty and not self._default_password[1])):
            dct["defaultPassword"] = dictify(self.default_password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._grid = (self._grid[0], True)
        self._default_user = (self._default_user[0], True)
        self._devices = (self._devices[0], True)
        self._default_password = (self._default_password[0], True)

    def is_dirty(self):
        return any([self._grid[1], self._default_user[1], self._devices[1], self._default_password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ControlNodeInitializationParameters):
            return False
        return super(ControlNodeInitializationParameters, self).__eq__(other) and \
               self.grid == other.grid and \
               self.default_user == other.default_user and \
               self.devices == other.devices and \
               self.default_password == other.default_password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def grid(self):
        """
        Indicates if the current machine will be used as a grid control node.

        :rtype: ``bool``
        """
        return self._grid[0]

    @grid.setter
    def grid(self, value):
        self._grid = (value, True)

    @property
    def default_user(self):
        """
        *(default value: delphix_admin)* Name of the default domain
        administrator to create.

        :rtype: ``basestring``
        """
        return self._default_user[0]

    @default_user.setter
    def default_user(self, value):
        self._default_user = (value, True)

    @property
    def devices(self):
        """
        List of storage devices to use for the node which is being initialized.

        :rtype: ``list`` of ``basestring``
        """
        return self._devices[0]

    @devices.setter
    def devices(self, value):
        self._devices = (value, True)

    @property
    def default_password(self):
        """
        *(default value: delphix)* Password to use for the default domain
        administrator.

        :rtype: ``basestring``
        """
        return self._default_password[0]

    @default_password.setter
    def default_password(self, value):
        self._default_password = (value, True)

class DataNodeInitializationParameters(SystemInitializationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SystemInitializationParameters` *)*
    Parameters used for initializing a grid data node.
    """
    def __init__(self, undef_enabled=True):
        super(DataNodeInitializationParameters, self).__init__()
        self._type = ("DataNodeInitializationParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(DataNodeInitializationParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(DataNodeInitializationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, DataNodeInitializationParameters):
            return False
        return super(DataNodeInitializationParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class SystemInfo(PublicSystemInfo):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PublicSystemInfo` *)* Retrieve system-
    wide properties and manage the state of the system.
    """
    def __init__(self, undef_enabled=True):
        super(SystemInfo, self).__init__()
        self._type = ("SystemInfo", True)
        self._hostname = (self.__undef__, True)
        self._processors = (self.__undef__, True)
        self._storage_total = (self.__undef__, True)
        self._ssh_public_key = (self.__undef__, True)
        self._installation_time = (self.__undef__, True)
        self._memory_size = (self.__undef__, True)
        self._platform = (self.__undef__, True)
        self._storage_used = (self.__undef__, True)
        self._uuid = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SystemInfo, cls).from_dict(data, dirty, undef_enabled)
        obj._hostname = (data.get("hostname", obj.__undef__), dirty)
        if obj._hostname[0] is not None and obj._hostname[0] is not obj.__undef__:
            assert isinstance(obj._hostname[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._hostname[0]))
            common.validate_format(obj._hostname[0], "hostname", None, None)
        obj._processors = []
        for item in data.get("processors") or []:
            obj._processors.append(factory.create_object(item))
            factory.validate_type(obj._processors[-1], "CPUInfo")
        obj._processors = (obj._processors, dirty)
        obj._storage_total = (data.get("storageTotal", obj.__undef__), dirty)
        if obj._storage_total[0] is not None and obj._storage_total[0] is not obj.__undef__:
            assert isinstance(obj._storage_total[0], float), ("Expected one of [u'number'], but got %s" % type(obj._storage_total[0]))
            common.validate_format(obj._storage_total[0], "None", None, None)
        obj._ssh_public_key = (data.get("sshPublicKey", obj.__undef__), dirty)
        if obj._ssh_public_key[0] is not None and obj._ssh_public_key[0] is not obj.__undef__:
            assert isinstance(obj._ssh_public_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ssh_public_key[0]))
            common.validate_format(obj._ssh_public_key[0], "None", None, None)
        obj._installation_time = (data.get("installationTime", obj.__undef__), dirty)
        if obj._installation_time[0] is not None and obj._installation_time[0] is not obj.__undef__:
            assert isinstance(obj._installation_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._installation_time[0]))
            common.validate_format(obj._installation_time[0], "date", None, None)
        obj._memory_size = (data.get("memorySize", obj.__undef__), dirty)
        if obj._memory_size[0] is not None and obj._memory_size[0] is not obj.__undef__:
            assert isinstance(obj._memory_size[0], float), ("Expected one of [u'number'], but got %s" % type(obj._memory_size[0]))
            common.validate_format(obj._memory_size[0], "None", None, None)
        obj._platform = (data.get("platform", obj.__undef__), dirty)
        if obj._platform[0] is not None and obj._platform[0] is not obj.__undef__:
            assert isinstance(obj._platform[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._platform[0]))
            common.validate_format(obj._platform[0], "None", None, None)
        obj._storage_used = (data.get("storageUsed", obj.__undef__), dirty)
        if obj._storage_used[0] is not None and obj._storage_used[0] is not obj.__undef__:
            assert isinstance(obj._storage_used[0], float), ("Expected one of [u'number'], but got %s" % type(obj._storage_used[0]))
            common.validate_format(obj._storage_used[0], "None", None, None)
        obj._uuid = (data.get("uuid", obj.__undef__), dirty)
        if obj._uuid[0] is not None and obj._uuid[0] is not obj.__undef__:
            assert isinstance(obj._uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._uuid[0]))
            common.validate_format(obj._uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SystemInfo, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "hostname" == "type" or (self.hostname is not self.__undef__ and not (dirty and not self._hostname[1])):
            dct["hostname"] = dictify(self.hostname)
        if "processors" == "type" or (self.processors is not self.__undef__ and not (dirty and not self._processors[1])):
            dct["processors"] = dictify(self.processors)
        if "storage_total" == "type" or (self.storage_total is not self.__undef__ and not (dirty and not self._storage_total[1])):
            dct["storageTotal"] = dictify(self.storage_total)
        if "ssh_public_key" == "type" or (self.ssh_public_key is not self.__undef__ and not (dirty and not self._ssh_public_key[1])):
            dct["sshPublicKey"] = dictify(self.ssh_public_key)
        if "installation_time" == "type" or (self.installation_time is not self.__undef__ and not (dirty and not self._installation_time[1])):
            dct["installationTime"] = dictify(self.installation_time)
        if "memory_size" == "type" or (self.memory_size is not self.__undef__ and not (dirty and not self._memory_size[1])):
            dct["memorySize"] = dictify(self.memory_size)
        if "platform" == "type" or (self.platform is not self.__undef__ and not (dirty and not self._platform[1])):
            dct["platform"] = dictify(self.platform)
        if "storage_used" == "type" or (self.storage_used is not self.__undef__ and not (dirty and not self._storage_used[1])):
            dct["storageUsed"] = dictify(self.storage_used)
        if "uuid" == "type" or (self.uuid is not self.__undef__ and not (dirty and not self._uuid[1])):
            dct["uuid"] = dictify(self.uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._hostname = (self._hostname[0], True)
        self._processors = (self._processors[0], True)
        self._storage_total = (self._storage_total[0], True)
        self._ssh_public_key = (self._ssh_public_key[0], True)
        self._installation_time = (self._installation_time[0], True)
        self._memory_size = (self._memory_size[0], True)
        self._platform = (self._platform[0], True)
        self._storage_used = (self._storage_used[0], True)
        self._uuid = (self._uuid[0], True)

    def is_dirty(self):
        return any([self._hostname[1], self._processors[1], self._storage_total[1], self._ssh_public_key[1], self._installation_time[1], self._memory_size[1], self._platform[1], self._storage_used[1], self._uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SystemInfo):
            return False
        return super(SystemInfo, self).__eq__(other) and \
               self.hostname == other.hostname and \
               self.processors == other.processors and \
               self.storage_total == other.storage_total and \
               self.ssh_public_key == other.ssh_public_key and \
               self.installation_time == other.installation_time and \
               self.memory_size == other.memory_size and \
               self.platform == other.platform and \
               self.storage_used == other.storage_used and \
               self.uuid == other.uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def hostname(self):
        """
        System hostname.

        :rtype: ``basestring``
        """
        return self._hostname[0]

    @hostname.setter
    def hostname(self, value):
        self._hostname = (value, True)

    @property
    def processors(self):
        """
        Processors on the system.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.CPUInfo`
        """
        return self._processors[0]

    @processors.setter
    def processors(self, value):
        self._processors = (value, True)

    @property
    def storage_total(self):
        """
        Total amount of raw storage allocated for dSources, VDBs, and system
        metadata. Zero if storage has not yet been configured.

        :rtype: ``float``
        """
        return self._storage_total[0]

    @storage_total.setter
    def storage_total(self, value):
        self._storage_total = (value, True)

    @property
    def ssh_public_key(self):
        """
        SSH public key to be added to SSH authorized_keys for environment users
        using the SystemKeyCredential authorization mechanism.

        :rtype: ``basestring``
        """
        return self._ssh_public_key[0]

    @ssh_public_key.setter
    def ssh_public_key(self, value):
        self._ssh_public_key = (value, True)

    @property
    def installation_time(self):
        """
        The date and time that the Delphix Engine was installed.

        :rtype: ``basestring``
        """
        return self._installation_time[0]

    @installation_time.setter
    def installation_time(self, value):
        self._installation_time = (value, True)

    @property
    def memory_size(self):
        """
        Total memory on the system, in bytes.

        :rtype: ``float``
        """
        return self._memory_size[0]

    @memory_size.setter
    def memory_size(self, value):
        self._memory_size = (value, True)

    @property
    def platform(self):
        """
        Description of the current system platform.

        :rtype: ``basestring``
        """
        return self._platform[0]

    @platform.setter
    def platform(self, value):
        self._platform = (value, True)

    @property
    def storage_used(self):
        """
        Amount of raw storage used by dSources, VDBs and system metadata.

        :rtype: ``float``
        """
        return self._storage_used[0]

    @storage_used.setter
    def storage_used(self, value):
        self._storage_used = (value, True)

    @property
    def uuid(self):
        """
        Globally unique identifier for this software installation.

        :rtype: ``basestring``
        """
        return self._uuid[0]

    @uuid.setter
    def uuid(self, value):
        self._uuid = (value, True)

class ASEAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the SAP ASE
    specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(ASEAttachData, self).__init__()
        self._type = ("ASEAttachData", True)
        self._operations = (self.__undef__, True)
        self._staging_repository = (self.__undef__, True)
        self._load_location = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._dump_credentials = (self.__undef__, True)
        self._staging_host_user = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._load_backup_path = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEAttachData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "stagingRepository" not in data:
            raise ValueError("Missing required property \"stagingRepository\".")
        obj._staging_repository = (data.get("stagingRepository", obj.__undef__), dirty)
        if obj._staging_repository[0] is not None and obj._staging_repository[0] is not obj.__undef__:
            assert isinstance(obj._staging_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_repository[0]))
            common.validate_format(obj._staging_repository[0], "objectReference", None, None)
        if "loadLocation" in data and data["loadLocation"] is not None:
            obj._load_location = (factory.create_object(data["loadLocation"], "ASEBackupLocation"), dirty)
            factory.validate_type(obj._load_location[0], "ASEBackupLocation")
        else:
            obj._load_location = (obj.__undef__, dirty)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'ENABLED', u'DISABLED'], "Expected enum [u'ENABLED', u'DISABLED'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        if "dumpCredentials" in data and data["dumpCredentials"] is not None:
            obj._dump_credentials = (factory.create_object(data["dumpCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._dump_credentials[0], "PasswordCredential")
        else:
            obj._dump_credentials = (obj.__undef__, dirty)
        if "stagingHostUser" not in data:
            raise ValueError("Missing required property \"stagingHostUser\".")
        obj._staging_host_user = (data.get("stagingHostUser", obj.__undef__), dirty)
        if obj._staging_host_user[0] is not None and obj._staging_host_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_host_user[0]))
            common.validate_format(obj._staging_host_user[0], "objectReference", None, None)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "sourceHostUser" not in data:
            raise ValueError("Missing required property \"sourceHostUser\".")
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "loadBackupPath" not in data:
            raise ValueError("Missing required property \"loadBackupPath\".")
        obj._load_backup_path = (data.get("loadBackupPath", obj.__undef__), dirty)
        if obj._load_backup_path[0] is not None and obj._load_backup_path[0] is not obj.__undef__:
            assert isinstance(obj._load_backup_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._load_backup_path[0]))
            common.validate_format(obj._load_backup_path[0], "None", None, 1024)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "staging_repository" == "type" or (self.staging_repository is not self.__undef__ and not (dirty and not self._staging_repository[1])):
            dct["stagingRepository"] = dictify(self.staging_repository)
        if "load_location" == "type" or (self.load_location is not self.__undef__ and not (dirty and not self._load_location[1])):
            dct["loadLocation"] = dictify(self.load_location)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "dump_credentials" == "type" or (self.dump_credentials is not self.__undef__ and not (dirty and not self._dump_credentials[1])):
            dct["dumpCredentials"] = dictify(self.dump_credentials)
        if "staging_host_user" == "type" or (self.staging_host_user is not self.__undef__ and not (dirty and not self._staging_host_user[1])):
            dct["stagingHostUser"] = dictify(self.staging_host_user)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "load_backup_path" == "type" or (self.load_backup_path is not self.__undef__ and not (dirty and not self._load_backup_path[1])):
            dct["loadBackupPath"] = dictify(self.load_backup_path)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._staging_repository = (self._staging_repository[0], True)
        self._load_location = (self._load_location[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._dump_credentials = (self._dump_credentials[0], True)
        self._staging_host_user = (self._staging_host_user[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._db_user = (self._db_user[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._config = (self._config[0], True)
        self._load_backup_path = (self._load_backup_path[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._staging_repository[1], self._load_location[1], self._external_file_path[1], self._validated_sync_mode[1], self._dump_credentials[1], self._staging_host_user[1], self._staging_post_script[1], self._db_credentials[1], self._db_user[1], self._source_host_user[1], self._staging_pre_script[1], self._config[1], self._load_backup_path[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEAttachData):
            return False
        return super(ASEAttachData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.staging_repository == other.staging_repository and \
               self.load_location == other.load_location and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.dump_credentials == other.dump_credentials and \
               self.staging_host_user == other.staging_host_user and \
               self.staging_post_script == other.staging_post_script and \
               self.db_credentials == other.db_credentials and \
               self.db_user == other.db_user and \
               self.source_host_user == other.source_host_user and \
               self.staging_pre_script == other.staging_pre_script and \
               self.config == other.config and \
               self.load_backup_path == other.load_backup_path

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def staging_repository(self):
        """
        The SAP ASE instance on the staging environment that we want to use for
        validated sync.

        :rtype: ``basestring``
        """
        return self._staging_repository[0]

    @staging_repository.setter
    def staging_repository(self, value):
        self._staging_repository = (value, True)

    @property
    def load_location(self):
        """
        Backup location to use for loading backups from the source.

        :rtype: :py:class:`v1_8_1.web.vo.ASEBackupLocation`
        """
        return self._load_location[0]

    @load_location.setter
    def load_location(self, value):
        self._load_location = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: ENABLED)* Specifies the validated sync mode to
        synchronize the dSource with the source database. *(permitted values:
        ENABLED, DISABLED)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def dump_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._dump_credentials[0]

    @dump_credentials.setter
    def dump_credentials(self, value):
        self._dump_credentials = (value, True)

    @property
    def staging_host_user(self):
        """
        Information about the host OS user on the staging environment to use
        for linking.

        :rtype: ``basestring``
        """
        return self._staging_host_user[0]

    @staging_host_user.setter
    def staging_host_user(self, value):
        self._staging_host_user = (value, True)

    @property
    def staging_post_script(self):
        """
        A user-provided shell script or executable to run after restoring from
        a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def db_credentials(self):
        """
        The credential for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def db_user(self):
        """
        The user name for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def source_host_user(self):
        """
        Information about the host OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def staging_pre_script(self):
        """
        A user-provided shell script or executable to run prior to restoring
        from a backup during validated sync.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def load_backup_path(self):
        """
        Source database backup location.

        :rtype: ``basestring``
        """
        return self._load_backup_path[0]

    @load_backup_path.setter
    def load_backup_path(self, value):
        self._load_backup_path = (value, True)

class MySQLAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the MySQL
    parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLAttachData, self).__init__()
        self._type = ("MySQLAttachData", True)
        self._config_params = (self.__undef__, True)
        self._operations = (self.__undef__, True)
        self._staging_repository = (self.__undef__, True)
        self._staging_port = (self.__undef__, True)
        self._staging_host_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._config = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLAttachData, cls).from_dict(data, dirty, undef_enabled)
        obj._config_params = (data.get("configParams", obj.__undef__), dirty)
        if obj._config_params[0] is not None and obj._config_params[0] is not obj.__undef__:
            assert isinstance(obj._config_params[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._config_params[0]))
            common.validate_format(obj._config_params[0], "None", None, None)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        if "stagingRepository" not in data:
            raise ValueError("Missing required property \"stagingRepository\".")
        obj._staging_repository = (data.get("stagingRepository", obj.__undef__), dirty)
        if obj._staging_repository[0] is not None and obj._staging_repository[0] is not obj.__undef__:
            assert isinstance(obj._staging_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_repository[0]))
            common.validate_format(obj._staging_repository[0], "objectReference", None, None)
        if "stagingPort" not in data:
            raise ValueError("Missing required property \"stagingPort\".")
        obj._staging_port = (data.get("stagingPort", obj.__undef__), dirty)
        if obj._staging_port[0] is not None and obj._staging_port[0] is not obj.__undef__:
            assert isinstance(obj._staging_port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._staging_port[0]))
            common.validate_format(obj._staging_port[0], "None", None, None)
        if "stagingHostUser" not in data:
            raise ValueError("Missing required property \"stagingHostUser\".")
        obj._staging_host_user = (data.get("stagingHostUser", obj.__undef__), dirty)
        if obj._staging_host_user[0] is not None and obj._staging_host_user[0] is not obj.__undef__:
            assert isinstance(obj._staging_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_host_user[0]))
            common.validate_format(obj._staging_host_user[0], "objectReference", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config_params" == "type" or (self.config_params is not self.__undef__ and not (dirty and not self._config_params[1])):
            dct["configParams"] = dictify(self.config_params)
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "staging_repository" == "type" or (self.staging_repository is not self.__undef__ and not (dirty and not self._staging_repository[1])):
            dct["stagingRepository"] = dictify(self.staging_repository)
        if "staging_port" == "type" or (self.staging_port is not self.__undef__ and not (dirty and not self._staging_port[1])):
            dct["stagingPort"] = dictify(self.staging_port)
        if "staging_host_user" == "type" or (self.staging_host_user is not self.__undef__ and not (dirty and not self._staging_host_user[1])):
            dct["stagingHostUser"] = dictify(self.staging_host_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config_params = (self._config_params[0], True)
        self._operations = (self._operations[0], True)
        self._staging_repository = (self._staging_repository[0], True)
        self._staging_port = (self._staging_port[0], True)
        self._staging_host_user = (self._staging_host_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._db_user = (self._db_user[0], True)
        self._config = (self._config[0], True)

    def is_dirty(self):
        return any([self._config_params[1], self._operations[1], self._staging_repository[1], self._staging_port[1], self._staging_host_user[1], self._db_credentials[1], self._db_user[1], self._config[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLAttachData):
            return False
        return super(MySQLAttachData, self).__eq__(other) and \
               self.config_params == other.config_params and \
               self.operations == other.operations and \
               self.staging_repository == other.staging_repository and \
               self.staging_port == other.staging_port and \
               self.staging_host_user == other.staging_host_user and \
               self.db_credentials == other.db_credentials and \
               self.db_user == other.db_user and \
               self.config == other.config

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config_params(self):
        """
        MySQL database configuration parameter overrides.

        :rtype: ``dict``
        """
        return self._config_params[0]

    @config_params.setter
    def config_params(self, value):
        self._config_params = (value, True)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def staging_repository(self):
        """
        The MySQL installation on the staging environment to use for validated
        sync.

        :rtype: ``basestring``
        """
        return self._staging_repository[0]

    @staging_repository.setter
    def staging_repository(self, value):
        self._staging_repository = (value, True)

    @property
    def staging_port(self):
        """
        The port on which the MySQL staging instance will listen.

        :rtype: ``int``
        """
        return self._staging_port[0]

    @staging_port.setter
    def staging_port(self, value):
        self._staging_port = (value, True)

    @property
    def staging_host_user(self):
        """
        OS user on the staging host to use for attaching.

        :rtype: ``basestring``
        """
        return self._staging_host_user[0]

    @staging_host_user.setter
    def staging_host_user(self, value):
        self._staging_host_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credentials for the database user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def db_user(self):
        """
        The database username.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source. Must be an existing
        linked source config.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

class MSSqlAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the MSSQL
    specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlAttachData, self).__init__()
        self._type = ("MSSqlAttachData", True)
        self._operations = (self.__undef__, True)
        self._ppt_host_user = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._validated_sync_mode = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._encryption_key = (self.__undef__, True)
        self._backup_location_credentials = (self.__undef__, True)
        self._shared_backup_location = (self.__undef__, True)
        self._staging_post_script = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._backup_location_user = (self.__undef__, True)
        self._source_host_user = (self.__undef__, True)
        self._staging_pre_script = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlAttachData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._validated_sync_mode = (data.get("validatedSyncMode", obj.__undef__), dirty)
        if obj._validated_sync_mode[0] is not None and obj._validated_sync_mode[0] is not obj.__undef__:
            assert isinstance(obj._validated_sync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._validated_sync_mode[0]))
            assert obj._validated_sync_mode[0] in [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'], "Expected enum [u'TRANSACTION_LOG', u'FULL_OR_DIFFERENTIAL', u'FULL', u'NONE'] but got %s" % obj._validated_sync_mode[0]
            common.validate_format(obj._validated_sync_mode[0], "None", None, None)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        obj._encryption_key = (data.get("encryptionKey", obj.__undef__), dirty)
        if obj._encryption_key[0] is not None and obj._encryption_key[0] is not obj.__undef__:
            assert isinstance(obj._encryption_key[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._encryption_key[0]))
            common.validate_format(obj._encryption_key[0], "None", None, None)
        if "backupLocationCredentials" in data and data["backupLocationCredentials"] is not None:
            obj._backup_location_credentials = (factory.create_object(data["backupLocationCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._backup_location_credentials[0], "PasswordCredential")
        else:
            obj._backup_location_credentials = (obj.__undef__, dirty)
        obj._shared_backup_location = (data.get("sharedBackupLocation", obj.__undef__), dirty)
        if obj._shared_backup_location[0] is not None and obj._shared_backup_location[0] is not obj.__undef__:
            assert isinstance(obj._shared_backup_location[0], basestring), ("Expected one of [u'string', u'null'], but got %s" % type(obj._shared_backup_location[0]))
            common.validate_format(obj._shared_backup_location[0], "None", None, 260)
        obj._staging_post_script = (data.get("stagingPostScript", obj.__undef__), dirty)
        if obj._staging_post_script[0] is not None and obj._staging_post_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_post_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_post_script[0]))
            common.validate_format(obj._staging_post_script[0], "None", None, 1024)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        obj._backup_location_user = (data.get("backupLocationUser", obj.__undef__), dirty)
        if obj._backup_location_user[0] is not None and obj._backup_location_user[0] is not obj.__undef__:
            assert isinstance(obj._backup_location_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_location_user[0]))
            common.validate_format(obj._backup_location_user[0], "None", None, 256)
        obj._source_host_user = (data.get("sourceHostUser", obj.__undef__), dirty)
        if obj._source_host_user[0] is not None and obj._source_host_user[0] is not obj.__undef__:
            assert isinstance(obj._source_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_host_user[0]))
            common.validate_format(obj._source_host_user[0], "objectReference", None, None)
        obj._staging_pre_script = (data.get("stagingPreScript", obj.__undef__), dirty)
        if obj._staging_pre_script[0] is not None and obj._staging_pre_script[0] is not obj.__undef__:
            assert isinstance(obj._staging_pre_script[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._staging_pre_script[0]))
            common.validate_format(obj._staging_pre_script[0], "None", None, 1024)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "validated_sync_mode" == "type" or (self.validated_sync_mode is not self.__undef__ and not (dirty and not self._validated_sync_mode[1])):
            dct["validatedSyncMode"] = dictify(self.validated_sync_mode)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "encryption_key" == "type" or (self.encryption_key is not self.__undef__ and not (dirty and not self._encryption_key[1])):
            dct["encryptionKey"] = dictify(self.encryption_key)
        if "backup_location_credentials" == "type" or (self.backup_location_credentials is not self.__undef__ and not (dirty and not self._backup_location_credentials[1])):
            dct["backupLocationCredentials"] = dictify(self.backup_location_credentials)
        if "shared_backup_location" == "type" or (self.shared_backup_location is not self.__undef__ and not (dirty and not self._shared_backup_location[1])):
            dct["sharedBackupLocation"] = dictify(self.shared_backup_location)
        if "staging_post_script" == "type" or (self.staging_post_script is not self.__undef__ and not (dirty and not self._staging_post_script[1])):
            dct["stagingPostScript"] = dictify(self.staging_post_script)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "backup_location_user" == "type" or (self.backup_location_user is not self.__undef__ and not (dirty and not self._backup_location_user[1])):
            dct["backupLocationUser"] = dictify(self.backup_location_user)
        if "source_host_user" == "type" or (self.source_host_user is not self.__undef__ and not (dirty and not self._source_host_user[1])):
            dct["sourceHostUser"] = dictify(self.source_host_user)
        if "staging_pre_script" == "type" or (self.staging_pre_script is not self.__undef__ and not (dirty and not self._staging_pre_script[1])):
            dct["stagingPreScript"] = dictify(self.staging_pre_script)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._validated_sync_mode = (self._validated_sync_mode[0], True)
        self._db_user = (self._db_user[0], True)
        self._encryption_key = (self._encryption_key[0], True)
        self._backup_location_credentials = (self._backup_location_credentials[0], True)
        self._shared_backup_location = (self._shared_backup_location[0], True)
        self._staging_post_script = (self._staging_post_script[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._backup_location_user = (self._backup_location_user[0], True)
        self._source_host_user = (self._source_host_user[0], True)
        self._staging_pre_script = (self._staging_pre_script[0], True)
        self._config = (self._config[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._ppt_host_user[1], self._external_file_path[1], self._validated_sync_mode[1], self._db_user[1], self._encryption_key[1], self._backup_location_credentials[1], self._shared_backup_location[1], self._staging_post_script[1], self._db_credentials[1], self._backup_location_user[1], self._source_host_user[1], self._staging_pre_script[1], self._config[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlAttachData):
            return False
        return super(MSSqlAttachData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.ppt_host_user == other.ppt_host_user and \
               self.external_file_path == other.external_file_path and \
               self.validated_sync_mode == other.validated_sync_mode and \
               self.db_user == other.db_user and \
               self.encryption_key == other.encryption_key and \
               self.backup_location_credentials == other.backup_location_credentials and \
               self.shared_backup_location == other.shared_backup_location and \
               self.staging_post_script == other.staging_post_script and \
               self.db_credentials == other.db_credentials and \
               self.backup_location_user == other.backup_location_user and \
               self.source_host_user == other.source_host_user and \
               self.staging_pre_script == other.staging_pre_script and \
               self.config == other.config and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def ppt_host_user(self):
        """
        OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def validated_sync_mode(self):
        """
        *(default value: TRANSACTION_LOG)* Specifies the backup types validated
        sync will use to synchronize the dSource with the source database.
        *(permitted values: TRANSACTION_LOG, FULL_OR_DIFFERENTIAL, FULL, NONE)*

        :rtype: ``basestring``
        """
        return self._validated_sync_mode[0]

    @validated_sync_mode.setter
    def validated_sync_mode(self, value):
        self._validated_sync_mode = (value, True)

    @property
    def db_user(self):
        """
        The SQL Server login username for the source DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def encryption_key(self):
        """
        The encryption key to use when restoring encrypted backups.

        :rtype: ``basestring``
        """
        return self._encryption_key[0]

    @encryption_key.setter
    def encryption_key(self, value):
        self._encryption_key = (value, True)

    @property
    def backup_location_credentials(self):
        """
        The password for accessing the shared backup location.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._backup_location_credentials[0]

    @backup_location_credentials.setter
    def backup_location_credentials(self, value):
        self._backup_location_credentials = (value, True)

    @property
    def shared_backup_location(self):
        """
        Shared source database backup location.

        :rtype: ``basestring`` *or* ``null``
        """
        return self._shared_backup_location[0]

    @shared_backup_location.setter
    def shared_backup_location(self, value):
        self._shared_backup_location = (value, True)

    @property
    def staging_post_script(self):
        """
        The path to a user-provided PowerShell script or executable to run
        after restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_post_script[0]

    @staging_post_script.setter
    def staging_post_script(self, value):
        self._staging_post_script = (value, True)

    @property
    def db_credentials(self):
        """
        The SQL Server login password for the source DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def backup_location_user(self):
        """
        The user for accessing the shared backup location.

        :rtype: ``basestring``
        """
        return self._backup_location_user[0]

    @backup_location_user.setter
    def backup_location_user(self, value):
        self._backup_location_user = (value, True)

    @property
    def source_host_user(self):
        """
        OS user on the source to use for linking.

        :rtype: ``basestring``
        """
        return self._source_host_user[0]

    @source_host_user.setter
    def source_host_user(self, value):
        self._source_host_user = (value, True)

    @property
    def staging_pre_script(self):
        """
        The path to a user-provided PowerShell script or executable to run
        prior to restoring from a backup during pre-provisioning.

        :rtype: ``basestring``
        """
        return self._staging_pre_script[0]

    @staging_pre_script.setter
    def staging_pre_script(self, value):
        self._staging_pre_script = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def ppt_repository(self):
        """
        The SQL Server instance on the staging environment to use for pre-
        provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class VMwareAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the VMware
    specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareAttachData, self).__init__()
        self._type = ("VMwareAttachData", True)
        self._config = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareAttachData, cls).from_dict(data, dirty, undef_enabled)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._config = (self._config[0], True)
        self._environment_user = (self._environment_user[0], True)

    def is_dirty(self):
        return any([self._config[1], self._environment_user[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareAttachData):
            return False
        return super(VMwareAttachData, self).__eq__(other) and \
               self.config == other.config and \
               self.environment_user == other.environment_user

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def environment_user(self):
        """
        The OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

class OracleAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the Oracle
    specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(OracleAttachData, self).__init__()
        self._type = ("OracleAttachData", True)
        self._operations = (self.__undef__, True)
        self._number_of_connections = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._allow_missing_resetlogs = (self.__undef__, True)
        self._files_per_set = (self.__undef__, True)
        self._bandwidth_limit = (self.__undef__, True)
        self._check_logical = (self.__undef__, True)
        self._allow_recreated_controlfile = (self.__undef__, True)
        self._backup_level_enabled = (self.__undef__, True)
        self._link_now = (self.__undef__, True)
        self._rman_channels = (self.__undef__, True)
        self._encrypted_linking_enabled = (self.__undef__, True)
        self._environment_user = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._compressed_linking_enabled = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._double_sync = (self.__undef__, True)
        self._allow_archivelog_not_found = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleAttachData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._number_of_connections = (data.get("numberOfConnections", obj.__undef__), dirty)
        if obj._number_of_connections[0] is not None and obj._number_of_connections[0] is not obj.__undef__:
            assert isinstance(obj._number_of_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._number_of_connections[0]))
            common.validate_format(obj._number_of_connections[0], "None", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._allow_missing_resetlogs = (data.get("allowMissingResetlogs", obj.__undef__), dirty)
        if obj._allow_missing_resetlogs[0] is not None and obj._allow_missing_resetlogs[0] is not obj.__undef__:
            assert isinstance(obj._allow_missing_resetlogs[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_missing_resetlogs[0]))
            common.validate_format(obj._allow_missing_resetlogs[0], "None", None, None)
        obj._files_per_set = (data.get("filesPerSet", obj.__undef__), dirty)
        if obj._files_per_set[0] is not None and obj._files_per_set[0] is not obj.__undef__:
            assert isinstance(obj._files_per_set[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._files_per_set[0]))
            common.validate_format(obj._files_per_set[0], "None", None, None)
        obj._bandwidth_limit = (data.get("bandwidthLimit", obj.__undef__), dirty)
        if obj._bandwidth_limit[0] is not None and obj._bandwidth_limit[0] is not obj.__undef__:
            assert isinstance(obj._bandwidth_limit[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._bandwidth_limit[0]))
            common.validate_format(obj._bandwidth_limit[0], "None", None, None)
        obj._check_logical = (data.get("checkLogical", obj.__undef__), dirty)
        if obj._check_logical[0] is not None and obj._check_logical[0] is not obj.__undef__:
            assert isinstance(obj._check_logical[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._check_logical[0]))
            common.validate_format(obj._check_logical[0], "None", None, None)
        obj._allow_recreated_controlfile = (data.get("allowRecreatedControlfile", obj.__undef__), dirty)
        if obj._allow_recreated_controlfile[0] is not None and obj._allow_recreated_controlfile[0] is not obj.__undef__:
            assert isinstance(obj._allow_recreated_controlfile[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_recreated_controlfile[0]))
            common.validate_format(obj._allow_recreated_controlfile[0], "None", None, None)
        obj._backup_level_enabled = (data.get("backupLevelEnabled", obj.__undef__), dirty)
        if obj._backup_level_enabled[0] is not None and obj._backup_level_enabled[0] is not obj.__undef__:
            assert isinstance(obj._backup_level_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._backup_level_enabled[0]))
            common.validate_format(obj._backup_level_enabled[0], "None", None, None)
        obj._link_now = (data.get("linkNow", obj.__undef__), dirty)
        if obj._link_now[0] is not None and obj._link_now[0] is not obj.__undef__:
            assert isinstance(obj._link_now[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._link_now[0]))
            common.validate_format(obj._link_now[0], "None", None, None)
        obj._rman_channels = (data.get("rmanChannels", obj.__undef__), dirty)
        if obj._rman_channels[0] is not None and obj._rman_channels[0] is not obj.__undef__:
            assert isinstance(obj._rman_channels[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._rman_channels[0]))
            common.validate_format(obj._rman_channels[0], "None", None, None)
        obj._encrypted_linking_enabled = (data.get("encryptedLinkingEnabled", obj.__undef__), dirty)
        if obj._encrypted_linking_enabled[0] is not None and obj._encrypted_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._encrypted_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encrypted_linking_enabled[0]))
            common.validate_format(obj._encrypted_linking_enabled[0], "None", None, None)
        if "environmentUser" not in data:
            raise ValueError("Missing required property \"environmentUser\".")
        obj._environment_user = (data.get("environmentUser", obj.__undef__), dirty)
        if obj._environment_user[0] is not None and obj._environment_user[0] is not obj.__undef__:
            assert isinstance(obj._environment_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._environment_user[0]))
            common.validate_format(obj._environment_user[0], "objectReference", None, None)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        obj._compressed_linking_enabled = (data.get("compressedLinkingEnabled", obj.__undef__), dirty)
        if obj._compressed_linking_enabled[0] is not None and obj._compressed_linking_enabled[0] is not obj.__undef__:
            assert isinstance(obj._compressed_linking_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compressed_linking_enabled[0]))
            common.validate_format(obj._compressed_linking_enabled[0], "None", None, None)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        obj._double_sync = (data.get("doubleSync", obj.__undef__), dirty)
        if obj._double_sync[0] is not None and obj._double_sync[0] is not obj.__undef__:
            assert isinstance(obj._double_sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._double_sync[0]))
            common.validate_format(obj._double_sync[0], "None", None, None)
        obj._allow_archivelog_not_found = (data.get("allowArchivelogNotFound", obj.__undef__), dirty)
        if obj._allow_archivelog_not_found[0] is not None and obj._allow_archivelog_not_found[0] is not obj.__undef__:
            assert isinstance(obj._allow_archivelog_not_found[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._allow_archivelog_not_found[0]))
            common.validate_format(obj._allow_archivelog_not_found[0], "None", None, None)
        if "dbCredentials" not in data:
            raise ValueError("Missing required property \"dbCredentials\".")
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "number_of_connections" == "type" or (self.number_of_connections is not self.__undef__ and not (dirty and not self._number_of_connections[1])):
            dct["numberOfConnections"] = dictify(self.number_of_connections)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "allow_missing_resetlogs" == "type" or (self.allow_missing_resetlogs is not self.__undef__ and not (dirty and not self._allow_missing_resetlogs[1])):
            dct["allowMissingResetlogs"] = dictify(self.allow_missing_resetlogs)
        if "files_per_set" == "type" or (self.files_per_set is not self.__undef__ and not (dirty and not self._files_per_set[1])):
            dct["filesPerSet"] = dictify(self.files_per_set)
        if "bandwidth_limit" == "type" or (self.bandwidth_limit is not self.__undef__ and not (dirty and not self._bandwidth_limit[1])):
            dct["bandwidthLimit"] = dictify(self.bandwidth_limit)
        if "check_logical" == "type" or (self.check_logical is not self.__undef__ and not (dirty and not self._check_logical[1])):
            dct["checkLogical"] = dictify(self.check_logical)
        if "allow_recreated_controlfile" == "type" or (self.allow_recreated_controlfile is not self.__undef__ and not (dirty and not self._allow_recreated_controlfile[1])):
            dct["allowRecreatedControlfile"] = dictify(self.allow_recreated_controlfile)
        if "backup_level_enabled" == "type" or (self.backup_level_enabled is not self.__undef__ and not (dirty and not self._backup_level_enabled[1])):
            dct["backupLevelEnabled"] = dictify(self.backup_level_enabled)
        if "link_now" == "type" or (self.link_now is not self.__undef__ and not (dirty and not self._link_now[1])):
            dct["linkNow"] = dictify(self.link_now)
        if "rman_channels" == "type" or (self.rman_channels is not self.__undef__ and not (dirty and not self._rman_channels[1])):
            dct["rmanChannels"] = dictify(self.rman_channels)
        if "encrypted_linking_enabled" == "type" or (self.encrypted_linking_enabled is not self.__undef__ and not (dirty and not self._encrypted_linking_enabled[1])):
            dct["encryptedLinkingEnabled"] = dictify(self.encrypted_linking_enabled)
        if "environment_user" == "type" or (self.environment_user is not self.__undef__ and not (dirty and not self._environment_user[1])):
            dct["environmentUser"] = dictify(self.environment_user)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "compressed_linking_enabled" == "type" or (self.compressed_linking_enabled is not self.__undef__ and not (dirty and not self._compressed_linking_enabled[1])):
            dct["compressedLinkingEnabled"] = dictify(self.compressed_linking_enabled)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "double_sync" == "type" or (self.double_sync is not self.__undef__ and not (dirty and not self._double_sync[1])):
            dct["doubleSync"] = dictify(self.double_sync)
        if "allow_archivelog_not_found" == "type" or (self.allow_archivelog_not_found is not self.__undef__ and not (dirty and not self._allow_archivelog_not_found[1])):
            dct["allowArchivelogNotFound"] = dictify(self.allow_archivelog_not_found)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._number_of_connections = (self._number_of_connections[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._allow_missing_resetlogs = (self._allow_missing_resetlogs[0], True)
        self._files_per_set = (self._files_per_set[0], True)
        self._bandwidth_limit = (self._bandwidth_limit[0], True)
        self._check_logical = (self._check_logical[0], True)
        self._allow_recreated_controlfile = (self._allow_recreated_controlfile[0], True)
        self._backup_level_enabled = (self._backup_level_enabled[0], True)
        self._link_now = (self._link_now[0], True)
        self._rman_channels = (self._rman_channels[0], True)
        self._encrypted_linking_enabled = (self._encrypted_linking_enabled[0], True)
        self._environment_user = (self._environment_user[0], True)
        self._db_user = (self._db_user[0], True)
        self._compressed_linking_enabled = (self._compressed_linking_enabled[0], True)
        self._config = (self._config[0], True)
        self._double_sync = (self._double_sync[0], True)
        self._allow_archivelog_not_found = (self._allow_archivelog_not_found[0], True)
        self._db_credentials = (self._db_credentials[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._number_of_connections[1], self._external_file_path[1], self._allow_missing_resetlogs[1], self._files_per_set[1], self._bandwidth_limit[1], self._check_logical[1], self._allow_recreated_controlfile[1], self._backup_level_enabled[1], self._link_now[1], self._rman_channels[1], self._encrypted_linking_enabled[1], self._environment_user[1], self._db_user[1], self._compressed_linking_enabled[1], self._config[1], self._double_sync[1], self._allow_archivelog_not_found[1], self._db_credentials[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleAttachData):
            return False
        return super(OracleAttachData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.number_of_connections == other.number_of_connections and \
               self.external_file_path == other.external_file_path and \
               self.allow_missing_resetlogs == other.allow_missing_resetlogs and \
               self.files_per_set == other.files_per_set and \
               self.bandwidth_limit == other.bandwidth_limit and \
               self.check_logical == other.check_logical and \
               self.allow_recreated_controlfile == other.allow_recreated_controlfile and \
               self.backup_level_enabled == other.backup_level_enabled and \
               self.link_now == other.link_now and \
               self.rman_channels == other.rman_channels and \
               self.encrypted_linking_enabled == other.encrypted_linking_enabled and \
               self.environment_user == other.environment_user and \
               self.db_user == other.db_user and \
               self.compressed_linking_enabled == other.compressed_linking_enabled and \
               self.config == other.config and \
               self.double_sync == other.double_sync and \
               self.allow_archivelog_not_found == other.allow_archivelog_not_found and \
               self.db_credentials == other.db_credentials

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def number_of_connections(self):
        """
        *(default value: 1)* Total number of transport connections to use
        during SnapSync.

        :rtype: ``int``
        """
        return self._number_of_connections[0]

    @number_of_connections.setter
    def number_of_connections(self, value):
        self._number_of_connections = (value, True)

    @property
    def external_file_path(self):
        """
        External file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def allow_missing_resetlogs(self):
        """
        True if attach should succeed even if the resetlogs of the original
        database does not match the resetlogs of the new database, the
        resetlogs information of the original database is not a parent
        incarnation of the current resetlogs because the controlfile has been
        recreated and the incarnation table is incomplete. As the controfile
        has been recreated, the creation time should also not match and
        allowRecreatedControlfile=true must be also used, otherwise this option
        is ignored. Use this option with extreme caution. Attached database
        must be the same database to avoid data corruption later on.

        :rtype: ``bool``
        """
        return self._allow_missing_resetlogs[0]

    @allow_missing_resetlogs.setter
    def allow_missing_resetlogs(self, value):
        self._allow_missing_resetlogs = (value, True)

    @property
    def files_per_set(self):
        """
        *(default value: 5)* Number of data files to include in each RMAN
        backup set.

        :rtype: ``int``
        """
        return self._files_per_set[0]

    @files_per_set.setter
    def files_per_set(self, value):
        self._files_per_set = (value, True)

    @property
    def bandwidth_limit(self):
        """
        Bandwidth limit (MB/s) for SnapSync and LogSync network traffic. A
        value of 0 means no limit.

        :rtype: ``int``
        """
        return self._bandwidth_limit[0]

    @bandwidth_limit.setter
    def bandwidth_limit(self, value):
        self._bandwidth_limit = (value, True)

    @property
    def check_logical(self):
        """
        True if extended block checking should be used for this linked
        database.

        :rtype: ``bool``
        """
        return self._check_logical[0]

    @check_logical.setter
    def check_logical(self, value):
        self._check_logical = (value, True)

    @property
    def allow_recreated_controlfile(self):
        """
        True if attach should succeed even if the creation time of the original
        database does not match the creation time of the new database. This
        parameter is necessary when the controlfile has been recreated. Use
        this option with extreme caution. Attached database must be the same
        database to avoid data corruption later on.

        :rtype: ``bool``
        """
        return self._allow_recreated_controlfile[0]

    @allow_recreated_controlfile.setter
    def allow_recreated_controlfile(self, value):
        self._allow_recreated_controlfile = (value, True)

    @property
    def backup_level_enabled(self):
        """
        Defines whether backup level is enabled.

        :rtype: ``bool``
        """
        return self._backup_level_enabled[0]

    @backup_level_enabled.setter
    def backup_level_enabled(self, value):
        self._backup_level_enabled = (value, True)

    @property
    def link_now(self):
        """
        True if initial load should be done immediately.

        :rtype: ``bool``
        """
        return self._link_now[0]

    @link_now.setter
    def link_now(self, value):
        self._link_now = (value, True)

    @property
    def rman_channels(self):
        """
        *(default value: 2)* Number of parallel channels to use.

        :rtype: ``int``
        """
        return self._rman_channels[0]

    @rman_channels.setter
    def rman_channels(self, value):
        self._rman_channels = (value, True)

    @property
    def encrypted_linking_enabled(self):
        """
        True if SnapSync data from the source should be retrieved through an
        encrypted connection. Enabling this feature can decrease the
        performance of SnapSync from the source but has no impact on the
        performance of VDBs created from the retrieved data.

        :rtype: ``bool``
        """
        return self._encrypted_linking_enabled[0]

    @encrypted_linking_enabled.setter
    def encrypted_linking_enabled(self, value):
        self._encrypted_linking_enabled = (value, True)

    @property
    def environment_user(self):
        """
        Information about the OS user to use for linking.

        :rtype: ``basestring``
        """
        return self._environment_user[0]

    @environment_user.setter
    def environment_user(self, value):
        self._environment_user = (value, True)

    @property
    def db_user(self):
        """
        The name of the DB user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def compressed_linking_enabled(self):
        """
        *(default value: True)* True if SnapSync data from the source should be
        compressed over the network. Enabling this feature will reduce network
        bandwidth consumption and may significantly improve throughput,
        especially over slow network.

        :rtype: ``bool``
        """
        return self._compressed_linking_enabled[0]

    @compressed_linking_enabled.setter
    def compressed_linking_enabled(self, value):
        self._compressed_linking_enabled = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def double_sync(self):
        """
        True if two SnapSyncs should be performed in immediate succession to
        reduce the number of logs required to provision the snapshot. This may
        significantly reduce the time necessary to provision from a snapshot.

        :rtype: ``bool``
        """
        return self._double_sync[0]

    @double_sync.setter
    def double_sync(self, value):
        self._double_sync = (value, True)

    @property
    def allow_archivelog_not_found(self):
        """
        True if attach should succeed even if the last archived log of the
        original database is not found in the current controlfile, as long as
        the database SCN is ahead of the SCN of the last archived log. Use this
        option with extreme caution. Attached database must be the same
        database to avoid data corruption later on.

        :rtype: ``bool``
        """
        return self._allow_archivelog_not_found[0]

    @allow_archivelog_not_found.setter
    def allow_archivelog_not_found(self, value):
        self._allow_archivelog_not_found = (value, True)

    @property
    def db_credentials(self):
        """
        The password for the DB user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

class PgSQLAttachData(AttachData):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AttachData` *)* Represents the
    PostgreSQL specific parameters of an attach request.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLAttachData, self).__init__()
        self._type = ("PgSQLAttachData", True)
        self._operations = (self.__undef__, True)
        self._ppt_host_user = (self.__undef__, True)
        self._external_file_path = (self.__undef__, True)
        self._connection_database = (self.__undef__, True)
        self._db_user = (self.__undef__, True)
        self._db_credentials = (self.__undef__, True)
        self._config = (self.__undef__, True)
        self._ppt_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLAttachData, cls).from_dict(data, dirty, undef_enabled)
        if "operations" in data and data["operations"] is not None:
            obj._operations = (factory.create_object(data["operations"], "LinkedSourceOperations"), dirty)
            factory.validate_type(obj._operations[0], "LinkedSourceOperations")
        else:
            obj._operations = (obj.__undef__, dirty)
        obj._ppt_host_user = (data.get("pptHostUser", obj.__undef__), dirty)
        if obj._ppt_host_user[0] is not None and obj._ppt_host_user[0] is not obj.__undef__:
            assert isinstance(obj._ppt_host_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_host_user[0]))
            common.validate_format(obj._ppt_host_user[0], "objectReference", None, None)
        obj._external_file_path = (data.get("externalFilePath", obj.__undef__), dirty)
        if obj._external_file_path[0] is not None and obj._external_file_path[0] is not obj.__undef__:
            assert isinstance(obj._external_file_path[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_file_path[0]))
            common.validate_format(obj._external_file_path[0], "None", None, 1024)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        if "dbUser" not in data:
            raise ValueError("Missing required property \"dbUser\".")
        obj._db_user = (data.get("dbUser", obj.__undef__), dirty)
        if obj._db_user[0] is not None and obj._db_user[0] is not obj.__undef__:
            assert isinstance(obj._db_user[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._db_user[0]))
            common.validate_format(obj._db_user[0], "None", None, None)
        if "dbCredentials" in data and data["dbCredentials"] is not None:
            obj._db_credentials = (factory.create_object(data["dbCredentials"], "PasswordCredential"), dirty)
            factory.validate_type(obj._db_credentials[0], "PasswordCredential")
        else:
            obj._db_credentials = (obj.__undef__, dirty)
        if "config" not in data:
            raise ValueError("Missing required property \"config\".")
        obj._config = (data.get("config", obj.__undef__), dirty)
        if obj._config[0] is not None and obj._config[0] is not obj.__undef__:
            assert isinstance(obj._config[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._config[0]))
            common.validate_format(obj._config[0], "objectReference", None, None)
        if "pptRepository" not in data:
            raise ValueError("Missing required property \"pptRepository\".")
        obj._ppt_repository = (data.get("pptRepository", obj.__undef__), dirty)
        if obj._ppt_repository[0] is not None and obj._ppt_repository[0] is not obj.__undef__:
            assert isinstance(obj._ppt_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._ppt_repository[0]))
            common.validate_format(obj._ppt_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLAttachData, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "operations" == "type" or (self.operations is not self.__undef__ and not (dirty and not self._operations[1])):
            dct["operations"] = dictify(self.operations)
        if "ppt_host_user" == "type" or (self.ppt_host_user is not self.__undef__ and not (dirty and not self._ppt_host_user[1])):
            dct["pptHostUser"] = dictify(self.ppt_host_user)
        if "external_file_path" == "type" or (self.external_file_path is not self.__undef__ and not (dirty and not self._external_file_path[1])):
            dct["externalFilePath"] = dictify(self.external_file_path)
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        if "db_user" == "type" or (self.db_user is not self.__undef__ and not (dirty and not self._db_user[1])):
            dct["dbUser"] = dictify(self.db_user)
        if "db_credentials" == "type" or (self.db_credentials is not self.__undef__ and not (dirty and not self._db_credentials[1])):
            dct["dbCredentials"] = dictify(self.db_credentials)
        if "config" == "type" or (self.config is not self.__undef__ and not (dirty and not self._config[1])):
            dct["config"] = dictify(self.config)
        if "ppt_repository" == "type" or (self.ppt_repository is not self.__undef__ and not (dirty and not self._ppt_repository[1])):
            dct["pptRepository"] = dictify(self.ppt_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._operations = (self._operations[0], True)
        self._ppt_host_user = (self._ppt_host_user[0], True)
        self._external_file_path = (self._external_file_path[0], True)
        self._connection_database = (self._connection_database[0], True)
        self._db_user = (self._db_user[0], True)
        self._db_credentials = (self._db_credentials[0], True)
        self._config = (self._config[0], True)
        self._ppt_repository = (self._ppt_repository[0], True)

    def is_dirty(self):
        return any([self._operations[1], self._ppt_host_user[1], self._external_file_path[1], self._connection_database[1], self._db_user[1], self._db_credentials[1], self._config[1], self._ppt_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLAttachData):
            return False
        return super(PgSQLAttachData, self).__eq__(other) and \
               self.operations == other.operations and \
               self.ppt_host_user == other.ppt_host_user and \
               self.external_file_path == other.external_file_path and \
               self.connection_database == other.connection_database and \
               self.db_user == other.db_user and \
               self.db_credentials == other.db_credentials and \
               self.config == other.config and \
               self.ppt_repository == other.ppt_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def operations(self):
        """
        User-specified operation hooks for this source.

        :rtype: :py:class:`v1_8_1.web.vo.LinkedSourceOperations`
        """
        return self._operations[0]

    @operations.setter
    def operations(self, value):
        self._operations = (value, True)

    @property
    def ppt_host_user(self):
        """
        Information about the host OS user on the PPT host to use for linking.

        :rtype: ``basestring``
        """
        return self._ppt_host_user[0]

    @ppt_host_user.setter
    def ppt_host_user(self, value):
        self._ppt_host_user = (value, True)

    @property
    def external_file_path(self):
        """
        The external file path.

        :rtype: ``basestring``
        """
        return self._external_file_path[0]

    @external_file_path.setter
    def external_file_path(self, value):
        self._external_file_path = (value, True)

    @property
    def connection_database(self):
        """
        *(default value: postgres)* The database that must be used to run SQL
        queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

    @property
    def db_user(self):
        """
        The username of the database cluster user.

        :rtype: ``basestring``
        """
        return self._db_user[0]

    @db_user.setter
    def db_user(self, value):
        self._db_user = (value, True)

    @property
    def db_credentials(self):
        """
        The credential of the database cluster user.

        :rtype: :py:class:`v1_8_1.web.vo.PasswordCredential`
        """
        return self._db_credentials[0]

    @db_credentials.setter
    def db_credentials(self, value):
        self._db_credentials = (value, True)

    @property
    def config(self):
        """
        Reference to the configuration for the source.

        :rtype: ``basestring``
        """
        return self._config[0]

    @config.setter
    def config(self, value):
        self._config = (value, True)

    @property
    def ppt_repository(self):
        """
        The Postgres installation on the PPT environment that will be used for
        pre-provisioning.

        :rtype: ``basestring``
        """
        return self._ppt_repository[0]

    @ppt_repository.setter
    def ppt_repository(self, value):
        self._ppt_repository = (value, True)

class OracleDeleteParameters(DeleteParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.DeleteParameters` *)* The parameters
    passed in for an Oracle database delete operation.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDeleteParameters, self).__init__()
        self._type = ("OracleDeleteParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDeleteParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDeleteParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDeleteParameters):
            return False
        return super(OracleDeleteParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the delete operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the delete
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class SnapshotLogFetchParameters(LogFetchSSH):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LogFetchSSH` *)* Parameters to fetch
    log files that cover a snapshot and the TimeFlow range up to the next
    snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(SnapshotLogFetchParameters, self).__init__()
        self._type = ("SnapshotLogFetchParameters", True)
        self._snapshot = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SnapshotLogFetchParameters, cls).from_dict(data, dirty, undef_enabled)
        if "snapshot" not in data:
            raise ValueError("Missing required property \"snapshot\".")
        obj._snapshot = (data.get("snapshot", obj.__undef__), dirty)
        if obj._snapshot[0] is not None and obj._snapshot[0] is not obj.__undef__:
            assert isinstance(obj._snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot[0]))
            common.validate_format(obj._snapshot[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SnapshotLogFetchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "snapshot" == "type" or (self.snapshot is not self.__undef__ and not (dirty and not self._snapshot[1])):
            dct["snapshot"] = dictify(self.snapshot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._snapshot = (self._snapshot[0], True)

    def is_dirty(self):
        return any([self._snapshot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SnapshotLogFetchParameters):
            return False
        return super(SnapshotLogFetchParameters, self).__eq__(other) and \
               self.snapshot == other.snapshot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def snapshot(self):
        """
        Reference to the snapshot for which to fetch logs.

        :rtype: ``basestring``
        """
        return self._snapshot[0]

    @snapshot.setter
    def snapshot(self, value):
        self._snapshot = (value, True)

class TimeflowLogFetchParameters(LogFetchSSH):
    """
    *(extends* :py:class:`v1_8_1.web.vo.LogFetchSSH` *)* Parameters to fetch
    log files within a TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowLogFetchParameters, self).__init__()
        self._type = ("TimeflowLogFetchParameters", True)
        self._end_location = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)
        self._start_location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowLogFetchParameters, cls).from_dict(data, dirty, undef_enabled)
        if "endLocation" not in data:
            raise ValueError("Missing required property \"endLocation\".")
        obj._end_location = (data.get("endLocation", obj.__undef__), dirty)
        if obj._end_location[0] is not None and obj._end_location[0] is not obj.__undef__:
            assert isinstance(obj._end_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._end_location[0]))
            common.validate_format(obj._end_location[0], "None", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        if "startLocation" not in data:
            raise ValueError("Missing required property \"startLocation\".")
        obj._start_location = (data.get("startLocation", obj.__undef__), dirty)
        if obj._start_location[0] is not None and obj._start_location[0] is not obj.__undef__:
            assert isinstance(obj._start_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._start_location[0]))
            common.validate_format(obj._start_location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowLogFetchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "end_location" == "type" or (self.end_location is not self.__undef__ and not (dirty and not self._end_location[1])):
            dct["endLocation"] = dictify(self.end_location)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "start_location" == "type" or (self.start_location is not self.__undef__ and not (dirty and not self._start_location[1])):
            dct["startLocation"] = dictify(self.start_location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._end_location = (self._end_location[0], True)
        self._timeflow = (self._timeflow[0], True)
        self._start_location = (self._start_location[0], True)

    def is_dirty(self):
        return any([self._end_location[1], self._timeflow[1], self._start_location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowLogFetchParameters):
            return False
        return super(TimeflowLogFetchParameters, self).__eq__(other) and \
               self.end_location == other.end_location and \
               self.timeflow == other.timeflow and \
               self.start_location == other.start_location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def end_location(self):
        """
        The ending SCN of the range of log files to fetch.

        :rtype: ``basestring``
        """
        return self._end_location[0]

    @end_location.setter
    def end_location(self, value):
        self._end_location = (value, True)

    @property
    def timeflow(self):
        """
        Reference to the TimeFlow for which to fetch logs.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def start_location(self):
        """
        The starting SCN of the range of log files to fetch.

        :rtype: ``basestring``
        """
        return self._start_location[0]

    @start_location.setter
    def start_location(self, value):
        self._start_location = (value, True)

class FileUploadResult(FileProcessingResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.FileProcessingResult` *)* Result of a
    file upload request.
    """
    def __init__(self, undef_enabled=True):
        super(FileUploadResult, self).__init__()
        self._type = ("FileUploadResult", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileUploadResult, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileUploadResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileUploadResult):
            return False
        return super(FileUploadResult, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class FileDownloadResult(FileProcessingResult):
    """
    *(extends* :py:class:`v1_8_1.web.vo.FileProcessingResult` *)* Result of a
    file download request.
    """
    def __init__(self, undef_enabled=True):
        super(FileDownloadResult, self).__init__()
        self._type = ("FileDownloadResult", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(FileDownloadResult, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(FileDownloadResult, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, FileDownloadResult):
            return False
        return super(FileDownloadResult, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of a MySQL TimeFlow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSnapshotRuntime, self).__init__()
        self._type = ("MySQLSnapshotRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSnapshotRuntime):
            return False
        return super(MySQLSnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASESnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of a SAP ASE TimeFlow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(ASESnapshotRuntime, self).__init__()
        self._type = ("ASESnapshotRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESnapshotRuntime):
            return False
        return super(ASESnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of a MSSQL TimeFlow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSnapshotRuntime, self).__init__()
        self._type = ("MSSqlSnapshotRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSnapshotRuntime):
            return False
        return super(MSSqlSnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of an Oracle TimeFlow snapshot.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSnapshotRuntime, self).__init__()
        self._type = ("OracleSnapshotRuntime", True)
        self._missing_logs = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._missing_logs = []
        for item in data.get("missingLogs") or []:
            obj._missing_logs.append(factory.create_object(item))
            factory.validate_type(obj._missing_logs[-1], "OracleLog")
        obj._missing_logs = (obj._missing_logs, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "missing_logs" == "type" or (self.missing_logs is not self.__undef__ and not (dirty and not self._missing_logs[1])):
            dct["missingLogs"] = dictify(self.missing_logs)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._missing_logs = (self._missing_logs[0], True)

    def is_dirty(self):
        return any([self._missing_logs[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSnapshotRuntime):
            return False
        return super(OracleSnapshotRuntime, self).__eq__(other) and \
               self.missing_logs == other.missing_logs

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def missing_logs(self):
        """
        List of missing log files for this snapshot, if any.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleLog`
        """
        return self._missing_logs[0]

    @missing_logs.setter
    def missing_logs(self, value):
        self._missing_logs = (value, True)

class AppDataSnapshotRuntime(SnapshotRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SnapshotRuntime` *)* Runtime (non-
    persistent) properties of AppData TimeFlow snapshots.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSnapshotRuntime, self).__init__()
        self._type = ("AppDataSnapshotRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSnapshotRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSnapshotRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSnapshotRuntime):
            return False
        return super(AppDataSnapshotRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NotificationDrop(Notification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Notification` *)* An object to track
    dropped notifications.
    """
    def __init__(self, undef_enabled=True):
        super(NotificationDrop, self).__init__()
        self._type = ("NotificationDrop", True)
        self._drop_count = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NotificationDrop, cls).from_dict(data, dirty, undef_enabled)
        obj._drop_count = (data.get("dropCount", obj.__undef__), dirty)
        if obj._drop_count[0] is not None and obj._drop_count[0] is not obj.__undef__:
            assert isinstance(obj._drop_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._drop_count[0]))
            common.validate_format(obj._drop_count[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NotificationDrop, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "drop_count" == "type" or (self.drop_count is not self.__undef__ and not (dirty and not self._drop_count[1])):
            dct["dropCount"] = dictify(self.drop_count)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._drop_count = (self._drop_count[0], True)

    def is_dirty(self):
        return any([self._drop_count[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NotificationDrop):
            return False
        return super(NotificationDrop, self).__eq__(other) and \
               self.drop_count == other.drop_count

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def drop_count(self):
        """
        The number of notifications which were dropped since the last
        notifications were pulled. If this is greater than zero, you may want
        to refresh your view of the data to ensure everything is up to date.

        :rtype: ``int``
        """
        return self._drop_count[0]

    @drop_count.setter
    def drop_count(self, value):
        self._drop_count = (value, True)

class SingletonUpdate(Notification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Notification` *)* An event indicating
    an update to a singleton object on the system.
    """
    def __init__(self, undef_enabled=True):
        super(SingletonUpdate, self).__init__()
        self._type = ("SingletonUpdate", True)
        self._object_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(SingletonUpdate, cls).from_dict(data, dirty, undef_enabled)
        obj._object_type = (data.get("objectType", obj.__undef__), dirty)
        if obj._object_type[0] is not None and obj._object_type[0] is not obj.__undef__:
            assert isinstance(obj._object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object_type[0]))
            common.validate_format(obj._object_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(SingletonUpdate, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "object_type" == "type" or (self.object_type is not self.__undef__ and not (dirty and not self._object_type[1])):
            dct["objectType"] = dictify(self.object_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._object_type = (self._object_type[0], True)

    def is_dirty(self):
        return any([self._object_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, SingletonUpdate):
            return False
        return super(SingletonUpdate, self).__eq__(other) and \
               self.object_type == other.object_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def object_type(self):
        """
        Type of target object.

        :rtype: ``basestring``
        """
        return self._object_type[0]

    @object_type.setter
    def object_type(self, value):
        self._object_type = (value, True)

class ObjectNotification(Notification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Notification` *)* An event indicating a
    change to an object on the system.
    """
    def __init__(self, undef_enabled=True):
        super(ObjectNotification, self).__init__()
        self._type = ("ObjectNotification", True)
        self._event_type = (self.__undef__, True)
        self._object = (self.__undef__, True)
        self._object_type = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ObjectNotification, cls).from_dict(data, dirty, undef_enabled)
        obj._event_type = (data.get("eventType", obj.__undef__), dirty)
        if obj._event_type[0] is not None and obj._event_type[0] is not obj.__undef__:
            assert isinstance(obj._event_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._event_type[0]))
            assert obj._event_type[0] in [u'CREATE', u'UPDATE', u'DELETE'], "Expected enum [u'CREATE', u'UPDATE', u'DELETE'] but got %s" % obj._event_type[0]
            common.validate_format(obj._event_type[0], "None", None, None)
        obj._object = (data.get("object", obj.__undef__), dirty)
        if obj._object[0] is not None and obj._object[0] is not obj.__undef__:
            assert isinstance(obj._object[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object[0]))
            common.validate_format(obj._object[0], "objectReference", None, None)
        obj._object_type = (data.get("objectType", obj.__undef__), dirty)
        if obj._object_type[0] is not None and obj._object_type[0] is not obj.__undef__:
            assert isinstance(obj._object_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._object_type[0]))
            common.validate_format(obj._object_type[0], "type", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ObjectNotification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "event_type" == "type" or (self.event_type is not self.__undef__ and not (dirty and not self._event_type[1])):
            dct["eventType"] = dictify(self.event_type)
        if "object" == "type" or (self.object is not self.__undef__ and not (dirty and not self._object[1])):
            dct["object"] = dictify(self.object)
        if "object_type" == "type" or (self.object_type is not self.__undef__ and not (dirty and not self._object_type[1])):
            dct["objectType"] = dictify(self.object_type)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._event_type = (self._event_type[0], True)
        self._object = (self._object[0], True)
        self._object_type = (self._object_type[0], True)

    def is_dirty(self):
        return any([self._event_type[1], self._object[1], self._object_type[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ObjectNotification):
            return False
        return super(ObjectNotification, self).__eq__(other) and \
               self.event_type == other.event_type and \
               self.object == other.object and \
               self.object_type == other.object_type

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def event_type(self):
        """
        Type of operation on the object. *(permitted values: CREATE, UPDATE,
        DELETE)*

        :rtype: ``basestring``
        """
        return self._event_type[0]

    @event_type.setter
    def event_type(self, value):
        self._event_type = (value, True)

    @property
    def object(self):
        """
        Target object reference.

        :rtype: ``basestring``
        """
        return self._object[0]

    @object.setter
    def object(self, value):
        self._object = (value, True)

    @property
    def object_type(self):
        """
        Type of target object.

        :rtype: ``basestring``
        """
        return self._object_type[0]

    @object_type.setter
    def object_type(self, value):
        self._object_type = (value, True)

class XppStatus(Checklist):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Checklist` *)* The current cross-
    platform provisioning status of a container.
    """
    def __init__(self, undef_enabled=True):
        super(XppStatus, self).__init__()
        self._type = ("XppStatus", True)
        self._last_run_status = (self.__undef__, True)
        self._staging_status = (self.__undef__, True)
        self._target_status = (self.__undef__, True)
        self._validate_status = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppStatus, cls).from_dict(data, dirty, undef_enabled)
        if "lastRunStatus" in data and data["lastRunStatus"] is not None:
            obj._last_run_status = (factory.create_object(data["lastRunStatus"], "XppLastRunStatus"), dirty)
            factory.validate_type(obj._last_run_status[0], "XppLastRunStatus")
        else:
            obj._last_run_status = (obj.__undef__, dirty)
        if "stagingStatus" in data and data["stagingStatus"] is not None:
            obj._staging_status = (factory.create_object(data["stagingStatus"], "XppStagingStatus"), dirty)
            factory.validate_type(obj._staging_status[0], "XppStagingStatus")
        else:
            obj._staging_status = (obj.__undef__, dirty)
        if "targetStatus" in data and data["targetStatus"] is not None:
            obj._target_status = (factory.create_object(data["targetStatus"], "XppTargetStatus"), dirty)
            factory.validate_type(obj._target_status[0], "XppTargetStatus")
        else:
            obj._target_status = (obj.__undef__, dirty)
        if "validateStatus" in data and data["validateStatus"] is not None:
            obj._validate_status = (factory.create_object(data["validateStatus"], "XppValidateStatus"), dirty)
            factory.validate_type(obj._validate_status[0], "XppValidateStatus")
        else:
            obj._validate_status = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "last_run_status" == "type" or (self.last_run_status is not self.__undef__ and not (dirty and not self._last_run_status[1])):
            dct["lastRunStatus"] = dictify(self.last_run_status)
        if "staging_status" == "type" or (self.staging_status is not self.__undef__ and not (dirty and not self._staging_status[1])):
            dct["stagingStatus"] = dictify(self.staging_status)
        if "target_status" == "type" or (self.target_status is not self.__undef__ and not (dirty and not self._target_status[1])):
            dct["targetStatus"] = dictify(self.target_status)
        if "validate_status" == "type" or (self.validate_status is not self.__undef__ and not (dirty and not self._validate_status[1])):
            dct["validateStatus"] = dictify(self.validate_status)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._last_run_status = (self._last_run_status[0], True)
        self._staging_status = (self._staging_status[0], True)
        self._target_status = (self._target_status[0], True)
        self._validate_status = (self._validate_status[0], True)

    def is_dirty(self):
        return any([self._last_run_status[1], self._staging_status[1], self._target_status[1], self._validate_status[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppStatus):
            return False
        return super(XppStatus, self).__eq__(other) and \
               self.last_run_status == other.last_run_status and \
               self.staging_status == other.staging_status and \
               self.target_status == other.target_status and \
               self.validate_status == other.validate_status

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def last_run_status(self):
        """
        Status of the last cross-platform provision of the container.

        :rtype: :py:class:`v1_8_1.web.vo.XppLastRunStatus`
        """
        return self._last_run_status[0]

    @last_run_status.setter
    def last_run_status(self, value):
        self._last_run_status = (value, True)

    @property
    def staging_status(self):
        """
        Status of the cross-platform provisioning staging environment.

        :rtype: :py:class:`v1_8_1.web.vo.XppStagingStatus`
        """
        return self._staging_status[0]

    @staging_status.setter
    def staging_status(self, value):
        self._staging_status = (value, True)

    @property
    def target_status(self):
        """
        Status of the cross-platform provisioning target environment.

        :rtype: :py:class:`v1_8_1.web.vo.XppTargetStatus`
        """
        return self._target_status[0]

    @target_status.setter
    def target_status(self, value):
        self._target_status = (value, True)

    @property
    def validate_status(self):
        """
        Cross-platform provisioning validation status of the container.

        :rtype: :py:class:`v1_8_1.web.vo.XppValidateStatus`
        """
        return self._validate_status[0]

    @validate_status.setter
    def validate_status(self, value):
        self._validate_status = (value, True)

class IntegerConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* Constraints placed
    on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerConstraint, self).__init__()
        self._type = ("IntegerConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerConstraint):
            return False
        return super(IntegerConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class BooleanConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* Constraints placed
    on a boolean axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(BooleanConstraint, self).__init__()
        self._type = ("BooleanConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BooleanConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BooleanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BooleanConstraint):
            return False
        return super(BooleanConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class PathConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* Constraint placed
    on a filesystem path axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(PathConstraint, self).__init__()
        self._type = ("PathConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PathConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PathConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PathConstraint):
            return False
        return super(PathConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class EnumConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* Constraints placed
    on an enumeration axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(EnumConstraint, self).__init__()
        self._type = ("EnumConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnumConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnumConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnumConstraint):
            return False
        return super(EnumConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class StringConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* Constraint placed
    on a string axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(StringConstraint, self).__init__()
        self._type = ("StringConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StringConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StringConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StringConstraint):
            return False
        return super(StringConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class NullConstraint(AxisConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AxisConstraint` *)* If an axis has this
    type of constraint, it means that no constraints can be placed on this
    axis. This constraint type does nothing and has no descendent types.
    """
    def __init__(self, undef_enabled=True):
        super(NullConstraint, self).__init__()
        self._type = ("NullConstraint", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NullConstraint, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NullConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NullConstraint):
            return False
        return super(NullConstraint, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class StringEqualConstraint(StringConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.StringConstraint` *)* Constraint placed
    on a string axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(StringEqualConstraint, self).__init__()
        self._type = ("StringEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StringEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StringEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StringEqualConstraint):
            return False
        return super(StringEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must match this string.

        :rtype: ``basestring``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class EnumEqualConstraint(EnumConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.EnumConstraint` *)* Constraints placed
    on an enumeration axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(EnumEqualConstraint, self).__init__()
        self._type = ("EnumEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(EnumEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(EnumEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, EnumEqualConstraint):
            return False
        return super(EnumEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must be equal to the specified value.

        :rtype: ``basestring``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class PathDescendantConstraint(PathConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.PathConstraint` *)* Constraint placed
    on a filesystem path axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(PathDescendantConstraint, self).__init__()
        self._type = ("PathDescendantConstraint", True)
        self._descendant_of = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PathDescendantConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._descendant_of = (data.get("descendantOf", obj.__undef__), dirty)
        if obj._descendant_of[0] is not None and obj._descendant_of[0] is not obj.__undef__:
            assert isinstance(obj._descendant_of[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._descendant_of[0]))
            common.validate_format(obj._descendant_of[0], "unixpath", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PathDescendantConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "descendant_of" == "type" or (self.descendant_of is not self.__undef__ and not (dirty and not self._descendant_of[1])):
            dct["descendantOf"] = dictify(self.descendant_of)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._descendant_of = (self._descendant_of[0], True)

    def is_dirty(self):
        return any([self._descendant_of[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PathDescendantConstraint):
            return False
        return super(PathDescendantConstraint, self).__eq__(other) and \
               self.descendant_of == other.descendant_of

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def descendant_of(self):
        """
        The axis values must be a descendant of this path.

        :rtype: ``basestring``
        """
        return self._descendant_of[0]

    @descendant_of.setter
    def descendant_of(self, value):
        self._descendant_of = (value, True)

class BooleanEqualConstraint(BooleanConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BooleanConstraint` *)* Constraints
    placed on a boolean axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(BooleanEqualConstraint, self).__init__()
        self._type = ("BooleanEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(BooleanEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(BooleanEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, BooleanEqualConstraint):
            return False
        return super(BooleanEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must be equal to the boolean argument.

        :rtype: ``bool``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class IntegerLessThanConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerLessThanConstraint, self).__init__()
        self._type = ("IntegerLessThanConstraint", True)
        self._less_than = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerLessThanConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._less_than = (data.get("lessThan", obj.__undef__), dirty)
        if obj._less_than[0] is not None and obj._less_than[0] is not obj.__undef__:
            assert isinstance(obj._less_than[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._less_than[0]))
            common.validate_format(obj._less_than[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerLessThanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "less_than" == "type" or (self.less_than is not self.__undef__ and not (dirty and not self._less_than[1])):
            dct["lessThan"] = dictify(self.less_than)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._less_than = (self._less_than[0], True)

    def is_dirty(self):
        return any([self._less_than[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerLessThanConstraint):
            return False
        return super(IntegerLessThanConstraint, self).__eq__(other) and \
               self.less_than == other.less_than

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def less_than(self):
        """
        The axis values must be less than than this value.

        :rtype: ``int``
        """
        return self._less_than[0]

    @less_than.setter
    def less_than(self, value):
        self._less_than = (value, True)

class IntegerGreaterThanConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerGreaterThanConstraint, self).__init__()
        self._type = ("IntegerGreaterThanConstraint", True)
        self._greater_than = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerGreaterThanConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._greater_than = (data.get("greaterThan", obj.__undef__), dirty)
        if obj._greater_than[0] is not None and obj._greater_than[0] is not obj.__undef__:
            assert isinstance(obj._greater_than[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._greater_than[0]))
            common.validate_format(obj._greater_than[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerGreaterThanConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "greater_than" == "type" or (self.greater_than is not self.__undef__ and not (dirty and not self._greater_than[1])):
            dct["greaterThan"] = dictify(self.greater_than)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._greater_than = (self._greater_than[0], True)

    def is_dirty(self):
        return any([self._greater_than[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerGreaterThanConstraint):
            return False
        return super(IntegerGreaterThanConstraint, self).__eq__(other) and \
               self.greater_than == other.greater_than

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def greater_than(self):
        """
        The axis values must be greater than this value.

        :rtype: ``int``
        """
        return self._greater_than[0]

    @greater_than.setter
    def greater_than(self, value):
        self._greater_than = (value, True)

class IntegerEqualConstraint(IntegerConstraint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.IntegerConstraint` *)* Constraint
    placed on a numerical axis of a particular analytics slice.
    """
    def __init__(self, undef_enabled=True):
        super(IntegerEqualConstraint, self).__init__()
        self._type = ("IntegerEqualConstraint", True)
        self._equals = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IntegerEqualConstraint, cls).from_dict(data, dirty, undef_enabled)
        obj._equals = (data.get("equals", obj.__undef__), dirty)
        if obj._equals[0] is not None and obj._equals[0] is not obj.__undef__:
            assert isinstance(obj._equals[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._equals[0]))
            common.validate_format(obj._equals[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IntegerEqualConstraint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "equals" == "type" or (self.equals is not self.__undef__ and not (dirty and not self._equals[1])):
            dct["equals"] = dictify(self.equals)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._equals = (self._equals[0], True)

    def is_dirty(self):
        return any([self._equals[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IntegerEqualConstraint):
            return False
        return super(IntegerEqualConstraint, self).__eq__(other) and \
               self.equals == other.equals

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def equals(self):
        """
        The axis values must equal this value.

        :rtype: ``int``
        """
        return self._equals[0]

    @equals.setter
    def equals(self, value):
        self._equals = (value, True)

class MySQLGtidCoordinates(MySQLReplicationCoordinates):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLReplicationCoordinates` *)* The
    GTID coordinates on the master when a MySQL backup was taken.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLGtidCoordinates, self).__init__()
        self._type = ("MySQLGtidCoordinates", True)
        self._gtids = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLGtidCoordinates, cls).from_dict(data, dirty, undef_enabled)
        if "gtids" not in data:
            raise ValueError("Missing required property \"gtids\".")
        obj._gtids = []
        for item in data.get("gtids") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._gtids.append(item)
        obj._gtids = (obj._gtids, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLGtidCoordinates, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "gtids" == "type" or (self.gtids is not self.__undef__ and not (dirty and not self._gtids[1])):
            dct["gtids"] = dictify(self.gtids)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._gtids = (self._gtids[0], True)

    def is_dirty(self):
        return any([self._gtids[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLGtidCoordinates):
            return False
        return super(MySQLGtidCoordinates, self).__eq__(other) and \
               self.gtids == other.gtids

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def gtids(self):
        """
        The GTID coordinates on the master to start replication from.

        :rtype: ``list`` of ``basestring``
        """
        return self._gtids[0]

    @gtids.setter
    def gtids(self, value):
        self._gtids = (value, True)

class MySQLBinlogCoordinates(MySQLReplicationCoordinates):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLReplicationCoordinates` *)* The
    current position in the master binary logs when a MySQL backup was taken.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLBinlogCoordinates, self).__init__()
        self._type = ("MySQLBinlogCoordinates", True)
        self._master_log_name = (self.__undef__, True)
        self._master_log_pos = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLBinlogCoordinates, cls).from_dict(data, dirty, undef_enabled)
        if "masterLogName" not in data:
            raise ValueError("Missing required property \"masterLogName\".")
        obj._master_log_name = (data.get("masterLogName", obj.__undef__), dirty)
        if obj._master_log_name[0] is not None and obj._master_log_name[0] is not obj.__undef__:
            assert isinstance(obj._master_log_name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._master_log_name[0]))
            common.validate_format(obj._master_log_name[0], "None", None, None)
        if "masterLogPos" not in data:
            raise ValueError("Missing required property \"masterLogPos\".")
        obj._master_log_pos = (data.get("masterLogPos", obj.__undef__), dirty)
        if obj._master_log_pos[0] is not None and obj._master_log_pos[0] is not obj.__undef__:
            assert isinstance(obj._master_log_pos[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._master_log_pos[0]))
            common.validate_format(obj._master_log_pos[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLBinlogCoordinates, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "master_log_name" == "type" or (self.master_log_name is not self.__undef__ and not (dirty and not self._master_log_name[1])):
            dct["masterLogName"] = dictify(self.master_log_name)
        if "master_log_pos" == "type" or (self.master_log_pos is not self.__undef__ and not (dirty and not self._master_log_pos[1])):
            dct["masterLogPos"] = dictify(self.master_log_pos)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._master_log_name = (self._master_log_name[0], True)
        self._master_log_pos = (self._master_log_pos[0], True)

    def is_dirty(self):
        return any([self._master_log_name[1], self._master_log_pos[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLBinlogCoordinates):
            return False
        return super(MySQLBinlogCoordinates, self).__eq__(other) and \
               self.master_log_name == other.master_log_name and \
               self.master_log_pos == other.master_log_pos

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def master_log_name(self):
        """
        Name of the master log file to start replication from.

        :rtype: ``basestring``
        """
        return self._master_log_name[0]

    @master_log_name.setter
    def master_log_name(self, value):
        self._master_log_name = (value, True)

    @property
    def master_log_pos(self):
        """
        Position within the master log file to start replication from.

        :rtype: ``int``
        """
        return self._master_log_pos[0]

    @master_log_pos.setter
    def master_log_pos(self, value):
        self._master_log_pos = (value, True)

class ASECreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for an ASE
    container.
    """
    def __init__(self, undef_enabled=True):
        super(ASECreateTransformationParameters, self).__init__()
        self._type = ("ASECreateTransformationParameters", True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASECreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "ASEDBContainer"), dirty)
            factory.validate_type(obj._container[0], "ASEDBContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASECreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASECreateTransformationParameters):
            return False
        return super(ASECreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.ASEDBContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class MSSqlCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for a MSSql
    container.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlCreateTransformationParameters, self).__init__()
        self._type = ("MSSqlCreateTransformationParameters", True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MSSqlDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MSSqlDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlCreateTransformationParameters):
            return False
        return super(MSSqlCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.MSSqlDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class MySQLCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for a MySQL
    container.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLCreateTransformationParameters, self).__init__()
        self._type = ("MySQLCreateTransformationParameters", True)
        self._container = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "MySQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "MySQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._container[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLCreateTransformationParameters):
            return False
        return super(MySQLCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.MySQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def port(self):
        """
        The port number used for provisioning a MySQL container during
        transformation application.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class OracleCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for an Oracle
    container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleCreateTransformationParameters, self).__init__()
        self._type = ("OracleCreateTransformationParameters", True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "OracleDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "OracleDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleCreateTransformationParameters):
            return False
        return super(OracleCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.OracleDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class AppDataCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for an AppData
    container.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataCreateTransformationParameters, self).__init__()
        self._type = ("AppDataCreateTransformationParameters", True)
        self._container = (self.__undef__, True)
        self._payload = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "AppDataContainer"), dirty)
            factory.validate_type(obj._container[0], "AppDataContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        if "payload" in data and data["payload"] is not None:
            obj._payload = (data["payload"], dirty)
        else:
            obj._payload = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "payload" == "type" or (self.payload is not self.__undef__ and not (dirty and not self._payload[1])):
            dct["payload"] = dictify(self.payload)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._payload = (self._payload[0], True)

    def is_dirty(self):
        return any([self._container[1], self._payload[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataCreateTransformationParameters):
            return False
        return super(AppDataCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container and \
               self.payload == other.payload

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.AppDataContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def payload(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._payload[0]

    @payload.setter
    def payload(self, value):
        self._payload = (value, True)

class PgSQLCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for a PgSQL
    container.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLCreateTransformationParameters, self).__init__()
        self._type = ("PgSQLCreateTransformationParameters", True)
        self._container = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "PgSQLDatabaseContainer"), dirty)
            factory.validate_type(obj._container[0], "PgSQLDatabaseContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._container[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLCreateTransformationParameters):
            return False
        return super(PgSQLCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.PgSQLDatabaseContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def port(self):
        """
        The port number used for provisioning a PgSQL container during
        transformation application.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class VMwareCreateTransformationParameters(CreateTransformationParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CreateTransformationParameters` *)*
    Represents the parameters of a createTransformation request for a VMware
    container.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareCreateTransformationParameters, self).__init__()
        self._type = ("VMwareCreateTransformationParameters", True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareCreateTransformationParameters, cls).from_dict(data, dirty, undef_enabled)
        if "container" in data and data["container"] is not None:
            obj._container = (factory.create_object(data["container"], "VMwareContainer"), dirty)
            factory.validate_type(obj._container[0], "VMwareContainer")
        else:
            obj._container = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareCreateTransformationParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareCreateTransformationParameters):
            return False
        return super(VMwareCreateTransformationParameters, self).__eq__(other) and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        The container that will contain the transformed data associated with
        the newly created transformation; the "transformation container".

        :rtype: :py:class:`v1_8_1.web.vo.VMwareContainer`
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class PopulateCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories to populate into a
    warehouse.
    """
    def __init__(self, undef_enabled=True):
        super(PopulateCompatibilityParameters, self).__init__()
        self._type = ("PopulateCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PopulateCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PopulateCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PopulateCompatibilityParameters):
            return False
        return super(PopulateCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The warehouse repository to use as a source of compatibility
        information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class XPPCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for cross-platform
    provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(XPPCompatibilityParameters, self).__init__()
        self._type = ("XPPCompatibilityParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XPPCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XPPCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XPPCompatibilityParameters):
            return False
        return super(XPPCompatibilityParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point to use as a source of compatibility information.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class MigrateCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for migration.
    """
    def __init__(self, undef_enabled=True):
        super(MigrateCompatibilityParameters, self).__init__()
        self._type = ("MigrateCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MigrateCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MigrateCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MigrateCompatibilityParameters):
            return False
        return super(MigrateCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class StagingCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for staging.
    """
    def __init__(self, undef_enabled=True):
        super(StagingCompatibilityParameters, self).__init__()
        self._type = ("StagingCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(StagingCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(StagingCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, StagingCompatibilityParameters):
            return False
        return super(StagingCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class ProvisionCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for provisioning.
    """
    def __init__(self, undef_enabled=True):
        super(ProvisionCompatibilityParameters, self).__init__()
        self._type = ("ProvisionCompatibilityParameters", True)
        self._timeflow_point_parameters = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ProvisionCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "timeflowPointParameters" not in data:
            raise ValueError("Missing required property \"timeflowPointParameters\".")
        if "timeflowPointParameters" in data and data["timeflowPointParameters"] is not None:
            obj._timeflow_point_parameters = (factory.create_object(data["timeflowPointParameters"], "TimeflowPointParameters"), dirty)
            factory.validate_type(obj._timeflow_point_parameters[0], "TimeflowPointParameters")
        else:
            obj._timeflow_point_parameters = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ProvisionCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow_point_parameters" == "type" or (self.timeflow_point_parameters is not self.__undef__ and not (dirty and not self._timeflow_point_parameters[1])):
            dct["timeflowPointParameters"] = dictify(self.timeflow_point_parameters)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow_point_parameters = (self._timeflow_point_parameters[0], True)

    def is_dirty(self):
        return any([self._timeflow_point_parameters[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ProvisionCompatibilityParameters):
            return False
        return super(ProvisionCompatibilityParameters, self).__eq__(other) and \
               self.timeflow_point_parameters == other.timeflow_point_parameters

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow_point_parameters(self):
        """
        The TimeFlow point to use as a source of compatibility information.

        :rtype: :py:class:`v1_8_1.web.vo.TimeflowPointParameters`
        """
        return self._timeflow_point_parameters[0]

    @timeflow_point_parameters.setter
    def timeflow_point_parameters(self, value):
        self._timeflow_point_parameters = (value, True)

class UpgradeCompatibilityParameters(CompatibleRepositoriesParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.CompatibleRepositoriesParameters` *)*
    The criteria necessary to select valid repositories for upgrading.
    """
    def __init__(self, undef_enabled=True):
        super(UpgradeCompatibilityParameters, self).__init__()
        self._type = ("UpgradeCompatibilityParameters", True)
        self._source_repository = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UpgradeCompatibilityParameters, cls).from_dict(data, dirty, undef_enabled)
        if "sourceRepository" not in data:
            raise ValueError("Missing required property \"sourceRepository\".")
        obj._source_repository = (data.get("sourceRepository", obj.__undef__), dirty)
        if obj._source_repository[0] is not None and obj._source_repository[0] is not obj.__undef__:
            assert isinstance(obj._source_repository[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_repository[0]))
            common.validate_format(obj._source_repository[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UpgradeCompatibilityParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_repository" == "type" or (self.source_repository is not self.__undef__ and not (dirty and not self._source_repository[1])):
            dct["sourceRepository"] = dictify(self.source_repository)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_repository = (self._source_repository[0], True)

    def is_dirty(self):
        return any([self._source_repository[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UpgradeCompatibilityParameters):
            return False
        return super(UpgradeCompatibilityParameters, self).__eq__(other) and \
               self.source_repository == other.source_repository

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_repository(self):
        """
        The repository to use as a source of compatibility information.

        :rtype: ``basestring``
        """
        return self._source_repository[0]

    @source_repository.setter
    def source_repository(self, value):
        self._source_repository = (value, True)

class OracleSourcingPolicy(SourcingPolicy):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourcingPolicy` *)* Database policies
    for managing SnapSync and LogSync across sources for an Oracle container.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourcingPolicy, self).__init__()
        self._type = ("OracleSourcingPolicy", True)
        self._logsync_mode = (self.__undef__, True)
        self._logsync_interval = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourcingPolicy, cls).from_dict(data, dirty, undef_enabled)
        obj._logsync_mode = (data.get("logsyncMode", obj.__undef__), dirty)
        if obj._logsync_mode[0] is not None and obj._logsync_mode[0] is not obj.__undef__:
            assert isinstance(obj._logsync_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._logsync_mode[0]))
            assert obj._logsync_mode[0] in [u'ARCHIVE_ONLY_MODE', u'ARCHIVE_REDO_MODE', u'UNDEFINED'], "Expected enum [u'ARCHIVE_ONLY_MODE', u'ARCHIVE_REDO_MODE', u'UNDEFINED'] but got %s" % obj._logsync_mode[0]
            common.validate_format(obj._logsync_mode[0], "None", None, None)
        obj._logsync_interval = (data.get("logsyncInterval", obj.__undef__), dirty)
        if obj._logsync_interval[0] is not None and obj._logsync_interval[0] is not obj.__undef__:
            assert isinstance(obj._logsync_interval[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._logsync_interval[0]))
            common.validate_format(obj._logsync_interval[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourcingPolicy, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "logsync_mode" == "type" or (self.logsync_mode is not self.__undef__ and not (dirty and not self._logsync_mode[1])):
            dct["logsyncMode"] = dictify(self.logsync_mode)
        if "logsync_interval" == "type" or (self.logsync_interval is not self.__undef__ and not (dirty and not self._logsync_interval[1])):
            dct["logsyncInterval"] = dictify(self.logsync_interval)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._logsync_mode = (self._logsync_mode[0], True)
        self._logsync_interval = (self._logsync_interval[0], True)

    def is_dirty(self):
        return any([self._logsync_mode[1], self._logsync_interval[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourcingPolicy):
            return False
        return super(OracleSourcingPolicy, self).__eq__(other) and \
               self.logsync_mode == other.logsync_mode and \
               self.logsync_interval == other.logsync_interval

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def logsync_mode(self):
        """
        *(default value: UNDEFINED)* LogSync operation mode for this database.
        *(permitted values: ARCHIVE_ONLY_MODE, ARCHIVE_REDO_MODE, UNDEFINED)*

        :rtype: ``basestring``
        """
        return self._logsync_mode[0]

    @logsync_mode.setter
    def logsync_mode(self, value):
        self._logsync_mode = (value, True)

    @property
    def logsync_interval(self):
        """
        *(default value: 5)* Interval between LogSync requests, in seconds.

        :rtype: ``int``
        """
        return self._logsync_interval[0]

    @logsync_interval.setter
    def logsync_interval(self, value):
        self._logsync_interval = (value, True)

class AppDataFilesystemLayout(FilesystemLayout):
    """
    *(extends* :py:class:`v1_8_1.web.vo.FilesystemLayout` *)* A filesystem
    layout that matches the filesystem of a Delphix TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataFilesystemLayout, self).__init__()
        self._type = ("AppDataFilesystemLayout", True)
        self._target_directory = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataFilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        if "targetDirectory" not in data:
            raise ValueError("Missing required property \"targetDirectory\".")
        obj._target_directory = (data.get("targetDirectory", obj.__undef__), dirty)
        if obj._target_directory[0] is not None and obj._target_directory[0] is not obj.__undef__:
            assert isinstance(obj._target_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_directory[0]))
            common.validate_format(obj._target_directory[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataFilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target_directory" == "type" or (self.target_directory is not self.__undef__ and not (dirty and not self._target_directory[1])):
            dct["targetDirectory"] = dictify(self.target_directory)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target_directory = (self._target_directory[0], True)

    def is_dirty(self):
        return any([self._target_directory[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataFilesystemLayout):
            return False
        return super(AppDataFilesystemLayout, self).__eq__(other) and \
               self.target_directory == other.target_directory

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target_directory(self):
        """
        The base directory to use for the exported database.

        :rtype: ``basestring``
        """
        return self._target_directory[0]

    @target_directory.setter
    def target_directory(self, value):
        self._target_directory = (value, True)

class TimeflowFilesystemLayout(FilesystemLayout):
    """
    *(extends* :py:class:`v1_8_1.web.vo.FilesystemLayout` *)* A filesystem
    layout that matches the filesystem of a Delphix TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowFilesystemLayout, self).__init__()
        self._type = ("TimeflowFilesystemLayout", True)
        self._target_directory = (self.__undef__, True)
        self._data_directory = (self.__undef__, True)
        self._archive_directory = (self.__undef__, True)
        self._external_directory = (self.__undef__, True)
        self._temp_directory = (self.__undef__, True)
        self._script_directory = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowFilesystemLayout, cls).from_dict(data, dirty, undef_enabled)
        obj._target_directory = (data.get("targetDirectory", obj.__undef__), dirty)
        if obj._target_directory[0] is not None and obj._target_directory[0] is not obj.__undef__:
            assert isinstance(obj._target_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._target_directory[0]))
            common.validate_format(obj._target_directory[0], "None", None, None)
        obj._data_directory = (data.get("dataDirectory", obj.__undef__), dirty)
        if obj._data_directory[0] is not None and obj._data_directory[0] is not obj.__undef__:
            assert isinstance(obj._data_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_directory[0]))
            common.validate_format(obj._data_directory[0], "None", None, None)
        obj._archive_directory = (data.get("archiveDirectory", obj.__undef__), dirty)
        if obj._archive_directory[0] is not None and obj._archive_directory[0] is not obj.__undef__:
            assert isinstance(obj._archive_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._archive_directory[0]))
            common.validate_format(obj._archive_directory[0], "None", None, None)
        obj._external_directory = (data.get("externalDirectory", obj.__undef__), dirty)
        if obj._external_directory[0] is not None and obj._external_directory[0] is not obj.__undef__:
            assert isinstance(obj._external_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._external_directory[0]))
            common.validate_format(obj._external_directory[0], "None", None, None)
        obj._temp_directory = (data.get("tempDirectory", obj.__undef__), dirty)
        if obj._temp_directory[0] is not None and obj._temp_directory[0] is not obj.__undef__:
            assert isinstance(obj._temp_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._temp_directory[0]))
            common.validate_format(obj._temp_directory[0], "None", None, None)
        obj._script_directory = (data.get("scriptDirectory", obj.__undef__), dirty)
        if obj._script_directory[0] is not None and obj._script_directory[0] is not obj.__undef__:
            assert isinstance(obj._script_directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._script_directory[0]))
            common.validate_format(obj._script_directory[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowFilesystemLayout, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "target_directory" == "type" or (self.target_directory is not self.__undef__ and not (dirty and not self._target_directory[1])):
            dct["targetDirectory"] = dictify(self.target_directory)
        if "data_directory" == "type" or (self.data_directory is not self.__undef__ and not (dirty and not self._data_directory[1])):
            dct["dataDirectory"] = dictify(self.data_directory)
        if "archive_directory" == "type" or (self.archive_directory is not self.__undef__ and not (dirty and not self._archive_directory[1])):
            dct["archiveDirectory"] = dictify(self.archive_directory)
        if "external_directory" == "type" or (self.external_directory is not self.__undef__ and not (dirty and not self._external_directory[1])):
            dct["externalDirectory"] = dictify(self.external_directory)
        if "temp_directory" == "type" or (self.temp_directory is not self.__undef__ and not (dirty and not self._temp_directory[1])):
            dct["tempDirectory"] = dictify(self.temp_directory)
        if "script_directory" == "type" or (self.script_directory is not self.__undef__ and not (dirty and not self._script_directory[1])):
            dct["scriptDirectory"] = dictify(self.script_directory)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._target_directory = (self._target_directory[0], True)
        self._data_directory = (self._data_directory[0], True)
        self._archive_directory = (self._archive_directory[0], True)
        self._external_directory = (self._external_directory[0], True)
        self._temp_directory = (self._temp_directory[0], True)
        self._script_directory = (self._script_directory[0], True)

    def is_dirty(self):
        return any([self._target_directory[1], self._data_directory[1], self._archive_directory[1], self._external_directory[1], self._temp_directory[1], self._script_directory[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowFilesystemLayout):
            return False
        return super(TimeflowFilesystemLayout, self).__eq__(other) and \
               self.target_directory == other.target_directory and \
               self.data_directory == other.data_directory and \
               self.archive_directory == other.archive_directory and \
               self.external_directory == other.external_directory and \
               self.temp_directory == other.temp_directory and \
               self.script_directory == other.script_directory

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def target_directory(self):
        """
        The base directory to use for the exported database.

        :rtype: ``basestring``
        """
        return self._target_directory[0]

    @target_directory.setter
    def target_directory(self, value):
        self._target_directory = (value, True)

    @property
    def data_directory(self):
        """
        The directory for data files.

        :rtype: ``basestring``
        """
        return self._data_directory[0]

    @data_directory.setter
    def data_directory(self, value):
        self._data_directory = (value, True)

    @property
    def archive_directory(self):
        """
        The directory for archive files.

        :rtype: ``basestring``
        """
        return self._archive_directory[0]

    @archive_directory.setter
    def archive_directory(self, value):
        self._archive_directory = (value, True)

    @property
    def external_directory(self):
        """
        The directory for external files.

        :rtype: ``basestring``
        """
        return self._external_directory[0]

    @external_directory.setter
    def external_directory(self, value):
        self._external_directory = (value, True)

    @property
    def temp_directory(self):
        """
        The directory for temporary files.

        :rtype: ``basestring``
        """
        return self._temp_directory[0]

    @temp_directory.setter
    def temp_directory(self, value):
        self._temp_directory = (value, True)

    @property
    def script_directory(self):
        """
        The directory for script files.

        :rtype: ``basestring``
        """
        return self._script_directory[0]

    @script_directory.setter
    def script_directory(self, value):
        self._script_directory = (value, True)

class IoOpsDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Datapoint` *)* An analytics datapoint
    generated by the DISK_OPS, DxFS_OPS, DxFS_IO_QUEUE_OPS, iSCSI_OPS, NFS_OPS,
    or VFS_OPS statistic types.
    """
    def __init__(self, undef_enabled=True):
        super(IoOpsDatapoint, self).__init__()
        self._type = ("IoOpsDatapoint", True)
        self._count = (self.__undef__, True)
        self._latency = (self.__undef__, True)
        self._avg_latency = (self.__undef__, True)
        self._throughput = (self.__undef__, True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(IoOpsDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._count = (data.get("count", obj.__undef__), dirty)
        if obj._count[0] is not None and obj._count[0] is not obj.__undef__:
            assert isinstance(obj._count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._count[0]))
            common.validate_format(obj._count[0], "None", None, None)
        obj._latency = (data.get("latency", obj.__undef__), dirty)
        if obj._latency[0] is not None and obj._latency[0] is not obj.__undef__:
            assert isinstance(obj._latency[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._latency[0]))
            common.validate_format(obj._latency[0], "None", None, None)
        obj._avg_latency = (data.get("avgLatency", obj.__undef__), dirty)
        if obj._avg_latency[0] is not None and obj._avg_latency[0] is not obj.__undef__:
            assert isinstance(obj._avg_latency[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._avg_latency[0]))
            common.validate_format(obj._avg_latency[0], "None", None, None)
        obj._throughput = (data.get("throughput", obj.__undef__), dirty)
        if obj._throughput[0] is not None and obj._throughput[0] is not obj.__undef__:
            assert isinstance(obj._throughput[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._throughput[0]))
            common.validate_format(obj._throughput[0], "None", None, None)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], dict), ("Expected one of [u'object'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(IoOpsDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "count" == "type" or (self.count is not self.__undef__ and not (dirty and not self._count[1])):
            dct["count"] = dictify(self.count)
        if "latency" == "type" or (self.latency is not self.__undef__ and not (dirty and not self._latency[1])):
            dct["latency"] = dictify(self.latency)
        if "avg_latency" == "type" or (self.avg_latency is not self.__undef__ and not (dirty and not self._avg_latency[1])):
            dct["avgLatency"] = dictify(self.avg_latency)
        if "throughput" == "type" or (self.throughput is not self.__undef__ and not (dirty and not self._throughput[1])):
            dct["throughput"] = dictify(self.throughput)
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._count = (self._count[0], True)
        self._latency = (self._latency[0], True)
        self._avg_latency = (self._avg_latency[0], True)
        self._throughput = (self._throughput[0], True)
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._count[1], self._latency[1], self._avg_latency[1], self._throughput[1], self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, IoOpsDatapoint):
            return False
        return super(IoOpsDatapoint, self).__eq__(other) and \
               self.count == other.count and \
               self.latency == other.latency and \
               self.avg_latency == other.avg_latency and \
               self.throughput == other.throughput and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def count(self):
        """
        Number of I/O operations.

        :rtype: ``int``
        """
        return self._count[0]

    @count.setter
    def count(self, value):
        self._count = (value, True)

    @property
    def latency(self):
        """
        I/O latencies in nanoseconds.

        :rtype: ``dict``
        """
        return self._latency[0]

    @latency.setter
    def latency(self, value):
        self._latency = (value, True)

    @property
    def avg_latency(self):
        """
        Average I/O latency in nanoseconds.

        :rtype: ``int``
        """
        return self._avg_latency[0]

    @avg_latency.setter
    def avg_latency(self, value):
        self._avg_latency = (value, True)

    @property
    def throughput(self):
        """
        I/O throughput in bytes.

        :rtype: ``int``
        """
        return self._throughput[0]

    @throughput.setter
    def throughput(self, value):
        self._throughput = (value, True)

    @property
    def size(self):
        """
        I/O sizes in bytes.

        :rtype: ``dict``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class CpuUtilDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Datapoint` *)* An analytics datapoint
    generated by the CPU_UTIL statistic type.
    """
    def __init__(self, undef_enabled=True):
        super(CpuUtilDatapoint, self).__init__()
        self._type = ("CpuUtilDatapoint", True)
        self._dtrace = (self.__undef__, True)
        self._idle = (self.__undef__, True)
        self._user = (self.__undef__, True)
        self._kernel = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(CpuUtilDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._dtrace = (data.get("dtrace", obj.__undef__), dirty)
        if obj._dtrace[0] is not None and obj._dtrace[0] is not obj.__undef__:
            assert isinstance(obj._dtrace[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._dtrace[0]))
            common.validate_format(obj._dtrace[0], "None", None, None)
        obj._idle = (data.get("idle", obj.__undef__), dirty)
        if obj._idle[0] is not None and obj._idle[0] is not obj.__undef__:
            assert isinstance(obj._idle[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._idle[0]))
            common.validate_format(obj._idle[0], "None", None, None)
        obj._user = (data.get("user", obj.__undef__), dirty)
        if obj._user[0] is not None and obj._user[0] is not obj.__undef__:
            assert isinstance(obj._user[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._user[0]))
            common.validate_format(obj._user[0], "None", None, None)
        obj._kernel = (data.get("kernel", obj.__undef__), dirty)
        if obj._kernel[0] is not None and obj._kernel[0] is not obj.__undef__:
            assert isinstance(obj._kernel[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._kernel[0]))
            common.validate_format(obj._kernel[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(CpuUtilDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "dtrace" == "type" or (self.dtrace is not self.__undef__ and not (dirty and not self._dtrace[1])):
            dct["dtrace"] = dictify(self.dtrace)
        if "idle" == "type" or (self.idle is not self.__undef__ and not (dirty and not self._idle[1])):
            dct["idle"] = dictify(self.idle)
        if "user" == "type" or (self.user is not self.__undef__ and not (dirty and not self._user[1])):
            dct["user"] = dictify(self.user)
        if "kernel" == "type" or (self.kernel is not self.__undef__ and not (dirty and not self._kernel[1])):
            dct["kernel"] = dictify(self.kernel)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._dtrace = (self._dtrace[0], True)
        self._idle = (self._idle[0], True)
        self._user = (self._user[0], True)
        self._kernel = (self._kernel[0], True)

    def is_dirty(self):
        return any([self._dtrace[1], self._idle[1], self._user[1], self._kernel[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, CpuUtilDatapoint):
            return False
        return super(CpuUtilDatapoint, self).__eq__(other) and \
               self.dtrace == other.dtrace and \
               self.idle == other.idle and \
               self.user == other.user and \
               self.kernel == other.kernel

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def dtrace(self):
        """
        DTrace time in milliseconds (subset of time in kernel).

        :rtype: ``int``
        """
        return self._dtrace[0]

    @dtrace.setter
    def dtrace(self, value):
        self._dtrace = (value, True)

    @property
    def idle(self):
        """
        Idle time in milliseconds.

        :rtype: ``int``
        """
        return self._idle[0]

    @idle.setter
    def idle(self, value):
        self._idle = (value, True)

    @property
    def user(self):
        """
        User time in milliseconds.

        :rtype: ``int``
        """
        return self._user[0]

    @user.setter
    def user(self, value):
        self._user = (value, True)

    @property
    def kernel(self):
        """
        Kernel time in milliseconds.

        :rtype: ``int``
        """
        return self._kernel[0]

    @kernel.setter
    def kernel(self, value):
        self._kernel = (value, True)

class NetworkInterfaceUtilDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Datapoint` *)* An analytics datapoint
    generated by the NETWORK_INTERFACE_UTIL statistic type.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkInterfaceUtilDatapoint, self).__init__()
        self._type = ("NetworkInterfaceUtilDatapoint", True)
        self._in_bytes = (self.__undef__, True)
        self._out_packets = (self.__undef__, True)
        self._in_packets = (self.__undef__, True)
        self._out_bytes = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkInterfaceUtilDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._in_bytes = (data.get("inBytes", obj.__undef__), dirty)
        if obj._in_bytes[0] is not None and obj._in_bytes[0] is not obj.__undef__:
            assert isinstance(obj._in_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_bytes[0]))
            common.validate_format(obj._in_bytes[0], "None", None, None)
        obj._out_packets = (data.get("outPackets", obj.__undef__), dirty)
        if obj._out_packets[0] is not None and obj._out_packets[0] is not obj.__undef__:
            assert isinstance(obj._out_packets[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._out_packets[0]))
            common.validate_format(obj._out_packets[0], "None", None, None)
        obj._in_packets = (data.get("inPackets", obj.__undef__), dirty)
        if obj._in_packets[0] is not None and obj._in_packets[0] is not obj.__undef__:
            assert isinstance(obj._in_packets[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_packets[0]))
            common.validate_format(obj._in_packets[0], "None", None, None)
        obj._out_bytes = (data.get("outBytes", obj.__undef__), dirty)
        if obj._out_bytes[0] is not None and obj._out_bytes[0] is not obj.__undef__:
            assert isinstance(obj._out_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._out_bytes[0]))
            common.validate_format(obj._out_bytes[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkInterfaceUtilDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "in_bytes" == "type" or (self.in_bytes is not self.__undef__ and not (dirty and not self._in_bytes[1])):
            dct["inBytes"] = dictify(self.in_bytes)
        if "out_packets" == "type" or (self.out_packets is not self.__undef__ and not (dirty and not self._out_packets[1])):
            dct["outPackets"] = dictify(self.out_packets)
        if "in_packets" == "type" or (self.in_packets is not self.__undef__ and not (dirty and not self._in_packets[1])):
            dct["inPackets"] = dictify(self.in_packets)
        if "out_bytes" == "type" or (self.out_bytes is not self.__undef__ and not (dirty and not self._out_bytes[1])):
            dct["outBytes"] = dictify(self.out_bytes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._in_bytes = (self._in_bytes[0], True)
        self._out_packets = (self._out_packets[0], True)
        self._in_packets = (self._in_packets[0], True)
        self._out_bytes = (self._out_bytes[0], True)

    def is_dirty(self):
        return any([self._in_bytes[1], self._out_packets[1], self._in_packets[1], self._out_bytes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkInterfaceUtilDatapoint):
            return False
        return super(NetworkInterfaceUtilDatapoint, self).__eq__(other) and \
               self.in_bytes == other.in_bytes and \
               self.out_packets == other.out_packets and \
               self.in_packets == other.in_packets and \
               self.out_bytes == other.out_bytes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def in_bytes(self):
        """
        Bytes received on the interface.

        :rtype: ``int``
        """
        return self._in_bytes[0]

    @in_bytes.setter
    def in_bytes(self, value):
        self._in_bytes = (value, True)

    @property
    def out_packets(self):
        """
        Packets transmitted on the interface.

        :rtype: ``int``
        """
        return self._out_packets[0]

    @out_packets.setter
    def out_packets(self, value):
        self._out_packets = (value, True)

    @property
    def in_packets(self):
        """
        Packets received on the interface.

        :rtype: ``int``
        """
        return self._in_packets[0]

    @in_packets.setter
    def in_packets(self, value):
        self._in_packets = (value, True)

    @property
    def out_bytes(self):
        """
        Bytes transmitted on the interface.

        :rtype: ``int``
        """
        return self._out_bytes[0]

    @out_bytes.setter
    def out_bytes(self, value):
        self._out_bytes = (value, True)

class TCPStatsDatapoint(Datapoint):
    """
    *(extends* :py:class:`v1_8_1.web.vo.Datapoint` *)* An analytics datapoint
    generated by the TCP_STATS statistic type.
    """
    def __init__(self, undef_enabled=True):
        super(TCPStatsDatapoint, self).__init__()
        self._type = ("TCPStatsDatapoint", True)
        self._in_unordered_bytes = (self.__undef__, True)
        self._retransmitted_bytes = (self.__undef__, True)
        self._out_bytes = (self.__undef__, True)
        self._in_bytes = (self.__undef__, True)
        self._round_trip_time = (self.__undef__, True)
        self._receive_window_size = (self.__undef__, True)
        self._send_window_size = (self.__undef__, True)
        self._unacknowledged_bytes = (self.__undef__, True)
        self._congestion_window_size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TCPStatsDatapoint, cls).from_dict(data, dirty, undef_enabled)
        obj._in_unordered_bytes = (data.get("inUnorderedBytes", obj.__undef__), dirty)
        if obj._in_unordered_bytes[0] is not None and obj._in_unordered_bytes[0] is not obj.__undef__:
            assert isinstance(obj._in_unordered_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_unordered_bytes[0]))
            common.validate_format(obj._in_unordered_bytes[0], "None", None, None)
        obj._retransmitted_bytes = (data.get("retransmittedBytes", obj.__undef__), dirty)
        if obj._retransmitted_bytes[0] is not None and obj._retransmitted_bytes[0] is not obj.__undef__:
            assert isinstance(obj._retransmitted_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._retransmitted_bytes[0]))
            common.validate_format(obj._retransmitted_bytes[0], "None", None, None)
        obj._out_bytes = (data.get("outBytes", obj.__undef__), dirty)
        if obj._out_bytes[0] is not None and obj._out_bytes[0] is not obj.__undef__:
            assert isinstance(obj._out_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._out_bytes[0]))
            common.validate_format(obj._out_bytes[0], "None", None, None)
        obj._in_bytes = (data.get("inBytes", obj.__undef__), dirty)
        if obj._in_bytes[0] is not None and obj._in_bytes[0] is not obj.__undef__:
            assert isinstance(obj._in_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._in_bytes[0]))
            common.validate_format(obj._in_bytes[0], "None", None, None)
        obj._round_trip_time = (data.get("roundTripTime", obj.__undef__), dirty)
        if obj._round_trip_time[0] is not None and obj._round_trip_time[0] is not obj.__undef__:
            assert isinstance(obj._round_trip_time[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._round_trip_time[0]))
            common.validate_format(obj._round_trip_time[0], "None", None, None)
        obj._receive_window_size = (data.get("receiveWindowSize", obj.__undef__), dirty)
        if obj._receive_window_size[0] is not None and obj._receive_window_size[0] is not obj.__undef__:
            assert isinstance(obj._receive_window_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._receive_window_size[0]))
            common.validate_format(obj._receive_window_size[0], "None", None, None)
        obj._send_window_size = (data.get("sendWindowSize", obj.__undef__), dirty)
        if obj._send_window_size[0] is not None and obj._send_window_size[0] is not obj.__undef__:
            assert isinstance(obj._send_window_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._send_window_size[0]))
            common.validate_format(obj._send_window_size[0], "None", None, None)
        obj._unacknowledged_bytes = (data.get("unacknowledgedBytes", obj.__undef__), dirty)
        if obj._unacknowledged_bytes[0] is not None and obj._unacknowledged_bytes[0] is not obj.__undef__:
            assert isinstance(obj._unacknowledged_bytes[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._unacknowledged_bytes[0]))
            common.validate_format(obj._unacknowledged_bytes[0], "None", None, None)
        obj._congestion_window_size = (data.get("congestionWindowSize", obj.__undef__), dirty)
        if obj._congestion_window_size[0] is not None and obj._congestion_window_size[0] is not obj.__undef__:
            assert isinstance(obj._congestion_window_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._congestion_window_size[0]))
            common.validate_format(obj._congestion_window_size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TCPStatsDatapoint, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "in_unordered_bytes" == "type" or (self.in_unordered_bytes is not self.__undef__ and not (dirty and not self._in_unordered_bytes[1])):
            dct["inUnorderedBytes"] = dictify(self.in_unordered_bytes)
        if "retransmitted_bytes" == "type" or (self.retransmitted_bytes is not self.__undef__ and not (dirty and not self._retransmitted_bytes[1])):
            dct["retransmittedBytes"] = dictify(self.retransmitted_bytes)
        if "out_bytes" == "type" or (self.out_bytes is not self.__undef__ and not (dirty and not self._out_bytes[1])):
            dct["outBytes"] = dictify(self.out_bytes)
        if "in_bytes" == "type" or (self.in_bytes is not self.__undef__ and not (dirty and not self._in_bytes[1])):
            dct["inBytes"] = dictify(self.in_bytes)
        if "round_trip_time" == "type" or (self.round_trip_time is not self.__undef__ and not (dirty and not self._round_trip_time[1])):
            dct["roundTripTime"] = dictify(self.round_trip_time)
        if "receive_window_size" == "type" or (self.receive_window_size is not self.__undef__ and not (dirty and not self._receive_window_size[1])):
            dct["receiveWindowSize"] = dictify(self.receive_window_size)
        if "send_window_size" == "type" or (self.send_window_size is not self.__undef__ and not (dirty and not self._send_window_size[1])):
            dct["sendWindowSize"] = dictify(self.send_window_size)
        if "unacknowledged_bytes" == "type" or (self.unacknowledged_bytes is not self.__undef__ and not (dirty and not self._unacknowledged_bytes[1])):
            dct["unacknowledgedBytes"] = dictify(self.unacknowledged_bytes)
        if "congestion_window_size" == "type" or (self.congestion_window_size is not self.__undef__ and not (dirty and not self._congestion_window_size[1])):
            dct["congestionWindowSize"] = dictify(self.congestion_window_size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._in_unordered_bytes = (self._in_unordered_bytes[0], True)
        self._retransmitted_bytes = (self._retransmitted_bytes[0], True)
        self._out_bytes = (self._out_bytes[0], True)
        self._in_bytes = (self._in_bytes[0], True)
        self._round_trip_time = (self._round_trip_time[0], True)
        self._receive_window_size = (self._receive_window_size[0], True)
        self._send_window_size = (self._send_window_size[0], True)
        self._unacknowledged_bytes = (self._unacknowledged_bytes[0], True)
        self._congestion_window_size = (self._congestion_window_size[0], True)

    def is_dirty(self):
        return any([self._in_unordered_bytes[1], self._retransmitted_bytes[1], self._out_bytes[1], self._in_bytes[1], self._round_trip_time[1], self._receive_window_size[1], self._send_window_size[1], self._unacknowledged_bytes[1], self._congestion_window_size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TCPStatsDatapoint):
            return False
        return super(TCPStatsDatapoint, self).__eq__(other) and \
               self.in_unordered_bytes == other.in_unordered_bytes and \
               self.retransmitted_bytes == other.retransmitted_bytes and \
               self.out_bytes == other.out_bytes and \
               self.in_bytes == other.in_bytes and \
               self.round_trip_time == other.round_trip_time and \
               self.receive_window_size == other.receive_window_size and \
               self.send_window_size == other.send_window_size and \
               self.unacknowledged_bytes == other.unacknowledged_bytes and \
               self.congestion_window_size == other.congestion_window_size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def in_unordered_bytes(self):
        """
        Number of bytes received out of order. This is a subset of the
        'inBytes' value.

        :rtype: ``int``
        """
        return self._in_unordered_bytes[0]

    @in_unordered_bytes.setter
    def in_unordered_bytes(self, value):
        self._in_unordered_bytes = (value, True)

    @property
    def retransmitted_bytes(self):
        """
        Bytes retransmitted.

        :rtype: ``int``
        """
        return self._retransmitted_bytes[0]

    @retransmitted_bytes.setter
    def retransmitted_bytes(self, value):
        self._retransmitted_bytes = (value, True)

    @property
    def out_bytes(self):
        """
        Data bytes transmitted.

        :rtype: ``int``
        """
        return self._out_bytes[0]

    @out_bytes.setter
    def out_bytes(self, value):
        self._out_bytes = (value, True)

    @property
    def in_bytes(self):
        """
        Data bytes received.

        :rtype: ``int``
        """
        return self._in_bytes[0]

    @in_bytes.setter
    def in_bytes(self, value):
        self._in_bytes = (value, True)

    @property
    def round_trip_time(self):
        """
        The smoothed average round trip time for this connection (us).

        :rtype: ``int``
        """
        return self._round_trip_time[0]

    @round_trip_time.setter
    def round_trip_time(self, value):
        self._round_trip_time = (value, True)

    @property
    def receive_window_size(self):
        """
        The size of the local receive window.

        :rtype: ``int``
        """
        return self._receive_window_size[0]

    @receive_window_size.setter
    def receive_window_size(self, value):
        self._receive_window_size = (value, True)

    @property
    def send_window_size(self):
        """
        The size of the peer's receive window.

        :rtype: ``int``
        """
        return self._send_window_size[0]

    @send_window_size.setter
    def send_window_size(self, value):
        self._send_window_size = (value, True)

    @property
    def unacknowledged_bytes(self):
        """
        Number of bytes sent but unacknowledged.

        :rtype: ``int``
        """
        return self._unacknowledged_bytes[0]

    @unacknowledged_bytes.setter
    def unacknowledged_bytes(self, value):
        self._unacknowledged_bytes = (value, True)

    @property
    def congestion_window_size(self):
        """
        The size of the local congestion window.

        :rtype: ``int``
        """
        return self._congestion_window_size[0]

    @congestion_window_size.setter
    def congestion_window_size(self, value):
        self._congestion_window_size = (value, True)

class MSSqlSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a MSSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSourceRuntime, self).__init__()
        self._type = ("MSSqlSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSourceRuntime):
            return False
        return super(MSSqlSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleBaseSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties common to all Oracle sources.
    """
    def __init__(self, undef_enabled=True):
        super(OracleBaseSourceRuntime, self).__init__()
        self._type = ("OracleBaseSourceRuntime", True)
        self._active_instances = (self.__undef__, True)
        self._database_mode = (self.__undef__, True)
        self._database_role = (self.__undef__, True)
        self._database_stats = (self.__undef__, True)
        self._last_non_logged_location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleBaseSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._active_instances = []
        for item in data.get("activeInstances") or []:
            obj._active_instances.append(factory.create_object(item))
            factory.validate_type(obj._active_instances[-1], "OracleActiveInstance")
        obj._active_instances = (obj._active_instances, dirty)
        obj._database_mode = (data.get("databaseMode", obj.__undef__), dirty)
        if obj._database_mode[0] is not None and obj._database_mode[0] is not obj.__undef__:
            assert isinstance(obj._database_mode[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_mode[0]))
            assert obj._database_mode[0] in [u'READ_WRITE', u'READ_ONLY', u'STANDBY_READ_ONLY', u'MOUNTED_ONLY', u'UNKNOWN'], "Expected enum [u'READ_WRITE', u'READ_ONLY', u'STANDBY_READ_ONLY', u'MOUNTED_ONLY', u'UNKNOWN'] but got %s" % obj._database_mode[0]
            common.validate_format(obj._database_mode[0], "None", None, None)
        obj._database_role = (data.get("databaseRole", obj.__undef__), dirty)
        if obj._database_role[0] is not None and obj._database_role[0] is not obj.__undef__:
            assert isinstance(obj._database_role[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._database_role[0]))
            assert obj._database_role[0] in [u'PHYSICAL_STANDBY', u'LOGICAL_STANDBY', u'SNAPSHOT_STANDBY', u'FAR_SYNC', u'PRIMARY', u'UNKNOWN'], "Expected enum [u'PHYSICAL_STANDBY', u'LOGICAL_STANDBY', u'SNAPSHOT_STANDBY', u'FAR_SYNC', u'PRIMARY', u'UNKNOWN'] but got %s" % obj._database_role[0]
            common.validate_format(obj._database_role[0], "None", None, None)
        obj._database_stats = []
        for item in data.get("databaseStats") or []:
            obj._database_stats.append(factory.create_object(item))
            factory.validate_type(obj._database_stats[-1], "OracleDatabaseStatsSection")
        obj._database_stats = (obj._database_stats, dirty)
        obj._last_non_logged_location = (data.get("lastNonLoggedLocation", obj.__undef__), dirty)
        if obj._last_non_logged_location[0] is not None and obj._last_non_logged_location[0] is not obj.__undef__:
            assert isinstance(obj._last_non_logged_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_non_logged_location[0]))
            common.validate_format(obj._last_non_logged_location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleBaseSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "active_instances" == "type" or (self.active_instances is not self.__undef__ and not (dirty and not self._active_instances[1])):
            dct["activeInstances"] = dictify(self.active_instances)
        if "database_mode" == "type" or (self.database_mode is not self.__undef__ and not (dirty and not self._database_mode[1])):
            dct["databaseMode"] = dictify(self.database_mode)
        if "database_role" == "type" or (self.database_role is not self.__undef__ and not (dirty and not self._database_role[1])):
            dct["databaseRole"] = dictify(self.database_role)
        if "database_stats" == "type" or (self.database_stats is not self.__undef__ and not (dirty and not self._database_stats[1])):
            dct["databaseStats"] = dictify(self.database_stats)
        if "last_non_logged_location" == "type" or (self.last_non_logged_location is not self.__undef__ and not (dirty and not self._last_non_logged_location[1])):
            dct["lastNonLoggedLocation"] = dictify(self.last_non_logged_location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._active_instances = (self._active_instances[0], True)
        self._database_mode = (self._database_mode[0], True)
        self._database_role = (self._database_role[0], True)
        self._database_stats = (self._database_stats[0], True)
        self._last_non_logged_location = (self._last_non_logged_location[0], True)

    def is_dirty(self):
        return any([self._active_instances[1], self._database_mode[1], self._database_role[1], self._database_stats[1], self._last_non_logged_location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleBaseSourceRuntime):
            return False
        return super(OracleBaseSourceRuntime, self).__eq__(other) and \
               self.active_instances == other.active_instances and \
               self.database_mode == other.database_mode and \
               self.database_role == other.database_role and \
               self.database_stats == other.database_stats and \
               self.last_non_logged_location == other.last_non_logged_location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def active_instances(self):
        """
        List of active database instances for the source.

        :rtype: ``list`` of :py:class:`v1_8_1.web.vo.OracleActiveInstance`
        """
        return self._active_instances[0]

    @active_instances.setter
    def active_instances(self, value):
        self._active_instances = (value, True)

    @property
    def database_mode(self):
        """
        *(default value: UNKNOWN)* Operating mode of the database. *(permitted
        values: READ_WRITE, READ_ONLY, STANDBY_READ_ONLY, MOUNTED_ONLY,
        UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._database_mode[0]

    @database_mode.setter
    def database_mode(self, value):
        self._database_mode = (value, True)

    @property
    def database_role(self):
        """
        *(default value: UNKNOWN)* The current role of the database.
        *(permitted values: PHYSICAL_STANDBY, LOGICAL_STANDBY,
        SNAPSHOT_STANDBY, FAR_SYNC, PRIMARY, UNKNOWN)*

        :rtype: ``basestring``
        """
        return self._database_role[0]

    @database_role.setter
    def database_role(self, value):
        self._database_role = (value, True)

    @property
    def database_stats(self):
        """
        Table of key database performance statistics.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.OracleDatabaseStatsSection`
        """
        return self._database_stats[0]

    @database_stats.setter
    def database_stats(self, value):
        self._database_stats = (value, True)

    @property
    def last_non_logged_location(self):
        """
        Highest SCN at which non-logged changes were generated.

        :rtype: ``basestring``
        """
        return self._last_non_logged_location[0]

    @last_non_logged_location.setter
    def last_non_logged_location(self, value):
        self._last_non_logged_location = (value, True)

class AppDataSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of an AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSourceRuntime, self).__init__()
        self._type = ("AppDataSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSourceRuntime):
            return False
        return super(AppDataSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class VMwareSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a VMware source.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareSourceRuntime, self).__init__()
        self._type = ("VMwareSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareSourceRuntime):
            return False
        return super(VMwareSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASESourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a SAP ASE source.
    """
    def __init__(self, undef_enabled=True):
        super(ASESourceRuntime, self).__init__()
        self._type = ("ASESourceRuntime", True)
        self._durability_level = (self.__undef__, True)
        self._truncate_log_on_checkpoint = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._durability_level = (data.get("durabilityLevel", obj.__undef__), dirty)
        if obj._durability_level[0] is not None and obj._durability_level[0] is not obj.__undef__:
            assert isinstance(obj._durability_level[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._durability_level[0]))
            assert obj._durability_level[0] in [u'FULL', u'AT_SHUTDOWN', u'NO_RECOVERY'], "Expected enum [u'FULL', u'AT_SHUTDOWN', u'NO_RECOVERY'] but got %s" % obj._durability_level[0]
            common.validate_format(obj._durability_level[0], "None", None, None)
        obj._truncate_log_on_checkpoint = (data.get("truncateLogOnCheckpoint", obj.__undef__), dirty)
        if obj._truncate_log_on_checkpoint[0] is not None and obj._truncate_log_on_checkpoint[0] is not obj.__undef__:
            assert isinstance(obj._truncate_log_on_checkpoint[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._truncate_log_on_checkpoint[0]))
            common.validate_format(obj._truncate_log_on_checkpoint[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "durability_level" == "type" or (self.durability_level is not self.__undef__ and not (dirty and not self._durability_level[1])):
            dct["durabilityLevel"] = dictify(self.durability_level)
        if "truncate_log_on_checkpoint" == "type" or (self.truncate_log_on_checkpoint is not self.__undef__ and not (dirty and not self._truncate_log_on_checkpoint[1])):
            dct["truncateLogOnCheckpoint"] = dictify(self.truncate_log_on_checkpoint)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._durability_level = (self._durability_level[0], True)
        self._truncate_log_on_checkpoint = (self._truncate_log_on_checkpoint[0], True)

    def is_dirty(self):
        return any([self._durability_level[1], self._truncate_log_on_checkpoint[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESourceRuntime):
            return False
        return super(ASESourceRuntime, self).__eq__(other) and \
               self.durability_level == other.durability_level and \
               self.truncate_log_on_checkpoint == other.truncate_log_on_checkpoint

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def durability_level(self):
        """
        SAP ASE database durability level. *(permitted values: FULL,
        AT_SHUTDOWN, NO_RECOVERY)*

        :rtype: ``basestring``
        """
        return self._durability_level[0]

    @durability_level.setter
    def durability_level(self, value):
        self._durability_level = (value, True)

    @property
    def truncate_log_on_checkpoint(self):
        """
        True if configured to truncate log on checkpoint.

        :rtype: ``bool``
        """
        return self._truncate_log_on_checkpoint[0]

    @truncate_log_on_checkpoint.setter
    def truncate_log_on_checkpoint(self, value):
        self._truncate_log_on_checkpoint = (value, True)

class PgSQLSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Runtime (non-
    persistent) properties of a PostgreSQL source.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSourceRuntime, self).__init__()
        self._type = ("PgSQLSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSourceRuntime):
            return False
        return super(PgSQLSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLSourceRuntime(SourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceRuntime` *)* Non-persistent
    runtime properties of a MySQL source.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSourceRuntime, self).__init__()
        self._type = ("MySQLSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSourceRuntime):
            return False
        return super(MySQLSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleSourceRuntime(OracleBaseSourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseSourceRuntime` *)* Runtime
    (non-persistent) properties of an Oracle source.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSourceRuntime, self).__init__()
        self._type = ("OracleSourceRuntime", True)
        self._bct_enabled = (self.__undef__, True)
        self._dnfs_enabled = (self.__undef__, True)
        self._archivelog_enabled = (self.__undef__, True)
        self._rac_enabled = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._bct_enabled = (data.get("bctEnabled", obj.__undef__), dirty)
        if obj._bct_enabled[0] is not None and obj._bct_enabled[0] is not obj.__undef__:
            assert isinstance(obj._bct_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._bct_enabled[0]))
            common.validate_format(obj._bct_enabled[0], "None", None, None)
        obj._dnfs_enabled = (data.get("dnfsEnabled", obj.__undef__), dirty)
        if obj._dnfs_enabled[0] is not None and obj._dnfs_enabled[0] is not obj.__undef__:
            assert isinstance(obj._dnfs_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._dnfs_enabled[0]))
            common.validate_format(obj._dnfs_enabled[0], "None", None, None)
        obj._archivelog_enabled = (data.get("archivelogEnabled", obj.__undef__), dirty)
        if obj._archivelog_enabled[0] is not None and obj._archivelog_enabled[0] is not obj.__undef__:
            assert isinstance(obj._archivelog_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._archivelog_enabled[0]))
            common.validate_format(obj._archivelog_enabled[0], "None", None, None)
        obj._rac_enabled = (data.get("racEnabled", obj.__undef__), dirty)
        if obj._rac_enabled[0] is not None and obj._rac_enabled[0] is not obj.__undef__:
            assert isinstance(obj._rac_enabled[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._rac_enabled[0]))
            common.validate_format(obj._rac_enabled[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bct_enabled" == "type" or (self.bct_enabled is not self.__undef__ and not (dirty and not self._bct_enabled[1])):
            dct["bctEnabled"] = dictify(self.bct_enabled)
        if "dnfs_enabled" == "type" or (self.dnfs_enabled is not self.__undef__ and not (dirty and not self._dnfs_enabled[1])):
            dct["dnfsEnabled"] = dictify(self.dnfs_enabled)
        if "archivelog_enabled" == "type" or (self.archivelog_enabled is not self.__undef__ and not (dirty and not self._archivelog_enabled[1])):
            dct["archivelogEnabled"] = dictify(self.archivelog_enabled)
        if "rac_enabled" == "type" or (self.rac_enabled is not self.__undef__ and not (dirty and not self._rac_enabled[1])):
            dct["racEnabled"] = dictify(self.rac_enabled)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bct_enabled = (self._bct_enabled[0], True)
        self._dnfs_enabled = (self._dnfs_enabled[0], True)
        self._archivelog_enabled = (self._archivelog_enabled[0], True)
        self._rac_enabled = (self._rac_enabled[0], True)

    def is_dirty(self):
        return any([self._bct_enabled[1], self._dnfs_enabled[1], self._archivelog_enabled[1], self._rac_enabled[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSourceRuntime):
            return False
        return super(OracleSourceRuntime, self).__eq__(other) and \
               self.bct_enabled == other.bct_enabled and \
               self.dnfs_enabled == other.dnfs_enabled and \
               self.archivelog_enabled == other.archivelog_enabled and \
               self.rac_enabled == other.rac_enabled

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bct_enabled(self):
        """
        True if block change tracking is enabled.

        :rtype: ``bool``
        """
        return self._bct_enabled[0]

    @bct_enabled.setter
    def bct_enabled(self, value):
        self._bct_enabled = (value, True)

    @property
    def dnfs_enabled(self):
        """
        True if the database has Oracle Direct NFS client enabled.

        :rtype: ``bool``
        """
        return self._dnfs_enabled[0]

    @dnfs_enabled.setter
    def dnfs_enabled(self, value):
        self._dnfs_enabled = (value, True)

    @property
    def archivelog_enabled(self):
        """
        True if the database is running in ARCHIVELOG mode.

        :rtype: ``bool``
        """
        return self._archivelog_enabled[0]

    @archivelog_enabled.setter
    def archivelog_enabled(self, value):
        self._archivelog_enabled = (value, True)

    @property
    def rac_enabled(self):
        """
        True for a RAC source database.

        :rtype: ``bool``
        """
        return self._rac_enabled[0]

    @rac_enabled.setter
    def rac_enabled(self, value):
        self._rac_enabled = (value, True)

class OraclePDBSourceRuntime(OracleBaseSourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseSourceRuntime` *)* Runtime
    (non-persistent) properties of an Oracle PDB source.
    """
    def __init__(self, undef_enabled=True):
        super(OraclePDBSourceRuntime, self).__init__()
        self._type = ("OraclePDBSourceRuntime", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OraclePDBSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OraclePDBSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OraclePDBSourceRuntime):
            return False
        return super(OraclePDBSourceRuntime, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleLiveSourceRuntime(OracleBaseSourceRuntime):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleBaseSourceRuntime` *)* Runtime
    (non-persistent) properties of an Oracle LiveSource.
    """
    def __init__(self, undef_enabled=True):
        super(OracleLiveSourceRuntime, self).__init__()
        self._type = ("OracleLiveSourceRuntime", True)
        self._source_resetlogs_id_change_detected = (self.__undef__, True)
        self._last_update_time = (self.__undef__, True)
        self._is_data_age_warning_exceeded = (self.__undef__, True)
        self._current_data_age = (self.__undef__, True)
        self._apply_status = (self.__undef__, True)
        self._unexpected_role_change_detected = (self.__undef__, True)
        self._transport_status = (self.__undef__, True)
        self._non_logged_data_detected = (self.__undef__, True)
        self._source_database_timezone = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleLiveSourceRuntime, cls).from_dict(data, dirty, undef_enabled)
        obj._source_resetlogs_id_change_detected = (data.get("sourceResetlogsIDChangeDetected", obj.__undef__), dirty)
        if obj._source_resetlogs_id_change_detected[0] is not None and obj._source_resetlogs_id_change_detected[0] is not obj.__undef__:
            assert isinstance(obj._source_resetlogs_id_change_detected[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._source_resetlogs_id_change_detected[0]))
            common.validate_format(obj._source_resetlogs_id_change_detected[0], "None", None, None)
        obj._last_update_time = (data.get("lastUpdateTime", obj.__undef__), dirty)
        if obj._last_update_time[0] is not None and obj._last_update_time[0] is not obj.__undef__:
            assert isinstance(obj._last_update_time[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._last_update_time[0]))
            common.validate_format(obj._last_update_time[0], "date", None, None)
        obj._is_data_age_warning_exceeded = (data.get("isDataAgeWarningExceeded", obj.__undef__), dirty)
        if obj._is_data_age_warning_exceeded[0] is not None and obj._is_data_age_warning_exceeded[0] is not obj.__undef__:
            assert isinstance(obj._is_data_age_warning_exceeded[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._is_data_age_warning_exceeded[0]))
            common.validate_format(obj._is_data_age_warning_exceeded[0], "None", None, None)
        obj._current_data_age = (data.get("currentDataAge", obj.__undef__), dirty)
        if obj._current_data_age[0] is not None and obj._current_data_age[0] is not obj.__undef__:
            assert isinstance(obj._current_data_age[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._current_data_age[0]))
            common.validate_format(obj._current_data_age[0], "None", None, None)
        obj._apply_status = (data.get("applyStatus", obj.__undef__), dirty)
        if obj._apply_status[0] is not None and obj._apply_status[0] is not obj.__undef__:
            assert isinstance(obj._apply_status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._apply_status[0]))
            assert obj._apply_status[0] in [u'UNKNOWN', u'WORKING', u'APPLY_FAILED', u'APPLY_ON_WRONG_INCARNATION', u'UNRESOLVABLE_GAP_DETECTED'], "Expected enum [u'UNKNOWN', u'WORKING', u'APPLY_FAILED', u'APPLY_ON_WRONG_INCARNATION', u'UNRESOLVABLE_GAP_DETECTED'] but got %s" % obj._apply_status[0]
            common.validate_format(obj._apply_status[0], "None", None, None)
        obj._unexpected_role_change_detected = (data.get("unexpectedRoleChangeDetected", obj.__undef__), dirty)
        if obj._unexpected_role_change_detected[0] is not None and obj._unexpected_role_change_detected[0] is not obj.__undef__:
            assert isinstance(obj._unexpected_role_change_detected[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._unexpected_role_change_detected[0]))
            common.validate_format(obj._unexpected_role_change_detected[0], "None", None, None)
        obj._transport_status = (data.get("transportStatus", obj.__undef__), dirty)
        if obj._transport_status[0] is not None and obj._transport_status[0] is not obj.__undef__:
            assert isinstance(obj._transport_status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._transport_status[0]))
            assert obj._transport_status[0] in [u'UNKNOWN', u'WORKING', u'NO_INITIAL_DATA', u'NO_NEW_DATA'], "Expected enum [u'UNKNOWN', u'WORKING', u'NO_INITIAL_DATA', u'NO_NEW_DATA'] but got %s" % obj._transport_status[0]
            common.validate_format(obj._transport_status[0], "None", None, None)
        obj._non_logged_data_detected = (data.get("nonLoggedDataDetected", obj.__undef__), dirty)
        if obj._non_logged_data_detected[0] is not None and obj._non_logged_data_detected[0] is not obj.__undef__:
            assert isinstance(obj._non_logged_data_detected[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._non_logged_data_detected[0]))
            common.validate_format(obj._non_logged_data_detected[0], "None", None, None)
        obj._source_database_timezone = (data.get("sourceDatabaseTimezone", obj.__undef__), dirty)
        if obj._source_database_timezone[0] is not None and obj._source_database_timezone[0] is not obj.__undef__:
            assert isinstance(obj._source_database_timezone[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._source_database_timezone[0]))
            common.validate_format(obj._source_database_timezone[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleLiveSourceRuntime, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "source_resetlogs_id_change_detected" == "type" or (self.source_resetlogs_id_change_detected is not self.__undef__ and not (dirty and not self._source_resetlogs_id_change_detected[1])):
            dct["sourceResetlogsIDChangeDetected"] = dictify(self.source_resetlogs_id_change_detected)
        if "last_update_time" == "type" or (self.last_update_time is not self.__undef__ and not (dirty and not self._last_update_time[1])):
            dct["lastUpdateTime"] = dictify(self.last_update_time)
        if "is_data_age_warning_exceeded" == "type" or (self.is_data_age_warning_exceeded is not self.__undef__ and not (dirty and not self._is_data_age_warning_exceeded[1])):
            dct["isDataAgeWarningExceeded"] = dictify(self.is_data_age_warning_exceeded)
        if "current_data_age" == "type" or (self.current_data_age is not self.__undef__ and not (dirty and not self._current_data_age[1])):
            dct["currentDataAge"] = dictify(self.current_data_age)
        if "apply_status" == "type" or (self.apply_status is not self.__undef__ and not (dirty and not self._apply_status[1])):
            dct["applyStatus"] = dictify(self.apply_status)
        if "unexpected_role_change_detected" == "type" or (self.unexpected_role_change_detected is not self.__undef__ and not (dirty and not self._unexpected_role_change_detected[1])):
            dct["unexpectedRoleChangeDetected"] = dictify(self.unexpected_role_change_detected)
        if "transport_status" == "type" or (self.transport_status is not self.__undef__ and not (dirty and not self._transport_status[1])):
            dct["transportStatus"] = dictify(self.transport_status)
        if "non_logged_data_detected" == "type" or (self.non_logged_data_detected is not self.__undef__ and not (dirty and not self._non_logged_data_detected[1])):
            dct["nonLoggedDataDetected"] = dictify(self.non_logged_data_detected)
        if "source_database_timezone" == "type" or (self.source_database_timezone is not self.__undef__ and not (dirty and not self._source_database_timezone[1])):
            dct["sourceDatabaseTimezone"] = dictify(self.source_database_timezone)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._source_resetlogs_id_change_detected = (self._source_resetlogs_id_change_detected[0], True)
        self._last_update_time = (self._last_update_time[0], True)
        self._is_data_age_warning_exceeded = (self._is_data_age_warning_exceeded[0], True)
        self._current_data_age = (self._current_data_age[0], True)
        self._apply_status = (self._apply_status[0], True)
        self._unexpected_role_change_detected = (self._unexpected_role_change_detected[0], True)
        self._transport_status = (self._transport_status[0], True)
        self._non_logged_data_detected = (self._non_logged_data_detected[0], True)
        self._source_database_timezone = (self._source_database_timezone[0], True)

    def is_dirty(self):
        return any([self._source_resetlogs_id_change_detected[1], self._last_update_time[1], self._is_data_age_warning_exceeded[1], self._current_data_age[1], self._apply_status[1], self._unexpected_role_change_detected[1], self._transport_status[1], self._non_logged_data_detected[1], self._source_database_timezone[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleLiveSourceRuntime):
            return False
        return super(OracleLiveSourceRuntime, self).__eq__(other) and \
               self.source_resetlogs_id_change_detected == other.source_resetlogs_id_change_detected and \
               self.last_update_time == other.last_update_time and \
               self.is_data_age_warning_exceeded == other.is_data_age_warning_exceeded and \
               self.current_data_age == other.current_data_age and \
               self.apply_status == other.apply_status and \
               self.unexpected_role_change_detected == other.unexpected_role_change_detected and \
               self.transport_status == other.transport_status and \
               self.non_logged_data_detected == other.non_logged_data_detected and \
               self.source_database_timezone == other.source_database_timezone

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def source_resetlogs_id_change_detected(self):
        """
        Indicates whether the incarnation ID changed on the primary database.

        :rtype: ``bool``
        """
        return self._source_resetlogs_id_change_detected[0]

    @source_resetlogs_id_change_detected.setter
    def source_resetlogs_id_change_detected(self, value):
        self._source_resetlogs_id_change_detected = (value, True)

    @property
    def last_update_time(self):
        """
        The time at which this runtime data was updated.

        :rtype: ``basestring``
        """
        return self._last_update_time[0]

    @last_update_time.setter
    def last_update_time(self, value):
        self._last_update_time = (value, True)

    @property
    def is_data_age_warning_exceeded(self):
        """
        Has data age exceeded the user specified threshold.

        :rtype: ``bool``
        """
        return self._is_data_age_warning_exceeded[0]

    @is_data_age_warning_exceeded.setter
    def is_data_age_warning_exceeded(self, value):
        self._is_data_age_warning_exceeded = (value, True)

    @property
    def current_data_age(self):
        """
        Current data lag between LiveSource and source database in seconds.

        :rtype: ``int``
        """
        return self._current_data_age[0]

    @current_data_age.setter
    def current_data_age(self, value):
        self._current_data_age = (value, True)

    @property
    def apply_status(self):
        """
        MRP apply status for the standby database associated with the
        LiveSource. *(permitted values: UNKNOWN, WORKING, APPLY_FAILED,
        APPLY_ON_WRONG_INCARNATION, UNRESOLVABLE_GAP_DETECTED)*

        :rtype: ``basestring``
        """
        return self._apply_status[0]

    @apply_status.setter
    def apply_status(self, value):
        self._apply_status = (value, True)

    @property
    def unexpected_role_change_detected(self):
        """
        Indicates whether the LiveSource is not in standby mode.

        :rtype: ``bool``
        """
        return self._unexpected_role_change_detected[0]

    @unexpected_role_change_detected.setter
    def unexpected_role_change_detected(self, value):
        self._unexpected_role_change_detected = (value, True)

    @property
    def transport_status(self):
        """
        Redo log transport status from the source database to the LiveSource.
        *(permitted values: UNKNOWN, WORKING, NO_INITIAL_DATA, NO_NEW_DATA)*

        :rtype: ``basestring``
        """
        return self._transport_status[0]

    @transport_status.setter
    def transport_status(self, value):
        self._transport_status = (value, True)

    @property
    def non_logged_data_detected(self):
        """
        Indicates whether there is non-logged data on the standby.

        :rtype: ``bool``
        """
        return self._non_logged_data_detected[0]

    @non_logged_data_detected.setter
    def non_logged_data_detected(self, value):
        self._non_logged_data_detected = (value, True)

    @property
    def source_database_timezone(self):
        """
        Time zone of the source database at the time the runtime data was
        updated.

        :rtype: ``basestring``
        """
        return self._source_database_timezone[0]

    @source_database_timezone.setter
    def source_database_timezone(self, value):
        self._source_database_timezone = (value, True)

class NetworkThroughputTestBaseParameters(NetworkTestParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkTestParameters` *)* Base type
    for parameters used to execute a network throughput test.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkThroughputTestBaseParameters, self).__init__()
        self._type = ("NetworkThroughputTestBaseParameters", True)
        self._duration = (self.__undef__, True)
        self._direction = (self.__undef__, True)
        self._num_connections = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkThroughputTestBaseParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._duration = (data.get("duration", obj.__undef__), dirty)
        if obj._duration[0] is not None and obj._duration[0] is not obj.__undef__:
            assert isinstance(obj._duration[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._duration[0]))
            common.validate_format(obj._duration[0], "None", None, None)
        obj._direction = (data.get("direction", obj.__undef__), dirty)
        if obj._direction[0] is not None and obj._direction[0] is not obj.__undef__:
            assert isinstance(obj._direction[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._direction[0]))
            assert obj._direction[0] in [u'TRANSMIT', u'RECEIVE'], "Expected enum [u'TRANSMIT', u'RECEIVE'] but got %s" % obj._direction[0]
            common.validate_format(obj._direction[0], "None", None, None)
        obj._num_connections = (data.get("numConnections", obj.__undef__), dirty)
        if obj._num_connections[0] is not None and obj._num_connections[0] is not obj.__undef__:
            assert isinstance(obj._num_connections[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._num_connections[0]))
            common.validate_format(obj._num_connections[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkThroughputTestBaseParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "duration" == "type" or (self.duration is not self.__undef__ and not (dirty and not self._duration[1])):
            dct["duration"] = dictify(self.duration)
        if "direction" == "type" or (self.direction is not self.__undef__ and not (dirty and not self._direction[1])):
            dct["direction"] = dictify(self.direction)
        if "num_connections" == "type" or (self.num_connections is not self.__undef__ and not (dirty and not self._num_connections[1])):
            dct["numConnections"] = dictify(self.num_connections)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._duration = (self._duration[0], True)
        self._direction = (self._direction[0], True)
        self._num_connections = (self._num_connections[0], True)

    def is_dirty(self):
        return any([self._duration[1], self._direction[1], self._num_connections[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkThroughputTestBaseParameters):
            return False
        return super(NetworkThroughputTestBaseParameters, self).__eq__(other) and \
               self.duration == other.duration and \
               self.direction == other.direction and \
               self.num_connections == other.num_connections

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def duration(self):
        """
        *(default value: 30)* The duration of the test in seconds. Note that
        when numConnections is 0, an initial period of time will be spent
        calculating the optimal number of connections, and that time does not
        count toward the duration of the test.

        :rtype: ``int``
        """
        return self._duration[0]

    @duration.setter
    def duration(self, value):
        self._duration = (value, True)

    @property
    def direction(self):
        """
        *(default value: TRANSMIT)* Whether the test is a transmit or receive
        test. *(permitted values: TRANSMIT, RECEIVE)*

        :rtype: ``basestring``
        """
        return self._direction[0]

    @direction.setter
    def direction(self, value):
        self._direction = (value, True)

    @property
    def num_connections(self):
        """
        The number of connections to use for the test. The special value 0 (the
        default) causes the test to automatically discover and use the optimal
        number of connections to use for maximum throughput.

        :rtype: ``int``
        """
        return self._num_connections[0]

    @num_connections.setter
    def num_connections(self, value):
        self._num_connections = (value, True)

class NetworkLatencyTestParameters(NetworkTestParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkTestParameters` *)* Parameters
    used to execute a network latency test.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkLatencyTestParameters, self).__init__()
        self._type = ("NetworkLatencyTestParameters", True)
        self._request_size = (self.__undef__, True)
        self._request_count = (self.__undef__, True)
        self._remote_address = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkLatencyTestParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._request_size = (data.get("requestSize", obj.__undef__), dirty)
        if obj._request_size[0] is not None and obj._request_size[0] is not obj.__undef__:
            assert isinstance(obj._request_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._request_size[0]))
            common.validate_format(obj._request_size[0], "None", None, None)
        obj._request_count = (data.get("requestCount", obj.__undef__), dirty)
        if obj._request_count[0] is not None and obj._request_count[0] is not obj.__undef__:
            assert isinstance(obj._request_count[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._request_count[0]))
            common.validate_format(obj._request_count[0], "None", None, None)
        obj._remote_address = (data.get("remoteAddress", obj.__undef__), dirty)
        if obj._remote_address[0] is not None and obj._remote_address[0] is not obj.__undef__:
            assert isinstance(obj._remote_address[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_address[0]))
            common.validate_format(obj._remote_address[0], "host", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkLatencyTestParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "request_size" == "type" or (self.request_size is not self.__undef__ and not (dirty and not self._request_size[1])):
            dct["requestSize"] = dictify(self.request_size)
        if "request_count" == "type" or (self.request_count is not self.__undef__ and not (dirty and not self._request_count[1])):
            dct["requestCount"] = dictify(self.request_count)
        if "remote_address" == "type" or (self.remote_address is not self.__undef__ and not (dirty and not self._remote_address[1])):
            dct["remoteAddress"] = dictify(self.remote_address)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._request_size = (self._request_size[0], True)
        self._request_count = (self._request_count[0], True)
        self._remote_address = (self._remote_address[0], True)

    def is_dirty(self):
        return any([self._request_size[1], self._request_count[1], self._remote_address[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkLatencyTestParameters):
            return False
        return super(NetworkLatencyTestParameters, self).__eq__(other) and \
               self.request_size == other.request_size and \
               self.request_count == other.request_count and \
               self.remote_address == other.remote_address

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def request_size(self):
        """
        *(default value: 8)* The size of requests to send (bytes).

        :rtype: ``int``
        """
        return self._request_size[0]

    @request_size.setter
    def request_size(self, value):
        self._request_size = (value, True)

    @property
    def request_count(self):
        """
        *(default value: 20)* Number of requests to send.

        :rtype: ``int``
        """
        return self._request_count[0]

    @request_count.setter
    def request_count(self, value):
        self._request_count = (value, True)

    @property
    def remote_address(self):
        """
        A hostname or literal IP address to test. Either remoteAddress or
        remoteHost must be set, but not both.

        :rtype: ``basestring``
        """
        return self._remote_address[0]

    @remote_address.setter
    def remote_address(self, value):
        self._remote_address = (value, True)

class NetworkThroughputTestParameters(NetworkThroughputTestBaseParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkThroughputTestBaseParameters`
    *)* Parameters used to execute a network throughput test.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkThroughputTestParameters, self).__init__()
        self._type = ("NetworkThroughputTestParameters", True)
        self._block_size = (self.__undef__, True)
        self._remote_host = (self.__undef__, True)
        self._port = (self.__undef__, True)
        self._send_socket_buffer = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkThroughputTestParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._block_size = (data.get("blockSize", obj.__undef__), dirty)
        if obj._block_size[0] is not None and obj._block_size[0] is not obj.__undef__:
            assert isinstance(obj._block_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._block_size[0]))
            common.validate_format(obj._block_size[0], "None", None, None)
        obj._remote_host = (data.get("remoteHost", obj.__undef__), dirty)
        if obj._remote_host[0] is not None and obj._remote_host[0] is not obj.__undef__:
            assert isinstance(obj._remote_host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._remote_host[0]))
            common.validate_format(obj._remote_host[0], "objectReference", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        obj._send_socket_buffer = (data.get("sendSocketBuffer", obj.__undef__), dirty)
        if obj._send_socket_buffer[0] is not None and obj._send_socket_buffer[0] is not obj.__undef__:
            assert isinstance(obj._send_socket_buffer[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._send_socket_buffer[0]))
            common.validate_format(obj._send_socket_buffer[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkThroughputTestParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "block_size" == "type" or (self.block_size is not self.__undef__ and not (dirty and not self._block_size[1])):
            dct["blockSize"] = dictify(self.block_size)
        if "remote_host" == "type" or (self.remote_host is not self.__undef__ and not (dirty and not self._remote_host[1])):
            dct["remoteHost"] = dictify(self.remote_host)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        if "send_socket_buffer" == "type" or (self.send_socket_buffer is not self.__undef__ and not (dirty and not self._send_socket_buffer[1])):
            dct["sendSocketBuffer"] = dictify(self.send_socket_buffer)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._block_size = (self._block_size[0], True)
        self._remote_host = (self._remote_host[0], True)
        self._port = (self._port[0], True)
        self._send_socket_buffer = (self._send_socket_buffer[0], True)

    def is_dirty(self):
        return any([self._block_size[1], self._remote_host[1], self._port[1], self._send_socket_buffer[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkThroughputTestParameters):
            return False
        return super(NetworkThroughputTestParameters, self).__eq__(other) and \
               self.block_size == other.block_size and \
               self.remote_host == other.remote_host and \
               self.port == other.port and \
               self.send_socket_buffer == other.send_socket_buffer

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def block_size(self):
        """
        *(default value: 131072)* The size of each transmit request in bytes.

        :rtype: ``int``
        """
        return self._block_size[0]

    @block_size.setter
    def block_size(self, value):
        self._block_size = (value, True)

    @property
    def remote_host(self):
        """
        The remote host for the test. The host must be part of an existing
        environment.

        :rtype: ``basestring``
        """
        return self._remote_host[0]

    @remote_host.setter
    def remote_host(self, value):
        self._remote_host = (value, True)

    @property
    def port(self):
        """
        The TCP port number that the server (the receiver) will be listening
        on.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

    @property
    def send_socket_buffer(self):
        """
        *(default value: 4194304)* The size of the send socket buffer in bytes.

        :rtype: ``int``
        """
        return self._send_socket_buffer[0]

    @send_socket_buffer.setter
    def send_socket_buffer(self, value):
        self._send_socket_buffer = (value, True)

class NetworkDSPTestParameters(NetworkThroughputTestBaseParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.NetworkThroughputTestBaseParameters`
    *)* Parameters used to execute a network throughput test using the Delphix
    Session Protocol.
    """
    def __init__(self, undef_enabled=True):
        super(NetworkDSPTestParameters, self).__init__()
        self._type = ("NetworkDSPTestParameters", True)
        self._compression = (self.__undef__, True)
        self._send_socket_buffer = (self.__undef__, True)
        self._encryption = (self.__undef__, True)
        self._remote_delphix_engine_info = (self.__undef__, True)
        self._block_size = (self.__undef__, True)
        self._queue_depth = (self.__undef__, True)
        self._destination_type = (self.__undef__, True)
        self._receive_socket_buffer = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(NetworkDSPTestParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._compression = (data.get("compression", obj.__undef__), dirty)
        if obj._compression[0] is not None and obj._compression[0] is not obj.__undef__:
            assert isinstance(obj._compression[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._compression[0]))
            common.validate_format(obj._compression[0], "None", None, None)
        obj._send_socket_buffer = (data.get("sendSocketBuffer", obj.__undef__), dirty)
        if obj._send_socket_buffer[0] is not None and obj._send_socket_buffer[0] is not obj.__undef__:
            assert isinstance(obj._send_socket_buffer[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._send_socket_buffer[0]))
            common.validate_format(obj._send_socket_buffer[0], "None", None, None)
        obj._encryption = (data.get("encryption", obj.__undef__), dirty)
        if obj._encryption[0] is not None and obj._encryption[0] is not obj.__undef__:
            assert isinstance(obj._encryption[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._encryption[0]))
            common.validate_format(obj._encryption[0], "None", None, None)
        if "remoteDelphixEngineInfo" in data and data["remoteDelphixEngineInfo"] is not None:
            obj._remote_delphix_engine_info = (factory.create_object(data["remoteDelphixEngineInfo"], "RemoteDelphixEngineInfo"), dirty)
            factory.validate_type(obj._remote_delphix_engine_info[0], "RemoteDelphixEngineInfo")
        else:
            obj._remote_delphix_engine_info = (obj.__undef__, dirty)
        obj._block_size = (data.get("blockSize", obj.__undef__), dirty)
        if obj._block_size[0] is not None and obj._block_size[0] is not obj.__undef__:
            assert isinstance(obj._block_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._block_size[0]))
            common.validate_format(obj._block_size[0], "None", None, None)
        obj._queue_depth = (data.get("queueDepth", obj.__undef__), dirty)
        if obj._queue_depth[0] is not None and obj._queue_depth[0] is not obj.__undef__:
            assert isinstance(obj._queue_depth[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._queue_depth[0]))
            common.validate_format(obj._queue_depth[0], "None", None, None)
        obj._destination_type = (data.get("destinationType", obj.__undef__), dirty)
        if obj._destination_type[0] is not None and obj._destination_type[0] is not obj.__undef__:
            assert isinstance(obj._destination_type[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._destination_type[0]))
            assert obj._destination_type[0] in [u'REMOTE_HOST', u'DELPHIX_ENGINE'], "Expected enum [u'REMOTE_HOST', u'DELPHIX_ENGINE'] but got %s" % obj._destination_type[0]
            common.validate_format(obj._destination_type[0], "None", None, None)
        obj._receive_socket_buffer = (data.get("receiveSocketBuffer", obj.__undef__), dirty)
        if obj._receive_socket_buffer[0] is not None and obj._receive_socket_buffer[0] is not obj.__undef__:
            assert isinstance(obj._receive_socket_buffer[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._receive_socket_buffer[0]))
            common.validate_format(obj._receive_socket_buffer[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(NetworkDSPTestParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "compression" == "type" or (self.compression is not self.__undef__ and not (dirty and not self._compression[1])):
            dct["compression"] = dictify(self.compression)
        if "send_socket_buffer" == "type" or (self.send_socket_buffer is not self.__undef__ and not (dirty and not self._send_socket_buffer[1])):
            dct["sendSocketBuffer"] = dictify(self.send_socket_buffer)
        if "encryption" == "type" or (self.encryption is not self.__undef__ and not (dirty and not self._encryption[1])):
            dct["encryption"] = dictify(self.encryption)
        if "remote_delphix_engine_info" == "type" or (self.remote_delphix_engine_info is not self.__undef__ and not (dirty and not self._remote_delphix_engine_info[1])):
            dct["remoteDelphixEngineInfo"] = dictify(self.remote_delphix_engine_info)
        if "block_size" == "type" or (self.block_size is not self.__undef__ and not (dirty and not self._block_size[1])):
            dct["blockSize"] = dictify(self.block_size)
        if "queue_depth" == "type" or (self.queue_depth is not self.__undef__ and not (dirty and not self._queue_depth[1])):
            dct["queueDepth"] = dictify(self.queue_depth)
        if "destination_type" == "type" or (self.destination_type is not self.__undef__ and not (dirty and not self._destination_type[1])):
            dct["destinationType"] = dictify(self.destination_type)
        if "receive_socket_buffer" == "type" or (self.receive_socket_buffer is not self.__undef__ and not (dirty and not self._receive_socket_buffer[1])):
            dct["receiveSocketBuffer"] = dictify(self.receive_socket_buffer)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._compression = (self._compression[0], True)
        self._send_socket_buffer = (self._send_socket_buffer[0], True)
        self._encryption = (self._encryption[0], True)
        self._remote_delphix_engine_info = (self._remote_delphix_engine_info[0], True)
        self._block_size = (self._block_size[0], True)
        self._queue_depth = (self._queue_depth[0], True)
        self._destination_type = (self._destination_type[0], True)
        self._receive_socket_buffer = (self._receive_socket_buffer[0], True)

    def is_dirty(self):
        return any([self._compression[1], self._send_socket_buffer[1], self._encryption[1], self._remote_delphix_engine_info[1], self._block_size[1], self._queue_depth[1], self._destination_type[1], self._receive_socket_buffer[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, NetworkDSPTestParameters):
            return False
        return super(NetworkDSPTestParameters, self).__eq__(other) and \
               self.compression == other.compression and \
               self.send_socket_buffer == other.send_socket_buffer and \
               self.encryption == other.encryption and \
               self.remote_delphix_engine_info == other.remote_delphix_engine_info and \
               self.block_size == other.block_size and \
               self.queue_depth == other.queue_depth and \
               self.destination_type == other.destination_type and \
               self.receive_socket_buffer == other.receive_socket_buffer

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def compression(self):
        """
        Whether or not compression is used for the test.

        :rtype: ``bool``
        """
        return self._compression[0]

    @compression.setter
    def compression(self, value):
        self._compression = (value, True)

    @property
    def send_socket_buffer(self):
        """
        *(default value: 262144)* The size of the send socket buffer in bytes.

        :rtype: ``int``
        """
        return self._send_socket_buffer[0]

    @send_socket_buffer.setter
    def send_socket_buffer(self, value):
        self._send_socket_buffer = (value, True)

    @property
    def encryption(self):
        """
        Whether or not encryption is used for the test.

        :rtype: ``bool``
        """
        return self._encryption[0]

    @encryption.setter
    def encryption(self, value):
        self._encryption = (value, True)

    @property
    def remote_delphix_engine_info(self):
        """
        Address, username and password used when running a test to another
        Delphix Engine.

        :rtype: :py:class:`v1_8_1.web.vo.RemoteDelphixEngineInfo`
        """
        return self._remote_delphix_engine_info[0]

    @remote_delphix_engine_info.setter
    def remote_delphix_engine_info(self, value):
        self._remote_delphix_engine_info = (value, True)

    @property
    def block_size(self):
        """
        *(default value: 65536)* The size of each transmit request in bytes.

        :rtype: ``int``
        """
        return self._block_size[0]

    @block_size.setter
    def block_size(self, value):
        self._block_size = (value, True)

    @property
    def queue_depth(self):
        """
        *(default value: 32)* The queue depth used for the DSP throughput test.

        :rtype: ``int``
        """
        return self._queue_depth[0]

    @queue_depth.setter
    def queue_depth(self, value):
        self._queue_depth = (value, True)

    @property
    def destination_type(self):
        """
        *(default value: REMOTE_HOST)* Whether the test is testing connectivity
        to a Delphix Engine or remote host. *(permitted values: REMOTE_HOST,
        DELPHIX_ENGINE)*

        :rtype: ``basestring``
        """
        return self._destination_type[0]

    @destination_type.setter
    def destination_type(self, value):
        self._destination_type = (value, True)

    @property
    def receive_socket_buffer(self):
        """
        *(default value: 262144)* The size of the receive socket buffer in
        bytes.

        :rtype: ``int``
        """
        return self._receive_socket_buffer[0]

    @receive_socket_buffer.setter
    def receive_socket_buffer(self, value):
        self._receive_socket_buffer = (value, True)

class WindowsHostCreateParameters(HostCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostCreateParameters` *)* The
    parameters used for the add Windows host operation.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsHostCreateParameters, self).__init__()
        self._type = ("WindowsHostCreateParameters", True)
        self._connector_keystore = (self.__undef__, True)
        self._connector_certificate_password = (self.__undef__, True)
        self._connector_keystore_password = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsHostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._connector_keystore = (data.get("connectorKeystore", obj.__undef__), dirty)
        if obj._connector_keystore[0] is not None and obj._connector_keystore[0] is not obj.__undef__:
            assert isinstance(obj._connector_keystore[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_keystore[0]))
            common.validate_format(obj._connector_keystore[0], "None", None, None)
        obj._connector_certificate_password = (data.get("connectorCertificatePassword", obj.__undef__), dirty)
        if obj._connector_certificate_password[0] is not None and obj._connector_certificate_password[0] is not obj.__undef__:
            assert isinstance(obj._connector_certificate_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_certificate_password[0]))
            common.validate_format(obj._connector_certificate_password[0], "None", None, None)
        obj._connector_keystore_password = (data.get("connectorKeystorePassword", obj.__undef__), dirty)
        if obj._connector_keystore_password[0] is not None and obj._connector_keystore_password[0] is not obj.__undef__:
            assert isinstance(obj._connector_keystore_password[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connector_keystore_password[0]))
            common.validate_format(obj._connector_keystore_password[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsHostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connector_keystore" == "type" or (self.connector_keystore is not self.__undef__ and not (dirty and not self._connector_keystore[1])):
            dct["connectorKeystore"] = dictify(self.connector_keystore)
        if "connector_certificate_password" == "type" or (self.connector_certificate_password is not self.__undef__ and not (dirty and not self._connector_certificate_password[1])):
            dct["connectorCertificatePassword"] = dictify(self.connector_certificate_password)
        if "connector_keystore_password" == "type" or (self.connector_keystore_password is not self.__undef__ and not (dirty and not self._connector_keystore_password[1])):
            dct["connectorKeystorePassword"] = dictify(self.connector_keystore_password)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connector_keystore = (self._connector_keystore[0], True)
        self._connector_certificate_password = (self._connector_certificate_password[0], True)
        self._connector_keystore_password = (self._connector_keystore_password[0], True)

    def is_dirty(self):
        return any([self._connector_keystore[1], self._connector_certificate_password[1], self._connector_keystore_password[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsHostCreateParameters):
            return False
        return super(WindowsHostCreateParameters, self).__eq__(other) and \
               self.connector_keystore == other.connector_keystore and \
               self.connector_certificate_password == other.connector_certificate_password and \
               self.connector_keystore_password == other.connector_keystore_password

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connector_keystore(self):
        """
        Byte array of the Java Keystore data.

        :rtype: ``basestring``
        """
        return self._connector_keystore[0]

    @connector_keystore.setter
    def connector_keystore(self, value):
        self._connector_keystore = (value, True)

    @property
    def connector_certificate_password(self):
        """
        Password for the certificate in the Java Keystore.

        :rtype: ``basestring``
        """
        return self._connector_certificate_password[0]

    @connector_certificate_password.setter
    def connector_certificate_password(self, value):
        self._connector_certificate_password = (value, True)

    @property
    def connector_keystore_password(self):
        """
        Password for the Java Keystore data.

        :rtype: ``basestring``
        """
        return self._connector_keystore_password[0]

    @connector_keystore_password.setter
    def connector_keystore_password(self, value):
        self._connector_keystore_password = (value, True)

class UnixHostCreateParameters(HostCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostCreateParameters` *)* The
    parameters used for the add Unix host operation.
    """
    def __init__(self, undef_enabled=True):
        super(UnixHostCreateParameters, self).__init__()
        self._type = ("UnixHostCreateParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(UnixHostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(UnixHostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, UnixHostCreateParameters):
            return False
        return super(UnixHostCreateParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class VMwareHostCreateParameters(HostCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.HostCreateParameters` *)* The
    parameters used for the add VMware host operation.
    """
    def __init__(self, undef_enabled=True):
        super(VMwareHostCreateParameters, self).__init__()
        self._type = ("VMwareHostCreateParameters", True)
        self._host = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwareHostCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "host" in data and data["host"] is not None:
            obj._host = (factory.create_object(data["host"], "VMwareHost"), dirty)
            factory.validate_type(obj._host[0], "VMwareHost")
        else:
            obj._host = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwareHostCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host = (self._host[0], True)

    def is_dirty(self):
        return any([self._host[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwareHostCreateParameters):
            return False
        return super(VMwareHostCreateParameters, self).__eq__(other) and \
               self.host == other.host

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host(self):
        """
        The host object.

        :rtype: :py:class:`v1_8_1.web.vo.VMwareHost`
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

class ASEPlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* ASE
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(ASEPlatformParameters, self).__init__()
        self._type = ("ASEPlatformParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASEPlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASEPlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASEPlatformParameters):
            return False
        return super(ASEPlatformParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLPlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* MySQL
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLPlatformParameters, self).__init__()
        self._type = ("MySQLPlatformParameters", True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLPlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLPlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLPlatformParameters):
            return False
        return super(MySQLPlatformParameters, self).__eq__(other) and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def port(self):
        """
        The port number used for provisioning a MySQL container during
        transformation application. This port must be available when the
        transformation is applied so that the temporary VDB created during the
        transformation process can start and listen to this port.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class MSSqlPlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* MSSql
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlPlatformParameters, self).__init__()
        self._type = ("MSSqlPlatformParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlPlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlPlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlPlatformParameters):
            return False
        return super(MSSqlPlatformParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OraclePlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* Oracle
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(OraclePlatformParameters, self).__init__()
        self._type = ("OraclePlatformParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OraclePlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OraclePlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OraclePlatformParameters):
            return False
        return super(OraclePlatformParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class VMwarePlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* VMware
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(VMwarePlatformParameters, self).__init__()
        self._type = ("VMwarePlatformParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(VMwarePlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(VMwarePlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, VMwarePlatformParameters):
            return False
        return super(VMwarePlatformParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class AppDataPlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* AppData
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataPlatformParameters, self).__init__()
        self._type = ("AppDataPlatformParameters", True)
        self._payload = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataPlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        if "payload" in data and data["payload"] is not None:
            obj._payload = (data["payload"], dirty)
        else:
            obj._payload = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataPlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "payload" == "type" or (self.payload is not self.__undef__ and not (dirty and not self._payload[1])):
            dct["payload"] = dictify(self.payload)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._payload = (self._payload[0], True)

    def is_dirty(self):
        return any([self._payload[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataPlatformParameters):
            return False
        return super(AppDataPlatformParameters, self).__eq__(other) and \
               self.payload == other.payload

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def payload(self):
        """
        The JSON payload conforming to the DraftV4 schema based on the type of
        application data being manipulated.

        :rtype: :py:class:`v1_8_1.web.vo.Json`
        """
        return self._payload[0]

    @payload.setter
    def payload(self, value):
        self._payload = (value, True)

class PgSQLPlatformParameters(BasePlatformParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.BasePlatformParameters` *)* PgSQL
    platform-specific parameters that are stored on a transformation.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLPlatformParameters, self).__init__()
        self._type = ("PgSQLPlatformParameters", True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLPlatformParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLPlatformParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLPlatformParameters):
            return False
        return super(PgSQLPlatformParameters, self).__eq__(other) and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def port(self):
        """
        The port number used for provisioning a PgSQL container during
        transformation application. This port must be available when the
        transformation is applied so that the temporary VDB created during the
        transformation process can start and listen to this port.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

class PgSQLDBClusterConfigConnectivity(SourceConfigConnectivity):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceConfigConnectivity` *)* Mechanism
    to test JDBC connectivity to PostgreSQL DB clusters.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLDBClusterConfigConnectivity, self).__init__()
        self._type = ("PgSQLDBClusterConfigConnectivity", True)
        self._connection_database = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLDBClusterConfigConnectivity, cls).from_dict(data, dirty, undef_enabled)
        obj._connection_database = (data.get("connectionDatabase", obj.__undef__), dirty)
        if obj._connection_database[0] is not None and obj._connection_database[0] is not obj.__undef__:
            assert isinstance(obj._connection_database[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._connection_database[0]))
            common.validate_format(obj._connection_database[0], "None", None, 256)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLDBClusterConfigConnectivity, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "connection_database" == "type" or (self.connection_database is not self.__undef__ and not (dirty and not self._connection_database[1])):
            dct["connectionDatabase"] = dictify(self.connection_database)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._connection_database = (self._connection_database[0], True)

    def is_dirty(self):
        return any([self._connection_database[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLDBClusterConfigConnectivity):
            return False
        return super(PgSQLDBClusterConfigConnectivity, self).__eq__(other) and \
               self.connection_database == other.connection_database

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def connection_database(self):
        """
        The database that must be used to run SQL queries against this cluster.

        :rtype: ``basestring``
        """
        return self._connection_database[0]

    @connection_database.setter
    def connection_database(self, value):
        self._connection_database = (value, True)

class ChecklistItemDetail(ChecklistItem):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ChecklistItem` *)* Fields to indicate
    detailed status for a specific checklist item.
    """
    def __init__(self, undef_enabled=True):
        super(ChecklistItemDetail, self).__init__()
        self._type = ("ChecklistItemDetail", True)
        self._status = (self.__undef__, True)
        self._message = (self.__undef__, True)
        self._description = (self.__undef__, True)
        self._name = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ChecklistItemDetail, cls).from_dict(data, dirty, undef_enabled)
        obj._status = (data.get("status", obj.__undef__), dirty)
        if obj._status[0] is not None and obj._status[0] is not obj.__undef__:
            assert isinstance(obj._status[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._status[0]))
            assert obj._status[0] in [u'SUCCESS', u'WARNING', u'ERROR'], "Expected enum [u'SUCCESS', u'WARNING', u'ERROR'] but got %s" % obj._status[0]
            common.validate_format(obj._status[0], "None", None, None)
        obj._message = (data.get("message", obj.__undef__), dirty)
        if obj._message[0] is not None and obj._message[0] is not obj.__undef__:
            assert isinstance(obj._message[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._message[0]))
            common.validate_format(obj._message[0], "None", None, None)
        obj._description = (data.get("description", obj.__undef__), dirty)
        if obj._description[0] is not None and obj._description[0] is not obj.__undef__:
            assert isinstance(obj._description[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._description[0]))
            common.validate_format(obj._description[0], "None", None, None)
        obj._name = (data.get("name", obj.__undef__), dirty)
        if obj._name[0] is not None and obj._name[0] is not obj.__undef__:
            assert isinstance(obj._name[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._name[0]))
            common.validate_format(obj._name[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ChecklistItemDetail, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "status" == "type" or (self.status is not self.__undef__ and not (dirty and not self._status[1])):
            dct["status"] = dictify(self.status)
        if "message" == "type" or (self.message is not self.__undef__ and not (dirty and not self._message[1])):
            dct["message"] = dictify(self.message)
        if "description" == "type" or (self.description is not self.__undef__ and not (dirty and not self._description[1])):
            dct["description"] = dictify(self.description)
        if "name" == "type" or (self.name is not self.__undef__ and not (dirty and not self._name[1])):
            dct["name"] = dictify(self.name)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._status = (self._status[0], True)
        self._message = (self._message[0], True)
        self._description = (self._description[0], True)
        self._name = (self._name[0], True)

    def is_dirty(self):
        return any([self._status[1], self._message[1], self._description[1], self._name[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ChecklistItemDetail):
            return False
        return super(ChecklistItemDetail, self).__eq__(other) and \
               self.status == other.status and \
               self.message == other.message and \
               self.description == other.description and \
               self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def status(self):
        """
        Status of this item. *(permitted values: SUCCESS, WARNING, ERROR)*

        :rtype: ``basestring``
        """
        return self._status[0]

    @status.setter
    def status(self, value):
        self._status = (value, True)

    @property
    def message(self):
        """
        Status message, if applicable.

        :rtype: ``basestring``
        """
        return self._message[0]

    @message.setter
    def message(self, value):
        self._message = (value, True)

    @property
    def description(self):
        """
        Description of this status item.

        :rtype: ``basestring``
        """
        return self._description[0]

    @description.setter
    def description(self, value):
        self._description = (value, True)

    @property
    def name(self):
        """
        The status item name.

        :rtype: ``basestring``
        """
        return self._name[0]

    @name.setter
    def name(self, value):
        self._name = (value, True)

class XppLastRunStatus(ChecklistItem):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ChecklistItem` *)* Status of the last
    cross-platform provision of the container.
    """
    def __init__(self, undef_enabled=True):
        super(XppLastRunStatus, self).__init__()
        self._type = ("XppLastRunStatus", True)
        self._job = (self.__undef__, True)
        self._error_message = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppLastRunStatus, cls).from_dict(data, dirty, undef_enabled)
        if "job" in data and data["job"] is not None:
            obj._job = (factory.create_object(data["job"], "Job"), dirty)
            factory.validate_type(obj._job[0], "Job")
        else:
            obj._job = (obj.__undef__, dirty)
        obj._error_message = (data.get("errorMessage", obj.__undef__), dirty)
        if obj._error_message[0] is not None and obj._error_message[0] is not obj.__undef__:
            assert isinstance(obj._error_message[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._error_message[0]))
            common.validate_format(obj._error_message[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppLastRunStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "job" == "type" or (self.job is not self.__undef__ and not (dirty and not self._job[1])):
            dct["job"] = dictify(self.job)
        if "error_message" == "type" or (self.error_message is not self.__undef__ and not (dirty and not self._error_message[1])):
            dct["errorMessage"] = dictify(self.error_message)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._job = (self._job[0], True)
        self._error_message = (self._error_message[0], True)

    def is_dirty(self):
        return any([self._job[1], self._error_message[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppLastRunStatus):
            return False
        return super(XppLastRunStatus, self).__eq__(other) and \
               self.job == other.job and \
               self.error_message == other.error_message

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def job(self):
        """
        Last cross-platform provision job run on the container.

        :rtype: :py:class:`v1_8_1.web.vo.Job`
        """
        return self._job[0]

    @job.setter
    def job(self, value):
        self._job = (value, True)

    @property
    def error_message(self):
        """
        Error message associated with the last run, if any.

        :rtype: ``basestring``
        """
        return self._error_message[0]

    @error_message.setter
    def error_message(self, value):
        self._error_message = (value, True)

class XppValidateStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ChecklistItemDetail` *)* Cross-platform
    provisioning validation status of the container.
    """
    def __init__(self, undef_enabled=True):
        super(XppValidateStatus, self).__init__()
        self._type = ("XppValidateStatus", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppValidateStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppValidateStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppValidateStatus):
            return False
        return super(XppValidateStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class XppStagingStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ChecklistItemDetail` *)* Status of the
    cross-platform provisioning staging environment.
    """
    def __init__(self, undef_enabled=True):
        super(XppStagingStatus, self).__init__()
        self._type = ("XppStagingStatus", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppStagingStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppStagingStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppStagingStatus):
            return False
        return super(XppStagingStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class XppTargetStatus(ChecklistItemDetail):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ChecklistItemDetail` *)* Status of the
    cross-platform provisioning target environment.
    """
    def __init__(self, undef_enabled=True):
        super(XppTargetStatus, self).__init__()
        self._type = ("XppTargetStatus", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(XppTargetStatus, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(XppTargetStatus, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, XppTargetStatus):
            return False
        return super(XppTargetStatus, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleClusterCreateParameters(SourceEnvironmentCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironmentCreateParameters` *)*
    The parameters used for the oracle cluster create operation.
    """
    def __init__(self, undef_enabled=True):
        super(OracleClusterCreateParameters, self).__init__()
        self._type = ("OracleClusterCreateParameters", True)
        self._cluster = (self.__undef__, True)
        self._nodes = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleClusterCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "cluster" in data and data["cluster"] is not None:
            obj._cluster = (factory.create_object(data["cluster"], "OracleCluster"), dirty)
            factory.validate_type(obj._cluster[0], "OracleCluster")
        else:
            obj._cluster = (obj.__undef__, dirty)
        obj._nodes = []
        for item in data.get("nodes") or []:
            obj._nodes.append(factory.create_object(item))
            factory.validate_type(obj._nodes[-1], "OracleClusterNodeCreateParameters")
        obj._nodes = (obj._nodes, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleClusterCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "nodes" == "type" or (self.nodes is not self.__undef__ and not (dirty and not self._nodes[1])):
            dct["nodes"] = dictify(self.nodes)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cluster = (self._cluster[0], True)
        self._nodes = (self._nodes[0], True)

    def is_dirty(self):
        return any([self._cluster[1], self._nodes[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleClusterCreateParameters):
            return False
        return super(OracleClusterCreateParameters, self).__eq__(other) and \
               self.cluster == other.cluster and \
               self.nodes == other.nodes

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cluster(self):
        """
        The representation of the cluster object.

        :rtype: :py:class:`v1_8_1.web.vo.OracleCluster`
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def nodes(self):
        """
        The list of nodes in the cluster.

        :rtype: ``list`` of
            :py:class:`v1_8_1.web.vo.OracleClusterNodeCreateParameters`
        """
        return self._nodes[0]

    @nodes.setter
    def nodes(self, value):
        self._nodes = (value, True)

class HostEnvironmentCreateParameters(SourceEnvironmentCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironmentCreateParameters` *)*
    The parameters used for the host environment create operation.
    """
    def __init__(self, undef_enabled=True):
        super(HostEnvironmentCreateParameters, self).__init__()
        self._type = ("HostEnvironmentCreateParameters", True)
        self._host_parameters = (self.__undef__, True)
        self._host_environment = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(HostEnvironmentCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "hostParameters" in data and data["hostParameters"] is not None:
            obj._host_parameters = (factory.create_object(data["hostParameters"], "HostCreateParameters"), dirty)
            factory.validate_type(obj._host_parameters[0], "HostCreateParameters")
        else:
            obj._host_parameters = (obj.__undef__, dirty)
        if "hostEnvironment" in data and data["hostEnvironment"] is not None:
            obj._host_environment = (factory.create_object(data["hostEnvironment"], "HostEnvironment"), dirty)
            factory.validate_type(obj._host_environment[0], "HostEnvironment")
        else:
            obj._host_environment = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(HostEnvironmentCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "host_parameters" == "type" or (self.host_parameters is not self.__undef__ and not (dirty and not self._host_parameters[1])):
            dct["hostParameters"] = dictify(self.host_parameters)
        if "host_environment" == "type" or (self.host_environment is not self.__undef__ and not (dirty and not self._host_environment[1])):
            dct["hostEnvironment"] = dictify(self.host_environment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._host_parameters = (self._host_parameters[0], True)
        self._host_environment = (self._host_environment[0], True)

    def is_dirty(self):
        return any([self._host_parameters[1], self._host_environment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, HostEnvironmentCreateParameters):
            return False
        return super(HostEnvironmentCreateParameters, self).__eq__(other) and \
               self.host_parameters == other.host_parameters and \
               self.host_environment == other.host_environment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def host_parameters(self):
        """
        The host parameters used to add a host.

        :rtype: :py:class:`v1_8_1.web.vo.HostCreateParameters`
        """
        return self._host_parameters[0]

    @host_parameters.setter
    def host_parameters(self, value):
        self._host_parameters = (value, True)

    @property
    def host_environment(self):
        """
        The host environment.

        :rtype: :py:class:`v1_8_1.web.vo.HostEnvironment`
        """
        return self._host_environment[0]

    @host_environment.setter
    def host_environment(self, value):
        self._host_environment = (value, True)

class WindowsClusterCreateParameters(SourceEnvironmentCreateParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SourceEnvironmentCreateParameters` *)*
    The parameters used to create a Windows Cluster.
    """
    def __init__(self, undef_enabled=True):
        super(WindowsClusterCreateParameters, self).__init__()
        self._type = ("WindowsClusterCreateParameters", True)
        self._cluster = (self.__undef__, True)
        self._target = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(WindowsClusterCreateParameters, cls).from_dict(data, dirty, undef_enabled)
        if "cluster" in data and data["cluster"] is not None:
            obj._cluster = (factory.create_object(data["cluster"], "WindowsCluster"), dirty)
            factory.validate_type(obj._cluster[0], "WindowsCluster")
        else:
            obj._cluster = (obj.__undef__, dirty)
        obj._target = (data.get("target", obj.__undef__), dirty)
        if obj._target[0] is not None and obj._target[0] is not obj.__undef__:
            assert isinstance(obj._target[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._target[0]))
            common.validate_format(obj._target[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(WindowsClusterCreateParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "cluster" == "type" or (self.cluster is not self.__undef__ and not (dirty and not self._cluster[1])):
            dct["cluster"] = dictify(self.cluster)
        if "target" == "type" or (self.target is not self.__undef__ and not (dirty and not self._target[1])):
            dct["target"] = dictify(self.target)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._cluster = (self._cluster[0], True)
        self._target = (self._target[0], True)

    def is_dirty(self):
        return any([self._cluster[1], self._target[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, WindowsClusterCreateParameters):
            return False
        return super(WindowsClusterCreateParameters, self).__eq__(other) and \
               self.cluster == other.cluster and \
               self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def cluster(self):
        """
        The representation of the cluster object.

        :rtype: :py:class:`v1_8_1.web.vo.WindowsCluster`
        """
        return self._cluster[0]

    @cluster.setter
    def cluster(self, value):
        self._cluster = (value, True)

    @property
    def target(self):
        """
        Create as a target environment.

        :rtype: ``bool``
        """
        return self._target[0]

    @target.setter
    def target(self, value):
        self._target = (value, True)

class PgSQLSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync PostgreSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(PgSQLSyncParameters, self).__init__()
        self._type = ("PgSQLSyncParameters", True)
        self._redo_base_backup = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(PgSQLSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._redo_base_backup = (data.get("redoBaseBackup", obj.__undef__), dirty)
        if obj._redo_base_backup[0] is not None and obj._redo_base_backup[0] is not obj.__undef__:
            assert isinstance(obj._redo_base_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._redo_base_backup[0]))
            common.validate_format(obj._redo_base_backup[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(PgSQLSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "redo_base_backup" == "type" or (self.redo_base_backup is not self.__undef__ and not (dirty and not self._redo_base_backup[1])):
            dct["redoBaseBackup"] = dictify(self.redo_base_backup)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._redo_base_backup = (self._redo_base_backup[0], True)

    def is_dirty(self):
        return any([self._redo_base_backup[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, PgSQLSyncParameters):
            return False
        return super(PgSQLSyncParameters, self).__eq__(other) and \
               self.redo_base_backup == other.redo_base_backup

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def redo_base_backup(self):
        """
        Whether or not to take another full backup of the source database.

        :rtype: ``bool``
        """
        return self._redo_base_backup[0]

    @redo_base_backup.setter
    def redo_base_backup(self, value):
        self._redo_base_backup = (value, True)

class AppDataSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync an AppData source.
    """
    def __init__(self, undef_enabled=True):
        super(AppDataSyncParameters, self).__init__()
        self._type = ("AppDataSyncParameters", True)
        self._resync = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(AppDataSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._resync = (data.get("resync", obj.__undef__), dirty)
        if obj._resync[0] is not None and obj._resync[0] is not obj.__undef__:
            assert isinstance(obj._resync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._resync[0]))
            common.validate_format(obj._resync[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(AppDataSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "resync" == "type" or (self.resync is not self.__undef__ and not (dirty and not self._resync[1])):
            dct["resync"] = dictify(self.resync)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._resync = (self._resync[0], True)

    def is_dirty(self):
        return any([self._resync[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, AppDataSyncParameters):
            return False
        return super(AppDataSyncParameters, self).__eq__(other) and \
               self.resync == other.resync

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def resync(self):
        """
        Whether or not to force a non-incremental load of data prior to taking
        a snapshot.

        :rtype: ``bool``
        """
        return self._resync[0]

    @resync.setter
    def resync(self, value):
        self._resync = (value, True)

class ASESyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync a SAP ASE database.
    """
    def __init__(self, undef_enabled=True):
        super(ASESyncParameters, self).__init__()
        self._type = ("ASESyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESyncParameters):
            return False
        return super(ASESyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync MSSQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlSyncParameters, self).__init__()
        self._type = ("MSSqlSyncParameters", True)
        self._load_from_backup = (self.__undef__, True)
        self._backup_uuid = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._load_from_backup = (data.get("loadFromBackup", obj.__undef__), dirty)
        if obj._load_from_backup[0] is not None and obj._load_from_backup[0] is not obj.__undef__:
            assert isinstance(obj._load_from_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._load_from_backup[0]))
            common.validate_format(obj._load_from_backup[0], "None", None, None)
        obj._backup_uuid = (data.get("backupUUID", obj.__undef__), dirty)
        if obj._backup_uuid[0] is not None and obj._backup_uuid[0] is not obj.__undef__:
            assert isinstance(obj._backup_uuid[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_uuid[0]))
            common.validate_format(obj._backup_uuid[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "load_from_backup" == "type" or (self.load_from_backup is not self.__undef__ and not (dirty and not self._load_from_backup[1])):
            dct["loadFromBackup"] = dictify(self.load_from_backup)
        if "backup_uuid" == "type" or (self.backup_uuid is not self.__undef__ and not (dirty and not self._backup_uuid[1])):
            dct["backupUUID"] = dictify(self.backup_uuid)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._load_from_backup = (self._load_from_backup[0], True)
        self._backup_uuid = (self._backup_uuid[0], True)

    def is_dirty(self):
        return any([self._load_from_backup[1], self._backup_uuid[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlSyncParameters):
            return False
        return super(MSSqlSyncParameters, self).__eq__(other) and \
               self.load_from_backup == other.load_from_backup and \
               self.backup_uuid == other.backup_uuid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def load_from_backup(self):
        """
        When set, this parameter overrides the loadFromBackup property in the
        container's sourcing policy. When set to true, Delphix will restore
        from an already existing database backup. If the backupUUID is set,
        that specific backup will be restored. Otherwise the most recent full
        or differential database backup will be restored. When set to false,
        Delphix will take a copy-only full backup and restore from that.

        :rtype: ``bool``
        """
        return self._load_from_backup[0]

    @load_from_backup.setter
    def load_from_backup(self, value):
        self._load_from_backup = (value, True)

    @property
    def backup_uuid(self):
        """
        The UUID of the full or differential backup of the source database to
        restore from. The backup should be present in the shared backup
        location for the source database. This property is relevant only if
        when loading from an existing backup.

        :rtype: ``basestring``
        """
        return self._backup_uuid[0]

    @backup_uuid.setter
    def backup_uuid(self, value):
        self._backup_uuid = (value, True)

class OracleSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSyncParameters, self).__init__()
        self._type = ("OracleSyncParameters", True)
        self._skip_space_check = (self.__undef__, True)
        self._double_sync = (self.__undef__, True)
        self._force_full_backup = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._skip_space_check = (data.get("skipSpaceCheck", obj.__undef__), dirty)
        if obj._skip_space_check[0] is not None and obj._skip_space_check[0] is not obj.__undef__:
            assert isinstance(obj._skip_space_check[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._skip_space_check[0]))
            common.validate_format(obj._skip_space_check[0], "None", None, None)
        obj._double_sync = (data.get("doubleSync", obj.__undef__), dirty)
        if obj._double_sync[0] is not None and obj._double_sync[0] is not obj.__undef__:
            assert isinstance(obj._double_sync[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._double_sync[0]))
            common.validate_format(obj._double_sync[0], "None", None, None)
        obj._force_full_backup = (data.get("forceFullBackup", obj.__undef__), dirty)
        if obj._force_full_backup[0] is not None and obj._force_full_backup[0] is not obj.__undef__:
            assert isinstance(obj._force_full_backup[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._force_full_backup[0]))
            common.validate_format(obj._force_full_backup[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "skip_space_check" == "type" or (self.skip_space_check is not self.__undef__ and not (dirty and not self._skip_space_check[1])):
            dct["skipSpaceCheck"] = dictify(self.skip_space_check)
        if "double_sync" == "type" or (self.double_sync is not self.__undef__ and not (dirty and not self._double_sync[1])):
            dct["doubleSync"] = dictify(self.double_sync)
        if "force_full_backup" == "type" or (self.force_full_backup is not self.__undef__ and not (dirty and not self._force_full_backup[1])):
            dct["forceFullBackup"] = dictify(self.force_full_backup)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._skip_space_check = (self._skip_space_check[0], True)
        self._double_sync = (self._double_sync[0], True)
        self._force_full_backup = (self._force_full_backup[0], True)

    def is_dirty(self):
        return any([self._skip_space_check[1], self._double_sync[1], self._force_full_backup[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSyncParameters):
            return False
        return super(OracleSyncParameters, self).__eq__(other) and \
               self.skip_space_check == other.skip_space_check and \
               self.double_sync == other.double_sync and \
               self.force_full_backup == other.force_full_backup

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def skip_space_check(self):
        """
        Skip check that tests if there is enough space available to store the
        database in the Delphix Engine. The Delphix Engine estimates how much
        space a database will occupy after compression and prevents SnapSync if
        insufficient space is available. This safeguard can be overridden using
        this option. This may be useful when linking highly compressible
        databases.

        :rtype: ``bool``
        """
        return self._skip_space_check[0]

    @skip_space_check.setter
    def skip_space_check(self, value):
        self._skip_space_check = (value, True)

    @property
    def double_sync(self):
        """
        True if two SnapSyncs should be performed in immediate succession to
        reduce the number of logs required to provision the snapshot. This may
        significantly reduce the time necessary to provision from a snapshot.

        :rtype: ``bool``
        """
        return self._double_sync[0]

    @double_sync.setter
    def double_sync(self, value):
        self._double_sync = (value, True)

    @property
    def force_full_backup(self):
        """
        Whether or not to take another full backup of the source database.

        :rtype: ``bool``
        """
        return self._force_full_backup[0]

    @force_full_backup.setter
    def force_full_backup(self, value):
        self._force_full_backup = (value, True)

class MySQLSyncParameters(SyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.SyncParameters` *)* The parameters to
    use as input to sync requests for MySQL databases.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLSyncParameters, self).__init__()
        self._type = ("MySQLSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLSyncParameters):
            return False
        return super(MySQLSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLExistingBackupSyncParameters(MySQLSyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLSyncParameters` *)* The parameters
    to use as input to sync requests for MySQL databases using an existing
    backup.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLExistingBackupSyncParameters, self).__init__()
        self._type = ("MySQLExistingBackupSyncParameters", True)
        self._backup_location = (self.__undef__, True)
        self._replication_coordinates = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLExistingBackupSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        if "backupLocation" not in data:
            raise ValueError("Missing required property \"backupLocation\".")
        obj._backup_location = (data.get("backupLocation", obj.__undef__), dirty)
        if obj._backup_location[0] is not None and obj._backup_location[0] is not obj.__undef__:
            assert isinstance(obj._backup_location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._backup_location[0]))
            common.validate_format(obj._backup_location[0], "None", None, None)
        if "replicationCoordinates" in data and data["replicationCoordinates"] is not None:
            obj._replication_coordinates = (factory.create_object(data["replicationCoordinates"], "MySQLReplicationCoordinates"), dirty)
            factory.validate_type(obj._replication_coordinates[0], "MySQLReplicationCoordinates")
        else:
            obj._replication_coordinates = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLExistingBackupSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "backup_location" == "type" or (self.backup_location is not self.__undef__ and not (dirty and not self._backup_location[1])):
            dct["backupLocation"] = dictify(self.backup_location)
        if "replication_coordinates" == "type" or (self.replication_coordinates is not self.__undef__ and not (dirty and not self._replication_coordinates[1])):
            dct["replicationCoordinates"] = dictify(self.replication_coordinates)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._backup_location = (self._backup_location[0], True)
        self._replication_coordinates = (self._replication_coordinates[0], True)

    def is_dirty(self):
        return any([self._backup_location[1], self._replication_coordinates[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLExistingBackupSyncParameters):
            return False
        return super(MySQLExistingBackupSyncParameters, self).__eq__(other) and \
               self.backup_location == other.backup_location and \
               self.replication_coordinates == other.replication_coordinates

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def backup_location(self):
        """
        Path to the existing backup to be loaded.

        :rtype: ``basestring``
        """
        return self._backup_location[0]

    @backup_location.setter
    def backup_location(self, value):
        self._backup_location = (value, True)

    @property
    def replication_coordinates(self):
        """
        The coordinates corresponding to the MySQL backup to start replication
        from.

        :rtype: :py:class:`v1_8_1.web.vo.MySQLReplicationCoordinates`
        """
        return self._replication_coordinates[0]

    @replication_coordinates.setter
    def replication_coordinates(self, value):
        self._replication_coordinates = (value, True)

class MySQLNewMySQLDumpSyncParameters(MySQLSyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLSyncParameters` *)* The parameters
    to use as input to sync requests for MySQL databases using a new MySQL dump
    taken by Delphix.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLNewMySQLDumpSyncParameters, self).__init__()
        self._type = ("MySQLNewMySQLDumpSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLNewMySQLDumpSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLNewMySQLDumpSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLNewMySQLDumpSyncParameters):
            return False
        return super(MySQLNewMySQLDumpSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLExistingMySQLDumpSyncParameters(MySQLExistingBackupSyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLExistingBackupSyncParameters` *)*
    The parameters to use as input to sync requests for MySQL databases using
    an existing MySQL dump.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLExistingMySQLDumpSyncParameters, self).__init__()
        self._type = ("MySQLExistingMySQLDumpSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLExistingMySQLDumpSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLExistingMySQLDumpSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLExistingMySQLDumpSyncParameters):
            return False
        return super(MySQLExistingMySQLDumpSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MySQLXtraBackupSyncParameters(MySQLExistingBackupSyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MySQLExistingBackupSyncParameters` *)*
    The parameters to use as input to sync requests for MySQL databases using
    an existing XtraBackup backup.
    """
    def __init__(self, undef_enabled=True):
        super(MySQLXtraBackupSyncParameters, self).__init__()
        self._type = ("MySQLXtraBackupSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MySQLXtraBackupSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MySQLXtraBackupSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MySQLXtraBackupSyncParameters):
            return False
        return super(MySQLXtraBackupSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASENewBackupSyncParameters(ASESyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESyncParameters` *)* The parameters
    to use as input to sync a SAP ASE database by taking a new full backup.
    """
    def __init__(self, undef_enabled=True):
        super(ASENewBackupSyncParameters, self).__init__()
        self._type = ("ASENewBackupSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASENewBackupSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASENewBackupSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASENewBackupSyncParameters):
            return False
        return super(ASENewBackupSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASELatestBackupSyncParameters(ASESyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESyncParameters` *)* The parameters
    to use as input to sync a SAP ASE database using the latest backup.
    """
    def __init__(self, undef_enabled=True):
        super(ASELatestBackupSyncParameters, self).__init__()
        self._type = ("ASELatestBackupSyncParameters", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASELatestBackupSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASELatestBackupSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASELatestBackupSyncParameters):
            return False
        return super(ASELatestBackupSyncParameters, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class ASESpecificBackupSyncParameters(ASESyncParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.ASESyncParameters` *)* The parameters
    to use as input to sync a SAP ASE database using a specific existing
    backup.
    """
    def __init__(self, undef_enabled=True):
        super(ASESpecificBackupSyncParameters, self).__init__()
        self._type = ("ASESpecificBackupSyncParameters", True)
        self._backup_files = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(ASESpecificBackupSyncParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._backup_files = []
        for item in data.get("backupFiles") or []:
            assert isinstance(item, basestring), ("Expected one of [u'string'], but got %s" % type(item))
            common.validate_format(item, "None", None, None)
            obj._backup_files.append(item)
        obj._backup_files = (obj._backup_files, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(ASESpecificBackupSyncParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "backup_files" == "type" or (self.backup_files is not self.__undef__ and not (dirty and not self._backup_files[1])):
            dct["backupFiles"] = dictify(self.backup_files)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._backup_files = (self._backup_files[0], True)

    def is_dirty(self):
        return any([self._backup_files[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, ASESpecificBackupSyncParameters):
            return False
        return super(ASESpecificBackupSyncParameters, self).__eq__(other) and \
               self.backup_files == other.backup_files

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def backup_files(self):
        """
        The location of the full backup of the source database to restore from.
        The backup should be present in the shared backup location for the
        source database.

        :rtype: ``list`` of ``basestring``
        """
        return self._backup_files[0]

    @backup_files.setter
    def backup_files(self, value):
        self._backup_files = (value, True)

class TimeflowPointSnapshot(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a snapshot reference.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointSnapshot, self).__init__()
        self._type = ("TimeflowPointSnapshot", True)
        self._snapshot = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointSnapshot, cls).from_dict(data, dirty, undef_enabled)
        if "snapshot" not in data:
            raise ValueError("Missing required property \"snapshot\".")
        obj._snapshot = (data.get("snapshot", obj.__undef__), dirty)
        if obj._snapshot[0] is not None and obj._snapshot[0] is not obj.__undef__:
            assert isinstance(obj._snapshot[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._snapshot[0]))
            common.validate_format(obj._snapshot[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointSnapshot, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "snapshot" == "type" or (self.snapshot is not self.__undef__ and not (dirty and not self._snapshot[1])):
            dct["snapshot"] = dictify(self.snapshot)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._snapshot = (self._snapshot[0], True)

    def is_dirty(self):
        return any([self._snapshot[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointSnapshot):
            return False
        return super(TimeflowPointSnapshot, self).__eq__(other) and \
               self.snapshot == other.snapshot

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def snapshot(self):
        """
        Reference to the snapshot.

        :rtype: ``basestring``
        """
        return self._snapshot[0]

    @snapshot.setter
    def snapshot(self, value):
        self._snapshot = (value, True)

class TimeflowPointBookmarkTag(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a TimeFlow bookmark tag.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointBookmarkTag, self).__init__()
        self._type = ("TimeflowPointBookmarkTag", True)
        self._tag = (self.__undef__, True)
        self._container = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointBookmarkTag, cls).from_dict(data, dirty, undef_enabled)
        if "tag" not in data:
            raise ValueError("Missing required property \"tag\".")
        obj._tag = (data.get("tag", obj.__undef__), dirty)
        if obj._tag[0] is not None and obj._tag[0] is not obj.__undef__:
            assert isinstance(obj._tag[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._tag[0]))
            common.validate_format(obj._tag[0], "None", None, None)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointBookmarkTag, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "tag" == "type" or (self.tag is not self.__undef__ and not (dirty and not self._tag[1])):
            dct["tag"] = dictify(self.tag)
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._tag = (self._tag[0], True)
        self._container = (self._container[0], True)

    def is_dirty(self):
        return any([self._tag[1], self._container[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointBookmarkTag):
            return False
        return super(TimeflowPointBookmarkTag, self).__eq__(other) and \
               self.tag == other.tag and \
               self.container == other.container

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def tag(self):
        """
        The name of the tag.

        :rtype: ``basestring``
        """
        return self._tag[0]

    @tag.setter
    def tag(self, value):
        self._tag = (value, True)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

class TimeflowPointTimestamp(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a timestamp.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointTimestamp, self).__init__()
        self._type = ("TimeflowPointTimestamp", True)
        self._timestamp = (self.__undef__, True)
        self._timeflow = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointTimestamp, cls).from_dict(data, dirty, undef_enabled)
        if "timestamp" not in data:
            raise ValueError("Missing required property \"timestamp\".")
        obj._timestamp = (data.get("timestamp", obj.__undef__), dirty)
        if obj._timestamp[0] is not None and obj._timestamp[0] is not obj.__undef__:
            assert isinstance(obj._timestamp[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timestamp[0]))
            common.validate_format(obj._timestamp[0], "date", None, None)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointTimestamp, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timestamp" == "type" or (self.timestamp is not self.__undef__ and not (dirty and not self._timestamp[1])):
            dct["timestamp"] = dictify(self.timestamp)
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timestamp = (self._timestamp[0], True)
        self._timeflow = (self._timeflow[0], True)

    def is_dirty(self):
        return any([self._timestamp[1], self._timeflow[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointTimestamp):
            return False
        return super(TimeflowPointTimestamp, self).__eq__(other) and \
               self.timestamp == other.timestamp and \
               self.timeflow == other.timeflow

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timestamp(self):
        """
        The logical time corresponding to the TimeFlow location.

        :rtype: ``basestring``
        """
        return self._timestamp[0]

    @timestamp.setter
    def timestamp(self, value):
        self._timestamp = (value, True)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this point.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

class TimeflowPointBookmark(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a TimeFlow bookmark.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointBookmark, self).__init__()
        self._type = ("TimeflowPointBookmark", True)
        self._bookmark = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointBookmark, cls).from_dict(data, dirty, undef_enabled)
        if "bookmark" not in data:
            raise ValueError("Missing required property \"bookmark\".")
        obj._bookmark = (data.get("bookmark", obj.__undef__), dirty)
        if obj._bookmark[0] is not None and obj._bookmark[0] is not obj.__undef__:
            assert isinstance(obj._bookmark[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._bookmark[0]))
            common.validate_format(obj._bookmark[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointBookmark, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "bookmark" == "type" or (self.bookmark is not self.__undef__ and not (dirty and not self._bookmark[1])):
            dct["bookmark"] = dictify(self.bookmark)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._bookmark = (self._bookmark[0], True)

    def is_dirty(self):
        return any([self._bookmark[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointBookmark):
            return False
        return super(TimeflowPointBookmark, self).__eq__(other) and \
               self.bookmark == other.bookmark

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def bookmark(self):
        """
        Reference to the bookmark.

        :rtype: ``basestring``
        """
        return self._bookmark[0]

    @bookmark.setter
    def bookmark(self, value):
        self._bookmark = (value, True)

class TimeflowPointLocation(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a database-specific identifier (SCN, LSN, etc).
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointLocation, self).__init__()
        self._type = ("TimeflowPointLocation", True)
        self._timeflow = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointLocation, cls).from_dict(data, dirty, undef_enabled)
        if "timeflow" not in data:
            raise ValueError("Missing required property \"timeflow\".")
        obj._timeflow = (data.get("timeflow", obj.__undef__), dirty)
        if obj._timeflow[0] is not None and obj._timeflow[0] is not obj.__undef__:
            assert isinstance(obj._timeflow[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._timeflow[0]))
            common.validate_format(obj._timeflow[0], "objectReference", None, None)
        if "location" not in data:
            raise ValueError("Missing required property \"location\".")
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointLocation, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "timeflow" == "type" or (self.timeflow is not self.__undef__ and not (dirty and not self._timeflow[1])):
            dct["timeflow"] = dictify(self.timeflow)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._timeflow = (self._timeflow[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._timeflow[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointLocation):
            return False
        return super(TimeflowPointLocation, self).__eq__(other) and \
               self.timeflow == other.timeflow and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def timeflow(self):
        """
        Reference to TimeFlow containing this location.

        :rtype: ``basestring``
        """
        return self._timeflow[0]

    @timeflow.setter
    def timeflow(self, value):
        self._timeflow = (value, True)

    @property
    def location(self):
        """
        The TimeFlow location.

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

class TimeflowPointSemantic(TimeflowPointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowPointParameters` *)* TimeFlow
    point based on a semantic reference.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowPointSemantic, self).__init__()
        self._type = ("TimeflowPointSemantic", True)
        self._container = (self.__undef__, True)
        self._location = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowPointSemantic, cls).from_dict(data, dirty, undef_enabled)
        if "container" not in data:
            raise ValueError("Missing required property \"container\".")
        obj._container = (data.get("container", obj.__undef__), dirty)
        if obj._container[0] is not None and obj._container[0] is not obj.__undef__:
            assert isinstance(obj._container[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._container[0]))
            common.validate_format(obj._container[0], "objectReference", None, None)
        obj._location = (data.get("location", obj.__undef__), dirty)
        if obj._location[0] is not None and obj._location[0] is not obj.__undef__:
            assert isinstance(obj._location[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._location[0]))
            assert obj._location[0] in [u'LATEST_POINT', u'LATEST_SNAPSHOT'], "Expected enum [u'LATEST_POINT', u'LATEST_SNAPSHOT'] but got %s" % obj._location[0]
            common.validate_format(obj._location[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowPointSemantic, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "container" == "type" or (self.container is not self.__undef__ and not (dirty and not self._container[1])):
            dct["container"] = dictify(self.container)
        if "location" == "type" or (self.location is not self.__undef__ and not (dirty and not self._location[1])):
            dct["location"] = dictify(self.location)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._container = (self._container[0], True)
        self._location = (self._location[0], True)

    def is_dirty(self):
        return any([self._container[1], self._location[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowPointSemantic):
            return False
        return super(TimeflowPointSemantic, self).__eq__(other) and \
               self.container == other.container and \
               self.location == other.location

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def container(self):
        """
        Reference to the container.

        :rtype: ``basestring``
        """
        return self._container[0]

    @container.setter
    def container(self, value):
        self._container = (value, True)

    @property
    def location(self):
        """
        *(default value: LATEST_POINT)* A semantic description of a TimeFlow
        location. *(permitted values: LATEST_POINT, LATEST_SNAPSHOT)*

        :rtype: ``basestring``
        """
        return self._location[0]

    @location.setter
    def location(self, value):
        self._location = (value, True)

class OracleRefreshParameters(RefreshParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.RefreshParameters` *)* The parameters
    to use as input to refresh Oracle databases.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRefreshParameters, self).__init__()
        self._type = ("OracleRefreshParameters", True)
        self._username = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRefreshParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRefreshParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRefreshParameters):
            return False
        return super(OracleRefreshParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the refresh operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the refresh
        operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class OracleDatafileTempfileSpecification(OracleFileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleFileSpecification` *)* Describes
    an Oracle datafile or tempfile for use when creating or altering
    controlfiles, databases, or tablespaces.
    """
    def __init__(self, undef_enabled=True):
        super(OracleDatafileTempfileSpecification, self).__init__()
        self._type = ("OracleDatafileTempfileSpecification", True)
        self._max_size = (self.__undef__, True)
        self._auto_extend = (self.__undef__, True)
        self._auto_extend_increment = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleDatafileTempfileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._max_size = (data.get("maxSize", obj.__undef__), dirty)
        if obj._max_size[0] is not None and obj._max_size[0] is not obj.__undef__:
            assert isinstance(obj._max_size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._max_size[0]))
            common.validate_format(obj._max_size[0], "None", None, None)
        obj._auto_extend = (data.get("autoExtend", obj.__undef__), dirty)
        if obj._auto_extend[0] is not None and obj._auto_extend[0] is not obj.__undef__:
            assert isinstance(obj._auto_extend[0], bool), ("Expected one of [u'boolean'], but got %s" % type(obj._auto_extend[0]))
            common.validate_format(obj._auto_extend[0], "None", None, None)
        obj._auto_extend_increment = (data.get("autoExtendIncrement", obj.__undef__), dirty)
        if obj._auto_extend_increment[0] is not None and obj._auto_extend_increment[0] is not obj.__undef__:
            assert isinstance(obj._auto_extend_increment[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._auto_extend_increment[0]))
            common.validate_format(obj._auto_extend_increment[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleDatafileTempfileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "max_size" == "type" or (self.max_size is not self.__undef__ and not (dirty and not self._max_size[1])):
            dct["maxSize"] = dictify(self.max_size)
        if "auto_extend" == "type" or (self.auto_extend is not self.__undef__ and not (dirty and not self._auto_extend[1])):
            dct["autoExtend"] = dictify(self.auto_extend)
        if "auto_extend_increment" == "type" or (self.auto_extend_increment is not self.__undef__ and not (dirty and not self._auto_extend_increment[1])):
            dct["autoExtendIncrement"] = dictify(self.auto_extend_increment)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._max_size = (self._max_size[0], True)
        self._auto_extend = (self._auto_extend[0], True)
        self._auto_extend_increment = (self._auto_extend_increment[0], True)

    def is_dirty(self):
        return any([self._max_size[1], self._auto_extend[1], self._auto_extend_increment[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleDatafileTempfileSpecification):
            return False
        return super(OracleDatafileTempfileSpecification, self).__eq__(other) and \
               self.max_size == other.max_size and \
               self.auto_extend == other.auto_extend and \
               self.auto_extend_increment == other.auto_extend_increment

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def max_size(self):
        """
        The maximum disk space allowed for automatic extension of the datafile.
        Omit this if you do not want to limit the disk space that Oracle can
        allocate to the datafile or tempfile.

        :rtype: ``int``
        """
        return self._max_size[0]

    @max_size.setter
    def max_size(self, value):
        self._max_size = (value, True)

    @property
    def auto_extend(self):
        """
        *(default value: True)* Enable or disable the automatic extension of a
        new or existing datafile or tempfile.

        :rtype: ``bool``
        """
        return self._auto_extend[0]

    @auto_extend.setter
    def auto_extend(self, value):
        self._auto_extend = (value, True)

    @property
    def auto_extend_increment(self):
        """
        The size in MB of the next increment of disk space to be allocated
        automatically when more extents are required. The default is the size
        of one data block.

        :rtype: ``int``
        """
        return self._auto_extend_increment[0]

    @auto_extend_increment.setter
    def auto_extend_increment(self, value):
        self._auto_extend_increment = (value, True)

class OracleRedoLogFileSpecification(OracleFileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleFileSpecification` *)* Describes
    an Oracle redo log file.
    """
    def __init__(self, undef_enabled=True):
        super(OracleRedoLogFileSpecification, self).__init__()
        self._type = ("OracleRedoLogFileSpecification", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleRedoLogFileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleRedoLogFileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleRedoLogFileSpecification):
            return False
        return super(OracleRedoLogFileSpecification, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        *(default value: 100)* The size of the log file in MB.

        :rtype: ``int``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class OracleTempfileSpecification(OracleDatafileTempfileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDatafileTempfileSpecification`
    *)* Describes an Oracle temporary file.
    """
    def __init__(self, undef_enabled=True):
        super(OracleTempfileSpecification, self).__init__()
        self._type = ("OracleTempfileSpecification", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleTempfileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleTempfileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleTempfileSpecification):
            return False
        return super(OracleTempfileSpecification, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        *(default value: 300)* The size of the file in MB.

        :rtype: ``int``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class OracleSystemDatafileSpecification(OracleDatafileTempfileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDatafileTempfileSpecification`
    *)* Describes an Oracle datafile in the SYSTEM tablespace.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSystemDatafileSpecification, self).__init__()
        self._type = ("OracleSystemDatafileSpecification", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSystemDatafileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSystemDatafileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSystemDatafileSpecification):
            return False
        return super(OracleSystemDatafileSpecification, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        *(default value: 700)* The size of the file in MB.

        :rtype: ``int``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class OracleSysauxDatafileSpecification(OracleDatafileTempfileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDatafileTempfileSpecification`
    *)* Describes an Oracle datafile in the SYSAUX tablespace.
    """
    def __init__(self, undef_enabled=True):
        super(OracleSysauxDatafileSpecification, self).__init__()
        self._type = ("OracleSysauxDatafileSpecification", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleSysauxDatafileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleSysauxDatafileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleSysauxDatafileSpecification):
            return False
        return super(OracleSysauxDatafileSpecification, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        *(default value: 900)* The size of the file in MB.

        :rtype: ``int``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class OracleUndoDatafileSpecification(OracleDatafileTempfileSpecification):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleDatafileTempfileSpecification`
    *)* Describes an Oracle datafile that stores undo data.
    """
    def __init__(self, undef_enabled=True):
        super(OracleUndoDatafileSpecification, self).__init__()
        self._type = ("OracleUndoDatafileSpecification", True)
        self._size = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleUndoDatafileSpecification, cls).from_dict(data, dirty, undef_enabled)
        obj._size = (data.get("size", obj.__undef__), dirty)
        if obj._size[0] is not None and obj._size[0] is not obj.__undef__:
            assert isinstance(obj._size[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._size[0]))
            common.validate_format(obj._size[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleUndoDatafileSpecification, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "size" == "type" or (self.size is not self.__undef__ and not (dirty and not self._size[1])):
            dct["size"] = dictify(self.size)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._size = (self._size[0], True)

    def is_dirty(self):
        return any([self._size[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleUndoDatafileSpecification):
            return False
        return super(OracleUndoDatafileSpecification, self).__eq__(other) and \
               self.size == other.size

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def size(self):
        """
        *(default value: 300)* The size of the file in MB.

        :rtype: ``int``
        """
        return self._size[0]

    @size.setter
    def size(self, value):
        self._size = (value, True)

class OracleAddLiveSourceParameters(AddLiveSourceParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.AddLiveSourceParameters` *)* The
    parameters to use as input to convert an Oracle dSource to an Oracle
    LiveSource.
    """
    def __init__(self, undef_enabled=True):
        super(OracleAddLiveSourceParameters, self).__init__()
        self._type = ("OracleAddLiveSourceParameters", True)
        self._username = (self.__undef__, True)
        self._source_config = (self.__undef__, True)
        self._source = (self.__undef__, True)
        self._credential = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleAddLiveSourceParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        if "sourceConfig" not in data:
            raise ValueError("Missing required property \"sourceConfig\".")
        if "sourceConfig" in data and data["sourceConfig"] is not None:
            obj._source_config = (factory.create_object(data["sourceConfig"], "OracleDBConfig"), dirty)
            factory.validate_type(obj._source_config[0], "OracleDBConfig")
        else:
            obj._source_config = (obj.__undef__, dirty)
        if "source" not in data:
            raise ValueError("Missing required property \"source\".")
        if "source" in data and data["source"] is not None:
            obj._source = (factory.create_object(data["source"], "OracleLiveSource"), dirty)
            factory.validate_type(obj._source[0], "OracleLiveSource")
        else:
            obj._source = (obj.__undef__, dirty)
        if "credential" in data and data["credential"] is not None:
            obj._credential = (factory.create_object(data["credential"], "Credential"), dirty)
            factory.validate_type(obj._credential[0], "Credential")
        else:
            obj._credential = (obj.__undef__, dirty)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleAddLiveSourceParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "source_config" == "type" or (self.source_config is not self.__undef__ and not (dirty and not self._source_config[1])):
            dct["sourceConfig"] = dictify(self.source_config)
        if "source" == "type" or (self.source is not self.__undef__ and not (dirty and not self._source[1])):
            dct["source"] = dictify(self.source)
        if "credential" == "type" or (self.credential is not self.__undef__ and not (dirty and not self._credential[1])):
            dct["credential"] = dictify(self.credential)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._username = (self._username[0], True)
        self._source_config = (self._source_config[0], True)
        self._source = (self._source[0], True)
        self._credential = (self._credential[0], True)

    def is_dirty(self):
        return any([self._username[1], self._source_config[1], self._source[1], self._credential[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleAddLiveSourceParameters):
            return False
        return super(OracleAddLiveSourceParameters, self).__eq__(other) and \
               self.username == other.username and \
               self.source_config == other.source_config and \
               self.source == other.source and \
               self.credential == other.credential

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def username(self):
        """
        The name of the privileged user to run the LiveSource creation
        operation as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def source_config(self):
        """
        The source config of the LiveSource.

        :rtype: :py:class:`v1_8_1.web.vo.OracleDBConfig`
        """
        return self._source_config[0]

    @source_config.setter
    def source_config(self, value):
        self._source_config = (value, True)

    @property
    def source(self):
        """
        The source that describes the LiveSource.

        :rtype: :py:class:`v1_8_1.web.vo.OracleLiveSource`
        """
        return self._source[0]

    @source.setter
    def source(self, value):
        self._source = (value, True)

    @property
    def credential(self):
        """
        The security credential of the privileged user to run the LiveSource
        creation operation as.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credential[0]

    @credential.setter
    def credential(self, value):
        self._credential = (value, True)

class JSOperationEndpointBranchParameters(JSOperationEndpointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSOperationEndpointParameters` *)* The
    branch to fetch the first and last event from.
    """
    def __init__(self, undef_enabled=True):
        super(JSOperationEndpointBranchParameters, self).__init__()
        self._type = ("JSOperationEndpointBranchParameters", True)
        self._branch = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSOperationEndpointBranchParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._branch = (data.get("branch", obj.__undef__), dirty)
        if obj._branch[0] is not None and obj._branch[0] is not obj.__undef__:
            assert isinstance(obj._branch[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._branch[0]))
            common.validate_format(obj._branch[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSOperationEndpointBranchParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "branch" == "type" or (self.branch is not self.__undef__ and not (dirty and not self._branch[1])):
            dct["branch"] = dictify(self.branch)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._branch = (self._branch[0], True)

    def is_dirty(self):
        return any([self._branch[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSOperationEndpointBranchParameters):
            return False
        return super(JSOperationEndpointBranchParameters, self).__eq__(other) and \
               self.branch == other.branch

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def branch(self):
        """
        The branch to search.

        :rtype: ``basestring``
        """
        return self._branch[0]

    @branch.setter
    def branch(self, value):
        self._branch = (value, True)

class JSOperationEndpointDataLayoutParameters(JSOperationEndpointParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.JSOperationEndpointParameters` *)* The
    data layout to fetch the first and last events from.
    """
    def __init__(self, undef_enabled=True):
        super(JSOperationEndpointDataLayoutParameters, self).__init__()
        self._type = ("JSOperationEndpointDataLayoutParameters", True)
        self._data_layout = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(JSOperationEndpointDataLayoutParameters, cls).from_dict(data, dirty, undef_enabled)
        obj._data_layout = (data.get("dataLayout", obj.__undef__), dirty)
        if obj._data_layout[0] is not None and obj._data_layout[0] is not obj.__undef__:
            assert isinstance(obj._data_layout[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._data_layout[0]))
            common.validate_format(obj._data_layout[0], "objectReference", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(JSOperationEndpointDataLayoutParameters, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "data_layout" == "type" or (self.data_layout is not self.__undef__ and not (dirty and not self._data_layout[1])):
            dct["dataLayout"] = dictify(self.data_layout)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._data_layout = (self._data_layout[0], True)

    def is_dirty(self):
        return any([self._data_layout[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, JSOperationEndpointDataLayoutParameters):
            return False
        return super(JSOperationEndpointDataLayoutParameters, self).__eq__(other) and \
               self.data_layout == other.data_layout

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def data_layout(self):
        """
        The data layout to search.

        :rtype: ``basestring``
        """
        return self._data_layout[0]

    @data_layout.setter
    def data_layout(self, value):
        self._data_layout = (value, True)

class MSSqlFailoverClusterInstance(MSSqlBaseClusterInstance):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterInstance` *)* The
    representation of a SQL Server Instance on a clustered node for Failover
    Clusters.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlFailoverClusterInstance, self).__init__()
        self._type = ("MSSqlFailoverClusterInstance", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlFailoverClusterInstance, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlFailoverClusterInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlFailoverClusterInstance):
            return False
        return super(MSSqlFailoverClusterInstance, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class MSSqlClusterInstance(MSSqlBaseClusterInstance):
    """
    *(extends* :py:class:`v1_8_1.web.vo.MSSqlBaseClusterInstance` *)* The
    representation of a SQL Server Instance on a clustered node for
    Availability Groups.
    """
    def __init__(self, undef_enabled=True):
        super(MSSqlClusterInstance, self).__init__()
        self._type = ("MSSqlClusterInstance", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(MSSqlClusterInstance, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(MSSqlClusterInstance, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, MSSqlClusterInstance):
            return False
        return super(MSSqlClusterInstance, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleFetchedLog(OracleTimeflowLog):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleTimeflowLog` *)* An Oracle log
    file fetched by LogSync.
    """
    def __init__(self, undef_enabled=True):
        super(OracleFetchedLog, self).__init__()
        self._type = ("OracleFetchedLog", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleFetchedLog, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleFetchedLog, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleFetchedLog):
            return False
        return super(OracleFetchedLog, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class OracleMissingLog(OracleTimeflowLog):
    """
    *(extends* :py:class:`v1_8_1.web.vo.OracleTimeflowLog` *)* An Oracle
    missing log file.
    """
    def __init__(self, undef_enabled=True):
        super(OracleMissingLog, self).__init__()
        self._type = ("OracleMissingLog", True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(OracleMissingLog, cls).from_dict(data, dirty, undef_enabled)
        return obj

    def to_dict(self, dirty=False):
        dct = super(OracleMissingLog, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        pass

    def is_dirty(self):
        return False

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, OracleMissingLog):
            return False
        return super(OracleMissingLog, self).__eq__(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

class TimeflowRepairSSH(TimeflowRepairParameters):
    """
    *(extends* :py:class:`v1_8_1.web.vo.TimeflowRepairParameters` *)*
    Parameters to repair log files within a TimeFlow.
    """
    def __init__(self, undef_enabled=True):
        super(TimeflowRepairSSH, self).__init__()
        self._type = ("TimeflowRepairSSH", True)
        self._directory = (self.__undef__, True)
        self._credentials = (self.__undef__, True)
        self._host = (self.__undef__, True)
        self._username = (self.__undef__, True)
        self._port = (self.__undef__, True)

    API_VERSION = "1.8.1"

    @classmethod
    def from_dict(cls, data, dirty=False, undef_enabled=True):
        obj = super(TimeflowRepairSSH, cls).from_dict(data, dirty, undef_enabled)
        if "directory" not in data:
            raise ValueError("Missing required property \"directory\".")
        obj._directory = (data.get("directory", obj.__undef__), dirty)
        if obj._directory[0] is not None and obj._directory[0] is not obj.__undef__:
            assert isinstance(obj._directory[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._directory[0]))
            common.validate_format(obj._directory[0], "None", None, None)
        if "credentials" in data and data["credentials"] is not None:
            obj._credentials = (factory.create_object(data["credentials"], "Credential"), dirty)
            factory.validate_type(obj._credentials[0], "Credential")
        else:
            obj._credentials = (obj.__undef__, dirty)
        if "host" not in data:
            raise ValueError("Missing required property \"host\".")
        obj._host = (data.get("host", obj.__undef__), dirty)
        if obj._host[0] is not None and obj._host[0] is not obj.__undef__:
            assert isinstance(obj._host[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._host[0]))
            common.validate_format(obj._host[0], "None", None, None)
        if "username" not in data:
            raise ValueError("Missing required property \"username\".")
        obj._username = (data.get("username", obj.__undef__), dirty)
        if obj._username[0] is not None and obj._username[0] is not obj.__undef__:
            assert isinstance(obj._username[0], basestring), ("Expected one of [u'string'], but got %s" % type(obj._username[0]))
            common.validate_format(obj._username[0], "None", None, None)
        obj._port = (data.get("port", obj.__undef__), dirty)
        if obj._port[0] is not None and obj._port[0] is not obj.__undef__:
            assert isinstance(obj._port[0], int), ("Expected one of [u'integer'], but got %s" % type(obj._port[0]))
            common.validate_format(obj._port[0], "None", None, None)
        return obj

    def to_dict(self, dirty=False):
        dct = super(TimeflowRepairSSH, self).to_dict(dirty)

        def dictify(obj):
            if isinstance(obj, list):
                return [dictify(o) for o in obj]
            elif hasattr(obj, "to_dict"):
                return obj.to_dict()
            else:
                return obj
        if "directory" == "type" or (self.directory is not self.__undef__ and not (dirty and not self._directory[1])):
            dct["directory"] = dictify(self.directory)
        if "credentials" == "type" or (self.credentials is not self.__undef__ and not (dirty and not self._credentials[1])):
            dct["credentials"] = dictify(self.credentials)
        if "host" == "type" or (self.host is not self.__undef__ and not (dirty and not self._host[1])):
            dct["host"] = dictify(self.host)
        if "username" == "type" or (self.username is not self.__undef__ and not (dirty and not self._username[1])):
            dct["username"] = dictify(self.username)
        if "port" == "type" or (self.port is not self.__undef__ and not (dirty and not self._port[1])):
            dct["port"] = dictify(self.port)
        return dct

    def dirty(self):
        return self.from_dict(self.to_dict(dirty=False), dirty=True)

    def force_dirty(self):
        self._directory = (self._directory[0], True)
        self._credentials = (self._credentials[0], True)
        self._host = (self._host[0], True)
        self._username = (self._username[0], True)
        self._port = (self._port[0], True)

    def is_dirty(self):
        return any([self._directory[1], self._credentials[1], self._host[1], self._username[1], self._port[1]])

    def __eq__(self, other):
        if other is None:
            return False
        if not isinstance(other, TimeflowRepairSSH):
            return False
        return super(TimeflowRepairSSH, self).__eq__(other) and \
               self.directory == other.directory and \
               self.credentials == other.credentials and \
               self.host == other.host and \
               self.username == other.username and \
               self.port == other.port

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return common.generate_repr_string(self)

    @property
    def directory(self):
        """
        Directory on the remote server where the missing log files reside.

        :rtype: ``basestring``
        """
        return self._directory[0]

    @directory.setter
    def directory(self, value):
        self._directory = (value, True)

    @property
    def credentials(self):
        """
        User credentials. If not provided will use environment credentials for
        'username' on 'host'.

        :rtype: :py:class:`v1_8_1.web.vo.Credential`
        """
        return self._credentials[0]

    @credentials.setter
    def credentials(self, value):
        self._credentials = (value, True)

    @property
    def host(self):
        """
        Remote host to connect to.

        :rtype: ``basestring``
        """
        return self._host[0]

    @host.setter
    def host(self, value):
        self._host = (value, True)

    @property
    def username(self):
        """
        User name to authenticate as.

        :rtype: ``basestring``
        """
        return self._username[0]

    @username.setter
    def username(self, value):
        self._username = (value, True)

    @property
    def port(self):
        """
        *(default value: 22)* SSH port to connect to.

        :rtype: ``int``
        """
        return self._port[0]

    @port.setter
    def port(self, value):
        self._port = (value, True)

