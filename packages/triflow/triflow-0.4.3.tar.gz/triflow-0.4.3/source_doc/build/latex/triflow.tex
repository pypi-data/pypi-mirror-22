%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% Jupyter Notebook prompt colors
\definecolor{nbsphinxin}{HTML}{303F9F}
\definecolor{nbsphinxout}{HTML}{D84315}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}



\title{triflow Documentation}
\date{May 24, 2017}
\release{0.4.3}
\author{Nicolas Cellier}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}\label{\detokenize{installation:welcome-to-triflow-s-documentation}}

\section{External requirements}
\label{\detokenize{installation:external-requirements}}
This library is written for python \textgreater{}= 3.6, and I recommend to install it via {\color{red}\bfseries{}Anaconda\_} : this is a full python distribution including a scientific-oriented IDE, the main scientific python libraries and the Jupyter project.

The library is based on Theano, thus extra dependecies like fortran and C compiler are needed, see Theano install page for extra informations:

\sphinxurl{http://deeplearning.net/software/theano/install.html}


\section{via PyPI}
\label{\detokenize{installation:via-pypi}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install triflow
\end{sphinxVerbatim}

will install the package and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install triflow \PYGZhy{}\PYGZhy{}upgrade
\end{sphinxVerbatim}

will update an old version of the library.

use sudo if needed, and the user flag if you want to install it without the root privileges:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install \PYGZhy{}\PYGZhy{}user triflow
\end{sphinxVerbatim}


\section{via github}
\label{\detokenize{installation:via-github}}
You can install the last version of the library using pip and the \sphinxhref{https://github.com/locie/triflow}{github repository}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install git+git://github.com/locie/triflow.git
\end{sphinxVerbatim}


\chapter{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview:github-repository}}\label{\detokenize{overview::doc}}

\section{Motivation}
\label{\detokenize{overview:motivation}}
The aim of this library is to have an easy way to write transient dynamic systems with 1D finite difference discretisation, with fast temporal solvers.

The main two parts of the library are:
\begin{itemize}
\item {} 
symbolic tools defining the spatial discretisation.

\item {} 
a fast temporal solver written to use the sparsity of the finite difference method to reduce the memory and CPU usage during the computation. \sphinxhref{http://deeplearning.net/software/theano/}{Theano} make this part easy.

\end{itemize}

Moreover, we provide extra tools and we write the library in a modular way, allowing an easy extension of these different parts (see the plug-in module of the library.)

The library fits well with an interactive usage (in a jupyter notebook).


\section{Model writing}
\label{\detokenize{overview:model-writing}}
We write all the models as function generating the F vector and the Jacobian matrix of the model defined as
\begin{equation*}
\begin{split}\frac{\partial U}{\partial t} = F(U)\end{split}
\end{equation*}
We write the symbolic model as a simple mathematic equation. For exemple, a diffusion advection model:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eq\PYGZus{}diff} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dep\PYGZus{}var} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pars} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{n}{eq\PYGZus{}diff}\PYG{p}{,} \PYG{n}{dep\PYGZus{}var}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}
\end{sphinxVerbatim}

the model give us access after that to the compiled routines for F and the corresponding Jacobian matrix as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{F}\PYG{p}{)}
\PYG{g+go}{Matrix([[\PYGZhy{}2*U*k/dx**2 + 0.5*U\PYGZus{}m1*c/dx + U\PYGZus{}m1*k/dx**2 \PYGZhy{} 0.5*U\PYGZus{}p1*c/dx + U\PYGZus{}p1*k/dx**2]])}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{J}\PYG{p}{)}
\PYG{g+go}{Matrix([}
\PYG{g+go}{[ 0.5*c/dx + k/dx**2],}
\PYG{g+go}{[         \PYGZhy{}2*k/dx**2],}
\PYG{g+go}{[\PYGZhy{}0.5*c/dx + k/dx**2]])}
\end{sphinxVerbatim}

We compute the Jacobian in a sparse form. These object are callable, and will return the numerical values if we provide the fields and the parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{F}\PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([...])}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{J}\PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}NxN sparse matrix of type \PYGZsq{}\PYGZlt{}class \PYGZsq{}numpy.float64\PYGZsq{}\PYGZgt{}\PYGZsq{}}
\PYG{g+go}{with M stored elements in Compressed Sparse Column format\PYGZgt{}}
\end{sphinxVerbatim}

a numerical approximation is available for debug purpose with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{F}\PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[...]])}
\end{sphinxVerbatim}

be aware that numerical approximation of the Jacobian is far less efficient than the provided optimized routine.


\subsection{optional arguments : fields and parameters}
\label{\detokenize{overview:optional-arguments-fields-and-parameters}}
The model take two mandatory parameters: differential\_equations, dependent\_variables. The first define the evaluation of the time derivative, the second the name of the dependant variables.

It can take two optional arguments :
\begin{itemize}
\item {} 
parameters, a list of parameters name. They can be scalar or vector with the same dimension as the dependant variables.

\item {} 
help\_functions, a list of outside variables : they have to be vector with the same dimension of the dependant variable.

\end{itemize}

So, what is main difference between them? The difference is that you have the possibility to use spatial derivative of the fields in the model. Because the fields are parsed and the derivative approximated, it make the graph optimization of the model grows.


\section{Model compilation}
\label{\detokenize{overview:model-compilation}}
The model has to be compiled before being employed. The sympy library provides an easy way to automatically write the Fortran or C routine corresponding. Better than that, a tool has been written in order to convert sympy complex expressions to \sphinxhref{http://deeplearning.net/software/theano/}{Theano} graph which can be easily compiled.

In the examples folder live some classic 1D PDE (diffusion, diffusion/advection, burger equation...).

The Model class is pickable, means that it can be sent across the network and between cpu for multiprocessing purpose. It can be sae on disk as a binary and reload later. It is important in order to reduce the large compilation overhead. (see Model.save and load\_model). Thus, the model has to be re-optimized by Theano on every new host, leading to potential long initialization for large and complex models. The memory footprint can be large (\textgreater{} 1Go) in some case: this is the cost of the theano aggressive graph optimization strategy. {[}Further work will include the choice between high performance and fast overhead{]}. It should be important to notice that Theano is able to handle GPU computation if properly configured (see the \sphinxhref{http://deeplearning.net/software/theano/}{Theano} documentation for more details).


\section{Fields containers}
\label{\detokenize{overview:fields-containers}}
A special container has been designed to handle initial values of the dependant solutions (the unknowns), the independant variables (spatial coordinates), the constant fields and the post-processed variable (known as helper function).

A factory is linked to the model and is accessible via the model.fields\_template property :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
\end{sphinxVerbatim}

The variable involved in the computation are stored on a large vector containing all the fields, and this object give access to each fields to simplify their modification and the computations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}
\PYG{g+go}{[5, 5, 5, ..., 5, 5]}
\end{sphinxVerbatim}

Be aware of difference between the attribute giving access to a view of the main array and the one returning a copy of the subarray: the first one allow an on-the-fly modification of the fields (in order to inject boundary condition for exemple), the second one should be only used as read-only meaning.


\section{Numerical scheme, temporal solver}
\label{\detokenize{overview:numerical-scheme-temporal-solver}}
In order to provide fast and scalable temporal solver, the Jacobian use the \sphinxhref{https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.sparse.csc\_matrix.html}{scipy sparse column matrix format} (which will reduce the memory usage, especialy for a large number of spatial nodes), and make available the \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU} decomposition, a fast LU sparse matrix decomposition algorithm.

Different temporal schemes are provided in the plugins module:
\begin{itemize}
\item {} 
a forward Euler scheme

\item {} 
a backward Euler scheme

\item {} 
a \(\theta\) mixed scheme

\item {} 
A ROW schemes from order 3 up to 6 with fixed and variable time stepping.

\item {} 
A proxy schemes giving access to all the scipy.integrate.ode schemes.

\end{itemize}

Each of them have advantages and disadvantages.

They can accept somme extra arguments during their instantiation (for exemple the \(\theta\) parameter for the \(\theta\) mixed scheme), and are called with the actual fields, time, time-step, parameters, and accept an optionnal hook modifying fields and parameters each time the solver compute the function or its jacobian.

The following code compute juste one time-step with a Crank-Nicolson scheme.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k+kn}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{schemes}

\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Agg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} noqa}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{pl}  \PYG{c+c1}{\PYGZsh{} isort:skip}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}whitegrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{03}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{001}\PYG{p}{,} \PYG{n}{dx}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1E\PYGZhy{}1}

\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{Theta}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{theta}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Crank\PYGZhy{}Nicolson scheme}

\PYG{n}{new\PYGZus{}t}\PYG{p}{,} \PYG{n}{new\PYGZus{}fields} \PYG{o}{=} \PYG{n}{scheme}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{new\PYGZus{}fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{new\PYGZus{}fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{overview_model_one_step}.pdf}

We obtain with the following code a full resolution up to the target time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{itertools} \PYG{k+kn}{as} \PYG{n+nn}{it}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k+kn}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{schemes}

\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Agg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} noqa}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{pl}  \PYG{c+c1}{\PYGZsh{} isort:skip}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}whitegrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{03}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{001}\PYG{p}{,} \PYG{n}{dx}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1E\PYGZhy{}2}
\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{Theta}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{theta}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Crank\PYGZhy{}Nicolson scheme}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{it}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o}{=} \PYG{n}{scheme}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{100} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{tmax}\PYG{p}{:}
        \PYG{k}{break}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{legend} \PYG{o}{=} \PYG{n}{pl}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{overview_model_multi_step}.pdf}


\subsection{hook and boundary conditions}
\label{\detokenize{overview:hook-and-boundary-conditions}}
The hook function is used in order to deal with variable and conditional parameters and boundary condition.

Inside the model, the fields are padded in order to solve the equation. If the parameter \sphinxquotedblleft{}periodic\sphinxquotedblright{} is used, the pad function is used with the mode \sphinxquotedblleft{}wrap\sphinxquotedblright{} leading to periodic fields. If not, the mode \sphinxquotedblleft{}edge\sphinxquotedblright{} is used, repeating the first and last node. It is very easy to implement Dirichlet condition with the following function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{itertools} \PYG{k+kn}{as} \PYG{n+nn}{it}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k+kn}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{schemes}

\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Agg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} noqa}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{pl}  \PYG{c+c1}{\PYGZsh{} isort:skip}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}whitegrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{03}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{001}\PYG{p}{,} \PYG{n}{dx}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{5E\PYGZhy{}1}
\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mf}{2.5}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{RODASPR}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{dirichlet\PYGZus{}condition}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{it}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o}{=} \PYG{n}{scheme}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{hook}\PYG{o}{=}\PYG{n}{dirichlet\PYGZus{}condition}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iteration: \PYGZob{}i\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
          \PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{tmax}\PYG{p}{:}
        \PYG{k}{break}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{legend} \PYG{o}{=} \PYG{n}{pl}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{overview_model_hook}.pdf}


\section{Simulation class: higher level control}
\label{\detokenize{overview:simulation-class-higher-level-control}}
The loop snippet

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{RODASPR}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{it}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o}{=} \PYG{n}{scheme}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iteration: }\PYG{l+s+si}{\PYGZob{}i\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{tmax}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{break}
\end{sphinxVerbatim}

is not handy.

To avoid it, we provide a higher level control class, the Simulation. It is an iterable and we can write the snippet as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,}
\PYG{g+gp}{... }                   \PYG{n}{scheme}\PYG{o}{=}\PYG{n}{schemes}\PYG{o}{.}\PYG{n}{RODASPR}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{n}{tmax}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simul}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iteration: }\PYG{l+s+si}{\PYGZob{}i\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

and we write the previous advection-diffusion example as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k+kn}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}

\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Agg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} noqa}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{pl}  \PYG{c+c1}{\PYGZsh{} isort:skip}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}whitegrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{03}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mo}{001}\PYG{p}{,} \PYG{n}{dx}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{5E\PYGZhy{}1}
\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mf}{2.5}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{dirichlet\PYGZus{}condition}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}


\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,}
                   \PYG{n}{hook}\PYG{o}{=}\PYG{n}{dirichlet\PYGZus{}condition}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{n}{tmax}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simul}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iteration: \PYGZob{}i\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
          \PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t: \PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{legend} \PYG{o}{=} \PYG{n}{pl}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{best}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{overview_simulation_hook}.pdf}


\subsection{Displays}
\label{\detokenize{overview:displays}}
Hooks are called every internal time step and allow granular modification of the parameters or fields.

Displays have to be called by the user and can not modify the fields or parameters, but can display or save data during the simulation.

Like the hooks, they are basically callable or coroutine taking fields or the other to output post-processed data. The built-ins displays are detailed on the section of the same name.


\chapter{Temporal schemes}
\label{\detokenize{schemes:temporal-schemes}}\label{\detokenize{schemes:superlu}}\label{\detokenize{schemes::doc}}
This section will present the structure of a typical temporal scheme and how to write your own schemes.


\section{List of available schemes}
\label{\detokenize{schemes:list-of-available-schemes}}

\subsection{schemes.Theta}
\label{\detokenize{schemes:schemes-theta}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{Theta}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\end{sphinxVerbatim}

This scheme represent a combinaison of the forward and the backward Euler. With theta = 0, it will be a full forward Euler, with theta = 1, a full backward Euler and with theta = 0.5, we will have a Crank-Nicolson method.


\subsection{schemes.scipy\_ode}
\label{\detokenize{schemes:schemes-scipy-ode}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scheme} \PYG{o}{=} \PYG{n}{schemes}\PYG{o}{.}\PYG{n}{scipy\PYGZus{}ode}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{integrator}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwd\PYGZus{}integrator}\PYG{p}{)}
\end{sphinxVerbatim}

This scheme is a wrapper around the scipy.integrate.ode.

The integrator is one of these provided by scipy and kwd\_integrator allow us to pass extra parameters to the solver.

Beware that this scheme do not use the sparse jacobian, leading to higher memory usage and possibly bad performance for large systems. However, the time-stepping provided is good and is a good choice for validate a new scheme.


\subsection{schemes.ROW\_general}
\label{\detokenize{schemes:schemes-row-general}}
\sphinxurl{http://www.digibib.tu-bs.de/?docid=00055262}
Rang, Joachim: Improved traditional Rosenbrock-Wanner methods for stiff odes and daes / Joachim Rang.

This is the parent of all the Rosenbrock-Wanner scheme provided: they follow the same algorithm with different number of internal steps and different coefficients. A time-stepping is available and these schemes are suitable for stiff equations.
\begin{itemize}
\item {} 
ROS2 (2 steps, only fixed time-step)

\item {} 
ROS3PRw (3 steps)

\item {} 
ROS3PRL (4 steps)

\item {} 
RODASPR (6 steps)

\end{itemize}


\section{Internal structure of a scheme}
\label{\detokenize{schemes:internal-structure-of-a-scheme}}
A temporal scheme can be written as any callable object initiated with a model attribute (which will give access to the system of differential equation to solve and its jacobian with model.F and model.J).

The \sphinxtitleref{\_\_call\_\_} method have the following signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o}{=} \PYG{n}{scheme}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{,}
                   \PYG{n}{hook}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{:} \PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

It will take as input the actual fields container, the time and the time-step wanted for this step. As keyword argument it will take a hook, a callable with the fields, time and parameters as input and fields and parameters as output. This function give us the ability to make on-the-fly modification of the fields (for boundary condition), or parameters (allowing time and space conditional parameters).

This hook has to be called before calling the model routines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{BackwardEuler}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{model}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}call\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{,}
                 \PYG{n}{hook}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{:} \PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fields} \PYG{o}{=} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars} \PYG{o}{=} \PYG{n}{hook}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}
        \PYG{n}{F} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{F}\PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}
        \PYG{n}{J} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{J}\PYG{p}{(}\PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} access the flatten copy of the dependant variables}
        \PYG{n}{U} \PYG{o}{=} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{uflat}
        \PYG{n}{B} \PYG{o}{=} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{F} \PYG{o}{\PYGZhy{}}  \PYG{n}{J} \PYG{o}{@} \PYG{n}{U}\PYG{p}{)} \PYG{o}{+} \PYG{n}{U}
        \PYG{n}{J} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sps}\PYG{o}{.}\PYG{n}{identity}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,}
                          \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{csc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{dt} \PYG{o}{*} \PYG{n}{J}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} used in order to update the value of the dependant variables}
        \PYG{n}{fields} \PYG{o}{=} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{fill}\PYG{p}{(}\PYG{n}{solver}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} We return the hooked fields, be sure that the bdc are taken into account.}
        \PYG{n}{fields}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{hook}\PYG{p}{(}\PYG{n}{t} \PYG{o}{+} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{t} \PYG{o}{+} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{fields}
\end{sphinxVerbatim}


\chapter{Displays}
\label{\detokenize{cookbook/displays:displays}}\label{\detokenize{cookbook/displays::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\section{displays objects}
\label{\detokenize{cookbook/displays:displays-objects}}
The displays are objects with a \sphinxcode{\_\_call\_\_} method. They can be add to
a simulation with the \sphinxcode{Simulation.add\_display} method, or just called
at every step during the simulation.

A \sphinxquotedblleft{}null\sphinxquotedblright{} display will be written as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{NullDisplay}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{simul}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}call\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}
\end{sphinxVerbatim}

this display will not change the simulation behavior.

A very simple display could be a one printing the time after each step

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{TimeDisplay}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{simul}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}call\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{simulation time: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

And can be used with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                   \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{)}

\PYG{n}{display} \PYG{o}{=} \PYG{n}{TimeDisplay}\PYG{p}{(}\PYG{n}{simul}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o+ow}{in} \PYG{n}{simul}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{10}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{20}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{30}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{40}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                   \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{)}

\PYG{n}{simul}\PYG{o}{.}\PYG{n}{add\PYGZus{}display}\PYG{p}{(}\PYG{n}{TimeDisplay}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o+ow}{in} \PYG{n}{simul}\PYG{p}{:}
    \PYG{k}{pass}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{10}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{20}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{30}
\PYG{n}{simulation} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mi}{40}
\end{sphinxVerbatim}


\section{built-in displays}
\label{\detokenize{cookbook/displays:built-in-displays}}

\subsection{bokeh displays}
\label{\detokenize{cookbook/displays:bokeh-displays}}

\subsubsection{field display}
\label{\detokenize{cookbook/displays:field-display}}
This display allow a real-time plot in a jupyter notebook. The \sphinxcode{keys}
argument allow to choose which fields will be plotted. All fields are
plotted on specific figure, and the \sphinxcode{line\_kwargs} and \sphinxcode{fig\_kwargs}
allow us to customize each bokeh figure and line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{displays}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dxxV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{o}{=}\PYG{n}{V}\PYG{p}{)}
\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                   \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{)}

\PYG{n}{display} \PYG{o}{=} \PYG{n}{displays}\PYG{o}{.}\PYG{n}{bokeh\PYGZus{}fields\PYGZus{}update}\PYG{p}{(}\PYG{n}{simul}\PYG{p}{,} \PYG{n}{keys}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
                                       \PYG{n}{fig\PYGZus{}kwargs}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
                                                   \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{width}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{600}\PYG{p}{,}
                                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{height}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{200}\PYG{p}{,}
                                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x\PYGZus{}range}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}
                                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y\PYGZus{}range}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                                   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
                                                   \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{width}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{600}\PYG{p}{,}
                                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{height}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{200}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                       \PYG{n}{line\PYGZus{}kwargs}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
                                                    \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{color}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{darkred}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                                                     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{line\PYGZus{}alpha}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{.}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o+ow}{in} \PYG{n}{simul}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{probe display}
\label{\detokenize{cookbook/displays:probe-display}}
The same way, this display give the possibility to plot in real time a
probe, a 0D post process data.

The probes are given as a dictionary with the name of the probe as key
and a callable as value. This callable take \sphinxcode{(t, fields)} as argument
and return a scalar. Like the fields display, it is possible to
customize the bokeh figure and line via two dictionnary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{displays}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{simul} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                   \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{std\PYGZus{}probe}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{display} \PYG{o}{=} \PYG{n}{displays}\PYG{o}{.}\PYG{n}{bokeh\PYGZus{}probes\PYGZus{}update}\PYG{p}{(}\PYG{n}{simul}\PYG{p}{,}
                                       \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{std}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{std\PYGZus{}probe}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                       \PYG{n}{fig\PYGZus{}kwargs}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{std}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{width}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{600}\PYG{p}{,}
                                                           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{height}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{200}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o+ow}{in} \PYG{n}{simul}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Cookbook}
\label{\detokenize{cookbook:cookbook}}\label{\detokenize{cookbook::doc}}
All the notebooks are available via \sphinxhref{http://nbviewer.jupyter.org/github/locie/triflow/tree/master/examples/notebooks/}{nbviewer}


\section{The convection diffusion equation}
\label{\detokenize{cookbook/advection_diffusion:the-convection-diffusion-equation}}\label{\detokenize{cookbook/advection_diffusion::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools} \PYG{k}{as} \PYG{n+nn}{ft}
\PYG{k+kn}{import} \PYG{n+nn}{multiprocessing} \PYG{k}{as} \PYG{n+nn}{mp}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k}{import} \PYG{n}{gaussian}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k}{as} \PYG{n+nn}{pl}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{schemes}\PYG{p}{,} \PYG{n}{displays}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

The convection\textendash{}diffusion equation is a combination of the diffusion and
convection (advection) equations, and describes physical phenomena where
particles, energy, or other physical quantities are transferred inside a
physical system due to two processes: diffusion and convection.
(\sphinxhref{https://en.wikipedia.org/wiki/Convection\%E2\%80\%93diffusion\_equation}{Wikipedia})

The equation reads
\begin{equation*}
\begin{split}\partial_{t}U = k \partial_{xx} U - c \partial_{x} U\end{split}
\end{equation*}
with
\begin{itemize}
\item {} 
\(U\) the physical quantities transferred (it could be a chemical
species concentration, the temperature of a fluid...)

\item {} 
\(k\) a diffusion convection

\item {} 
\(c\) a velocity, which will be constant in our example.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

We discretize our spatial domain. \sphinxcode{retstep=True} ask to return the
spatial step. We want periodic condition, so \sphinxcode{endpoint=True} exclude
the final node (which will be redondant with the first node, \(x=0\)
and \(x=100\) are merged)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize with three gaussian pulses for the initial condition

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+}
     \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}}
     \PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{advection_diffusion_7_0}.png}

We precise our parameters. The default scheme provide an automatic
time\_stepping. We set the periodic flag to True.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{k}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                        \PYG{n}{dt}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\end{sphinxVerbatim}

We iterate on the simulation until the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simulation}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{darkred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{:} \PYG{l+m+mf}{29.9}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{advection_diffusion_13_1}.png}


\section{The burger equation}
\label{\detokenize{cookbook/burger_equation:the-burger-equation}}\label{\detokenize{cookbook/burger_equation::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools} \PYG{k}{as} \PYG{n+nn}{ft}
\PYG{k+kn}{import} \PYG{n+nn}{multiprocessing} \PYG{k}{as} \PYG{n+nn}{mp}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k}{import} \PYG{n}{gaussian}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k}{as} \PYG{n+nn}{pl}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{schemes}\PYG{p}{,} \PYG{n}{displays}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

Burgers' equation is a fundamental partial differential equation
occurring in various areas of applied mathematics, such as fluid
mechanics, nonlinear acoustics, gas dynamics, traffic flow. It is named
for Johannes Martinus Burgers (1895\textendash{}1981).
(\sphinxhref{https://en.wikipedia.org/wiki/Convection\%E2\%80\%93diffusion\_equation}{Wikipedia})

The viscous Burger equation in 1D reads:
\begin{equation*}
\begin{split}\partial_{t}U = k \partial_{xx} U - U \partial_{x} U\end{split}
\end{equation*}
with
\begin{itemize}
\item {} 
\(U\) the velocity

\item {} 
\(k\) a diffusion convection

\end{itemize}

The expected behaviour is a wave moving forward with a growing shock.
This shock leads to discontinuity smoothed by the diffusion term.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} U * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

We discretize our spatial domain. \sphinxcode{retstep=True} ask to return the
spatial step. We want periodic condition, so \sphinxcode{endpoint=True} exclude
the final node (which will be redondant with the first node, \(x=0\)
and \(x=100\) are merged)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize with a simple gaussian pulse initial condition.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U} \PYG{o}{=} \PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{burger_equation_7_0}.png}

We precise our parameters. The default scheme provide an automatic
time\_stepping. We set the periodic flag to True

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                        \PYG{n}{dt}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}4}\PYG{p}{)}
\end{sphinxVerbatim}

We iterate on the simulation until the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simulation}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{darkred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{:} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{burger_equation_13_1}.png}


\section{The burger - kdv equation}
\label{\detokenize{cookbook/burger_kdv_equation:the-burger-kdv-equation}}\label{\detokenize{cookbook/burger_kdv_equation::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools} \PYG{k}{as} \PYG{n+nn}{ft}
\PYG{k+kn}{import} \PYG{n+nn}{multiprocessing} \PYG{k}{as} \PYG{n+nn}{mp}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k}{import} \PYG{n}{Image}\PYG{p}{,} \PYG{n}{display}\PYG{p}{,} \PYG{n}{HTML}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k}{import} \PYG{n}{gaussian}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k}{as} \PYG{n+nn}{pl}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{schemes}\PYG{p}{,} \PYG{n}{displays}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seaborn\PYGZhy{}white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

This notebook is an attempt to reproduce the \sphinxhref{http://nbviewer.jupyter.org/urls/bitbucket.org/dedalus-project/dedalus/raw/tip/docs/notebooks/dedalus\_tutorial\_problems\_solvers.ipynb}{Dedalus Project
tutorial}.
The equation to solve is
\begin{equation*}
\begin{split}\partial_{t}\,U + U \partial_{x}\,U = a\partial_{xx}\,U + b\partial_{xxx}\,U\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}U * dxU + a * dxxU + b * dxxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

We discretize our spatial domain. \sphinxcode{retstep=True} ask to return the
spatial step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize with the same initial condition as in the Dedalus tutorial

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cosh}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cosh}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{n}\PYG{p}{)}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{burger_kdv_equation_7_0}.png}

We precise our parameters. The default scheme provide an automatic
time\_stepping.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mf}{2E\PYGZhy{}4}\PYG{p}{,} \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}4}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                        \PYG{n}{dt}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{05}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}1}\PYG{p}{)}
\end{sphinxVerbatim}

We iterate on the simulation until the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{full\PYGZus{}data} \PYG{o}{=} \PYG{n}{displays}\PYG{o}{.}\PYG{n}{window\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simulation}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{darkred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{full\PYGZus{}data}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{:} \PYG{l+m+mf}{9.95}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{burger_kdv_equation_13_1}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{HTML}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}h3\PYGZgt{}Triflow result\PYGZlt{}/h3\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{pcolormesh}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fields}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fields}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{viridis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{HTML}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}h3\PYGZgt{}Dedalus result\PYGZlt{}/h3\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Image}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dedalus\PYGZhy{}kdv.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{burger_kdv_equation_14_1}.png}

\noindent\sphinxincludegraphics{{burger_kdv_equation_14_3}.png}


\section{Wave equation}
\label{\detokenize{cookbook/wave_equation:wave-equation}}\label{\detokenize{cookbook/wave_equation::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools} \PYG{k}{as} \PYG{n+nn}{ft}
\PYG{k+kn}{import} \PYG{n+nn}{multiprocessing} \PYG{k}{as} \PYG{n+nn}{mp}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k}{import} \PYG{n}{gaussian}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k}{as} \PYG{n+nn}{pl}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{schemes}\PYG{p}{,} \PYG{n}{displays}

\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

We initialize the model with the wave equation written as a system of
first order differential equations.
\begin{equation*}
\begin{split}\partial_{t,\,t}u = c^2 \partial_{x,\,x} u\end{split}
\end{equation*}
which lead to
\begin{align}
    \partial_{t}u &= v\\
    \partial_{t}v &= c^2 \partial_{x,\,x} u
\end{align}
with \(c\) the velocity of the wave.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c**2 * dxxu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

We discretize our spatial domain. \sphinxcode{retstep=True} ask to return the
spatial step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize with three gaussian pulses for the initial condition

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{u} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+}
     \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}}
     \PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{1.5}\PYG{p}{)}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}

\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n}{v}\PYG{p}{)}

\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{wave_equation_7_0}.png}

We precise our parameters. The default scheme provide an automatic
time\_stepping. We want dirichlet boundary condition, so we set the
periodic flag to False.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

This function will set the boundary condition. We will have a fixed rope
at each edge.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dirichlet}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} fields.u[:] = np.sin(t * 2 * np.pi * 2) * gaussian(x.size, 10) \PYGZhy{} fields.u[:]}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{fields}\PYG{o}{.}\PYG{n}{v}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{pars}
\end{sphinxVerbatim}

We initialize the simulation, and we set a bokeh display in order to
have real-time plotting.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                        \PYG{n}{dt}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{,}
                        \PYG{n}{hook}\PYG{o}{=}\PYG{n}{dirichlet}\PYG{p}{)}
\end{sphinxVerbatim}

We iterate on the simulation until the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simulation}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{darkred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{u} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{:} \PYG{l+m+mi}{15}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{wave_equation_15_1}.png}


\section{Coupled burger's-like equations}
\label{\detokenize{cookbook/so_wavy:coupled-burger-s-like-equations}}\label{\detokenize{cookbook/so_wavy::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools} \PYG{k}{as} \PYG{n+nn}{ft}
\PYG{k+kn}{import} \PYG{n+nn}{multiprocessing} \PYG{k}{as} \PYG{n+nn}{mp}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k}{import} \PYG{n}{gaussian}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k}{as} \PYG{n+nn}{pl}

\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}\PYG{p}{,} \PYG{n}{Simulation}\PYG{p}{,} \PYG{n}{schemes}\PYG{p}{,} \PYG{n}{displays}

\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

We initialize the model with a coupled burger-like system of equations
\begin{align}
    \partial_{t}U &= k \partial_{xx} U - c U \partial_{x} V \\
    \partial_{t}V &= k \partial_{xx} U - c V \partial_{x} U
\end{align}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU \PYGZhy{} c * U * dxV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxV \PYGZhy{} c * V * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

We discretize our spatial domain. \sphinxcode{retstep=True} ask to return the
spatial step. We want periodic condition, so \sphinxcode{endpoint=True} exclude
the final node (which will be redondant with the first node, \(x=0\)
and \(x=100\) are merged)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{n}{retstep}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize with cosine and sine function for \(U\) and \(V\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{o}{=}\PYG{n}{V}\PYG{p}{)}
\end{sphinxVerbatim}

We precise our parameters. The default scheme provide an automatic
time\_stepping. We set the periodic flag to True.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{periodic}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

We initialize the simulation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,}
                        \PYG{n}{dt}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}2}\PYG{p}{)}
\end{sphinxVerbatim}

We iterate on the simulation until the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{simulation}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{darkred}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{i}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{U} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{V} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{fields}\PYG{o}{.}\PYG{n}{V}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
                        \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lightsteelblue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{)}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{V} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t: }\PYG{l+s+si}{\PYGZob{}t:g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pl}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{p}{:} \PYG{l+m+mf}{3.9}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{so_wavy_13_1}.png}


\chapter{Contribution guide}
\label{\detokenize{contribute:contribution-guide}}\label{\detokenize{contribute:nbviewer}}\label{\detokenize{contribute::doc}}

\section{Minor Contribution}
\label{\detokenize{contribute:minor-contribution}}
Testing, issue reporting, new feature request are welcome (via the \sphinxhref{https://github.com/locie/triflow}{github repository}).


\section{Make}
\label{\detokenize{contribute:make}}\begin{itemize}
\item {} 
a makefile is provided, and
\begin{itemize}
\item {} 
\sphinxtitleref{make env} install the requirement for triflow and triflow itself

\item {} 
\sphinxtitleref{make init} install the developpement requirement

\item {} 
\sphinxtitleref{make clean} remove all the build artefacts

\item {} 
\sphinxtitleref{make test} launch the test (doctest + pytest, with coverage)

\item {} 
\sphinxtitleref{make doc} build the documentation

\end{itemize}

\end{itemize}


\section{Testing}
\label{\detokenize{contribute:testing}}\begin{itemize}
\item {} 
the master branch require 100\% coverage (or good reason to ignore part of the code)

\item {} 
the doctest needs to pass the test too, making sure the examples are consistants

\item {} 
if the API change, the test will move to a file \sphinxtitleref{deprecated.py} in tests folder, a warning will be raised and the deprecated API will be removed at the next major version (after the 1.0), or after 2 minor version (before the 1.0)

\end{itemize}


\section{Style guide}
\label{\detokenize{contribute:style-guide}}
The code is pep8 complient, and the tests is running with pytest-pep8 and pylama. the \#noqa flag is allowed, but the reason has to be written.

Docstring for public API and main methods are mandatory.


\section{Roadmap}
\label{\detokenize{contribute:roadmap}}\begin{itemize}
\item {} 
go to continous integration via travis (or other?)

\item {} 
include t as symbolic variable to allow time dependent functions (non-autonomous dynamical systems)

\item {} 
test different model against analytical solutions or reference library

\item {} 
benchmark the solver

\item {} 
drop the 1D limitation with
\begin{itemize}
\item {} 
2D

\item {} 
ND with arbitrary independant variable

\end{itemize}

\item {} 
implement various finite different scheme (as upwind), or better, an easy way to add new spatial scheme

\item {} 
give the ability to use mixed scheme

\end{itemize}


\chapter{triflow}
\label{\detokenize{modules:github-repository}}\label{\detokenize{modules::doc}}\label{\detokenize{modules:triflow}}

\section{triflow package}
\label{\detokenize{triflow:triflow-package}}\label{\detokenize{triflow::doc}}

\subsection{Subpackages}
\label{\detokenize{triflow:subpackages}}

\subsubsection{triflow.core package}
\label{\detokenize{triflow.core:triflow-core-package}}\label{\detokenize{triflow.core::doc}}

\paragraph{Submodules}
\label{\detokenize{triflow.core:submodules}}

\paragraph{triflow.core.fields module}
\label{\detokenize{triflow.core:triflow-core-fields-module}}\label{\detokenize{triflow.core:module-triflow.core.fields}}\index{triflow.core.fields (module)}\index{BaseFields (class in triflow.core.fields)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.fields.}\sphinxbfcode{BaseFields}}{\emph{**inputs}}{}
Bases: \sphinxcode{object}

Specialized container which expose the data as a structured numpy array,
give access to the dependants variables and the herlpers function as
attributes (as a numpy rec array) and is able to give access to a flat
view of the dependent variables only (which is needed by the ode
solvers for all the linear algebra manipulation).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{**inputs} (\sphinxstyleliteralemphasis{numpy.array}) -- named argument providing x, the dependent variables and the helper functions. All of these are mendatory and a KeyError will be raised if a data is missing.

\end{description}\end{quote}
\index{array (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.array}}\pysigline{\sphinxbfcode{array}}
\sphinxstyleemphasis{numpy.array} -- vanilla numpy array containing the data

\end{fulllineitems}

\index{size (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.size}}\pysigline{\sphinxbfcode{size}}
\sphinxstyleemphasis{int} -- Number of discretisation nodes

\end{fulllineitems}

\index{copy() (triflow.core.fields.BaseFields method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.copy}}\pysiglinewithargsret{\sphinxbfcode{copy}}{}{}
\end{fulllineitems}

\index{factory() (triflow.core.fields.BaseFields static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.factory}}\pysiglinewithargsret{\sphinxstrong{static }\sphinxbfcode{factory}}{\emph{dependent\_variables}, \emph{helper\_functions}}{}
Fields factory generating specialized container build around a
triflow Model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dependent\_variables} (\sphinxstyleliteralemphasis{iterable of str}) -- name of the dependent variables

\item {} 
\sphinxstyleliteralstrong{helper\_functions} (\sphinxstyleliteralemphasis{iterable of str}) -- name of the helper functions

\end{itemize}

\item[{Returns}] \leavevmode
Specialized container which expose the data as a structured numpy array

\item[{Return type}] \leavevmode
triflow.BaseFields

\end{description}\end{quote}

\end{fulllineitems}

\index{fill() (triflow.core.fields.BaseFields method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.fill}}\pysiglinewithargsret{\sphinxbfcode{fill}}{\emph{flat\_array}}{}
take a flat numpy array and update inplace the dependent
variables of the container
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{flat\_array} (\sphinxstyleliteralemphasis{numpy.ndarray}) -- flat array which will be put in the dependant variable flat array.

\end{description}\end{quote}

\end{fulllineitems}

\index{flat (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.flat}}\pysigline{\sphinxbfcode{flat}}
\sphinxstyleemphasis{numpy.ndarray.view} -- flat view of the main numpy array

\end{fulllineitems}

\index{structured (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.structured}}\pysigline{\sphinxbfcode{structured}}
\sphinxstyleemphasis{numpy.ndarray.view} -- structured view of the main numpy array

\end{fulllineitems}

\index{uarray (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.uarray}}\pysigline{\sphinxbfcode{uarray}}
\sphinxstyleemphasis{numpy.ndarray.view} -- view of the dependent variables of the main numpy array

\end{fulllineitems}

\index{uflat (triflow.core.fields.BaseFields attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.fields.BaseFields.uflat}}\pysigline{\sphinxbfcode{uflat}}
return a flatten \sphinxstylestrong{copy} of the main numpy array with only the
dependant variables.

Be carefull, modification of these data will not be reflected on
the main array!

\end{fulllineitems}


\end{fulllineitems}



\paragraph{triflow.core.model module}
\label{\detokenize{triflow.core:triflow-core-model-module}}\label{\detokenize{triflow.core:module-triflow.core.model}}\index{triflow.core.model (module)}\index{Model (class in triflow.core.model)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.model.}\sphinxbfcode{Model}}{\emph{differential\_equations}, \emph{dependent\_variables}, \emph{parameters=None}, \emph{help\_functions=None}}{}
Bases: \sphinxcode{object}

Contain finite difference approximation and routine of the dynamical system

Take a mathematical form as input, use Sympy to transform it as a symbolic
expression, perform the finite difference approximation and expose theano
optimized routine for both the right hand side of the dynamical system and
Jacobian matrix approximation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{differential\_equations} (\sphinxstyleliteralemphasis{iterable of str}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{str}) -- the right hand sides of the partial differential equations written as \(\frac{\partial U}{\partial t} = F(U)\), where the spatial derivative can be written as \sphinxtitleref{dxxU} or \sphinxtitleref{dx(U, 2)} or with the sympy notation \sphinxtitleref{Derivative(U, x, x)}

\item {} 
\sphinxstyleliteralstrong{dependent\_variables} (\sphinxstyleliteralemphasis{iterable of str}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{str}) -- the dependent variables with the same order as the temporal derivative of the previous arg.

\item {} 
\sphinxstyleliteralstrong{parameters} (\sphinxstyleliteralemphasis{iterable of str}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{str}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- list of the parameters. Can be feed with a scalar of an array with the same size

\item {} 
\sphinxstyleliteralstrong{help\_functions} (\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- All fields which have not to be solved with the time derivative but will be derived in space.

\end{itemize}

\end{description}\end{quote}
\index{F (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.F}}\pysigline{\sphinxbfcode{F}}
\sphinxstyleemphasis{triflow.F\_Routine} -- Callable used to compute the right hand side of the dynamical system

\end{fulllineitems}

\index{F\_array (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.F_array}}\pysigline{\sphinxbfcode{F\_array}}
\sphinxstyleemphasis{numpy.ndarray of sympy.Expr} -- Symbolic expressions of the right hand side of the dynamical system

\end{fulllineitems}

\index{J (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.J}}\pysigline{\sphinxbfcode{J}}
\sphinxstyleemphasis{triflow.J\_Routine} -- Callable used to compute the Jacobian of the dynamical system

\end{fulllineitems}

\index{J\_array (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.J_array}}\pysigline{\sphinxbfcode{J\_array}}
\sphinxstyleemphasis{numpy.ndarray of sympy.Expr} -- Symbolic expressions of the Jacobian side of the dynamical system

\end{fulllineitems}

\index{Properties (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.Properties}}\pysigline{\sphinxbfcode{Properties}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{-{-}-{-}-{-}-{-}-{-}}}
\end{fulllineitems}

\index{fields\_template (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.fields_template}}\pysigline{\sphinxbfcode{fields\_template}}
\sphinxstyleemphasis{Model specific Fields container used to store and access to the model variables in an efficient way.}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{save:~Save~a~binary~of~the~Model~with~pre-optimized~F~and~J~routines}}
\end{fulllineitems}

\paragraph{Examples}

A simple diffusion equation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k * dxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

A coupled system of convection-diffusion equation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow} \PYG{k}{import} \PYG{n}{Model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{Model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k1 * dxxU \PYGZhy{} c1 * dxV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k2 * dxxV \PYGZhy{} c2 * dxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\index{fields\_template (triflow.core.model.Model attribute)}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{fields\_template}}
\end{fulllineitems}

\index{load() (triflow.core.model.Model static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.load}}\pysiglinewithargsret{\sphinxstrong{static }\sphinxbfcode{load}}{\emph{filename}}{}
load a pre-compiled triflow model. The internal of theano allow a
caching of the model. Will be slow if it is the first time the model is
loaded on the system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- path of the pre-compiled model

\item[{Returns}] \leavevmode
triflow pre-compiled model

\item[{Return type}] \leavevmode
triflow.core.Model

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (triflow.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.model.Model.save}}\pysiglinewithargsret{\sphinxbfcode{save}}{\emph{filename}}{}
Save the model as a binary pickle file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{str}) -- name of the file where the model is saved.

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{triflow.core.routines module}
\label{\detokenize{triflow.core:triflow-core-routines-module}}\label{\detokenize{triflow.core:module-triflow.core.routines}}\index{triflow.core.routines (module)}\index{F\_Routine (class in triflow.core.routines)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.routines.F_Routine}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.routines.}\sphinxbfcode{F\_Routine}}{\emph{matrix}, \emph{args}, \emph{pars}, \emph{ufunc}, \emph{reduced=False}}{}
Bases: {\hyperref[\detokenize{triflow.core:triflow.core.routines.ModelRoutine}]{\sphinxcrossref{\sphinxcode{triflow.core.routines.ModelRoutine}}}}

Compute the right hand side of the dynamical system
\(\frac{\partial U}{\partial t} = F(U)\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- triflow fields container generated by a triflow.Model containing the actual state of the dependent variables and helper functions.

\item {} 
\sphinxstyleliteralstrong{pars} (\sphinxstyleliteralemphasis{dict}) -- dictionnary with the different physical parameters of the model and the `periodic' key.

\end{itemize}

\item[{Returns}] \leavevmode
flat array containing the right hand side of the dynamical system.

\item[{Return type}] \leavevmode
numpy.ndarray

\end{description}\end{quote}
\index{diff\_approx() (triflow.core.routines.F\_Routine method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.routines.F_Routine.diff_approx}}\pysiglinewithargsret{\sphinxbfcode{diff\_approx}}{\emph{fields}, \emph{pars}, \emph{eps=1e-08}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{J\_Routine (class in triflow.core.routines)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.routines.J_Routine}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.routines.}\sphinxbfcode{J\_Routine}}{\emph{matrix}, \emph{args}, \emph{pars}, \emph{ufunc}, \emph{reduced=False}}{}
Bases: {\hyperref[\detokenize{triflow.core:triflow.core.routines.ModelRoutine}]{\sphinxcrossref{\sphinxcode{triflow.core.routines.ModelRoutine}}}}

Compute the right hand side of the dynamical system
\(\frac{\partial U}{\partial t} = F(U)\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- triflow fields container generated by a triflow.Model containing the actual state of the dependent variables and helper functions.

\item {} 
\sphinxstyleliteralstrong{pars} (\sphinxstyleliteralemphasis{dict}) -- dictionnary with the different physical parameters of the model and the `periodic' key.

\item {} 
\sphinxstyleliteralstrong{sparse} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default True}) -- whether should the matrix returned as dense or sparse form.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{scipy.sparse.CSC or numpy.ndarray}

\item[{Return type}] \leavevmode
sparse or dense form (depending of the \sphinxtitleref{sparse} argument) of the Jacobian approximation of the dynamical system right hand side.

\end{description}\end{quote}

\end{fulllineitems}

\index{ModelRoutine (class in triflow.core.routines)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.routines.ModelRoutine}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.routines.}\sphinxbfcode{ModelRoutine}}{\emph{matrix}, \emph{args}, \emph{pars}, \emph{ufunc}, \emph{reduced=False}}{}
Bases: \sphinxcode{object}

\end{fulllineitems}



\paragraph{triflow.core.simulation module}
\label{\detokenize{triflow.core:module-triflow.core.simulation}}\label{\detokenize{triflow.core:triflow-core-simulation-module}}\index{triflow.core.simulation (module)}\index{Simulation (class in triflow.core.simulation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.core.simulation.}\sphinxbfcode{Simulation}}{\emph{model}, \emph{t}, \emph{fields}, \emph{physical\_parameters}, \emph{dt}, \emph{id=None}, \emph{hook=\textless{}function Simulation.\textless{}lambda\textgreater{}\textgreater{}}, \emph{scheme=\textless{}class `triflow.plugins.schemes.RODASPR'\textgreater{}}, \emph{tmax=None}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

High level container used to run simulation build on triflow Model.
This object is an iterable which will yield every time step until the parameters `tmax' is reached if provided.
By default, the solver use a 6th order ROW solver, an implicit method with integrated time-stepping.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- Contain finite difference approximation and routine of the dynamical system

\item {} 
\sphinxstyleliteralstrong{t} (\sphinxstyleliteralemphasis{float}) -- initial time

\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- triflow container filled with initial conditions

\item {} 
\sphinxstyleliteralstrong{physical\_parameters} (\sphinxstyleliteralemphasis{dict}) -- physical parameters of the simulation

\item {} 
\sphinxstyleliteralstrong{id} (\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- name of the simulation. A 2 word slug will be generated if not provided.

\item {} 
\sphinxstyleliteralstrong{hook} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- any callable taking the actual time, fields and parameters and return modified fields and parameters. Will be called every internal time step and can be used to include time dependent or conditionnal parameters, boundary conditions...

\item {} 
\sphinxstyleliteralstrong{scheme} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default triflow.schemes.RODASPR}) -- an callable object which take the simulation state and return the next step. Its signature is scheme.\_\_call\_\_(fields, t, dt, pars, hook) and it should return the next time and the updated fields. It take the model and extra positional and named arguments.

\item {} 
\sphinxstyleliteralstrong{**kwargs} (\sphinxstyleliteralemphasis{*args}\sphinxstyleliteralemphasis{,}\sphinxstyleliteralemphasis{}) -- 
extra arguments passed to the scheme.


\item {} 
\sphinxstyleliteralstrong{**kwargs} -- 
extra arguments passed to the scheme.


\end{itemize}

\end{description}\end{quote}
\index{dt (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.dt}}\pysigline{\sphinxbfcode{dt}}
\sphinxstyleemphasis{float} -- output time step

\end{fulllineitems}

\index{fields (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.fields}}\pysigline{\sphinxbfcode{fields}}
\sphinxstyleemphasis{triflow.Fields} -- triflow container filled with actual data

\end{fulllineitems}

\index{i (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.i}}\pysigline{\sphinxbfcode{i}}
\sphinxstyleemphasis{int} -- actual iteration

\end{fulllineitems}

\index{id (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.id}}\pysigline{\sphinxbfcode{id}}
\sphinxstyleemphasis{str} -- name of the simulation

\end{fulllineitems}

\index{model (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.model}}\pysigline{\sphinxbfcode{model}}
\sphinxstyleemphasis{triflow.Model} -- triflow Model used in the simulation

\end{fulllineitems}

\index{physical\_parameters (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.physical_parameters}}\pysigline{\sphinxbfcode{physical\_parameters}}
\sphinxstyleemphasis{dict} -- physical parameters of the simulation

\end{fulllineitems}

\index{status (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.status}}\pysigline{\sphinxbfcode{status}}
\sphinxstyleemphasis{str} -- status of the simulation, one of the following one: (`created', `running', `finished', `failed')

\end{fulllineitems}

\index{t (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.t}}\pysigline{\sphinxbfcode{t}}
\sphinxstyleemphasis{float} -- actual time

\end{fulllineitems}

\index{tmax (triflow.core.simulation.Simulation attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.tmax}}\pysigline{\sphinxbfcode{tmax}}
\sphinxstyleemphasis{float or None, default None} -- stopping time of the simulation. Not stopping if set to None.

\end{fulllineitems}

\paragraph{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{triflow}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{triflow}\PYG{o}{.}\PYG{n}{Model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k1 * dxxU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{... }                       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k2 * dxxV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                      \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                      \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{V} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fields} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{fields\PYGZus{}template}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{o}{=}\PYG{n}{V}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pars} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{periodic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k+kc}{True}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simulation} \PYG{o}{=} \PYG{n}{triflow}\PYG{o}{.}\PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fields}\PYG{p}{,}
\PYG{g+gp}{... }                                \PYG{n}{pars}\PYG{p}{,} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{t}\PYG{p}{,} \PYG{n}{fields} \PYG{o+ow}{in} \PYG{n}{simulation}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{pass}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{50}
\end{sphinxVerbatim}
\index{add\_display() (triflow.core.simulation.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.add_display}}\pysiglinewithargsret{\sphinxbfcode{add\_display}}{\emph{display}, \emph{*display\_args}, \emph{**display\_kwargs}}{}
add a display for the simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{display} (\sphinxstyleliteralemphasis{callable}) -- a display as the one available in triflow.displays

\item {} 
\sphinxstyleliteralstrong{*display\_args} -- positional arguments for the display function (other than the simulation itself)

\item {} 
\sphinxstyleliteralstrong{**display\_kwargs} -- named arguments for the display function

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute() (triflow.core.simulation.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.core:triflow.core.simulation.Simulation.compute}}\pysiglinewithargsret{\sphinxbfcode{compute}}{}{}
Generator which yield the actual state of the system every dt.
\begin{quote}\begin{description}
\item[{Yields}] \leavevmode
\sphinxstylestrong{tuple} (\sphinxstyleemphasis{t, fields}) -- Actual time and updated fields container.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{triflow.core:module-triflow.core}}\label{\detokenize{triflow.core:module-contents}}\index{triflow.core (module)}

\subsubsection{triflow.plugins package}
\label{\detokenize{triflow.plugins::doc}}\label{\detokenize{triflow.plugins:triflow-plugins-package}}

\paragraph{Submodules}
\label{\detokenize{triflow.plugins:submodules}}

\paragraph{triflow.plugins.displays module}
\label{\detokenize{triflow.plugins:module-triflow.plugins.displays}}\label{\detokenize{triflow.plugins:triflow-plugins-displays-module}}\index{triflow.plugins.displays (module)}
This module regroups different displays: function and coroutine written
in order to give extra informationto the user during the simulation
(plot, post-processing...)
\index{bokeh\_fields\_update (class in triflow.plugins.displays)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.displays.bokeh_fields_update}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.displays.}\sphinxbfcode{bokeh\_fields\_update}}{\emph{simul}, \emph{keys=None}, \emph{line\_kwargs=\{\}}, \emph{fig\_kwargs=\{\}}, \emph{notebook=True}}{}
Bases: \sphinxcode{object}

Display fields data in a interactive Bokeh plot displayed in
a jupyter notebook.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{keys} (\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- list of the dependant variables to be displayed

\item {} 
\sphinxstyleliteralstrong{line\_kwargs} (\sphinxstyleliteralemphasis{dict of dict}) -- dictionnary with vars as key and a dictionnary of keywords arguments passed to the lines plots

\item {} 
\sphinxstyleliteralstrong{fig\_kwargs} (\sphinxstyleliteralemphasis{dict of dict}) -- dictionnary with vars as key and a dictionnary of keywords arguments passed to the figs plots

\item {} 
\sphinxstyleliteralstrong{init\_notebook} (\sphinxstyleliteralemphasis{True}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- if True, initialize the javascript component needed for bokeh.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{bokeh\_probes\_update (class in triflow.plugins.displays)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.displays.bokeh_probes_update}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.displays.}\sphinxbfcode{bokeh\_probes\_update}}{\emph{simul}, \emph{probes}, \emph{line\_kwargs=\{\}}, \emph{fig\_kwargs=\{\}}, \emph{notebook=True}}{}
Bases: \sphinxcode{object}

Display custom probes in a interactive Bokeh plot displayed in a jupyter notebook.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{probes} (\sphinxstyleliteralemphasis{dictionnary of callable}) -- Dictionnary with \{name: callable\} used to plot the probes. The signature is the same as in the hooks and return the value we want to plot.

\item {} 
\sphinxstyleliteralstrong{line\_kwargs} (\sphinxstyleliteralemphasis{dict of dict}) -- dictionnary with vars as key and a dictionnary of keywords arguments passed to the lines plots

\item {} 
\sphinxstyleliteralstrong{fig\_kwargs} (\sphinxstyleliteralemphasis{dict of dict}) -- dictionnary with vars as key and a dictionnary of keywords arguments passed to the figs plots

\item {} 
\sphinxstyleliteralstrong{init\_notebook} (\sphinxstyleliteralemphasis{True}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- if True, initialize the javascript component needed for bokeh.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{triflow.plugins.schemes module}
\label{\detokenize{triflow.plugins:triflow-plugins-schemes-module}}\label{\detokenize{triflow.plugins:module-triflow.plugins.schemes}}\index{triflow.plugins.schemes (module)}
This module regroups all the implemented temporal schemes.
They are written as callable class which take the model and some control
arguments at the init, and perform a computation step every time they are
called.
\begin{description}
\item[{The following solvers are implemented:}] \leavevmode\begin{itemize}
\item {} 
Backward and Forward Euler, Crank-Nicolson method (with the Theta class)

\item {} 
Some Rosenbrock Wanner schemes (up to the 6th order) with time controler

\item {} 
All the scipy.integrate.ode integrators with the scipy\_ode class.

\end{itemize}

\end{description}
\index{RODASPR (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.RODASPR}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{RODASPR}}{\emph{model}, \emph{tol=0.01}, \emph{time\_stepping=True}, \emph{max\_iter=None}, \emph{dt\_min=None}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general}]{\sphinxcrossref{\sphinxcode{triflow.plugins.schemes.ROW\_general}}}}

6th order Rosenbrock scheme, with time stepping
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1E-2}) -- tolerance factor for the time stepping. The time step will adapt to ensure that the maximum relative error on all fields stay under that value.

\item {} 
\sphinxstyleliteralstrong{time\_stepping} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default True}) -- allow a variable internal time-step to ensure good agreement between computing performance and accuracy.

\item {} 
\sphinxstyleliteralstrong{max\_iter} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- maximum internal iteration allowed

\item {} 
\sphinxstyleliteralstrong{dt\_min} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- minimum internal time step allowed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ROS2 (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.ROS2}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{ROS2}}{\emph{model}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general}]{\sphinxcrossref{\sphinxcode{triflow.plugins.schemes.ROW\_general}}}}

Second order Rosenbrock scheme, without time stepping
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\end{description}\end{quote}

\end{fulllineitems}

\index{ROS3PRL (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.ROS3PRL}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{ROS3PRL}}{\emph{model}, \emph{tol=0.01}, \emph{time\_stepping=True}, \emph{max\_iter=None}, \emph{dt\_min=None}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general}]{\sphinxcrossref{\sphinxcode{triflow.plugins.schemes.ROW\_general}}}}

4th order Rosenbrock scheme, with time stepping
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1E-2}) -- tolerance factor for the time stepping. The time step will adapt to ensure that the maximum relative error on all fields stay under that value.

\item {} 
\sphinxstyleliteralstrong{time\_stepping} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default True}) -- allow a variable internal time-step to ensure good agreement between computing performance and accuracy.

\item {} 
\sphinxstyleliteralstrong{max\_iter} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- maximum internal iteration allowed

\item {} 
\sphinxstyleliteralstrong{dt\_min} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- minimum internal time step allowed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ROS3PRw (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.ROS3PRw}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{ROS3PRw}}{\emph{model}, \emph{tol=0.01}, \emph{time\_stepping=True}, \emph{max\_iter=None}, \emph{dt\_min=None}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general}]{\sphinxcrossref{\sphinxcode{triflow.plugins.schemes.ROW\_general}}}}

Third order Rosenbrock scheme, with time stepping
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\item {} 
\sphinxstyleliteralstrong{tol} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1E-2}) -- tolerance factor for the time stepping. The time step will adapt to ensure that the maximum relative error on all fields stay under that value.

\item {} 
\sphinxstyleliteralstrong{time\_stepping} (\sphinxstyleliteralemphasis{bool}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default True}) -- allow a variable internal time-step to ensure good agreement between computing performance and accuracy.

\item {} 
\sphinxstyleliteralstrong{max\_iter} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- maximum internal iteration allowed

\item {} 
\sphinxstyleliteralstrong{dt\_min} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default None}) -- minimum internal time step allowed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ROW\_general (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{ROW\_general}}{\emph{model}, \emph{alpha}, \emph{gamma}, \emph{b}, \emph{b\_pred=None}, \emph{time\_stepping=False}, \emph{tol=None}, \emph{max\_iter=None}, \emph{dt\_min=None}}{}
Bases: \sphinxcode{object}

Rosenbrock Wanner class of temporal solvers

The implementation and the different parameters can be found in
\sphinxurl{http://www.digibib.tu-bs.de/?docid=00055262}
\index{\_\_call\_\_() (triflow.plugins.schemes.ROW\_general method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.ROW_general.__call__}}\pysiglinewithargsret{\sphinxbfcode{\_\_call\_\_}}{\emph{t}, \emph{fields}, \emph{dt}, \emph{pars}, \emph{hook=\textless{}function ROW\_general.\textless{}lambda\textgreater{}\textgreater{}}}{}
Perform a step of the solver: took a time and a system state as a
triflow Fields container and return the next time step with updated
container.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{t} (\sphinxstyleliteralemphasis{float}) -- actual time step

\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- actual system state in a triflow Fields

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{float}) -- temporal step-size

\item {} 
\sphinxstyleliteralstrong{pars} (\sphinxstyleliteralemphasis{dict}) -- physical parameters of the model

\item {} 
\sphinxstyleliteralstrong{hook} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- any callable taking the actual time, fields and parameters and return modified fields and parameters. Will be called every internal time step and can be used to include time dependent or conditionnal parameters, boundary conditions...

\item {} 
\sphinxstyleliteralstrong{container} -- 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} -- updated time and fields container

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{triflow.core:triflow.core.simulation.Simulation.t}]{\sphinxcrossref{t}}}, {\hyperref[\detokenize{triflow.core:module-triflow.core.fields}]{\sphinxcrossref{fields}}}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{NotImplementedError} -- raised if a time stepping is requested but the scheme do not provide the b predictor coefficients.

\item {} 
\sphinxcode{ValueError} -- raised if time\_stepping is True and tol is not provided.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Theta (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.Theta}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{Theta}}{\emph{model}, \emph{theta=1}, \emph{solver=\textless{}function spsolve\textgreater{}}}{}
Bases: \sphinxcode{object}
\begin{description}
\item[{Simple theta-based scheme where theta is a weight}] \leavevmode
if theta = 0, the scheme is a forward-euler scheme
if theta = 1, the scheme is a backward-euler scheme
if theta = 0.5, the scheme is called a Crank-Nicolson scheme

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\item {} 
\sphinxstyleliteralstrong{theta} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1}) -- weight of the theta-scheme

\item {} 
\sphinxstyleliteralstrong{solver} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default scipy.sparse.linalg.spsolve}) -- method able to solve a Ax = b linear equation with A a sparse matrix. Take A and b as argument and return x.

\end{itemize}

\end{description}\end{quote}
\index{\_\_call\_\_() (triflow.plugins.schemes.Theta method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.Theta.__call__}}\pysiglinewithargsret{\sphinxbfcode{\_\_call\_\_}}{\emph{t}, \emph{fields}, \emph{dt}, \emph{pars}, \emph{hook=\textless{}function Theta.\textless{}lambda\textgreater{}\textgreater{}}}{}
Perform a step of the solver: took a time and a system state as a
triflow Fields container and return the next time step with updated
container.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{t} (\sphinxstyleliteralemphasis{float}) -- actual time step

\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- actual system state in a triflow Fields container

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{float}) -- temporal step-size

\item {} 
\sphinxstyleliteralstrong{pars} (\sphinxstyleliteralemphasis{dict}) -- physical parameters of the model

\item {} 
\sphinxstyleliteralstrong{hook} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- any callable taking the actual time, fields and parameters and return modified fields and parameters. Will be called every internal time step and can be used to include time dependent or conditionnal parameters, boundary conditions...

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} -- updated time and fields container

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{triflow.core:triflow.core.simulation.Simulation.t}]{\sphinxcrossref{t}}}, {\hyperref[\detokenize{triflow.core:module-triflow.core.fields}]{\sphinxcrossref{fields}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{scipy\_ode (class in triflow.plugins.schemes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.scipy_ode}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.schemes.}\sphinxbfcode{scipy\_ode}}{\emph{model}, \emph{integrator='vode'}, \emph{**integrator\_kwargs}}{}
Bases: \sphinxcode{object}

Proxy written around the scipy.integrate.ode class. Give access to all
the scpy integrators.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model} (\sphinxstyleliteralemphasis{triflow.Model}) -- triflow Model

\item {} 
\sphinxstyleliteralstrong{integrator} (\sphinxstyleliteralemphasis{str}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 'vode'}) -- name of the chosen scipy integration scheme.

\item {} 
\sphinxstyleliteralstrong{**integrator\_kwargs} -- extra arguments provided to the scipy integration scheme.

\end{itemize}

\end{description}\end{quote}
\index{\_\_call\_\_() (triflow.plugins.schemes.scipy\_ode method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.schemes.scipy_ode.__call__}}\pysiglinewithargsret{\sphinxbfcode{\_\_call\_\_}}{\emph{t}, \emph{fields}, \emph{dt}, \emph{pars}, \emph{hook=\textless{}function scipy\_ode.\textless{}lambda\textgreater{}\textgreater{}}}{}
Perform a step of the solver: took a time and a system state as a
triflow Fields container and return the next time step with updated
container.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{t} (\sphinxstyleliteralemphasis{float}) -- actual time step

\item {} 
\sphinxstyleliteralstrong{fields} (\sphinxstyleliteralemphasis{triflow.Fields}) -- actual system state in a triflow Fields

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{float}) -- temporal step-size

\item {} 
\sphinxstyleliteralstrong{pars} (\sphinxstyleliteralemphasis{dict}) -- physical parameters of the model

\item {} 
\sphinxstyleliteralstrong{hook} (\sphinxstyleliteralemphasis{callable}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- any callable taking the actual time, fields and parameters and return modified fields and parameters. Will be called every internal time step and can be used to include time dependent or conditionnal parameters, boundary conditions...

\item {} 
\sphinxstyleliteralstrong{container} -- 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} -- updated time and fields container

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{triflow.core:triflow.core.simulation.Simulation.t}]{\sphinxcrossref{t}}}, {\hyperref[\detokenize{triflow.core:module-triflow.core.fields}]{\sphinxcrossref{fields}}}

\item[{Raises}] \leavevmode
\sphinxcode{RuntimeError} -- Description

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{triflow.plugins.signals module}
\label{\detokenize{triflow.plugins:triflow-plugins-signals-module}}\label{\detokenize{triflow.plugins:module-triflow.plugins.signals}}\index{triflow.plugins.signals (module)}
This module provides a Signal class usefull for time variable boundary
conditions.
\begin{description}
\item[{Available signals:}] \leavevmode\begin{itemize}
\item {} 
ConstantSignal: just an offset signal

\item {} 
ForcedSignal: a sinusoidal wave

\item {} 
WhiteNoise: a noisy signal

\item {} 
BrownNoise: a noisy signal with Fourrier modes set to 0 for a fraction of the available modes.

\end{itemize}

\end{description}
\index{AdditiveSignal (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.AdditiveSignal}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{AdditiveSignal}}{\emph{signal\_a}, \emph{signal\_b}, \emph{op}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.signals.Signal}]{\sphinxcrossref{\sphinxcode{triflow.plugins.signals.Signal}}}}

Additive signal. Proxy the different signals and sum their interpolation functions.

\end{fulllineitems}

\index{ConstantSignal (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.ConstantSignal}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{ConstantSignal}}{\emph{offset: float}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.signals.Signal}]{\sphinxcrossref{\sphinxcode{triflow.plugins.signals.Signal}}}}

Offset signal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{offset} (\sphinxstyleliteralemphasis{float}) -- Value of the offset

\end{description}\end{quote}
\paragraph{Examples}

Set an offset to a white noise:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow}\PYG{n+nn}{.}\PYG{n+nn}{plugins} \PYG{k}{import} \PYG{n}{signals}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noisy} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianWhiteNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{offset} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{ConstantSignal}\PYG{p}{(}\PYG{n}{offset}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise\PYGZus{}with\PYGZus{}offset} \PYG{o}{=} \PYG{n}{noisy} \PYG{o}{+} \PYG{n}{offset}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise\PYGZus{}without\PYGZus{}offset} \PYG{o}{=} \PYG{n}{noise\PYGZus{}with\PYGZus{}offset} \PYG{o}{\PYGZhy{}} \PYG{n}{offset}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{isclose}\PYG{p}{(}\PYG{n}{noisy}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{n}{noise\PYGZus{}without\PYGZus{}offset}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{GaussianBrownNoise (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.GaussianBrownNoise}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{GaussianBrownNoise}}{\emph{frequency\_sampling: float}, \emph{frequency\_cut: float}, \emph{mean=0}, \emph{std=0.2}, \emph{n=1000}, \emph{filter\_std=25}, \emph{filter\_window\_size=500}, \emph{seed=None}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.signals.GaussianWhiteNoise}]{\sphinxcrossref{\sphinxcode{triflow.plugins.signals.GaussianWhiteNoise}}}}

Gaussian Brown noise signal, seeded with numpy.random.randn and with frequency cut at specific value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{frequency\_sampling} (\sphinxstyleliteralemphasis{float}) -- Frequency sampling (the highest frequency of the white signal spectrum).

\item {} 
\sphinxstyleliteralstrong{frequency\_cut} (\sphinxstyleliteralemphasis{float}) -- Filter frequency cut.

\item {} 
\sphinxstyleliteralstrong{mean} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1000}) -- sampling number of the signal.

\item {} 
\sphinxstyleliteralstrong{n} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1000}) -- sampling number of the signal.

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- pseudo-random number generator seed. Signals with same signal\_period, sampling number and seed will be similar.

\end{itemize}

\end{description}\end{quote}
\paragraph{Examples}

White signal with frequencies cut after 50 Hz:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow}\PYG{n+nn}{.}\PYG{n+nn}{plugins} \PYG{k}{import} \PYG{n}{signals}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{brown\PYGZus{}signal} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianBrownNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,}
\PYG{g+gp}{... }                                          \PYG{n}{frequency\PYGZus{}cut}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{spectrum\PYGZus{}frequencies}\PYG{p}{,} \PYG{n}{spectrum\PYGZus{}density} \PYG{o}{=} \PYG{n}{brown\PYGZus{}signal}\PYG{o}{.}\PYG{n}{fourrier\PYGZus{}spectrum}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{isclose}\PYG{p}{(}\PYG{n}{spectrum\PYGZus{}density}\PYG{p}{[}\PYG{n}{spectrum\PYGZus{}frequencies} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{atol}\PYG{o}{=}\PYG{l+m+mf}{1E\PYGZhy{}3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{GaussianWhiteNoise (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.GaussianWhiteNoise}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{GaussianWhiteNoise}}{\emph{frequency\_sampling}, \emph{mean=0}, \emph{std=0.2}, \emph{n=1000}, \emph{seed=None}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.signals.Signal}]{\sphinxcrossref{\sphinxcode{triflow.plugins.signals.Signal}}}}

Gaussian White noise signal, seeded with numpy.random.randn
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{frequency\_sampling} (\sphinxstyleliteralemphasis{float}) -- Frequency sampling (the highest frequency of the white signal spectrum).

\item {} 
\sphinxstyleliteralstrong{mean} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1000}) -- sampling number of the signal.

\item {} 
\sphinxstyleliteralstrong{n} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{default 1000}) -- sampling number of the signal.

\item {} 
\sphinxstyleliteralstrong{seed} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{ or }\sphinxstyleliteralemphasis{None}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- pseudo-random number generator seed. Signals with same signal\_period, sampling number and seed will be similar.

\end{itemize}

\end{description}\end{quote}
\paragraph{Examples}

Simple white signal with a 200 Hz frequency sampling:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow}\PYG{n+nn}{.}\PYG{n+nn}{plugins} \PYG{k}{import} \PYG{n}{signals}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{signal} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianWhiteNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\end{sphinxVerbatim}

Forcing the pseudo-random-number generator seed for reproductible signal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow}\PYG{n+nn}{.}\PYG{n+nn}{plugins} \PYG{k}{import} \PYG{n}{signals}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{signal1} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianWhiteNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{signal2} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianWhiteNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{isclose}\PYG{p}{(}\PYG{n}{signal1}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{signal2}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{signal3} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{GaussianWhiteNoise}\PYG{p}{(}\PYG{n}{frequency\PYGZus{}sampling}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{isclose}\PYG{p}{(}\PYG{n}{signal1}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{signal3}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Signal (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.Signal}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{Signal}}{\emph{signal\_period: float}, \emph{n: int = 1000}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Base class for signal object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{signal\_period} (\sphinxstyleliteralemphasis{float}) -- period of the signal.

\item {} 
\sphinxstyleliteralstrong{n} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- sampling number of the signal.

\item {} 
\sphinxstyleliteralstrong{**kwargs} -- extra arguments provided to the custom signal template.

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{NotImplementedError}

\item {} 
this class is not supposed to be used by the user. If initialized directly, it will raise a NotImplementedError.

\end{itemize}

\end{description}\end{quote}
\index{\_\_add\_\_() (triflow.plugins.signals.Signal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.Signal.__add__}}\pysiglinewithargsret{\sphinxbfcode{\_\_add\_\_}}{\emph{other\_signal}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{other\_signal} (\sphinxstyleliteralemphasis{triflow.plugins.signal.Signal}) -- second signal to which this one will be added.

\item[{Returns}] \leavevmode
added signal.

\item[{Return type}] \leavevmode
triflow.plugins.signal.AdditiveSignal

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_call\_\_() (triflow.plugins.signals.Signal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.Signal.__call__}}\pysiglinewithargsret{\sphinxbfcode{\_\_call\_\_}}{\emph{t: float}}{}
return the signal value for the time t.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{t} (\sphinxstyleliteralemphasis{float}) -- time where the signal is evaluated.

\item[{Returns}] \leavevmode
amplitude of the signal a the time t.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_sub\_\_() (triflow.plugins.signals.Signal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.Signal.__sub__}}\pysiglinewithargsret{\sphinxbfcode{\_\_sub\_\_}}{\emph{other\_signal}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{other\_signal} (\sphinxstyleliteralemphasis{triflow.plugins.signal.Signal}) -- second signal to which this one will be added.

\item[{Returns}] \leavevmode
added signal.

\item[{Return type}] \leavevmode
triflow.plugins.signal.AdditiveSignal

\end{description}\end{quote}

\end{fulllineitems}

\index{fourrier\_spectrum (triflow.plugins.signals.Signal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.Signal.fourrier_spectrum}}\pysigline{\sphinxbfcode{fourrier\_spectrum}}
param *args, {\color{red}\bfseries{}**}kwargs: extra arguments provided to the periodogram function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple of numpy.ndarray}

\item[{Return type}] \leavevmode
fourrier modes and power density obtained with the scipy.signal.periodogram function.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SinusoidalSignal (class in triflow.plugins.signals)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{triflow.plugins:triflow.plugins.signals.SinusoidalSignal}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{triflow.plugins.signals.}\sphinxbfcode{SinusoidalSignal}}{\emph{frequency: float}, \emph{amplitude: float}, \emph{phase: float = 0}, \emph{n: int = 1000}}{}
Bases: {\hyperref[\detokenize{triflow.plugins:triflow.plugins.signals.Signal}]{\sphinxcrossref{\sphinxcode{triflow.plugins.signals.Signal}}}}

Simple sinusoidal signal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{frequency} (\sphinxstyleliteralemphasis{float}) -- frequency of the signal

\item {} 
\sphinxstyleliteralstrong{amplitude} (\sphinxstyleliteralemphasis{float}) -- amplitude of the signal

\item {} 
\sphinxstyleliteralstrong{phase} (\sphinxstyleliteralemphasis{float}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- phase of the signam

\item {} 
\sphinxstyleliteralstrong{n} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{optional}) -- number of sample for 2 period of the signal

\end{itemize}

\end{description}\end{quote}
\paragraph{Examples}

We generate a 5 Hz signal with an amplitude of 0.5, and we check the signal.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{triflow}\PYG{n+nn}{.}\PYG{n+nn}{plugins} \PYG{k}{import} \PYG{n}{signals}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{signal} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{SinusoidalSignal}\PYG{p}{(}\PYG{n}{frequency}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{amplitude}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{spectrum\PYGZus{}frequencies}\PYG{p}{,} \PYG{n}{spectrum\PYGZus{}density} \PYG{o}{=} \PYG{n}{signal}\PYG{o}{.}\PYG{n}{fourrier\PYGZus{}spectrum}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Amplitude: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{signal(t).max():g\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Amplitude: 0.499999}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{main mode: }\PYG{l+s+si}{\PYGZob{}spectrum\PYGZus{}frequencies[spectrum\PYGZus{}density.argmax()]:g\PYGZcb{}}\PYG{l+s+s2}{ Hz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{main mode: 4.995 Hz}
\end{sphinxVerbatim}

The class give a warning if the number of sample is too low and lead to aliasing. You can try it with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{logger} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{triflow.plugins.signals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{logger}\PYG{o}{.}\PYG{n}{handlers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{logger}\PYG{o}{.}\PYG{n}{addHandler}\PYG{p}{(}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{StreamHandler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{logger}\PYG{o}{.}\PYG{n}{setLevel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{INFO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aliased\PYGZus{}signal} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{SinusoidalSignal}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{triflow.plugins:module-contents}}\label{\detokenize{triflow.plugins:module-triflow.plugins}}\index{triflow.plugins (module)}

\subsection{Module contents}
\label{\detokenize{triflow:module-contents}}\label{\detokenize{triflow:module-triflow}}\index{triflow (module)}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{t}
\item {\sphinxstyleindexentry{triflow}}\sphinxstyleindexpageref{triflow:\detokenize{module-triflow}}
\item {\sphinxstyleindexentry{triflow.core}}\sphinxstyleindexpageref{triflow.core:\detokenize{module-triflow.core}}
\item {\sphinxstyleindexentry{triflow.core.fields}}\sphinxstyleindexpageref{triflow.core:\detokenize{module-triflow.core.fields}}
\item {\sphinxstyleindexentry{triflow.core.model}}\sphinxstyleindexpageref{triflow.core:\detokenize{module-triflow.core.model}}
\item {\sphinxstyleindexentry{triflow.core.routines}}\sphinxstyleindexpageref{triflow.core:\detokenize{module-triflow.core.routines}}
\item {\sphinxstyleindexentry{triflow.core.simulation}}\sphinxstyleindexpageref{triflow.core:\detokenize{module-triflow.core.simulation}}
\item {\sphinxstyleindexentry{triflow.plugins}}\sphinxstyleindexpageref{triflow.plugins:\detokenize{module-triflow.plugins}}
\item {\sphinxstyleindexentry{triflow.plugins.displays}}\sphinxstyleindexpageref{triflow.plugins:\detokenize{module-triflow.plugins.displays}}
\item {\sphinxstyleindexentry{triflow.plugins.schemes}}\sphinxstyleindexpageref{triflow.plugins:\detokenize{module-triflow.plugins.schemes}}
\item {\sphinxstyleindexentry{triflow.plugins.signals}}\sphinxstyleindexpageref{triflow.plugins:\detokenize{module-triflow.plugins.signals}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}