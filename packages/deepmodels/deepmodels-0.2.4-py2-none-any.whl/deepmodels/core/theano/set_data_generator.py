# generate different types of set data
# used for set hashing

from data_manager import *
import random

'''
set data configurations
1) augmented sets
2) real sets
3) mixed sets

all sets are generated from images / image files and labels
'''


''' 
    real sets are generated by sampling from the same class
    if sets are predefined, subsets will be sampled from the same set
    min set size: 5
    min set size to get subsets
'''
def gen_real_sets(img_data, labels, set_ids, max_set_num):
    print 'generating real sets...'
    if set_ids is None:
        set_data, set_labels, set_ids = form_sets(img_data, labels, max_set_num)
    else:
        # get subsets from defined sets
        set_data = []
        set_labels = []
        unique_set_ids = np.unique(set_ids)
        for i in range(len(unique_set_ids)):
            cur_set = np.where(set_ids == unique_set_ids[i])
            cur_set = cur_set[0]
            set_data.append(cur_set)
            set_labels.append(labels[cur_set[0]])
            # leave augment to loading image time
            if len(cur_set) > 6:
                # if N > 7, possible set number already exceeds 10
                # generate 10
                set_sz = random.sample(range(6, len(cur_set)), 20)
                for sz in set_sz:
                    random.shuffle(cur_set)
                    new_set = cur_set[:sz]
                    set_data.append(new_set)
                    set_labels.append(labels[new_set[0]])

    return set_data, set_labels


def gen_subsets(img_sets, set_labels, subset_num=10):
    new_data = []
    new_labels = []
    for i in range(len(img_sets)):
        cur_set = img_sets[i]
        new_data.append(cur_set)
        new_labels.append(set_labels[i])
        # leave augment to loading image time
        if len(cur_set) > 6:
            # if N > 7, possible set number already exceeds 10
            # generate 10
            for j in range(subset_num):
                random.shuffle(cur_set)
                new_set = cur_set[:6]
                new_data.append(new_set)
                new_labels.append(set_labels[i])
    return np.asarray(new_data), np.asarray(new_labels, np.int32)

'''
    produce augmented images from one sample
'''
def gen_augmented_sets(img_data, labels, set_ids, max_set_sz, num_per_type, augment_types):
    print 'generating augmented sets...'
    if set_ids is None:
        set_data = []
        for i in range(img_data.shape[0]):
            img_set = augment_img(img_data[[i]], max_set_sz, num_per_type, augment_types)
            set_data.append(img_set)
        return set_data, labels

# for each set, augment images to reach a size
def gen_augmented_sets_for_sets(img_sets, labels, max_set_sz, num_per_type, augment_types):
    set_data = []
    for i in range(len(img_sets)):
        # augment every image
        cur_sets = None
        for j in range(len(img_sets[i])):
            img_set = augment_img(img_sets[i][[j]], 3, 2, augment_types)
            if cur_sets is None:
                cur_sets = img_set
            else:
                cur_sets = np.vstack((cur_sets, img_set))
        # resample
        cur_sets = rand.sample(cur_sets, max_set_sz)
        set_data.append(cur_sets)
    return set_data, labels


'''
    create both real and augmented sets
'''
def gen_mixed_sets(img_data, labels, set_ids, max_set_sz, num_per_type, augment_types):
    print 'generating mixed sets...'
    # real sets
    real_set_data, real_set_labels = gen_real_sets(img_data, labels, set_ids, max_set_sz)
    # augmented sets
    aug_set_data, aug_set_labels = gen_augmented_sets(img_data, labels, set_ids, max_set_sz, num_per_type, augment_types)
    # combine
    print('combining {} real sets and {} aug sets'.format(len(real_set_labels), len(aug_set_labels)))
    real_set_data.extend(aug_set_data)
    real_set_labels.extend(aug_set_labels)
    return (real_set_data, real_set_labels)


if __name__ == '__main__':
    print 'hello'