# -*- coding: utf-8 -*-
from DateTime import DateTime
from Products.CMFPlone.utils import base_hasattr
from plone.app.content.interfaces import INameFromTitle
from plone.restapi.deserializer import json_body
from plone.restapi.exceptions import DeserializationError
from plone.restapi.interfaces import ISerializeToJson
from plone.restapi.interfaces import IDeserializeFromJson
from plone.restapi.services import Service
from random import randint
from zExceptions import BadRequest
from zope.component import queryMultiAdapter
from zope.container.interfaces import INameChooser
from zope.interface import alsoProvides

import plone.protect.interfaces
import transaction


class FolderPost(Service):
    """Creates a new content object.
    """

    def reply(self):
        data = json_body(self.request)

        type_ = data.get('@type', None)
        id_ = data.get('id', None)
        title = data.get('title', None)

        if not type_:
            raise BadRequest("Property '@type' is required")

        # Disable CSRF protection
        if 'IDisableCSRFProtection' in dir(plone.protect.interfaces):
            alsoProvides(self.request,
                         plone.protect.interfaces.IDisableCSRFProtection)

        # Generate a temporary id if the id is not given
        if not id_:
            now = DateTime()
            new_id = '{}.{}.{}{:04d}'.format(
                type_.lower().replace(' ', '_'),
                now.strftime('%Y-%m-%d'),
                str(now.millis())[7:],
                randint(0, 9999))
        else:
            new_id = id_

        # Create object
        try:
            new_id = self.context.invokeFactory(type_, new_id, title=title)
        except BadRequest as e:
            self.request.response.setStatus(400)
            return dict(error=dict(
                type='DeserializationError',
                message=str(e.message)))
        except ValueError as e:
            self.request.response.setStatus(400)
            return dict(error=dict(
                type='DeserializationError',
                message=str(e.message)))

        # Update fields
        obj = self.context[new_id]
        deserializer = queryMultiAdapter((obj, self.request),
                                         IDeserializeFromJson)
        if deserializer is None:
            self.request.response.setStatus(501)
            return dict(error=dict(
                message='Cannot deserialize type {}'.format(obj.portal_type)))

        try:
            deserializer(validate_all=True)
        except DeserializationError as e:
            self.request.response.setStatus(400)
            return dict(error=dict(
                type='DeserializationError',
                message=str(e)))

        # Rename if generated id
        if not id_:
            self.rename_object(obj)

        self.request.response.setStatus(201)
        self.request.response.setHeader('Location', obj.absolute_url())

        serializer = queryMultiAdapter(
            (obj, self.request),
            ISerializeToJson
        )
        serialized_obj = serializer()

        # HypermediaBatch can't determine the correct canonical URL for
        # objects that have just been created via POST - so we make sure
        # to set it here
        serialized_obj['@id'] = obj.absolute_url()

        return serialized_obj

    def rename_object(self, obj):
        # Archetypes objects may get renamed during deserialization.
        # Do not rename again.
        if (base_hasattr(obj, '_isIDAutoGenerated') and
                not obj._isIDAutoGenerated(obj.getId())):
            return

        chooser = INameChooser(self.context)
        # INameFromTitle adaptable objects should not get a name
        # suggestion. NameChooser would prefer the given name instead of
        # the one provided by the INameFromTitle adapter.
        suggestion = None
        name_from_title = INameFromTitle(obj, None)
        if name_from_title is None:
            if base_hasattr(obj, 'generateNewId'):
                suggestion = obj.generateNewId()
            else:
                suggestion = obj.Title()
        name = chooser.chooseName(suggestion, obj)
        transaction.savepoint(optimistic=True)
        self.context.manage_renameObject(obj.getId(), name)
