#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport


class Iface(object):
    def testConnection(self):
        pass

    def storeDataFrame(self, df, experimentRunId):
        """
        Parameters:
         - df
         - experimentRunId
        """
        pass

    def pathForTransformer(self, transformerId):
        """
        Parameters:
         - transformerId
        """
        pass

    def storeFitEvent(self, fe):
        """
        Parameters:
         - fe
        """
        pass

    def storeMetricEvent(self, me):
        """
        Parameters:
         - me
        """
        pass

    def getFilePath(self, t, experimentRunId, filename):
        """
        Parameters:
         - t
         - experimentRunId
         - filename
        """
        pass

    def storeTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        pass

    def storeRandomSplitEvent(self, rse):
        """
        Parameters:
         - rse
        """
        pass

    def storePipelineEvent(self, pipelineEvent):
        """
        Parameters:
         - pipelineEvent
        """
        pass

    def storeCrossValidationEvent(self, cve):
        """
        Parameters:
         - cve
        """
        pass

    def storeGridSearchCrossValidationEvent(self, gscve):
        """
        Parameters:
         - gscve
        """
        pass

    def storeAnnotationEvent(self, ae):
        """
        Parameters:
         - ae
        """
        pass

    def storeProjectEvent(self, pr):
        """
        Parameters:
         - pr
        """
        pass

    def storeExperimentEvent(self, er):
        """
        Parameters:
         - er
        """
        pass

    def storeExperimentRunEvent(self, er):
        """
        Parameters:
         - er
        """
        pass

    def storeLinearModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        pass

    def getDataFrameAncestry(self, dataFrameId):
        """
        Parameters:
         - dataFrameId
        """
        pass

    def getCommonAncestor(self, dfId1, dfId2):
        """
        Parameters:
         - dfId1
         - dfId2
        """
        pass

    def getCommonAncestorForModels(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def getTrainingRowsCount(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def getTrainingRowsCounts(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        pass

    def compareHyperparameters(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def compareFeatures(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def groupByProblemType(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        pass

    def similarModels(self, modelId, compMetrics, numModels):
        """
        Parameters:
         - modelId
         - compMetrics
         - numModels
        """
        pass

    def linearModelFeatureImportances(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def compareLinearModelFeatureImportances(self, model1Id, model2Id):
        """
        Parameters:
         - model1Id
         - model2Id
        """
        pass

    def iterationsUntilConvergence(self, modelIds, tolerance):
        """
        Parameters:
         - modelIds
         - tolerance
        """
        pass

    def rankModels(self, modelIds, metric):
        """
        Parameters:
         - modelIds
         - metric
        """
        pass

    def confidenceIntervals(self, modelId, sigLevel):
        """
        Parameters:
         - modelId
         - sigLevel
        """
        pass

    def modelsWithFeatures(self, featureNames):
        """
        Parameters:
         - featureNames
        """
        pass

    def modelsDerivedFromDataFrame(self, dfId):
        """
        Parameters:
         - dfId
        """
        pass

    def getProjectIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        pass

    def getModelIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        pass

    def updateProject(self, projectId, key, value):
        """
        Parameters:
         - projectId
         - key
         - value
        """
        pass

    def createOrUpdateScalarField(self, modelId, key, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - value
         - valueType
        """
        pass

    def createVectorField(self, modelId, vectorName, vectorConfig):
        """
        Parameters:
         - modelId
         - vectorName
         - vectorConfig
        """
        pass

    def updateVectorField(self, modelId, key, valueIndex, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - valueIndex
         - value
         - valueType
        """
        pass

    def appendToVectorField(self, modelId, vectorName, value, valueType):
        """
        Parameters:
         - modelId
         - vectorName
         - value
         - valueType
        """
        pass

    def getModel(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def getRunsInExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        pass

    def getRunsAndExperimentsInProject(self, projId):
        """
        Parameters:
         - projId
        """
        pass

    def getProjectOverviews(self):
        pass

    def getExperimentRunDetails(self, experimentRunId):
        """
        Parameters:
         - experimentRunId
        """
        pass

    def originalFeatures(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def storeTreeModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        pass

    def storePipelineTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        pass

    def computeModelAncestry(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def extractPipeline(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def createProject(self, project):
        """
        Parameters:
         - project
        """
        pass

    def createExperiment(self, experiment):
        """
        Parameters:
         - experiment
        """
        pass

    def createExperimentRun(self, experimentRun):
        """
        Parameters:
         - experimentRun
        """
        pass

    def API_updateProject(self, projectId, updatedKVs):
        """
        Parameters:
         - projectId
         - updatedKVs
        """
        pass

    def updateExperiment(self, experimentId, updatedKVs):
        """
        Parameters:
         - experimentId
         - updatedKVs
        """
        pass

    def updateExperimentRun(self, experimentRunId, updatedKVs):
        """
        Parameters:
         - experimentRunId
         - updatedKVs
        """
        pass

    def getProject(self, projectId):
        """
        Parameters:
         - projectId
        """
        pass

    def getExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def testConnection(self):
        self.send_testConnection()
        return self.recv_testConnection()

    def send_testConnection(self):
        self._oprot.writeMessageBegin('testConnection', TMessageType.CALL, self._seqid)
        args = testConnection_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testConnection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testConnection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testConnection failed: unknown result")

    def storeDataFrame(self, df, experimentRunId):
        """
        Parameters:
         - df
         - experimentRunId
        """
        self.send_storeDataFrame(df, experimentRunId)
        return self.recv_storeDataFrame()

    def send_storeDataFrame(self, df, experimentRunId):
        self._oprot.writeMessageBegin('storeDataFrame', TMessageType.CALL, self._seqid)
        args = storeDataFrame_args()
        args.df = df
        args.experimentRunId = experimentRunId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeDataFrame(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeDataFrame_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeDataFrame failed: unknown result")

    def pathForTransformer(self, transformerId):
        """
        Parameters:
         - transformerId
        """
        self.send_pathForTransformer(transformerId)
        return self.recv_pathForTransformer()

    def send_pathForTransformer(self, transformerId):
        self._oprot.writeMessageBegin('pathForTransformer', TMessageType.CALL, self._seqid)
        args = pathForTransformer_args()
        args.transformerId = transformerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pathForTransformer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pathForTransformer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.efEx is not None:
            raise result.efEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pathForTransformer failed: unknown result")

    def storeFitEvent(self, fe):
        """
        Parameters:
         - fe
        """
        self.send_storeFitEvent(fe)
        return self.recv_storeFitEvent()

    def send_storeFitEvent(self, fe):
        self._oprot.writeMessageBegin('storeFitEvent', TMessageType.CALL, self._seqid)
        args = storeFitEvent_args()
        args.fe = fe
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeFitEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeFitEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeFitEvent failed: unknown result")

    def storeMetricEvent(self, me):
        """
        Parameters:
         - me
        """
        self.send_storeMetricEvent(me)
        return self.recv_storeMetricEvent()

    def send_storeMetricEvent(self, me):
        self._oprot.writeMessageBegin('storeMetricEvent', TMessageType.CALL, self._seqid)
        args = storeMetricEvent_args()
        args.me = me
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeMetricEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeMetricEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeMetricEvent failed: unknown result")

    def getFilePath(self, t, experimentRunId, filename):
        """
        Parameters:
         - t
         - experimentRunId
         - filename
        """
        self.send_getFilePath(t, experimentRunId, filename)
        return self.recv_getFilePath()

    def send_getFilePath(self, t, experimentRunId, filename):
        self._oprot.writeMessageBegin('getFilePath', TMessageType.CALL, self._seqid)
        args = getFilePath_args()
        args.t = t
        args.experimentRunId = experimentRunId
        args.filename = filename
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFilePath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFilePath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilePath failed: unknown result")

    def storeTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        self.send_storeTransformEvent(te)
        return self.recv_storeTransformEvent()

    def send_storeTransformEvent(self, te):
        self._oprot.writeMessageBegin('storeTransformEvent', TMessageType.CALL, self._seqid)
        args = storeTransformEvent_args()
        args.te = te
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeTransformEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeTransformEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeTransformEvent failed: unknown result")

    def storeRandomSplitEvent(self, rse):
        """
        Parameters:
         - rse
        """
        self.send_storeRandomSplitEvent(rse)
        return self.recv_storeRandomSplitEvent()

    def send_storeRandomSplitEvent(self, rse):
        self._oprot.writeMessageBegin('storeRandomSplitEvent', TMessageType.CALL, self._seqid)
        args = storeRandomSplitEvent_args()
        args.rse = rse
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeRandomSplitEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeRandomSplitEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeRandomSplitEvent failed: unknown result")

    def storePipelineEvent(self, pipelineEvent):
        """
        Parameters:
         - pipelineEvent
        """
        self.send_storePipelineEvent(pipelineEvent)
        return self.recv_storePipelineEvent()

    def send_storePipelineEvent(self, pipelineEvent):
        self._oprot.writeMessageBegin('storePipelineEvent', TMessageType.CALL, self._seqid)
        args = storePipelineEvent_args()
        args.pipelineEvent = pipelineEvent
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storePipelineEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storePipelineEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storePipelineEvent failed: unknown result")

    def storeCrossValidationEvent(self, cve):
        """
        Parameters:
         - cve
        """
        self.send_storeCrossValidationEvent(cve)
        return self.recv_storeCrossValidationEvent()

    def send_storeCrossValidationEvent(self, cve):
        self._oprot.writeMessageBegin('storeCrossValidationEvent', TMessageType.CALL, self._seqid)
        args = storeCrossValidationEvent_args()
        args.cve = cve
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeCrossValidationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeCrossValidationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeCrossValidationEvent failed: unknown result")

    def storeGridSearchCrossValidationEvent(self, gscve):
        """
        Parameters:
         - gscve
        """
        self.send_storeGridSearchCrossValidationEvent(gscve)
        return self.recv_storeGridSearchCrossValidationEvent()

    def send_storeGridSearchCrossValidationEvent(self, gscve):
        self._oprot.writeMessageBegin('storeGridSearchCrossValidationEvent', TMessageType.CALL, self._seqid)
        args = storeGridSearchCrossValidationEvent_args()
        args.gscve = gscve
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeGridSearchCrossValidationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeGridSearchCrossValidationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeGridSearchCrossValidationEvent failed: unknown result")

    def storeAnnotationEvent(self, ae):
        """
        Parameters:
         - ae
        """
        self.send_storeAnnotationEvent(ae)
        return self.recv_storeAnnotationEvent()

    def send_storeAnnotationEvent(self, ae):
        self._oprot.writeMessageBegin('storeAnnotationEvent', TMessageType.CALL, self._seqid)
        args = storeAnnotationEvent_args()
        args.ae = ae
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeAnnotationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeAnnotationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeAnnotationEvent failed: unknown result")

    def storeProjectEvent(self, pr):
        """
        Parameters:
         - pr
        """
        self.send_storeProjectEvent(pr)
        return self.recv_storeProjectEvent()

    def send_storeProjectEvent(self, pr):
        self._oprot.writeMessageBegin('storeProjectEvent', TMessageType.CALL, self._seqid)
        args = storeProjectEvent_args()
        args.pr = pr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeProjectEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeProjectEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeProjectEvent failed: unknown result")

    def storeExperimentEvent(self, er):
        """
        Parameters:
         - er
        """
        self.send_storeExperimentEvent(er)
        return self.recv_storeExperimentEvent()

    def send_storeExperimentEvent(self, er):
        self._oprot.writeMessageBegin('storeExperimentEvent', TMessageType.CALL, self._seqid)
        args = storeExperimentEvent_args()
        args.er = er
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeExperimentEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeExperimentEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentEvent failed: unknown result")

    def storeExperimentRunEvent(self, er):
        """
        Parameters:
         - er
        """
        self.send_storeExperimentRunEvent(er)
        return self.recv_storeExperimentRunEvent()

    def send_storeExperimentRunEvent(self, er):
        self._oprot.writeMessageBegin('storeExperimentRunEvent', TMessageType.CALL, self._seqid)
        args = storeExperimentRunEvent_args()
        args.er = er
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeExperimentRunEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeExperimentRunEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentRunEvent failed: unknown result")

    def storeLinearModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        self.send_storeLinearModel(modelId, model)
        return self.recv_storeLinearModel()

    def send_storeLinearModel(self, modelId, model):
        self._oprot.writeMessageBegin('storeLinearModel', TMessageType.CALL, self._seqid)
        args = storeLinearModel_args()
        args.modelId = modelId
        args.model = model
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeLinearModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeLinearModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeLinearModel failed: unknown result")

    def getDataFrameAncestry(self, dataFrameId):
        """
        Parameters:
         - dataFrameId
        """
        self.send_getDataFrameAncestry(dataFrameId)
        return self.recv_getDataFrameAncestry()

    def send_getDataFrameAncestry(self, dataFrameId):
        self._oprot.writeMessageBegin('getDataFrameAncestry', TMessageType.CALL, self._seqid)
        args = getDataFrameAncestry_args()
        args.dataFrameId = dataFrameId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataFrameAncestry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataFrameAncestry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataFrameAncestry failed: unknown result")

    def getCommonAncestor(self, dfId1, dfId2):
        """
        Parameters:
         - dfId1
         - dfId2
        """
        self.send_getCommonAncestor(dfId1, dfId2)
        return self.recv_getCommonAncestor()

    def send_getCommonAncestor(self, dfId1, dfId2):
        self._oprot.writeMessageBegin('getCommonAncestor', TMessageType.CALL, self._seqid)
        args = getCommonAncestor_args()
        args.dfId1 = dfId1
        args.dfId2 = dfId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonAncestor(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonAncestor_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestor failed: unknown result")

    def getCommonAncestorForModels(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_getCommonAncestorForModels(modelId1, modelId2)
        return self.recv_getCommonAncestorForModels()

    def send_getCommonAncestorForModels(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('getCommonAncestorForModels', TMessageType.CALL, self._seqid)
        args = getCommonAncestorForModels_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonAncestorForModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonAncestorForModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestorForModels failed: unknown result")

    def getTrainingRowsCount(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_getTrainingRowsCount(modelId)
        return self.recv_getTrainingRowsCount()

    def send_getTrainingRowsCount(self, modelId):
        self._oprot.writeMessageBegin('getTrainingRowsCount', TMessageType.CALL, self._seqid)
        args = getTrainingRowsCount_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTrainingRowsCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTrainingRowsCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCount failed: unknown result")

    def getTrainingRowsCounts(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        self.send_getTrainingRowsCounts(modelIds)
        return self.recv_getTrainingRowsCounts()

    def send_getTrainingRowsCounts(self, modelIds):
        self._oprot.writeMessageBegin('getTrainingRowsCounts', TMessageType.CALL, self._seqid)
        args = getTrainingRowsCounts_args()
        args.modelIds = modelIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTrainingRowsCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTrainingRowsCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCounts failed: unknown result")

    def compareHyperparameters(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_compareHyperparameters(modelId1, modelId2)
        return self.recv_compareHyperparameters()

    def send_compareHyperparameters(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('compareHyperparameters', TMessageType.CALL, self._seqid)
        args = compareHyperparameters_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareHyperparameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareHyperparameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareHyperparameters failed: unknown result")

    def compareFeatures(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_compareFeatures(modelId1, modelId2)
        return self.recv_compareFeatures()

    def send_compareFeatures(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('compareFeatures', TMessageType.CALL, self._seqid)
        args = compareFeatures_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareFeatures failed: unknown result")

    def groupByProblemType(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        self.send_groupByProblemType(modelIds)
        return self.recv_groupByProblemType()

    def send_groupByProblemType(self, modelIds):
        self._oprot.writeMessageBegin('groupByProblemType', TMessageType.CALL, self._seqid)
        args = groupByProblemType_args()
        args.modelIds = modelIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_groupByProblemType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = groupByProblemType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "groupByProblemType failed: unknown result")

    def similarModels(self, modelId, compMetrics, numModels):
        """
        Parameters:
         - modelId
         - compMetrics
         - numModels
        """
        self.send_similarModels(modelId, compMetrics, numModels)
        return self.recv_similarModels()

    def send_similarModels(self, modelId, compMetrics, numModels):
        self._oprot.writeMessageBegin('similarModels', TMessageType.CALL, self._seqid)
        args = similarModels_args()
        args.modelId = modelId
        args.compMetrics = compMetrics
        args.numModels = numModels
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_similarModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = similarModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.brEx is not None:
            raise result.brEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "similarModels failed: unknown result")

    def linearModelFeatureImportances(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_linearModelFeatureImportances(modelId)
        return self.recv_linearModelFeatureImportances()

    def send_linearModelFeatureImportances(self, modelId):
        self._oprot.writeMessageBegin('linearModelFeatureImportances', TMessageType.CALL, self._seqid)
        args = linearModelFeatureImportances_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_linearModelFeatureImportances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = linearModelFeatureImportances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "linearModelFeatureImportances failed: unknown result")

    def compareLinearModelFeatureImportances(self, model1Id, model2Id):
        """
        Parameters:
         - model1Id
         - model2Id
        """
        self.send_compareLinearModelFeatureImportances(model1Id, model2Id)
        return self.recv_compareLinearModelFeatureImportances()

    def send_compareLinearModelFeatureImportances(self, model1Id, model2Id):
        self._oprot.writeMessageBegin('compareLinearModelFeatureImportances', TMessageType.CALL, self._seqid)
        args = compareLinearModelFeatureImportances_args()
        args.model1Id = model1Id
        args.model2Id = model2Id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareLinearModelFeatureImportances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareLinearModelFeatureImportances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareLinearModelFeatureImportances failed: unknown result")

    def iterationsUntilConvergence(self, modelIds, tolerance):
        """
        Parameters:
         - modelIds
         - tolerance
        """
        self.send_iterationsUntilConvergence(modelIds, tolerance)
        return self.recv_iterationsUntilConvergence()

    def send_iterationsUntilConvergence(self, modelIds, tolerance):
        self._oprot.writeMessageBegin('iterationsUntilConvergence', TMessageType.CALL, self._seqid)
        args = iterationsUntilConvergence_args()
        args.modelIds = modelIds
        args.tolerance = tolerance
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_iterationsUntilConvergence(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = iterationsUntilConvergence_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "iterationsUntilConvergence failed: unknown result")

    def rankModels(self, modelIds, metric):
        """
        Parameters:
         - modelIds
         - metric
        """
        self.send_rankModels(modelIds, metric)
        return self.recv_rankModels()

    def send_rankModels(self, modelIds, metric):
        self._oprot.writeMessageBegin('rankModels', TMessageType.CALL, self._seqid)
        args = rankModels_args()
        args.modelIds = modelIds
        args.metric = metric
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rankModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rankModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rankModels failed: unknown result")

    def confidenceIntervals(self, modelId, sigLevel):
        """
        Parameters:
         - modelId
         - sigLevel
        """
        self.send_confidenceIntervals(modelId, sigLevel)
        return self.recv_confidenceIntervals()

    def send_confidenceIntervals(self, modelId, sigLevel):
        self._oprot.writeMessageBegin('confidenceIntervals', TMessageType.CALL, self._seqid)
        args = confidenceIntervals_args()
        args.modelId = modelId
        args.sigLevel = sigLevel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_confidenceIntervals(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = confidenceIntervals_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.brEx is not None:
            raise result.brEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "confidenceIntervals failed: unknown result")

    def modelsWithFeatures(self, featureNames):
        """
        Parameters:
         - featureNames
        """
        self.send_modelsWithFeatures(featureNames)
        return self.recv_modelsWithFeatures()

    def send_modelsWithFeatures(self, featureNames):
        self._oprot.writeMessageBegin('modelsWithFeatures', TMessageType.CALL, self._seqid)
        args = modelsWithFeatures_args()
        args.featureNames = featureNames
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modelsWithFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modelsWithFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsWithFeatures failed: unknown result")

    def modelsDerivedFromDataFrame(self, dfId):
        """
        Parameters:
         - dfId
        """
        self.send_modelsDerivedFromDataFrame(dfId)
        return self.recv_modelsDerivedFromDataFrame()

    def send_modelsDerivedFromDataFrame(self, dfId):
        self._oprot.writeMessageBegin('modelsDerivedFromDataFrame', TMessageType.CALL, self._seqid)
        args = modelsDerivedFromDataFrame_args()
        args.dfId = dfId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modelsDerivedFromDataFrame(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modelsDerivedFromDataFrame_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsDerivedFromDataFrame failed: unknown result")

    def getProjectIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        self.send_getProjectIds(keyValuePairs)
        return self.recv_getProjectIds()

    def send_getProjectIds(self, keyValuePairs):
        self._oprot.writeMessageBegin('getProjectIds', TMessageType.CALL, self._seqid)
        args = getProjectIds_args()
        args.keyValuePairs = keyValuePairs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProjectIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProjectIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProjectIds failed: unknown result")

    def getModelIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        self.send_getModelIds(keyValuePairs)
        return self.recv_getModelIds()

    def send_getModelIds(self, keyValuePairs):
        self._oprot.writeMessageBegin('getModelIds', TMessageType.CALL, self._seqid)
        args = getModelIds_args()
        args.keyValuePairs = keyValuePairs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModelIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModelIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModelIds failed: unknown result")

    def updateProject(self, projectId, key, value):
        """
        Parameters:
         - projectId
         - key
         - value
        """
        self.send_updateProject(projectId, key, value)
        return self.recv_updateProject()

    def send_updateProject(self, projectId, key, value):
        self._oprot.writeMessageBegin('updateProject', TMessageType.CALL, self._seqid)
        args = updateProject_args()
        args.projectId = projectId
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateProject failed: unknown result")

    def createOrUpdateScalarField(self, modelId, key, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - value
         - valueType
        """
        self.send_createOrUpdateScalarField(modelId, key, value, valueType)
        return self.recv_createOrUpdateScalarField()

    def send_createOrUpdateScalarField(self, modelId, key, value, valueType):
        self._oprot.writeMessageBegin('createOrUpdateScalarField', TMessageType.CALL, self._seqid)
        args = createOrUpdateScalarField_args()
        args.modelId = modelId
        args.key = key
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createOrUpdateScalarField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createOrUpdateScalarField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createOrUpdateScalarField failed: unknown result")

    def createVectorField(self, modelId, vectorName, vectorConfig):
        """
        Parameters:
         - modelId
         - vectorName
         - vectorConfig
        """
        self.send_createVectorField(modelId, vectorName, vectorConfig)
        return self.recv_createVectorField()

    def send_createVectorField(self, modelId, vectorName, vectorConfig):
        self._oprot.writeMessageBegin('createVectorField', TMessageType.CALL, self._seqid)
        args = createVectorField_args()
        args.modelId = modelId
        args.vectorName = vectorName
        args.vectorConfig = vectorConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createVectorField failed: unknown result")

    def updateVectorField(self, modelId, key, valueIndex, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - valueIndex
         - value
         - valueType
        """
        self.send_updateVectorField(modelId, key, valueIndex, value, valueType)
        return self.recv_updateVectorField()

    def send_updateVectorField(self, modelId, key, valueIndex, value, valueType):
        self._oprot.writeMessageBegin('updateVectorField', TMessageType.CALL, self._seqid)
        args = updateVectorField_args()
        args.modelId = modelId
        args.key = key
        args.valueIndex = valueIndex
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateVectorField failed: unknown result")

    def appendToVectorField(self, modelId, vectorName, value, valueType):
        """
        Parameters:
         - modelId
         - vectorName
         - value
         - valueType
        """
        self.send_appendToVectorField(modelId, vectorName, value, valueType)
        return self.recv_appendToVectorField()

    def send_appendToVectorField(self, modelId, vectorName, value, valueType):
        self._oprot.writeMessageBegin('appendToVectorField', TMessageType.CALL, self._seqid)
        args = appendToVectorField_args()
        args.modelId = modelId
        args.vectorName = vectorName
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_appendToVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = appendToVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "appendToVectorField failed: unknown result")

    def getModel(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_getModel(modelId)
        return self.recv_getModel()

    def send_getModel(self, modelId):
        self._oprot.writeMessageBegin('getModel', TMessageType.CALL, self._seqid)
        args = getModel_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModel failed: unknown result")

    def getRunsInExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        self.send_getRunsInExperiment(experimentId)
        return self.recv_getRunsInExperiment()

    def send_getRunsInExperiment(self, experimentId):
        self._oprot.writeMessageBegin('getRunsInExperiment', TMessageType.CALL, self._seqid)
        args = getRunsInExperiment_args()
        args.experimentId = experimentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunsInExperiment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunsInExperiment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunsInExperiment failed: unknown result")

    def getRunsAndExperimentsInProject(self, projId):
        """
        Parameters:
         - projId
        """
        self.send_getRunsAndExperimentsInProject(projId)
        return self.recv_getRunsAndExperimentsInProject()

    def send_getRunsAndExperimentsInProject(self, projId):
        self._oprot.writeMessageBegin('getRunsAndExperimentsInProject', TMessageType.CALL, self._seqid)
        args = getRunsAndExperimentsInProject_args()
        args.projId = projId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunsAndExperimentsInProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunsAndExperimentsInProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunsAndExperimentsInProject failed: unknown result")

    def getProjectOverviews(self):
        self.send_getProjectOverviews()
        return self.recv_getProjectOverviews()

    def send_getProjectOverviews(self):
        self._oprot.writeMessageBegin('getProjectOverviews', TMessageType.CALL, self._seqid)
        args = getProjectOverviews_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProjectOverviews(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProjectOverviews_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProjectOverviews failed: unknown result")

    def getExperimentRunDetails(self, experimentRunId):
        """
        Parameters:
         - experimentRunId
        """
        self.send_getExperimentRunDetails(experimentRunId)
        return self.recv_getExperimentRunDetails()

    def send_getExperimentRunDetails(self, experimentRunId):
        self._oprot.writeMessageBegin('getExperimentRunDetails', TMessageType.CALL, self._seqid)
        args = getExperimentRunDetails_args()
        args.experimentRunId = experimentRunId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getExperimentRunDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getExperimentRunDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        if result.rnfEx is not None:
            raise result.rnfEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getExperimentRunDetails failed: unknown result")

    def originalFeatures(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_originalFeatures(modelId)
        return self.recv_originalFeatures()

    def send_originalFeatures(self, modelId):
        self._oprot.writeMessageBegin('originalFeatures', TMessageType.CALL, self._seqid)
        args = originalFeatures_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_originalFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = originalFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "originalFeatures failed: unknown result")

    def storeTreeModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        self.send_storeTreeModel(modelId, model)
        return self.recv_storeTreeModel()

    def send_storeTreeModel(self, modelId, model):
        self._oprot.writeMessageBegin('storeTreeModel', TMessageType.CALL, self._seqid)
        args = storeTreeModel_args()
        args.modelId = modelId
        args.model = model
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeTreeModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeTreeModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeTreeModel failed: unknown result")

    def storePipelineTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        self.send_storePipelineTransformEvent(te)
        return self.recv_storePipelineTransformEvent()

    def send_storePipelineTransformEvent(self, te):
        self._oprot.writeMessageBegin('storePipelineTransformEvent', TMessageType.CALL, self._seqid)
        args = storePipelineTransformEvent_args()
        args.te = te
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storePipelineTransformEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storePipelineTransformEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storePipelineTransformEvent failed: unknown result")

    def computeModelAncestry(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_computeModelAncestry(modelId)
        return self.recv_computeModelAncestry()

    def send_computeModelAncestry(self, modelId):
        self._oprot.writeMessageBegin('computeModelAncestry', TMessageType.CALL, self._seqid)
        args = computeModelAncestry_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeModelAncestry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeModelAncestry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeModelAncestry failed: unknown result")

    def extractPipeline(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_extractPipeline(modelId)
        return self.recv_extractPipeline()

    def send_extractPipeline(self, modelId):
        self._oprot.writeMessageBegin('extractPipeline', TMessageType.CALL, self._seqid)
        args = extractPipeline_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_extractPipeline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = extractPipeline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "extractPipeline failed: unknown result")

    def createProject(self, project):
        """
        Parameters:
         - project
        """
        self.send_createProject(project)
        return self.recv_createProject()

    def send_createProject(self, project):
        self._oprot.writeMessageBegin('createProject', TMessageType.CALL, self._seqid)
        args = createProject_args()
        args.project = project
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createProject failed: unknown result")

    def createExperiment(self, experiment):
        """
        Parameters:
         - experiment
        """
        self.send_createExperiment(experiment)
        return self.recv_createExperiment()

    def send_createExperiment(self, experiment):
        self._oprot.writeMessageBegin('createExperiment', TMessageType.CALL, self._seqid)
        args = createExperiment_args()
        args.experiment = experiment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createExperiment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createExperiment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createExperiment failed: unknown result")

    def createExperimentRun(self, experimentRun):
        """
        Parameters:
         - experimentRun
        """
        self.send_createExperimentRun(experimentRun)
        return self.recv_createExperimentRun()

    def send_createExperimentRun(self, experimentRun):
        self._oprot.writeMessageBegin('createExperimentRun', TMessageType.CALL, self._seqid)
        args = createExperimentRun_args()
        args.experimentRun = experimentRun
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createExperimentRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createExperimentRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createExperimentRun failed: unknown result")

    def API_updateProject(self, projectId, updatedKVs):
        """
        Parameters:
         - projectId
         - updatedKVs
        """
        self.send_API_updateProject(projectId, updatedKVs)
        return self.recv_API_updateProject()

    def send_API_updateProject(self, projectId, updatedKVs):
        self._oprot.writeMessageBegin('API_updateProject', TMessageType.CALL, self._seqid)
        args = API_updateProject_args()
        args.projectId = projectId
        args.updatedKVs = updatedKVs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_API_updateProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = API_updateProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "API_updateProject failed: unknown result")

    def updateExperiment(self, experimentId, updatedKVs):
        """
        Parameters:
         - experimentId
         - updatedKVs
        """
        self.send_updateExperiment(experimentId, updatedKVs)
        return self.recv_updateExperiment()

    def send_updateExperiment(self, experimentId, updatedKVs):
        self._oprot.writeMessageBegin('updateExperiment', TMessageType.CALL, self._seqid)
        args = updateExperiment_args()
        args.experimentId = experimentId
        args.updatedKVs = updatedKVs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateExperiment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateExperiment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateExperiment failed: unknown result")

    def updateExperimentRun(self, experimentRunId, updatedKVs):
        """
        Parameters:
         - experimentRunId
         - updatedKVs
        """
        self.send_updateExperimentRun(experimentRunId, updatedKVs)
        return self.recv_updateExperimentRun()

    def send_updateExperimentRun(self, experimentRunId, updatedKVs):
        self._oprot.writeMessageBegin('updateExperimentRun', TMessageType.CALL, self._seqid)
        args = updateExperimentRun_args()
        args.experimentRunId = experimentRunId
        args.updatedKVs = updatedKVs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateExperimentRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateExperimentRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateExperimentRun failed: unknown result")

    def getProject(self, projectId):
        """
        Parameters:
         - projectId
        """
        self.send_getProject(projectId)
        return self.recv_getProject()

    def send_getProject(self, projectId):
        self._oprot.writeMessageBegin('getProject', TMessageType.CALL, self._seqid)
        args = getProject_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        if result.rnfEx is not None:
            raise result.rnfEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProject failed: unknown result")

    def getExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        self.send_getExperiment(experimentId)
        return self.recv_getExperiment()

    def send_getExperiment(self, experimentId):
        self._oprot.writeMessageBegin('getExperiment', TMessageType.CALL, self._seqid)
        args = getExperiment_args()
        args.experimentId = experimentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getExperiment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getExperiment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        if result.rnfEx is not None:
            raise result.rnfEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getExperiment failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["testConnection"] = Processor.process_testConnection
        self._processMap["storeDataFrame"] = Processor.process_storeDataFrame
        self._processMap["pathForTransformer"] = Processor.process_pathForTransformer
        self._processMap["storeFitEvent"] = Processor.process_storeFitEvent
        self._processMap["storeMetricEvent"] = Processor.process_storeMetricEvent
        self._processMap["getFilePath"] = Processor.process_getFilePath
        self._processMap["storeTransformEvent"] = Processor.process_storeTransformEvent
        self._processMap["storeRandomSplitEvent"] = Processor.process_storeRandomSplitEvent
        self._processMap["storePipelineEvent"] = Processor.process_storePipelineEvent
        self._processMap["storeCrossValidationEvent"] = Processor.process_storeCrossValidationEvent
        self._processMap["storeGridSearchCrossValidationEvent"] = Processor.process_storeGridSearchCrossValidationEvent
        self._processMap["storeAnnotationEvent"] = Processor.process_storeAnnotationEvent
        self._processMap["storeProjectEvent"] = Processor.process_storeProjectEvent
        self._processMap["storeExperimentEvent"] = Processor.process_storeExperimentEvent
        self._processMap["storeExperimentRunEvent"] = Processor.process_storeExperimentRunEvent
        self._processMap["storeLinearModel"] = Processor.process_storeLinearModel
        self._processMap["getDataFrameAncestry"] = Processor.process_getDataFrameAncestry
        self._processMap["getCommonAncestor"] = Processor.process_getCommonAncestor
        self._processMap["getCommonAncestorForModels"] = Processor.process_getCommonAncestorForModels
        self._processMap["getTrainingRowsCount"] = Processor.process_getTrainingRowsCount
        self._processMap["getTrainingRowsCounts"] = Processor.process_getTrainingRowsCounts
        self._processMap["compareHyperparameters"] = Processor.process_compareHyperparameters
        self._processMap["compareFeatures"] = Processor.process_compareFeatures
        self._processMap["groupByProblemType"] = Processor.process_groupByProblemType
        self._processMap["similarModels"] = Processor.process_similarModels
        self._processMap["linearModelFeatureImportances"] = Processor.process_linearModelFeatureImportances
        self._processMap["compareLinearModelFeatureImportances"] = Processor.process_compareLinearModelFeatureImportances
        self._processMap["iterationsUntilConvergence"] = Processor.process_iterationsUntilConvergence
        self._processMap["rankModels"] = Processor.process_rankModels
        self._processMap["confidenceIntervals"] = Processor.process_confidenceIntervals
        self._processMap["modelsWithFeatures"] = Processor.process_modelsWithFeatures
        self._processMap["modelsDerivedFromDataFrame"] = Processor.process_modelsDerivedFromDataFrame
        self._processMap["getProjectIds"] = Processor.process_getProjectIds
        self._processMap["getModelIds"] = Processor.process_getModelIds
        self._processMap["updateProject"] = Processor.process_updateProject
        self._processMap["createOrUpdateScalarField"] = Processor.process_createOrUpdateScalarField
        self._processMap["createVectorField"] = Processor.process_createVectorField
        self._processMap["updateVectorField"] = Processor.process_updateVectorField
        self._processMap["appendToVectorField"] = Processor.process_appendToVectorField
        self._processMap["getModel"] = Processor.process_getModel
        self._processMap["getRunsInExperiment"] = Processor.process_getRunsInExperiment
        self._processMap["getRunsAndExperimentsInProject"] = Processor.process_getRunsAndExperimentsInProject
        self._processMap["getProjectOverviews"] = Processor.process_getProjectOverviews
        self._processMap["getExperimentRunDetails"] = Processor.process_getExperimentRunDetails
        self._processMap["originalFeatures"] = Processor.process_originalFeatures
        self._processMap["storeTreeModel"] = Processor.process_storeTreeModel
        self._processMap["storePipelineTransformEvent"] = Processor.process_storePipelineTransformEvent
        self._processMap["computeModelAncestry"] = Processor.process_computeModelAncestry
        self._processMap["extractPipeline"] = Processor.process_extractPipeline
        self._processMap["createProject"] = Processor.process_createProject
        self._processMap["createExperiment"] = Processor.process_createExperiment
        self._processMap["createExperimentRun"] = Processor.process_createExperimentRun
        self._processMap["API_updateProject"] = Processor.process_API_updateProject
        self._processMap["updateExperiment"] = Processor.process_updateExperiment
        self._processMap["updateExperimentRun"] = Processor.process_updateExperimentRun
        self._processMap["getProject"] = Processor.process_getProject
        self._processMap["getExperiment"] = Processor.process_getExperiment

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_testConnection(self, seqid, iprot, oprot):
        args = testConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testConnection_result()
        try:
            result.success = self._handler.testConnection()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testConnection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeDataFrame(self, seqid, iprot, oprot):
        args = storeDataFrame_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeDataFrame_result()
        try:
            result.success = self._handler.storeDataFrame(args.df, args.experimentRunId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeDataFrame", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pathForTransformer(self, seqid, iprot, oprot):
        args = pathForTransformer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pathForTransformer_result()
        try:
            result.success = self._handler.pathForTransformer(args.transformerId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except InvalidFieldException as efEx:
            msg_type = TMessageType.REPLY
            result.efEx = efEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pathForTransformer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeFitEvent(self, seqid, iprot, oprot):
        args = storeFitEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeFitEvent_result()
        try:
            result.success = self._handler.storeFitEvent(args.fe)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeFitEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeMetricEvent(self, seqid, iprot, oprot):
        args = storeMetricEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeMetricEvent_result()
        try:
            result.success = self._handler.storeMetricEvent(args.me)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeMetricEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFilePath(self, seqid, iprot, oprot):
        args = getFilePath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFilePath_result()
        try:
            result.success = self._handler.getFilePath(args.t, args.experimentRunId, args.filename)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFilePath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeTransformEvent(self, seqid, iprot, oprot):
        args = storeTransformEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeTransformEvent_result()
        try:
            result.success = self._handler.storeTransformEvent(args.te)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeTransformEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeRandomSplitEvent(self, seqid, iprot, oprot):
        args = storeRandomSplitEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeRandomSplitEvent_result()
        try:
            result.success = self._handler.storeRandomSplitEvent(args.rse)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeRandomSplitEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storePipelineEvent(self, seqid, iprot, oprot):
        args = storePipelineEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storePipelineEvent_result()
        try:
            result.success = self._handler.storePipelineEvent(args.pipelineEvent)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storePipelineEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeCrossValidationEvent(self, seqid, iprot, oprot):
        args = storeCrossValidationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeCrossValidationEvent_result()
        try:
            result.success = self._handler.storeCrossValidationEvent(args.cve)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeCrossValidationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeGridSearchCrossValidationEvent(self, seqid, iprot, oprot):
        args = storeGridSearchCrossValidationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeGridSearchCrossValidationEvent_result()
        try:
            result.success = self._handler.storeGridSearchCrossValidationEvent(args.gscve)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeGridSearchCrossValidationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeAnnotationEvent(self, seqid, iprot, oprot):
        args = storeAnnotationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeAnnotationEvent_result()
        try:
            result.success = self._handler.storeAnnotationEvent(args.ae)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeAnnotationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeProjectEvent(self, seqid, iprot, oprot):
        args = storeProjectEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeProjectEvent_result()
        try:
            result.success = self._handler.storeProjectEvent(args.pr)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeProjectEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeExperimentEvent(self, seqid, iprot, oprot):
        args = storeExperimentEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeExperimentEvent_result()
        try:
            result.success = self._handler.storeExperimentEvent(args.er)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeExperimentEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeExperimentRunEvent(self, seqid, iprot, oprot):
        args = storeExperimentRunEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeExperimentRunEvent_result()
        try:
            result.success = self._handler.storeExperimentRunEvent(args.er)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeExperimentRunEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeLinearModel(self, seqid, iprot, oprot):
        args = storeLinearModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeLinearModel_result()
        try:
            result.success = self._handler.storeLinearModel(args.modelId, args.model)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeLinearModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataFrameAncestry(self, seqid, iprot, oprot):
        args = getDataFrameAncestry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataFrameAncestry_result()
        try:
            result.success = self._handler.getDataFrameAncestry(args.dataFrameId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataFrameAncestry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonAncestor(self, seqid, iprot, oprot):
        args = getCommonAncestor_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonAncestor_result()
        try:
            result.success = self._handler.getCommonAncestor(args.dfId1, args.dfId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonAncestor", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonAncestorForModels(self, seqid, iprot, oprot):
        args = getCommonAncestorForModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonAncestorForModels_result()
        try:
            result.success = self._handler.getCommonAncestorForModels(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonAncestorForModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTrainingRowsCount(self, seqid, iprot, oprot):
        args = getTrainingRowsCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTrainingRowsCount_result()
        try:
            result.success = self._handler.getTrainingRowsCount(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTrainingRowsCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTrainingRowsCounts(self, seqid, iprot, oprot):
        args = getTrainingRowsCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTrainingRowsCounts_result()
        try:
            result.success = self._handler.getTrainingRowsCounts(args.modelIds)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTrainingRowsCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareHyperparameters(self, seqid, iprot, oprot):
        args = compareHyperparameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareHyperparameters_result()
        try:
            result.success = self._handler.compareHyperparameters(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareHyperparameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareFeatures(self, seqid, iprot, oprot):
        args = compareFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareFeatures_result()
        try:
            result.success = self._handler.compareFeatures(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_groupByProblemType(self, seqid, iprot, oprot):
        args = groupByProblemType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = groupByProblemType_result()
        try:
            result.success = self._handler.groupByProblemType(args.modelIds)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("groupByProblemType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_similarModels(self, seqid, iprot, oprot):
        args = similarModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = similarModels_result()
        try:
            result.success = self._handler.similarModels(args.modelId, args.compMetrics, args.numModels)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except BadRequestException as brEx:
            msg_type = TMessageType.REPLY
            result.brEx = brEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("similarModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_linearModelFeatureImportances(self, seqid, iprot, oprot):
        args = linearModelFeatureImportances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = linearModelFeatureImportances_result()
        try:
            result.success = self._handler.linearModelFeatureImportances(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("linearModelFeatureImportances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareLinearModelFeatureImportances(self, seqid, iprot, oprot):
        args = compareLinearModelFeatureImportances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareLinearModelFeatureImportances_result()
        try:
            result.success = self._handler.compareLinearModelFeatureImportances(args.model1Id, args.model2Id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareLinearModelFeatureImportances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_iterationsUntilConvergence(self, seqid, iprot, oprot):
        args = iterationsUntilConvergence_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = iterationsUntilConvergence_result()
        try:
            result.success = self._handler.iterationsUntilConvergence(args.modelIds, args.tolerance)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("iterationsUntilConvergence", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rankModels(self, seqid, iprot, oprot):
        args = rankModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rankModels_result()
        try:
            result.success = self._handler.rankModels(args.modelIds, args.metric)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rankModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_confidenceIntervals(self, seqid, iprot, oprot):
        args = confidenceIntervals_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = confidenceIntervals_result()
        try:
            result.success = self._handler.confidenceIntervals(args.modelId, args.sigLevel)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except BadRequestException as brEx:
            msg_type = TMessageType.REPLY
            result.brEx = brEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("confidenceIntervals", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modelsWithFeatures(self, seqid, iprot, oprot):
        args = modelsWithFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modelsWithFeatures_result()
        try:
            result.success = self._handler.modelsWithFeatures(args.featureNames)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modelsWithFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modelsDerivedFromDataFrame(self, seqid, iprot, oprot):
        args = modelsDerivedFromDataFrame_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modelsDerivedFromDataFrame_result()
        try:
            result.success = self._handler.modelsDerivedFromDataFrame(args.dfId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modelsDerivedFromDataFrame", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProjectIds(self, seqid, iprot, oprot):
        args = getProjectIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProjectIds_result()
        try:
            result.success = self._handler.getProjectIds(args.keyValuePairs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProjectIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModelIds(self, seqid, iprot, oprot):
        args = getModelIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModelIds_result()
        try:
            result.success = self._handler.getModelIds(args.keyValuePairs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModelIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateProject(self, seqid, iprot, oprot):
        args = updateProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProject_result()
        try:
            result.success = self._handler.updateProject(args.projectId, args.key, args.value)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createOrUpdateScalarField(self, seqid, iprot, oprot):
        args = createOrUpdateScalarField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createOrUpdateScalarField_result()
        try:
            result.success = self._handler.createOrUpdateScalarField(args.modelId, args.key, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createOrUpdateScalarField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createVectorField(self, seqid, iprot, oprot):
        args = createVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createVectorField_result()
        try:
            result.success = self._handler.createVectorField(args.modelId, args.vectorName, args.vectorConfig)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateVectorField(self, seqid, iprot, oprot):
        args = updateVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateVectorField_result()
        try:
            result.success = self._handler.updateVectorField(args.modelId, args.key, args.valueIndex, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_appendToVectorField(self, seqid, iprot, oprot):
        args = appendToVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = appendToVectorField_result()
        try:
            result.success = self._handler.appendToVectorField(args.modelId, args.vectorName, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("appendToVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModel(self, seqid, iprot, oprot):
        args = getModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModel_result()
        try:
            result.success = self._handler.getModel(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunsInExperiment(self, seqid, iprot, oprot):
        args = getRunsInExperiment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunsInExperiment_result()
        try:
            result.success = self._handler.getRunsInExperiment(args.experimentId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunsInExperiment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunsAndExperimentsInProject(self, seqid, iprot, oprot):
        args = getRunsAndExperimentsInProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunsAndExperimentsInProject_result()
        try:
            result.success = self._handler.getRunsAndExperimentsInProject(args.projId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunsAndExperimentsInProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProjectOverviews(self, seqid, iprot, oprot):
        args = getProjectOverviews_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProjectOverviews_result()
        try:
            result.success = self._handler.getProjectOverviews()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProjectOverviews", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getExperimentRunDetails(self, seqid, iprot, oprot):
        args = getExperimentRunDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getExperimentRunDetails_result()
        try:
            result.success = self._handler.getExperimentRunDetails(args.experimentRunId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getExperimentRunDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_originalFeatures(self, seqid, iprot, oprot):
        args = originalFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = originalFeatures_result()
        try:
            result.success = self._handler.originalFeatures(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("originalFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeTreeModel(self, seqid, iprot, oprot):
        args = storeTreeModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeTreeModel_result()
        try:
            result.success = self._handler.storeTreeModel(args.modelId, args.model)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeTreeModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storePipelineTransformEvent(self, seqid, iprot, oprot):
        args = storePipelineTransformEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storePipelineTransformEvent_result()
        try:
            result.success = self._handler.storePipelineTransformEvent(args.te)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storePipelineTransformEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeModelAncestry(self, seqid, iprot, oprot):
        args = computeModelAncestry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeModelAncestry_result()
        try:
            result.success = self._handler.computeModelAncestry(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeModelAncestry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_extractPipeline(self, seqid, iprot, oprot):
        args = extractPipeline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = extractPipeline_result()
        try:
            result.success = self._handler.extractPipeline(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("extractPipeline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createProject(self, seqid, iprot, oprot):
        args = createProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createProject_result()
        try:
            result.success = self._handler.createProject(args.project)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createExperiment(self, seqid, iprot, oprot):
        args = createExperiment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createExperiment_result()
        try:
            result.success = self._handler.createExperiment(args.experiment)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createExperiment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createExperimentRun(self, seqid, iprot, oprot):
        args = createExperimentRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createExperimentRun_result()
        try:
            result.success = self._handler.createExperimentRun(args.experimentRun)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createExperimentRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_API_updateProject(self, seqid, iprot, oprot):
        args = API_updateProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = API_updateProject_result()
        try:
            result.success = self._handler.API_updateProject(args.projectId, args.updatedKVs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("API_updateProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateExperiment(self, seqid, iprot, oprot):
        args = updateExperiment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateExperiment_result()
        try:
            result.success = self._handler.updateExperiment(args.experimentId, args.updatedKVs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateExperiment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateExperimentRun(self, seqid, iprot, oprot):
        args = updateExperimentRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateExperimentRun_result()
        try:
            result.success = self._handler.updateExperimentRun(args.experimentRunId, args.updatedKVs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateExperimentRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProject(self, seqid, iprot, oprot):
        args = getProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProject_result()
        try:
            result.success = self._handler.getProject(args.projectId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getExperiment(self, seqid, iprot, oprot):
        args = getExperiment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getExperiment_result()
        try:
            result.success = self._handler.getExperiment(args.experimentId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getExperiment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class testConnection_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('testConnection_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class testConnection_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('testConnection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeDataFrame_args(object):
    """
    Attributes:
     - df
     - experimentRunId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ),  # 1
        (2, TType.I32, 'experimentRunId', None, None, ),  # 2
    )

    def __init__(self, df=None, experimentRunId=None,):
        self.df = df
        self.experimentRunId = experimentRunId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.df = DataFrame()
                    self.df.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeDataFrame_args')
        if self.df is not None:
            oprot.writeFieldBegin('df', TType.STRUCT, 1)
            self.df.write(oprot)
            oprot.writeFieldEnd()
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeDataFrame_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeDataFrame_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class pathForTransformer_args(object):
    """
    Attributes:
     - transformerId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'transformerId', None, None, ),  # 1
    )

    def __init__(self, transformerId=None,):
        self.transformerId = transformerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.transformerId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('pathForTransformer_args')
        if self.transformerId is not None:
            oprot.writeFieldBegin('transformerId', TType.I32, 1)
            oprot.writeI32(self.transformerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class pathForTransformer_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - efEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'efEx', (InvalidFieldException, InvalidFieldException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, efEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.efEx = efEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.efEx = InvalidFieldException()
                    self.efEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('pathForTransformer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.efEx is not None:
            oprot.writeFieldBegin('efEx', TType.STRUCT, 2)
            self.efEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeFitEvent_args(object):
    """
    Attributes:
     - fe
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'fe', (FitEvent, FitEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, fe=None,):
        self.fe = fe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = FitEvent()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeFitEvent_args')
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeFitEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (FitEventResponse, FitEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FitEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeFitEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeMetricEvent_args(object):
    """
    Attributes:
     - me
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'me', (MetricEvent, MetricEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, me=None,):
        self.me = me

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.me = MetricEvent()
                    self.me.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeMetricEvent_args')
        if self.me is not None:
            oprot.writeFieldBegin('me', TType.STRUCT, 1)
            self.me.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeMetricEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (MetricEventResponse, MetricEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MetricEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeMetricEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilePath_args(object):
    """
    Attributes:
     - t
     - experimentRunId
     - filename
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 't', (Transformer, Transformer.thrift_spec), None, ),  # 1
        (2, TType.I32, 'experimentRunId', None, None, ),  # 2
        (3, TType.STRING, 'filename', 'UTF8', None, ),  # 3
    )

    def __init__(self, t=None, experimentRunId=None, filename=None,):
        self.t = t
        self.experimentRunId = experimentRunId
        self.filename = filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.t = Transformer()
                    self.t.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilePath_args')
        if self.t is not None:
            oprot.writeFieldBegin('t', TType.STRUCT, 1)
            self.t.write(oprot)
            oprot.writeFieldEnd()
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 3)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilePath_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilePath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTransformEvent_args(object):
    """
    Attributes:
     - te
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'te', (TransformEvent, TransformEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, te=None,):
        self.te = te

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.te = TransformEvent()
                    self.te.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTransformEvent_args')
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.STRUCT, 1)
            self.te.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTransformEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (TransformEventResponse, TransformEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TransformEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTransformEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeRandomSplitEvent_args(object):
    """
    Attributes:
     - rse
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rse', (RandomSplitEvent, RandomSplitEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, rse=None,):
        self.rse = rse

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rse = RandomSplitEvent()
                    self.rse.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeRandomSplitEvent_args')
        if self.rse is not None:
            oprot.writeFieldBegin('rse', TType.STRUCT, 1)
            self.rse.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeRandomSplitEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RandomSplitEventResponse, RandomSplitEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RandomSplitEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeRandomSplitEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineEvent_args(object):
    """
    Attributes:
     - pipelineEvent
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'pipelineEvent', (PipelineEvent, PipelineEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, pipelineEvent=None,):
        self.pipelineEvent = pipelineEvent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pipelineEvent = PipelineEvent()
                    self.pipelineEvent.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineEvent_args')
        if self.pipelineEvent is not None:
            oprot.writeFieldBegin('pipelineEvent', TType.STRUCT, 1)
            self.pipelineEvent.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PipelineEventResponse, PipelineEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PipelineEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeCrossValidationEvent_args(object):
    """
    Attributes:
     - cve
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'cve', (CrossValidationEvent, CrossValidationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, cve=None,):
        self.cve = cve

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cve = CrossValidationEvent()
                    self.cve.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeCrossValidationEvent_args')
        if self.cve is not None:
            oprot.writeFieldBegin('cve', TType.STRUCT, 1)
            self.cve.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeCrossValidationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CrossValidationEventResponse, CrossValidationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CrossValidationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeCrossValidationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeGridSearchCrossValidationEvent_args(object):
    """
    Attributes:
     - gscve
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'gscve', (GridSearchCrossValidationEvent, GridSearchCrossValidationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, gscve=None,):
        self.gscve = gscve

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.gscve = GridSearchCrossValidationEvent()
                    self.gscve.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeGridSearchCrossValidationEvent_args')
        if self.gscve is not None:
            oprot.writeFieldBegin('gscve', TType.STRUCT, 1)
            self.gscve.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeGridSearchCrossValidationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GridSearchCrossValidationEventResponse, GridSearchCrossValidationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GridSearchCrossValidationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeGridSearchCrossValidationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeAnnotationEvent_args(object):
    """
    Attributes:
     - ae
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'ae', (AnnotationEvent, AnnotationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, ae=None,):
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = AnnotationEvent()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeAnnotationEvent_args')
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeAnnotationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (AnnotationEventResponse, AnnotationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AnnotationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeAnnotationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeProjectEvent_args(object):
    """
    Attributes:
     - pr
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'pr', (ProjectEvent, ProjectEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, pr=None,):
        self.pr = pr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pr = ProjectEvent()
                    self.pr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeProjectEvent_args')
        if self.pr is not None:
            oprot.writeFieldBegin('pr', TType.STRUCT, 1)
            self.pr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeProjectEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProjectEventResponse, ProjectEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProjectEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeProjectEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentEvent_args(object):
    """
    Attributes:
     - er
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'er', (ExperimentEvent, ExperimentEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, er=None,):
        self.er = er

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.er = ExperimentEvent()
                    self.er.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentEvent_args')
        if self.er is not None:
            oprot.writeFieldBegin('er', TType.STRUCT, 1)
            self.er.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentEventResponse, ExperimentEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentRunEvent_args(object):
    """
    Attributes:
     - er
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'er', (ExperimentRunEvent, ExperimentRunEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, er=None,):
        self.er = er

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.er = ExperimentRunEvent()
                    self.er.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentRunEvent_args')
        if self.er is not None:
            oprot.writeFieldBegin('er', TType.STRUCT, 1)
            self.er.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentRunEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentRunEventResponse, ExperimentRunEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentRunEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentRunEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeLinearModel_args(object):
    """
    Attributes:
     - modelId
     - model
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRUCT, 'model', (LinearModel, LinearModel.thrift_spec), None, ),  # 2
    )

    def __init__(self, modelId=None, model=None,):
        self.modelId = modelId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.model = LinearModel()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeLinearModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 2)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeLinearModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeLinearModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDataFrameAncestry_args(object):
    """
    Attributes:
     - dataFrameId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dataFrameId', None, None, ),  # 1
    )

    def __init__(self, dataFrameId=None,):
        self.dataFrameId = dataFrameId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataFrameId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDataFrameAncestry_args')
        if self.dataFrameId is not None:
            oprot.writeFieldBegin('dataFrameId', TType.I32, 1)
            oprot.writeI32(self.dataFrameId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDataFrameAncestry_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (DataFrameAncestry, DataFrameAncestry.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DataFrameAncestry()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDataFrameAncestry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestor_args(object):
    """
    Attributes:
     - dfId1
     - dfId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dfId1', None, None, ),  # 1
        (2, TType.I32, 'dfId2', None, None, ),  # 2
    )

    def __init__(self, dfId1=None, dfId2=None,):
        self.dfId1 = dfId1
        self.dfId2 = dfId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dfId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dfId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestor_args')
        if self.dfId1 is not None:
            oprot.writeFieldBegin('dfId1', TType.I32, 1)
            oprot.writeI32(self.dfId1)
            oprot.writeFieldEnd()
        if self.dfId2 is not None:
            oprot.writeFieldBegin('dfId2', TType.I32, 2)
            oprot.writeI32(self.dfId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestor_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CommonAncestor()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestor_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestorForModels_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestorForModels_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestorForModels_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CommonAncestor()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestorForModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCount_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCount_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCount_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCounts_args(object):
    """
    Attributes:
     - modelIds
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
    )

    def __init__(self, modelIds=None,):
        self.modelIds = modelIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype395, _size392) = iprot.readListBegin()
                    for _i396 in range(_size392):
                        _elem397 = iprot.readI32()
                        self.modelIds.append(_elem397)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCounts_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter398 in self.modelIds:
                oprot.writeI32(iter398)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCounts_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = iprot.readI32()
                        self.success.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter405 in self.success:
                oprot.writeI32(iter405)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareHyperparameters_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareHyperparameters_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareHyperparameters_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CompareHyperParametersResponse, CompareHyperParametersResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompareHyperParametersResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareHyperparameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareFeatures_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareFeatures_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareFeatures_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CompareFeaturesResponse, CompareFeaturesResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompareFeaturesResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class groupByProblemType_args(object):
    """
    Attributes:
     - modelIds
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
    )

    def __init__(self, modelIds=None,):
        self.modelIds = modelIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = iprot.readI32()
                        self.modelIds.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('groupByProblemType_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter412 in self.modelIds:
                oprot.writeI32(iter412)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class groupByProblemType_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.MAP, 'success', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype414, _vtype415, _size413) = iprot.readMapBegin()
                    for _i417 in range(_size413):
                        _key418 = iprot.readI32()
                        _val419 = []
                        (_etype423, _size420) = iprot.readListBegin()
                        for _i424 in range(_size420):
                            _elem425 = iprot.readI32()
                            _val419.append(_elem425)
                        iprot.readListEnd()
                        self.success[_key418] = _val419
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('groupByProblemType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.success))
            for kiter426, viter427 in self.success.items():
                oprot.writeI32(kiter426)
                oprot.writeListBegin(TType.I32, len(viter427))
                for iter428 in viter427:
                    oprot.writeI32(iter428)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class similarModels_args(object):
    """
    Attributes:
     - modelId
     - compMetrics
     - numModels
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.LIST, 'compMetrics', (TType.I32, None, False), None, ),  # 2
        (3, TType.I32, 'numModels', None, None, ),  # 3
    )

    def __init__(self, modelId=None, compMetrics=None, numModels=None,):
        self.modelId = modelId
        self.compMetrics = compMetrics
        self.numModels = numModels

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.compMetrics = []
                    (_etype432, _size429) = iprot.readListBegin()
                    for _i433 in range(_size429):
                        _elem434 = iprot.readI32()
                        self.compMetrics.append(_elem434)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.numModels = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('similarModels_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.compMetrics is not None:
            oprot.writeFieldBegin('compMetrics', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.compMetrics))
            for iter435 in self.compMetrics:
                oprot.writeI32(iter435)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.numModels is not None:
            oprot.writeFieldBegin('numModels', TType.I32, 3)
            oprot.writeI32(self.numModels)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class similarModels_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - brEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, brEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.brEx = brEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype439, _size436) = iprot.readListBegin()
                    for _i440 in range(_size436):
                        _elem441 = iprot.readI32()
                        self.success.append(_elem441)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.brEx = BadRequestException()
                    self.brEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('similarModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter442 in self.success:
                oprot.writeI32(iter442)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.brEx is not None:
            oprot.writeFieldBegin('brEx', TType.STRUCT, 2)
            self.brEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linearModelFeatureImportances_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('linearModelFeatureImportances_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linearModelFeatureImportances_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype446, _size443) = iprot.readListBegin()
                    for _i447 in range(_size443):
                        _elem448 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem448)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('linearModelFeatureImportances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter449 in self.success:
                oprot.writeString(iter449.encode('utf-8') if sys.version_info[0] == 2 else iter449)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareLinearModelFeatureImportances_args(object):
    """
    Attributes:
     - model1Id
     - model2Id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'model1Id', None, None, ),  # 1
        (2, TType.I32, 'model2Id', None, None, ),  # 2
    )

    def __init__(self, model1Id=None, model2Id=None,):
        self.model1Id = model1Id
        self.model2Id = model2Id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.model1Id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.model2Id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareLinearModelFeatureImportances_args')
        if self.model1Id is not None:
            oprot.writeFieldBegin('model1Id', TType.I32, 1)
            oprot.writeI32(self.model1Id)
            oprot.writeFieldEnd()
        if self.model2Id is not None:
            oprot.writeFieldBegin('model2Id', TType.I32, 2)
            oprot.writeI32(self.model2Id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareLinearModelFeatureImportances_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FeatureImportanceComparison, FeatureImportanceComparison.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype453, _size450) = iprot.readListBegin()
                    for _i454 in range(_size450):
                        _elem455 = FeatureImportanceComparison()
                        _elem455.read(iprot)
                        self.success.append(_elem455)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareLinearModelFeatureImportances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter456 in self.success:
                iter456.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class iterationsUntilConvergence_args(object):
    """
    Attributes:
     - modelIds
     - tolerance
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
        (2, TType.DOUBLE, 'tolerance', None, None, ),  # 2
    )

    def __init__(self, modelIds=None, tolerance=None,):
        self.modelIds = modelIds
        self.tolerance = tolerance

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype460, _size457) = iprot.readListBegin()
                    for _i461 in range(_size457):
                        _elem462 = iprot.readI32()
                        self.modelIds.append(_elem462)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.tolerance = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('iterationsUntilConvergence_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter463 in self.modelIds:
                oprot.writeI32(iter463)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tolerance is not None:
            oprot.writeFieldBegin('tolerance', TType.DOUBLE, 2)
            oprot.writeDouble(self.tolerance)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class iterationsUntilConvergence_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype467, _size464) = iprot.readListBegin()
                    for _i468 in range(_size464):
                        _elem469 = iprot.readI32()
                        self.success.append(_elem469)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('iterationsUntilConvergence_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter470 in self.success:
                oprot.writeI32(iter470)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rankModels_args(object):
    """
    Attributes:
     - modelIds
     - metric
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
        (2, TType.I32, 'metric', None, None, ),  # 2
    )

    def __init__(self, modelIds=None, metric=None,):
        self.modelIds = modelIds
        self.metric = metric

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype474, _size471) = iprot.readListBegin()
                    for _i475 in range(_size471):
                        _elem476 = iprot.readI32()
                        self.modelIds.append(_elem476)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.metric = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rankModels_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter477 in self.modelIds:
                oprot.writeI32(iter477)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metric is not None:
            oprot.writeFieldBegin('metric', TType.I32, 2)
            oprot.writeI32(self.metric)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rankModels_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype481, _size478) = iprot.readListBegin()
                    for _i482 in range(_size478):
                        _elem483 = iprot.readI32()
                        self.success.append(_elem483)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rankModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter484 in self.success:
                oprot.writeI32(iter484)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class confidenceIntervals_args(object):
    """
    Attributes:
     - modelId
     - sigLevel
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.DOUBLE, 'sigLevel', None, None, ),  # 2
    )

    def __init__(self, modelId=None, sigLevel=None,):
        self.modelId = modelId
        self.sigLevel = sigLevel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.sigLevel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('confidenceIntervals_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.sigLevel is not None:
            oprot.writeFieldBegin('sigLevel', TType.DOUBLE, 2)
            oprot.writeDouble(self.sigLevel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class confidenceIntervals_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - brEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ConfidenceInterval, ConfidenceInterval.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, brEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.brEx = brEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = ConfidenceInterval()
                        _elem490.read(iprot)
                        self.success.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.brEx = BadRequestException()
                    self.brEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('confidenceIntervals_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter491 in self.success:
                iter491.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.brEx is not None:
            oprot.writeFieldBegin('brEx', TType.STRUCT, 3)
            self.brEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 4)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsWithFeatures_args(object):
    """
    Attributes:
     - featureNames
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'featureNames', (TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, featureNames=None,):
        self.featureNames = featureNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.featureNames = []
                    (_etype495, _size492) = iprot.readListBegin()
                    for _i496 in range(_size492):
                        _elem497 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.featureNames.append(_elem497)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsWithFeatures_args')
        if self.featureNames is not None:
            oprot.writeFieldBegin('featureNames', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.featureNames))
            for iter498 in self.featureNames:
                oprot.writeString(iter498.encode('utf-8') if sys.version_info[0] == 2 else iter498)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsWithFeatures_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = iprot.readI32()
                        self.success.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsWithFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter505 in self.success:
                oprot.writeI32(iter505)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsDerivedFromDataFrame_args(object):
    """
    Attributes:
     - dfId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dfId', None, None, ),  # 1
    )

    def __init__(self, dfId=None,):
        self.dfId = dfId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dfId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsDerivedFromDataFrame_args')
        if self.dfId is not None:
            oprot.writeFieldBegin('dfId', TType.I32, 1)
            oprot.writeI32(self.dfId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsDerivedFromDataFrame_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype509, _size506) = iprot.readListBegin()
                    for _i510 in range(_size506):
                        _elem511 = iprot.readI32()
                        self.success.append(_elem511)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsDerivedFromDataFrame_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter512 in self.success:
                oprot.writeI32(iter512)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectIds_args(object):
    """
    Attributes:
     - keyValuePairs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyValuePairs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, keyValuePairs=None,):
        self.keyValuePairs = keyValuePairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.keyValuePairs = {}
                    (_ktype514, _vtype515, _size513) = iprot.readMapBegin()
                    for _i517 in range(_size513):
                        _key518 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val519 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyValuePairs[_key518] = _val519
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectIds_args')
        if self.keyValuePairs is not None:
            oprot.writeFieldBegin('keyValuePairs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyValuePairs))
            for kiter520, viter521 in self.keyValuePairs.items():
                oprot.writeString(kiter520.encode('utf-8') if sys.version_info[0] == 2 else kiter520)
                oprot.writeString(viter521.encode('utf-8') if sys.version_info[0] == 2 else viter521)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectIds_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = iprot.readI32()
                        self.success.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter528 in self.success:
                oprot.writeI32(iter528)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModelIds_args(object):
    """
    Attributes:
     - keyValuePairs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyValuePairs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, keyValuePairs=None,):
        self.keyValuePairs = keyValuePairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.keyValuePairs = {}
                    (_ktype530, _vtype531, _size529) = iprot.readMapBegin()
                    for _i533 in range(_size529):
                        _key534 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val535 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyValuePairs[_key534] = _val535
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModelIds_args')
        if self.keyValuePairs is not None:
            oprot.writeFieldBegin('keyValuePairs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyValuePairs))
            for kiter536, viter537 in self.keyValuePairs.items():
                oprot.writeString(kiter536.encode('utf-8') if sys.version_info[0] == 2 else kiter536)
                oprot.writeString(viter537.encode('utf-8') if sys.version_info[0] == 2 else viter537)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModelIds_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype541, _size538) = iprot.readListBegin()
                    for _i542 in range(_size538):
                        _elem543 = iprot.readI32()
                        self.success.append(_elem543)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModelIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter544 in self.success:
                oprot.writeI32(iter544)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateProject_args(object):
    """
    Attributes:
     - projectId
     - key
     - value
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projectId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
    )

    def __init__(self, projectId=None, key=None, value=None,):
        self.projectId = projectId
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateProject_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.I32, 1)
            oprot.writeI32(self.projectId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createOrUpdateScalarField_args(object):
    """
    Attributes:
     - modelId
     - key
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'valueType', 'UTF8', None, ),  # 4
    )

    def __init__(self, modelId=None, key=None, value=None, valueType=None,):
        self.modelId = modelId
        self.key = key
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createOrUpdateScalarField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 4)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createOrUpdateScalarField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createOrUpdateScalarField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createVectorField_args(object):
    """
    Attributes:
     - modelId
     - vectorName
     - vectorConfig
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'vectorName', 'UTF8', None, ),  # 2
        (3, TType.MAP, 'vectorConfig', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, modelId=None, vectorName=None, vectorConfig=None,):
        self.modelId = modelId
        self.vectorName = vectorName
        self.vectorConfig = vectorConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.vectorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.vectorConfig = {}
                    (_ktype546, _vtype547, _size545) = iprot.readMapBegin()
                    for _i549 in range(_size545):
                        _key550 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val551 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vectorConfig[_key550] = _val551
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.vectorName is not None:
            oprot.writeFieldBegin('vectorName', TType.STRING, 2)
            oprot.writeString(self.vectorName.encode('utf-8') if sys.version_info[0] == 2 else self.vectorName)
            oprot.writeFieldEnd()
        if self.vectorConfig is not None:
            oprot.writeFieldBegin('vectorConfig', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vectorConfig))
            for kiter552, viter553 in self.vectorConfig.items():
                oprot.writeString(kiter552.encode('utf-8') if sys.version_info[0] == 2 else kiter552)
                oprot.writeString(viter553.encode('utf-8') if sys.version_info[0] == 2 else viter553)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateVectorField_args(object):
    """
    Attributes:
     - modelId
     - key
     - valueIndex
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.I32, 'valueIndex', None, None, ),  # 3
        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'valueType', 'UTF8', None, ),  # 5
    )

    def __init__(self, modelId=None, key=None, valueIndex=None, value=None, valueType=None,):
        self.modelId = modelId
        self.key = key
        self.valueIndex = valueIndex
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.valueIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.valueIndex is not None:
            oprot.writeFieldBegin('valueIndex', TType.I32, 3)
            oprot.writeI32(self.valueIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 5)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class appendToVectorField_args(object):
    """
    Attributes:
     - modelId
     - vectorName
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'vectorName', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'valueType', 'UTF8', None, ),  # 4
    )

    def __init__(self, modelId=None, vectorName=None, value=None, valueType=None,):
        self.modelId = modelId
        self.vectorName = vectorName
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.vectorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('appendToVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.vectorName is not None:
            oprot.writeFieldBegin('vectorName', TType.STRING, 2)
            oprot.writeString(self.vectorName.encode('utf-8') if sys.version_info[0] == 2 else self.vectorName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 4)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class appendToVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('appendToVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ModelResponse, ModelResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ModelResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsInExperiment_args(object):
    """
    Attributes:
     - experimentId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentId', None, None, ),  # 1
    )

    def __init__(self, experimentId=None,):
        self.experimentId = experimentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsInExperiment_args')
        if self.experimentId is not None:
            oprot.writeFieldBegin('experimentId', TType.I32, 1)
            oprot.writeI32(self.experimentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsInExperiment_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ExperimentRun, ExperimentRun.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype557, _size554) = iprot.readListBegin()
                    for _i558 in range(_size554):
                        _elem559 = ExperimentRun()
                        _elem559.read(iprot)
                        self.success.append(_elem559)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsInExperiment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter560 in self.success:
                iter560.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsAndExperimentsInProject_args(object):
    """
    Attributes:
     - projId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projId', None, None, ),  # 1
    )

    def __init__(self, projId=None,):
        self.projId = projId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsAndExperimentsInProject_args')
        if self.projId is not None:
            oprot.writeFieldBegin('projId', TType.I32, 1)
            oprot.writeI32(self.projId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsAndExperimentsInProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProjectExperimentsAndRuns, ProjectExperimentsAndRuns.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProjectExperimentsAndRuns()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsAndExperimentsInProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectOverviews_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectOverviews_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectOverviews_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ProjectOverviewResponse, ProjectOverviewResponse.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype564, _size561) = iprot.readListBegin()
                    for _i565 in range(_size561):
                        _elem566 = ProjectOverviewResponse()
                        _elem566.read(iprot)
                        self.success.append(_elem566)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectOverviews_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter567 in self.success:
                iter567.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperimentRunDetails_args(object):
    """
    Attributes:
     - experimentRunId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentRunId', None, None, ),  # 1
    )

    def __init__(self, experimentRunId=None,):
        self.experimentRunId = experimentRunId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperimentRunDetails_args')
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 1)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperimentRunDetails_result(object):
    """
    Attributes:
     - success
     - svEx
     - rnfEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentRunDetailsResponse, ExperimentRunDetailsResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, svEx=None, rnfEx=None,):
        self.success = success
        self.svEx = svEx
        self.rnfEx = rnfEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentRunDetailsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperimentRunDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 2)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class originalFeatures_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('originalFeatures_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class originalFeatures_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype571, _size568) = iprot.readListBegin()
                    for _i572 in range(_size568):
                        _elem573 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem573)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('originalFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter574 in self.success:
                oprot.writeString(iter574.encode('utf-8') if sys.version_info[0] == 2 else iter574)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTreeModel_args(object):
    """
    Attributes:
     - modelId
     - model
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRUCT, 'model', (TreeModel, TreeModel.thrift_spec), None, ),  # 2
    )

    def __init__(self, modelId=None, model=None,):
        self.modelId = modelId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.model = TreeModel()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTreeModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 2)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTreeModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTreeModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineTransformEvent_args(object):
    """
    Attributes:
     - te
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'te', (TType.STRUCT, (TransformEvent, TransformEvent.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, te=None,):
        self.te = te

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.te = []
                    (_etype578, _size575) = iprot.readListBegin()
                    for _i579 in range(_size575):
                        _elem580 = TransformEvent()
                        _elem580.read(iprot)
                        self.te.append(_elem580)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineTransformEvent_args')
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.te))
            for iter581 in self.te:
                iter581.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineTransformEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (TransformEventResponse, TransformEventResponse.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype585, _size582) = iprot.readListBegin()
                    for _i586 in range(_size582):
                        _elem587 = TransformEventResponse()
                        _elem587.read(iprot)
                        self.success.append(_elem587)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineTransformEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter588 in self.success:
                iter588.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class computeModelAncestry_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('computeModelAncestry_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class computeModelAncestry_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ModelAncestryResponse, ModelAncestryResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ModelAncestryResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('computeModelAncestry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class extractPipeline_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('extractPipeline_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class extractPipeline_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExtractedPipelineResponse, ExtractedPipelineResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExtractedPipelineResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('extractPipeline_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createProject_args(object):
    """
    Attributes:
     - project
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'project', (Project, Project.thrift_spec), None, ),  # 1
    )

    def __init__(self, project=None,):
        self.project = project

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.project = Project()
                    self.project.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createProject_args')
        if self.project is not None:
            oprot.writeFieldBegin('project', TType.STRUCT, 1)
            self.project.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createExperiment_args(object):
    """
    Attributes:
     - experiment
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'experiment', (Experiment, Experiment.thrift_spec), None, ),  # 1
    )

    def __init__(self, experiment=None,):
        self.experiment = experiment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.experiment = Experiment()
                    self.experiment.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createExperiment_args')
        if self.experiment is not None:
            oprot.writeFieldBegin('experiment', TType.STRUCT, 1)
            self.experiment.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createExperiment_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createExperiment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createExperimentRun_args(object):
    """
    Attributes:
     - experimentRun
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'experimentRun', (ExperimentRun, ExperimentRun.thrift_spec), None, ),  # 1
    )

    def __init__(self, experimentRun=None,):
        self.experimentRun = experimentRun

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.experimentRun = ExperimentRun()
                    self.experimentRun.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createExperimentRun_args')
        if self.experimentRun is not None:
            oprot.writeFieldBegin('experimentRun', TType.STRUCT, 1)
            self.experimentRun.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createExperimentRun_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createExperimentRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class API_updateProject_args(object):
    """
    Attributes:
     - projectId
     - updatedKVs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projectId', None, None, ),  # 1
        (2, TType.MAP, 'updatedKVs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    )

    def __init__(self, projectId=None, updatedKVs=None,):
        self.projectId = projectId
        self.updatedKVs = updatedKVs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.updatedKVs = {}
                    (_ktype590, _vtype591, _size589) = iprot.readMapBegin()
                    for _i593 in range(_size589):
                        _key594 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val595 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.updatedKVs[_key594] = _val595
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('API_updateProject_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.I32, 1)
            oprot.writeI32(self.projectId)
            oprot.writeFieldEnd()
        if self.updatedKVs is not None:
            oprot.writeFieldBegin('updatedKVs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.updatedKVs))
            for kiter596, viter597 in self.updatedKVs.items():
                oprot.writeString(kiter596.encode('utf-8') if sys.version_info[0] == 2 else kiter596)
                oprot.writeString(viter597.encode('utf-8') if sys.version_info[0] == 2 else viter597)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class API_updateProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('API_updateProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateExperiment_args(object):
    """
    Attributes:
     - experimentId
     - updatedKVs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentId', None, None, ),  # 1
        (2, TType.MAP, 'updatedKVs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    )

    def __init__(self, experimentId=None, updatedKVs=None,):
        self.experimentId = experimentId
        self.updatedKVs = updatedKVs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.updatedKVs = {}
                    (_ktype599, _vtype600, _size598) = iprot.readMapBegin()
                    for _i602 in range(_size598):
                        _key603 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val604 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.updatedKVs[_key603] = _val604
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateExperiment_args')
        if self.experimentId is not None:
            oprot.writeFieldBegin('experimentId', TType.I32, 1)
            oprot.writeI32(self.experimentId)
            oprot.writeFieldEnd()
        if self.updatedKVs is not None:
            oprot.writeFieldBegin('updatedKVs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.updatedKVs))
            for kiter605, viter606 in self.updatedKVs.items():
                oprot.writeString(kiter605.encode('utf-8') if sys.version_info[0] == 2 else kiter605)
                oprot.writeString(viter606.encode('utf-8') if sys.version_info[0] == 2 else viter606)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateExperiment_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateExperiment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateExperimentRun_args(object):
    """
    Attributes:
     - experimentRunId
     - updatedKVs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentRunId', None, None, ),  # 1
        (2, TType.MAP, 'updatedKVs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    )

    def __init__(self, experimentRunId=None, updatedKVs=None,):
        self.experimentRunId = experimentRunId
        self.updatedKVs = updatedKVs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.updatedKVs = {}
                    (_ktype608, _vtype609, _size607) = iprot.readMapBegin()
                    for _i611 in range(_size607):
                        _key612 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val613 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.updatedKVs[_key612] = _val613
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateExperimentRun_args')
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 1)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        if self.updatedKVs is not None:
            oprot.writeFieldBegin('updatedKVs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.updatedKVs))
            for kiter614, viter615 in self.updatedKVs.items():
                oprot.writeString(kiter614.encode('utf-8') if sys.version_info[0] == 2 else kiter614)
                oprot.writeString(viter615.encode('utf-8') if sys.version_info[0] == 2 else viter615)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateExperimentRun_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateExperimentRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProject_args(object):
    """
    Attributes:
     - projectId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projectId', None, None, ),  # 1
    )

    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProject_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.I32, 1)
            oprot.writeI32(self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProject_result(object):
    """
    Attributes:
     - success
     - svEx
     - rnfEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Project, Project.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, svEx=None, rnfEx=None,):
        self.success = success
        self.svEx = svEx
        self.rnfEx = rnfEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Project()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 2)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperiment_args(object):
    """
    Attributes:
     - experimentId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentId', None, None, ),  # 1
    )

    def __init__(self, experimentId=None,):
        self.experimentId = experimentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperiment_args')
        if self.experimentId is not None:
            oprot.writeFieldBegin('experimentId', TType.I32, 1)
            oprot.writeI32(self.experimentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperiment_result(object):
    """
    Attributes:
     - success
     - svEx
     - rnfEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Experiment, Experiment.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, svEx=None, rnfEx=None,):
        self.success = success
        self.svEx = svEx
        self.rnfEx = rnfEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Experiment()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperiment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 2)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
